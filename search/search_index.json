{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Yuyo # A collection of utility classes and functions designed to expand Hikari. Instillation # You can install yuyo from PyPI using the following command. python -m pip install -U hikari-yuyo Quick Usage. # For usage see the the documentation and soon to come examples. Support # Hikari's support guild provides for support for Yuyo. Contributing # Before contributing you should read through the contributing guidelines and the code of conduct","title":"Home"},{"location":"#yuyo","text":"A collection of utility classes and functions designed to expand Hikari.","title":"Yuyo"},{"location":"#instillation","text":"You can install yuyo from PyPI using the following command. python -m pip install -U hikari-yuyo","title":"Instillation"},{"location":"#quick-usage","text":"For usage see the the documentation and soon to come examples.","title":"Quick Usage."},{"location":"#support","text":"Hikari's support guild provides for support for Yuyo.","title":"Support"},{"location":"#contributing","text":"Before contributing you should read through the contributing guidelines and the code of conduct","title":"Contributing"},{"location":"changelog/","text":"Changelog # All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . Unreleased # 1.2.1a1 - 2022-11-04 # Added # ephemeral keyword-argument to yuyo.components.ComponentContext 's create_initial_response , create_follow_up and defer methods as a shorthand for including 1 << 6 in the passed flags. delete_after option to yuyo.components.ComponentContext response methods. expires_at property to yuyo.components.ComponentContext . Support for dependency injection through Alluka to the reaction and component clients. Changed # ComponentExecutor.execute now takes a context object instead of interaction and future objects. yuyo.pagination.async_paginate_string , yuyo.pagination.sync_paginate_string and yuyo.pagination.paginate_string now return an (async) iterator of the str pages rather than an iterator of tuple[str, int] . If you need page counts, use enumerate or yuyo.pagination.aenumerate . (Async) iterables can now be passed to yuyo.pagination.async_paginate_string , yuyo.pagination.sync_paginate_string and yuyo.pagination.paginate_string instead of just iterators. Fixed # yuyo.components.ComponentContext.respond trying to edit in the initial response instead of create a follow up if a deferred initial response was deleted. Long running delete_after and component execution tasks will no-longer be cancelled by GC. Removed # The project metadata dunder attributes from yuyo . importlib.metadata should be used to get this metadata instead. 1.1.1a1 - 2022-08-28 # Added # Support for sending attachments in the initial response to the ASGI server implementation. Support for sending attachments on initial response to the ComponentContext . Changed # Bumped the minimum hikari version to dev109. Async functions must be typed as returning typing.Coroutine / collections.abc.Coroutine rather than typing.Awaitable now. Fixed # Several bug fixes on handling context response tracking have been copied over from Tanjun to ComponentContext . 1.0.6a1 - 2022-05-24 # Changed # Bumped the minimum hikari version to dev108. Fixed # WaitForExecutor now has better semantics/behaviour around being called when it's inactive. Timeouts are now handled better meaning that a wait for executor timeout will mark it to be de-registered. Execute calls to an executor that hasn't been waited for yet will 1.0.5a1.post1 - 2021-12-21 # Changed # AsgiBot is now (by default) started and closed based on the ASGI lifespan events with the asgi_managed keyword argument to AsgiBot.__init__ allowing this to be disabled. 1.0.5a1 - 2021-12-21 # Added # AsgiBot extension for AsgiAdapter which can be run by itself (manages a rest client). Changed # Renamed WaitForComponent to WaitForExecutor . 1.0.4a1 - 2021-11-22 # Added # prefix_match option to ComponentClient custom ids to make storing metadata in custom ids possible. Fixed # custom id methods now raise ValueError on conflict rather than KeyError. 1.0.3a1 - 2021-10-27 # Added # An ASGI/3 adapter for Hikari's interaction server. Ability to register a callback for a constant custom_id in the component client. This takes precedence over any registered component executors. Changed # Renamed components.WaitFor to WaitForComponent and added it to components.__all__ and yuyo.__all__ . Fixed # Context.defer is now used in the ComponentPaginator instead of Context.create_initial_response to defer the initial response since before deleting it as Context.create_initial_response errors in the REST flow when a defer type is passed. Context.create_initial_response is no longer typed as taking deferred types. Handling of authors in WaitForComponent. Added timeout handling to the future returned by WaitForComponent.wait_for. [1.0.2a1.post1] - 2021-10-02 # Fixed # ComponentClient erroneously garbage collecting unexpired executors. ComponentPaginator and ReactionPaginator both starting on index 1 instead of 0. 1.0.2a1 - 2021-10-02 # Added # Option to have the ComponentClient be event managed when linked to an event manager. This is True by default. Changed # The client now gives a ephemeral timed out response when an unknown message is received. Fixed # ComponentClient's gc task not being started when its opened. Handling of access errors in the component client. MultiComponentExecutor slots. 1.0.1a1 - 2021-09-21 # Added # Higher level component execution client and a pagination specific implementation of its executor. Changed # Totally refactored reaction pagination client to make it more abstract and abstracted away from pagination where the pagination is just a standard use case specific implementation of its executor. Renamed module pagnation to pagination. Move the reaction handling logic over to \"reactions.py\" Renamed string_patinator functions to paginate_string Fixed # Iffy behaviour around \"locking\" the reaction executor which lead to some requests just being ignored.","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#unreleased","text":"","title":"Unreleased"},{"location":"changelog/#121a1-2022-11-04","text":"","title":"1.2.1a1 - 2022-11-04"},{"location":"changelog/#added","text":"ephemeral keyword-argument to yuyo.components.ComponentContext 's create_initial_response , create_follow_up and defer methods as a shorthand for including 1 << 6 in the passed flags. delete_after option to yuyo.components.ComponentContext response methods. expires_at property to yuyo.components.ComponentContext . Support for dependency injection through Alluka to the reaction and component clients.","title":"Added"},{"location":"changelog/#changed","text":"ComponentExecutor.execute now takes a context object instead of interaction and future objects. yuyo.pagination.async_paginate_string , yuyo.pagination.sync_paginate_string and yuyo.pagination.paginate_string now return an (async) iterator of the str pages rather than an iterator of tuple[str, int] . If you need page counts, use enumerate or yuyo.pagination.aenumerate . (Async) iterables can now be passed to yuyo.pagination.async_paginate_string , yuyo.pagination.sync_paginate_string and yuyo.pagination.paginate_string instead of just iterators.","title":"Changed"},{"location":"changelog/#fixed","text":"yuyo.components.ComponentContext.respond trying to edit in the initial response instead of create a follow up if a deferred initial response was deleted. Long running delete_after and component execution tasks will no-longer be cancelled by GC.","title":"Fixed"},{"location":"changelog/#removed","text":"The project metadata dunder attributes from yuyo . importlib.metadata should be used to get this metadata instead.","title":"Removed"},{"location":"changelog/#111a1-2022-08-28","text":"","title":"1.1.1a1 - 2022-08-28"},{"location":"changelog/#added_1","text":"Support for sending attachments in the initial response to the ASGI server implementation. Support for sending attachments on initial response to the ComponentContext .","title":"Added"},{"location":"changelog/#changed_1","text":"Bumped the minimum hikari version to dev109. Async functions must be typed as returning typing.Coroutine / collections.abc.Coroutine rather than typing.Awaitable now.","title":"Changed"},{"location":"changelog/#fixed_1","text":"Several bug fixes on handling context response tracking have been copied over from Tanjun to ComponentContext .","title":"Fixed"},{"location":"changelog/#106a1-2022-05-24","text":"","title":"1.0.6a1 - 2022-05-24"},{"location":"changelog/#changed_2","text":"Bumped the minimum hikari version to dev108.","title":"Changed"},{"location":"changelog/#fixed_2","text":"WaitForExecutor now has better semantics/behaviour around being called when it's inactive. Timeouts are now handled better meaning that a wait for executor timeout will mark it to be de-registered. Execute calls to an executor that hasn't been waited for yet will","title":"Fixed"},{"location":"changelog/#105a1post1-2021-12-21","text":"","title":"1.0.5a1.post1 - 2021-12-21"},{"location":"changelog/#changed_3","text":"AsgiBot is now (by default) started and closed based on the ASGI lifespan events with the asgi_managed keyword argument to AsgiBot.__init__ allowing this to be disabled.","title":"Changed"},{"location":"changelog/#105a1-2021-12-21","text":"","title":"1.0.5a1 - 2021-12-21"},{"location":"changelog/#added_2","text":"AsgiBot extension for AsgiAdapter which can be run by itself (manages a rest client).","title":"Added"},{"location":"changelog/#changed_4","text":"Renamed WaitForComponent to WaitForExecutor .","title":"Changed"},{"location":"changelog/#104a1-2021-11-22","text":"","title":"1.0.4a1 - 2021-11-22"},{"location":"changelog/#added_3","text":"prefix_match option to ComponentClient custom ids to make storing metadata in custom ids possible.","title":"Added"},{"location":"changelog/#fixed_3","text":"custom id methods now raise ValueError on conflict rather than KeyError.","title":"Fixed"},{"location":"changelog/#103a1-2021-10-27","text":"","title":"1.0.3a1 - 2021-10-27"},{"location":"changelog/#added_4","text":"An ASGI/3 adapter for Hikari's interaction server. Ability to register a callback for a constant custom_id in the component client. This takes precedence over any registered component executors.","title":"Added"},{"location":"changelog/#changed_5","text":"Renamed components.WaitFor to WaitForComponent and added it to components.__all__ and yuyo.__all__ .","title":"Changed"},{"location":"changelog/#fixed_4","text":"Context.defer is now used in the ComponentPaginator instead of Context.create_initial_response to defer the initial response since before deleting it as Context.create_initial_response errors in the REST flow when a defer type is passed. Context.create_initial_response is no longer typed as taking deferred types. Handling of authors in WaitForComponent. Added timeout handling to the future returned by WaitForComponent.wait_for.","title":"Fixed"},{"location":"changelog/#102a1post1-2021-10-02","text":"","title":"[1.0.2a1.post1] - 2021-10-02"},{"location":"changelog/#fixed_5","text":"ComponentClient erroneously garbage collecting unexpired executors. ComponentPaginator and ReactionPaginator both starting on index 1 instead of 0.","title":"Fixed"},{"location":"changelog/#102a1-2021-10-02","text":"","title":"1.0.2a1 - 2021-10-02"},{"location":"changelog/#added_5","text":"Option to have the ComponentClient be event managed when linked to an event manager. This is True by default.","title":"Added"},{"location":"changelog/#changed_6","text":"The client now gives a ephemeral timed out response when an unknown message is received.","title":"Changed"},{"location":"changelog/#fixed_6","text":"ComponentClient's gc task not being started when its opened. Handling of access errors in the component client. MultiComponentExecutor slots.","title":"Fixed"},{"location":"changelog/#101a1-2021-09-21","text":"","title":"1.0.1a1 - 2021-09-21"},{"location":"changelog/#added_6","text":"Higher level component execution client and a pagination specific implementation of its executor.","title":"Added"},{"location":"changelog/#changed_7","text":"Totally refactored reaction pagination client to make it more abstract and abstracted away from pagination where the pagination is just a standard use case specific implementation of its executor. Renamed module pagnation to pagination. Move the reaction handling logic over to \"reactions.py\" Renamed string_patinator functions to paginate_string","title":"Changed"},{"location":"changelog/#fixed_7","text":"Iffy behaviour around \"locking\" the reaction executor which lead to some requests just being ignored.","title":"Fixed"},{"location":"usage/","text":"Usage # Coming soon.","title":"Usage"},{"location":"usage/#usage","text":"Coming soon.","title":"Usage"},{"location":"reference/","text":"yuyo # A collection of utility functions and classes designed to enhances Hikari. AbstractComponentExecutor # Bases: abc . ABC Abstract interface of an object which handles the execution of a message component. custom_ids property abstractmethod # custom_ids () Collection of the custom IDs this executor is listening for. has_expired property abstractmethod # has_expired () Whether this executor has ended. AbstractReactionHandler # Bases: abc . ABC The interface for a reaction handler used with yuyo.reactions.ReactionClient . close abstractmethod async # close () Close this handler. has_expired property abstractmethod # has_expired () Whether this handler has ended. last_triggered property abstractmethod # last_triggered () When this handler was last triggered. Note If it hasn't ever been triggered then this will be when it was created. on_reaction_event abstractmethod async # on_reaction_event ( event , / , * , alluka = None ) Handle a reaction event. PARAMETER DESCRIPTION event The event to handle. TYPE: EventT alluka The Alluka client to use for callback dependency injection during callback calls. TYPE: typing . Optional [ alluka_ . abc . Client ] DEFAULT: None RAISES DESCRIPTION HandlerClosed If this reaction handler has been closed. open abstractmethod async # open ( message ) Open this handler. PARAMETER DESCRIPTION message The message to bind this handler to. TYPE: hikari . Message ActionRowExecutor # Bases: ComponentExecutor , hikari . api . ComponentBuilder Class used for handling the execution of an action row. __init__ # __init__ ( * , ephemeral_default = False , load_from_attributes = False , timeout = datetime . timedelta ( seconds = 30 )) Initialise an action row executor. PARAMETER DESCRIPTION ephemeral_default Whether this executor's responses should default to being ephemeral. TYPE: bool DEFAULT: False timeout How long this component should last until its marked as timed out. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30) AsgiAdapter # Asgi/3 adapter for Hikari's interaction server interface. For this to work, hikari has to be installed with the optional \"server\" feature (e.g python -m pip install hikari[server] ). __call__ async # __call__ ( scope , receive , send ) Call the adapter. Note This method is called by the ASGI server. PARAMETER DESCRIPTION scope The scope of the request. TYPE: asgiref . Scope receive The receive function to use. TYPE: asgiref . ASGIReceiveCallable send The send function to use. TYPE: asgiref . ASGISendCallable RAISES DESCRIPTION NotImplementedError If this is called with a websocket scope. RuntimeError If an invalid scope event is passed. __init__ # __init__ ( server , / , * , executor = None ) Initialise the adapter. PARAMETER DESCRIPTION server The interaction server to use. TYPE: hikari . api . InteractionServer executor If non- None , then this executor is used instead of the concurrent.futures.ThreadPoolExecutor attached to the asyncio.AbstractEventLoop that the bot will run on. This executor is used primarily for file-IO. While mainly supporting the concurrent.futures.ThreadPoolExecutor implementation in the standard lib, Hikari's file handling systems should also work with concurrent.futures.ProcessPoolExecutor , which relies on all objects used in IPC to be pickle able. Many third-party libraries will not support this fully though, so your mileage may vary on using ProcessPoolExecutor implementations with this parameter. TYPE: typing . Optional [ concurrent . futures . Executor ] DEFAULT: None add_shutdown_callback # add_shutdown_callback ( callback ) Add a callback to be called when the ASGI server shuts down. Warning These callbacks will block the ASGI server from shutting down until they complete and any raised errors will lead to a failed shutdown. PARAMETER DESCRIPTION callback The shutdown callback to add. TYPE: typing . Callable [[], typing . Union [None, typing . Coroutine [ typing . Any , typing . Any , None]]] RETURNS DESCRIPTION Self This adapter to enable call chaining. add_startup_callback # add_startup_callback ( callback ) Add a callback to be called when the ASGI server starts up. Warning These callbacks will block the ASGI server from starting until they complete and any raised errors will lead to a failed startup. PARAMETER DESCRIPTION callback The startup callback to add. TYPE: typing . Callable [[], typing . Union [None, typing . Coroutine [ typing . Any , typing . Any , None]]] RETURNS DESCRIPTION Self This adapter to enable call chaining. process_lifespan_event async # process_lifespan_event ( receive , send ) Process a lifespan ASGI event. Note This function is used internally by the adapter. PARAMETER DESCRIPTION receive The receive function to use. TYPE: asgiref . ASGIReceiveCallable send The send function to use. TYPE: asgiref . ASGISendCallable RAISES DESCRIPTION RuntimeError If an invalid lifespan event is passed. process_request async # process_request ( scope , receive , send ) Process an HTTP request. Note This function is used internally by the adapter. PARAMETER DESCRIPTION scope The scope of the request. TYPE: asgiref . HTTPScope receive The receive function to use. TYPE: asgiref . ASGIReceiveCallable send The send function to use. TYPE: asgiref . ASGISendCallable server property # server () The interaction server this adapter is bound to. AsgiBot # Bases: AsgiAdapter , hikari . RESTBotAware Bot implementation which acts as an ASGI adapter. This bot doesn't initiate a server internally but instead relies on being called as an ASGI app. For this to work, hikari has to be installed with the optional \"server\" feature (e.g python -m pip install hikari[server] ). __init__ # __init__ ( token , token_type = None , public_key = None , * , asgi_managed = True , executor = None , http_settings = None , max_rate_limit = 300.0 , max_retries = 3 , proxy_settings = None , rest_url = None ) Initialise a new ASGI bot. PARAMETER DESCRIPTION token The bot or bearer token. If no token is to be used, this can be undefined. TYPE: typing . Union [ str , hikari . api . TokenStrategy ] token_type The type of token in use. This should only be passed when str is passed for token , can be \"Bot\" or \"Bearer\" and will be defaulted to \"Bearer\" in this situation. This should be left as None when either hikari.api.rest.TokenStrategy or None is passed for token . TYPE: typing . Union [ hikari . TokenType , str , None] DEFAULT: None asgi_managed Whether this bot's internal components should be automatically started and stopped based on the Asgi lifespan events. TYPE: bool DEFAULT: True executor If non- None , then this executor is used instead of the concurrent.futures.ThreadPoolExecutor attached to the asyncio.AbstractEventLoop that the bot will run on. This executor is used primarily for file-IO. While mainly supporting the concurrent.futures.ThreadPoolExecutor implementation in the standard lib, Hikari's file handling systems should also work with concurrent.futures.ProcessPoolExecutor , which relies on all objects used in IPC to be pickle able. Many third-party libraries will not support this fully though, so your mileage may vary on using ProcessPoolExecutor implementations with this parameter. TYPE: typing . Optional [ concurrent . futures . Executor ] DEFAULT: None http_settings Optional custom HTTP configuration settings to use. Allows you to customise functionality such as whether SSL-verification is enabled, what timeouts aiohttp should expect to use for requests, and behavior regarding HTTP-redirects. TYPE: typing . Optional [ hikari . impl . HTTPSettings ] DEFAULT: None max_rate_limit The max number of seconds to backoff for when rate limited. Anything greater than this will instead raise an error. This defaults to five minutes to stop potentially indefinitely waiting on an endpoint, which is almost never what you want to do if giving a response to a user. You can set this to float(\"inf\") to disable this check entirely. Note that this only applies to the REST API component that communicates with Discord, and will not affect sharding or third party HTTP endpoints that may be in use. TYPE: float DEFAULT: 300.0 max_retries Maximum number of times a request will be retried if it fails with a 5xx status. Defaults to 3 if set to None . TYPE: int DEFAULT: 3 proxy_settings Custom proxy settings to use with network-layer logic in your application to get through an HTTP-proxy. TYPE: typing . Optional [ hikari . impl . ProxySettings ] DEFAULT: None public_key The public key to use to verify received interaction requests. This may be a hex encoded str or the raw bytes . If left as None then the client will try to work this value out based on token . TYPE: typing . Union [ bytes , str , None] DEFAULT: None rest_url Defaults to the Discord REST API URL if None . Can be overridden if you are attempting to point to an unofficial endpoint, or if you are attempting to mock/stub the Discord API for any reason. Generally you do not want to change this. TYPE: typing . Optional [ str ] DEFAULT: None RAISES DESCRIPTION ValueError If token_type is provided when a token strategy is passed for token . if token_type is left as None when a string is passed for token . close async # close () Close the bot's REST client. Warning Unless asgi_managed=False is passed to AsgiBot.__init__ , the bot will be automatically closed based on the ASGI lifespan events and any other calls to this function will raise a RuntimeError . RAISES DESCRIPTION RuntimeError If the client isn't alive. If the client is ASGI managed. run # run () Start the bot's REST client and wait until the bot's closed. Warning Unless asgi_managed=False is passed to yuyo.asgi.AsgiBot. init , the bot will be automatically started and closed based on the ASGI lifespan events and any other calls to this function will raise a RuntimeError . RAISES DESCRIPTION RuntimeError If the client is already alive. If the client is ASGI managed. start async # start () Start the bot's REST client. Warning Unless asgi_managed=False is passed to yuyo.asgi.AsgiBot. init , the bot will be automatically started based on the ASGI lifespan events and any other calls to this function will raise a RuntimeError . RAISES DESCRIPTION RuntimeError If the client is already alive. If the client is ASGI managed. Backoff # Used to exponentially backoff asynchronously. This class acts as an asynchronous iterator and can be iterated over to provide implicit backoff where for every iteration other than the first this will either back off for the time passed to yuyo.backoff.Backoff.set_next_backoff if applicable or a time calculated exponentially. Examples: An example of using this class as an asynchronous iterator may look like the following # While we can directly do `async for _ in Backoff()`, by assigning it to a # variable we allow ourself to provide a specific backoff time in some cases. backoff = Backoff () async for _ in backoff : try : message = await bot . rest . fetch_message ( channel_id , message_id ) except errors . RateLimitedError as exc : # If we have a specific backoff time then set it for the next iteration backoff . set_next_backoff ( exc . retry_after ) except errors . InternalServerError : # Else let the iterator calculate an exponential backoff before the next loop. pass else : # We need to break out of the iterator to make sure it doesn't backoff again. # Alternatively `Backoff.finish()` can be called to break out of the loop. break Alternatively you may want to explicitly call yuyo.backoff.Backoff.backoff , a alternative of the previous example which uses yuyo.backoff.Backoff.backoff may look like the following backoff = Backoff () message : typing . Optional [ messages . Message ] = None while not message : try : message = await bot . rest . fetch_message ( channel_id , message_id ) except errors . RateLimitedError as exc : # If we have a specific backoff time then set it for the next iteration. await backoff . backoff ( exc . retry_after ) except errors . InternalServerError : # Else let the iterator calculate an exponential backoff before the next loop. await backoff . backoff () __init__ # __init__ ( max_retries = None , * , base = 2.0 , maximum = 64.0 , jitter_multiplier = 1.0 , initial_increment = 0 ) Initialise a backoff instance. PARAMETER DESCRIPTION max_retries The maximum amount of times this should iterate for between resets. If left as None then this iterator will be unlimited. This must be greater than or equal to 1. TYPE: typing . Optional [ int ] DEFAULT: None base The base to use. TYPE: float DEFAULT: 2.0 maximum The max value the backoff can be in a single iteration. Anything above this will be capped to this base value plus random jitter. TYPE: float DEFAULT: 64.0 jitter_multiplier The multiplier for the random jitter. Set to 0 to disable jitter. TYPE: float DEFAULT: 1.0 initial_increment The initial increment to start at. TYPE: int DEFAULT: 0 RAISES DESCRIPTION ValueError If an int that's too big to be represented as a float or a non-finite value is passed in place of a field that's annotated as float or if max_retries is less than 1 . backoff async # backoff ( backoff_ ) Sleep for the provided backoff or for the next exponent. This provides an alternative to iterating over this class. PARAMETER DESCRIPTION backoff_ The time this should backoff for. If left as None then this will back off for the last time provided with yuyo.backoff.Backoff.set_next_backoff if available or the next exponential time. TYPE: typing . Optional [ float ] finish # finish () Mark the iterator as finished to break out of the current loop. is_depleted property # is_depleted () Whether \"max_retries\" has been reached. This can be used to workout whether the loop was explicitly broken out of using yuyo.backoff.Backoff.finish / break or if it hit \"max_retries\". reset # reset () Reset the backoff to it's original state to reuse it. set_next_backoff # set_next_backoff ( backoff_ ) Specify a backoff time for the next iteration or yuyo.backoff.Backoff.backoff call. If this is called then the exponent won't be increased for this iteration. Note Calling this multiple times in a single iteration will overwrite any previously set next backoff. ChildActionRowExecutor # Bases: ActionRowExecutor , typing . Generic [ _ParentExecutorProtoT ] Extended action row implementation which can be tied to a multi-component executor. add_to_parent # add_to_parent () Add this action row to its parent executor. RETURNS DESCRIPTION _ParentExecutorProtoT The parent executor this action row was added to. ComponentClient # Client used to handle component executors within a REST or gateway flow. __init__ # __init__ ( * , alluka = None , event_manager = None , event_managed = None , server = None ) Initialise a component client. Note For an easier way to initialise the client from a bot see yuyo.components.ComponentClient.from_gateway_bot and yuyo.components.ComponentClient.from_rest_bot . PARAMETER DESCRIPTION alluka The Alluka client to use for callback dependency injection in this client. If not provided then this will initialise its own Alluka client. TYPE: typing . Optional [ alluka_ . abc . Client ] DEFAULT: None event_manager The event manager this client should listen to dispatched component interactions from if applicable. TYPE: typing . Optional [ hikari . api . EventManager ] DEFAULT: None event_managed Whether this client should be automatically opened and closed based on the lifetime events dispatched by event_manager . Defaults to True if an event manager is passed. TYPE: typing . Optional [ bool ] DEFAULT: None server The server this client should listen to component interactions from if applicable. TYPE: typing . Optional [ hikari . api . InteractionServer ] DEFAULT: None RAISES DESCRIPTION ValueError If event_managed is passed as True when event_manager is None . add_executor # add_executor ( message , executor ) Deprecated alias of yuyo.components.ComponentClient.add_executor . alluka property # alluka () The Alluka client being used for callback dependency injection. close # close () Close the component client. from_gateway_bot classmethod # from_gateway_bot ( bot , / , * , event_managed = True ) Build a component client froma Gateway Bot. PARAMETER DESCRIPTION bot The Gateway bot this component client should be bound to. TYPE: hikari . GatewayBotAware event_managed Whether the component client should be automatically opened and closed based on the lifetime events dispatched by bot . TYPE: bool DEFAULT: True RETURNS DESCRIPTION ComponentClient The initialised component client. from_rest_bot classmethod # from_rest_bot ( bot ) Build a component client froma REST Bot. PARAMETER DESCRIPTION bot The REST bot this component client should be bound to. TYPE: hikari . RESTBotAware RETURNS DESCRIPTION ComponentClient The initialised component client. get_constant_id # get_constant_id ( custom_id ) Get a set constant \"custom_id\" callback. PARAMETER DESCRIPTION custom_id The custom_id to get the callback for. TYPE: str RETURNS DESCRIPTION CallbackSig | None The callback for the custom_id, or None if it doesn't exist. get_executor # get_executor ( message ) Get the component executor set for a message. PARAMETER DESCRIPTION message The message to get the executor for. TYPE: hikari . SnowflakeishOr [ hikari . Message ] RETURNS DESCRIPTION yuyo . components . AbstractComponentExecutor | None The executor set for the message or None if none is set. open # open () Startup the component client. remove_constant_id # remove_constant_id ( custom_id ) Remove a constant \"custom_id\" callback. PARAMETER DESCRIPTION custom_id The custom_id to remove the callback for. TYPE: str RETURNS DESCRIPTION Self The component client to allow chaining. RAISES DESCRIPTION KeyError If the custom_id is not registered. remove_executor # remove_executor ( message ) Remove the component executor for a message. PARAMETER DESCRIPTION message The message to remove the executor for. TYPE: hikari . SnowflakeishOr [ hikari . Message ] RETURNS DESCRIPTION Self The component client to allow chaining. set_constant_id # set_constant_id ( custom_id , callback , / , * , prefix_match = False ) Add a constant \"custom_id\" callback. These are callbacks which'll always be called for a specific custom_id while taking priority over executors. PARAMETER DESCRIPTION custom_id The custom_id to register the callback for. TYPE: str callback The callback to register. This should take a single argument of type yuyo.components.ComponentContext , be asynchronous and return None . TYPE: CallbackSig prefix_match Whether the custom_id should be treated as a prefix match. This allows for further state to be held in the custom id after the prefix and is lower priority than normal custom id match. TYPE: bool DEFAULT: False RETURNS DESCRIPTION Self The component client to allow chaining. RAISES DESCRIPTION ValueError If the custom_id is already registered. set_executor # set_executor ( message , executor ) Set the component executor for a message. PARAMETER DESCRIPTION message The message to set the executor for. TYPE: hikari . SnowflakeishOr [ hikari . Message ] executor The executor to set. This will be called for every component interaction for the message unless the component's custom_id is registered as a constant id callback. TYPE: AbstractComponentExecutor RETURNS DESCRIPTION Self The component client to allow chaining. with_constant_id # with_constant_id ( custom_id , / , * , prefix_match = False ) Add a constant \"custom_id\" callback through a decorator call. These are callbacks which'll always be called for a specific custom_id while taking priority over executors. PARAMETER DESCRIPTION custom_id The custom_id to register the callback for. TYPE: str prefix_match Whether the custom_id should be treated as a prefix match. This allows for further state to be held in the custom id after the prefix and is lower priority than normal custom id match. TYPE: bool DEFAULT: False RETURNS DESCRIPTION Callable [[ CallbackSigT ], CallbackSigT ] A decorator to register the callback. RAISES DESCRIPTION KeyError If the custom_id is already registered. ComponentContext # The general context passed around for a component trigger. create_followup async # create_followup ( content = hikari . UNDEFINED , * , delete_after = None , ephemeral = False , attachment = hikari . UNDEFINED , attachments = hikari . UNDEFINED , component = hikari . UNDEFINED , components = hikari . UNDEFINED , embed = hikari . UNDEFINED , embeds = hikari . UNDEFINED , mentions_everyone = hikari . UNDEFINED , user_mentions = hikari . UNDEFINED , role_mentions = hikari . UNDEFINED , tts = hikari . UNDEFINED , flags = hikari . UNDEFINED ) Create a followup response for this context. Warning Calling this on a context which hasn't had an initial response yet will lead to a hikari.errors.NotFoundError being raised. PARAMETER DESCRIPTION content If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED delete_after If provided, the seconds after which the response message should be deleted. Slash command responses can only be deleted within 15 minutes of the command being received. TYPE: typing . Union [ datetime . timedelta , float , int , None] DEFAULT: None ephemeral Whether the deferred response should be ephemeral. Passing True here is a shorthand for including 1 << 64 in the passed flags. TYPE: bool DEFAULT: False attachment If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL. TYPE: hikari . UndefinedOr [ hikari . Resourceish ] DEFAULT: hikari.UNDEFINED attachments If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . Resourceish ]] DEFAULT: hikari.UNDEFINED component If provided, builder object of the component to include in this message. TYPE: hikari . UndefinedOr [ hikari . api . ComponentBuilder ] DEFAULT: hikari.UNDEFINED components If provided, a sequence of the component builder objects to include in this message. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . api . ComponentBuilder ]] DEFAULT: hikari.UNDEFINED embed If provided, the message embed. TYPE: hikari . UndefinedOr [ hikari . Embed ] DEFAULT: hikari.UNDEFINED embeds If provided, the message embeds. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . Embed ]] DEFAULT: hikari.UNDEFINED mentions_everyone If provided, whether the message should parse @everyone/@here mentions. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED user_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialUser ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED role_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialRole ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED tts If provided, whether the message will be sent as a TTS message. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED flags The flags to set for this response. As of writing this can only flag which can be provided is EPHEMERAL, other flags are just ignored. TYPE: typing . Union [ hikari . UndefinedType , int , hikari . MessageFlag ] DEFAULT: hikari.UNDEFINED RETURNS DESCRIPTION hikari . Message The created message object. RAISES DESCRIPTION hikari . NotFoundError If the current interaction is not found or it hasn't had an initial response yet. hikari . BadRequestError This can be raised if the file is too large; if the embed exceeds the defined limits; if the message content is specified only and empty or greater than 2000 characters; if neither content, file or embeds are specified. If any invalid snowflake IDs are passed; a snowflake may be invalid due to it being outside of the range of a 64 bit integer. ValueError If more than 100 unique objects/entities are passed for role_mentions or `user_mentions. If the interaction will have expired before delete_after is reached. If both attachment and attachments are passed or both component and components are passed or both embed and embeds are passed. create_initial_response async # create_initial_response ( response_type , / , content = hikari . UNDEFINED , * , delete_after = None , ephemeral = False , attachment = hikari . UNDEFINED , attachments = hikari . UNDEFINED , component = hikari . UNDEFINED , components = hikari . UNDEFINED , embed = hikari . UNDEFINED , embeds = hikari . UNDEFINED , mentions_everyone = hikari . UNDEFINED , user_mentions = hikari . UNDEFINED , role_mentions = hikari . UNDEFINED , flags = hikari . UNDEFINED , tts = hikari . UNDEFINED ) Create the initial response for this context. Warning Calling this on a context which already has an initial response will result in this raising a hikari.errors.NotFoundError . This includes if the REST interaction server has already responded to the request and deferrals. PARAMETER DESCRIPTION response_type The type of message response to give. TYPE: hikari . MessageResponseTypesT content The content to edit the last response with. If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED delete_after If provided, the seconds after which the response message should be deleted. Slash command responses can only be deleted within 15 minutes of the command being received. TYPE: typing . Union [ datetime . timedelta , float , int , None] DEFAULT: None ephemeral Whether the deferred response should be ephemeral. Passing True here is a shorthand for including 1 << 64 in the passed flags. TYPE: bool DEFAULT: False content If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED attachment If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL. TYPE: hikari . UndefinedOr [ hikari . Resourceish ] DEFAULT: hikari.UNDEFINED attachments If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . Resourceish ]] DEFAULT: hikari.UNDEFINED component If provided, builder object of the component to include in this message. TYPE: hikari . UndefinedOr [ hikari . api . ComponentBuilder ] DEFAULT: hikari.UNDEFINED components If provided, a sequence of the component builder objects to include in this message. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . api . ComponentBuilder ]] DEFAULT: hikari.UNDEFINED embed If provided, the message embed. TYPE: hikari . UndefinedOr [ hikari . Embed ] DEFAULT: hikari.UNDEFINED embeds If provided, the message embeds. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . Embed ]] DEFAULT: hikari.UNDEFINED flags If provided, the message flags this response should have. As of writing the only message flag which can be set here is hikari.messages.MessageFlag.EPHEMERAL . TYPE: typing . Union [ int , hikari . MessageFlag , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED tts If provided, whether the message will be read out by a screen reader using Discord's TTS (text-to-speech) system. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED mentions_everyone If provided, whether the message should parse @everyone/@here mentions. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED user_mentions If provided, and True , all user mentions will be detected. If provided, and False , all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialUser ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED role_mentions If provided, and True , all role mentions will be detected. If provided, and False , all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of [hikari.snowflakes.Snowflake], or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialRole ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED RAISES DESCRIPTION ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions . If the interaction will have expired before delete_after is reached. If both attachment and attachments are passed or both component and components are passed or both embed and embeds are passed. hikari . BadRequestError This may be raised in several discrete situations, such as messages being empty with no embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; invalid image URLs in embeds. hikari . UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari . NotFoundError If the interaction is not found or if the interaction's initial response has already been created. hikari . RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request. hikari . RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari . InternalServerError If an internal error occurs on Discord while handling the request. defer async # defer ( defer_type , / , * , ephemeral = False , flags = hikari . UNDEFINED ) Defer the initial response for this context. Note The ephemeral state of the first response is decided by whether the deferral is ephemeral. PARAMETER DESCRIPTION defer_type The type of deferral this should be. This may any of the following * ResponseType.DEFERRED_MESSAGE_CREATE to indicate that the following up call to yuyo.components.ComponentContext.edit_initial_response or yuyo.components.ComponentContext.respond should create a new message. * ResponseType.DEFERRED_MESSAGE_UPDATE to indicate that the following call to the aforementioned methods should update the existing message. TYPE: hikari . DeferredResponseTypesT ephemeral Whether the deferred response should be ephemeral. Passing True here is a shorthand for including 1 << 64 in the passed flags. TYPE: bool DEFAULT: False flags The flags to use for the initial response. TYPE: typing . Union [ hikari . UndefinedType , int , hikari . MessageFlag ] DEFAULT: hikari.UNDEFINED delete_initial_response async # delete_initial_response () Delete the initial response after invoking this context. RAISES DESCRIPTION LookupError , hikari . NotFoundError The last context has no initial response. delete_last_response async # delete_last_response () Delete the last response after invoking this context. RAISES DESCRIPTION LookupError , hikari . NotFoundError The last context has no responses. edit_initial_response async # edit_initial_response ( content = hikari . UNDEFINED , * , delete_after = None , attachment = hikari . UNDEFINED , attachments = hikari . UNDEFINED , component = hikari . UNDEFINED , components = hikari . UNDEFINED , embed = hikari . UNDEFINED , embeds = hikari . UNDEFINED , replace_attachments = False , mentions_everyone = hikari . UNDEFINED , user_mentions = hikari . UNDEFINED , role_mentions = hikari . UNDEFINED ) Edit the initial response for this context. PARAMETER DESCRIPTION content The content to edit the initial response with. If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED delete_after If provided, the seconds after which the response message should be deleted. Slash command responses can only be deleted within 15 minutes of the command being received. TYPE: typing . Union [ datetime . timedelta , float , int , None] DEFAULT: None attachment A singular attachment to edit the initial response with. TYPE: hikari . UndefinedOr [ hikari . Resourceish ] DEFAULT: hikari.UNDEFINED attachments A sequence of attachments to edit the initial response with. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . Resourceish ]] DEFAULT: hikari.UNDEFINED component If provided, builder object of the component to set for this message. This component will replace any previously set components and passing None will remove all components. TYPE: hikari . UndefinedNoneOr [ hikari . api . ComponentBuilder ] DEFAULT: hikari.UNDEFINED components If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing None or an empty sequence will remove all components. TYPE: hikari . UndefinedNoneOr [ typing . Sequence [ hikari . api . ComponentBuilder ]] DEFAULT: hikari.UNDEFINED embed An embed to replace the initial response with. TYPE: hikari . UndefinedNoneOr [ hikari . Embed ] DEFAULT: hikari.UNDEFINED embeds A sequence of embeds to replace the initial response with. TYPE: hikari . UndefinedNoneOr [ typing . Sequence [ hikari . Embed ]] DEFAULT: hikari.UNDEFINED replace_attachments Whether to replace the attachments of the response or not. TYPE: bool DEFAULT: False mentions_everyone If provided, whether the message should parse @everyone/@here mentions. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED user_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialUser ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED role_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialRole ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED RETURNS DESCRIPTION hikari . Message The message that has been edited. RAISES DESCRIPTION ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions . If delete_after would be more than 15 minutes after the slash command was called. If both attachment and attachments are passed or both component and components are passed or both embed and embeds are passed. hikari . BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components. hikari . UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari . ForbiddenError If you are missing the SEND_MESSAGES in the channel or the person you are trying to message has the DM's disabled. hikari . NotFoundError If the channel is not found. hikari . RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request. hikari . RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari . InternalServerError If an internal error occurs on Discord while handling the request. edit_last_response async # edit_last_response ( content = hikari . UNDEFINED , * , delete_after = None , attachment = hikari . UNDEFINED , attachments = hikari . UNDEFINED , component = hikari . UNDEFINED , components = hikari . UNDEFINED , embed = hikari . UNDEFINED , embeds = hikari . UNDEFINED , replace_attachments = False , mentions_everyone = hikari . UNDEFINED , user_mentions = hikari . UNDEFINED , role_mentions = hikari . UNDEFINED ) Edit the last response for this context. PARAMETER DESCRIPTION content The content to edit the last response with. If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED delete_after If provided, the seconds after which the response message should be deleted. Slash command responses can only be deleted within 15 minutes of the command being received. TYPE: typing . Union [ datetime . timedelta , float , int , None] DEFAULT: None attachment A singular attachment to edit the last response with. TYPE: hikari . UndefinedOr [ hikari . Resourceish ] DEFAULT: hikari.UNDEFINED attachments A sequence of attachments to edit the last response with. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . Resourceish ]] DEFAULT: hikari.UNDEFINED component If provided, builder object of the component to set for this message. This component will replace any previously set components and passing None will remove all components. TYPE: hikari . UndefinedNoneOr [ hikari . api . ComponentBuilder ] DEFAULT: hikari.UNDEFINED components If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing None or an empty sequence will remove all components. TYPE: hikari . UndefinedNoneOr [ typing . Sequence [ hikari . api . ComponentBuilder ]] DEFAULT: hikari.UNDEFINED embed An embed to replace the last response with. TYPE: hikari . UndefinedNoneOr [ hikari . Embed ] DEFAULT: hikari.UNDEFINED embeds A sequence of embeds to replace the last response with. TYPE: hikari . UndefinedNoneOr [ typing . Sequence [ hikari . Embed ]] DEFAULT: hikari.UNDEFINED replace_attachments Whether to replace the attachments of the response or not. TYPE: bool DEFAULT: False mentions_everyone If provided, whether the message should parse @everyone/@here mentions. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED user_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialUser ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED role_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialRole ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED RETURNS DESCRIPTION hikari . Message The message that has been edited. RAISES DESCRIPTION ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions . If delete_after would be more than 15 minutes after the slash command was called. If both attachment and attachments are passed or both component and components are passed or both embed and embeds are passed. hikari . BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components. hikari . UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari . ForbiddenError If you are missing the SEND_MESSAGES in the channel or the person you are trying to message has the DM's disabled. hikari . NotFoundError If the channel is not found. hikari . RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request. hikari . RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari . InternalServerError If an internal error occurs on Discord while handling the request. fetch_initial_response async # fetch_initial_response () Fetch the initial response for this context. RETURNS DESCRIPTION hikari . messages . Message The initial response's message object. RAISES DESCRIPTION LookupError , hikari . NotFoundError The response was not found. fetch_last_response async # fetch_last_response () Fetch the last response for this context. RETURNS DESCRIPTION hikari . messages . Message The most response response's message object. RAISES DESCRIPTION LookupError , hikari . NotFoundError The response was not found. has_been_deferred property # has_been_deferred () Whether this context's initial response has been deferred. This will be true if yuyo.components.ComponentContext.defer has been called. has_responded property # has_responded () Whether an initial response has been made to this context yet. It's worth noting that a context must be either responded to or deferred within 3 seconds from it being received otherwise it'll be marked as failed. This will be true if either yuyo.components.ComponentContext.respond , yuyo.components.ComponentContext.create_initial_response or yuyo.components.ComponentContext.edit_initial_response (after a deferral) has been called. interaction property # interaction () Object of the interaction this context is for. respond async # respond ( content = hikari . UNDEFINED , * , ensure_result = False , delete_after = None , attachment = hikari . UNDEFINED , attachments = hikari . UNDEFINED , component = hikari . UNDEFINED , components = hikari . UNDEFINED , embed = hikari . UNDEFINED , embeds = hikari . UNDEFINED , mentions_everyone = hikari . UNDEFINED , user_mentions = hikari . UNDEFINED , role_mentions = hikari . UNDEFINED ) Respond to this context. PARAMETER DESCRIPTION content The content to respond with. If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED ensure_result Ensure that this call will always return a message object. If True then this will always return hikari.messages.Message , otherwise this will return hikari.Message | None . It's worth noting that, under certain scenarios within the slash command flow, this may lead to an extre request being made. TYPE: bool DEFAULT: False delete_after If provided, the seconds after which the response message should be deleted. Slash command responses can only be deleted within 15 minutes of the command being received. TYPE: typing . Union [ datetime . timedelta , float , int , None] DEFAULT: None attachment If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL. TYPE: hikari . UndefinedOr [ hikari . Resourceish ] DEFAULT: hikari.UNDEFINED attachments If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . Resourceish ]] DEFAULT: hikari.UNDEFINED component If provided, builder object of the component to include in this response. TYPE: hikari . UndefinedOr [ hikari . api . ComponentBuilder ] DEFAULT: hikari.UNDEFINED components If provided, a sequence of the component builder objects to include in this response. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . api . ComponentBuilder ]] DEFAULT: hikari.UNDEFINED embed An embed to respond with. TYPE: hikari . UndefinedOr [ hikari . Embed ] DEFAULT: hikari.UNDEFINED embeds A sequence of embeds to respond with. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . Embed ]] DEFAULT: hikari.UNDEFINED mentions_everyone If provided, whether the message should parse @everyone/@here mentions. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED user_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialUser ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED role_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialRole ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED RETURNS DESCRIPTION hikari . Message | None The message that has been created if it was immedieatly available or ensure_result was set to True , else None . RAISES DESCRIPTION ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions . If delete_after would be more than 15 minutes after the slash command was called. If both attachment and attachments are passed or both component and components are passed or both embed and embeds are passed. hikari . BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components. hikari . UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari . ForbiddenError If you are missing the SEND_MESSAGES in the channel or the person you are trying to message has the DM's disabled. hikari . NotFoundError If the channel is not found. hikari . RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request. hikari . RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari . InternalServerError If an internal error occurs on Discord while handling the request. set_ephemeral_default # set_ephemeral_default ( state ) Set the ephemeral default state for this context. PARAMETER DESCRIPTION state The new ephemeral default state. If this is True then all calls to the response creating methods on this context will default to being ephemeral. TYPE: bool ComponentExecutor # Bases: AbstractComponentExecutor Basic implementation of a class used for handling the execution of a message component. __init__ # __init__ ( * , ephemeral_default = False , load_from_attributes = True , timeout = datetime . timedelta ( seconds = 30 )) Initialise a component executor. PARAMETER DESCRIPTION ephemeral_default Whether this executor's responses should default to being ephemeral. TYPE: bool DEFAULT: False timeout How long this component should last until its marked as timed out. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30) ComponentPaginator # Bases: ActionRowExecutor Standard implementation of an action row executor used for pagination. This is a convenience class that allows you to easily implement a paginator. __init__ # __init__ ( iterator , * , authors , ephemeral_default = False , triggers = ( pagination . LEFT_TRIANGLE , pagination . STOP_SQUARE , pagination . RIGHT_TRIANGLE ), load_from_attributes = False , timeout = datetime . timedelta ( seconds = 30 )) Initialise a component paginator. PARAMETER DESCRIPTION iterator The iterator to paginate. This should be an iterator of tuples of (hikari.UndefinedOr[str], hikari.UndefinedOr[hikari.Embed]) . TYPE: typing . Iterator [ yuyo . pagination . EntryT ] | typing . AsyncIterator [ yuyo . pagination . EntryT ] authors The authors of the entries. If None is passed here then the paginator will be public (meaning that anybody can use it). TYPE: typing . Optional [ typing . Iterable [ hikari . SnowflakeishOr [ hikari . User ]]] ephemeral_default Whether or not the responses made on contexts spawned from this paginator should default to ephemeral (meaning only the author can see them) unless flags is specified on the response method. TYPE: bool DEFAULT: False triggers Collection of the unicode emojis that should trigger this paginator. As of current the only usable emojis are yuyo.pagination.LEFT_TRIANGLE , yuyo.pagination.RIGHT_TRIANGLE , yuyo.pagination.STOP_SQUARE , yuyo.pagination.LEFT_DOUBLE_TRIANGLE and yuyo.pagination.LEFT_TRIANGLE . TYPE: typing . Collection [ str ] DEFAULT: (pagination.LEFT_TRIANGLE, pagination.STOP_SQUARE, pagination.RIGHT_TRIANGLE) timeout The amount of time to wait after the component's last execution or creation until it times out. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30) builder # builder () Get a sequence of the component builders for this paginator. RETURNS DESCRIPTION typing . Sequence [ hikari . api . ComponentBuilder ] The component builders for this paginator. get_next_entry async # get_next_entry () Get the next entry in this paginator. This is generally helpful for making the message which the paginator will be based off and will still internally store the entry and increment the position of the paginator. Examples: response_paginator = yuyo . ComponentPaginator ( pages , authors = ( ctx . author . id ,) ) first_response = await response_paginator . get_next_entry () assert first_response content , embed = first_response message = await ctx . respond ( content = content , embed = embed , component = response_paginator , ensure_result = True ) component_client . set_executor ( message , response_paginator ) RETURNS DESCRIPTION yuyo . pagination . EntryT | None The next entry in this paginator, or None if there are no more entries. ErrorManager # A context manager provided to allow for more concise error handling with yuyo.backoff.Backoff . Examples: The following is an example of using yuyo.backoff.ErrorManager alongside yuyo.backoff.Backoff in-order to handle the exceptions which may be raised while trying to reply to a message. retry = Backoff () # Rules can either be passed to `ErrorManager`'s initiate as variable arguments # or one at a time to `ErrorManager.with_rule` through possibly chained-calls. error_handler = ( # For the 1st rule we catch two errors which would indicate the bot # no-longer has access to the target channel and break out of the # retry loop using `Backoff.retry`. ErrorManager ((( errors . NotFoundError , errors . ForbiddenError ), lambda _ : retry . finish ())) # For the 2nd rule we catch rate limited errors and set their # `retry` value as the next backoff time before suppressing the # error to allow this to retry the request. . with_rule (( errors . RateLimitedError ,), lambda exc : retry . set_next_backoff ( exc . retry_after )) # For the 3rd rule we suppress the internal server error to allow # backoff to reach the next retry and exponentially backoff as we # don't have any specific retry time for this error. . with_rule (( errors . InternalServerError ,), lambda _ : False ) ) async for _ in retry : # We entre this context manager each iteration to catch errors before # they cause us to break out of the `Backoff` loop. with error_handler : await message . respond ( \"General Kenobi\" ) # We need to break out of `retry` if this request succeeds. break __init__ # __init__ ( * rules ) Initialise an error manager instance. PARAMETER DESCRIPTION *rules Rules to initiate this error context manager with. These are each a 2-length tuple where the tuple[0] is an iterable of types of the exceptions this rule should apply to and tuple[1] is the rule's callback function. The callback function will be called with the raised exception when it matches one of the passed exceptions for the relevant rule and may raise, return True to indicate that the current error should be raised outside of the context manager or False / None to suppress the current error. TYPE: typing . Tuple [ typing . Iterable [ typing . Type [ BaseException ]], typing . Callable [[ typing . Any ], typing . Optional [ bool ]]] DEFAULT: () clear_rules # clear_rules () Clear the rules registered with this handler. with_rule # with_rule ( exceptions , result ) Add a rule to this exception context manager. PARAMETER DESCRIPTION exceptions An iterable of types of the exceptions this rule should apply to. TYPE: typing . Iterable [ typing . Type [ BaseException ]] result The function called with the raised exception when it matches one of the passed exceptions . This may raise, return True to indicate that the current error should be raised outside of the context manager or False / None to suppress the current error. TYPE: typing . Callable [[ typing . Any ], typing . Optional [ bool ]] RETURNS DESCRIPTION Self This returns the handler a rule was being added to in-order to allow for chained calls. MultiComponentExecutor # Bases: AbstractComponentExecutor Multi-component implementation of a component executor. This implementation allows for multiple components to be executed as a single view. __init__ # __init__ ( * , load_from_attributes = False , timeout = datetime . timedelta ( seconds = 30 )) Initialise a multi-component executor. PARAMETER DESCRIPTION timeout The amount of time to wait after the component's last execution or creation until it times out. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30) add_action_row # add_action_row () Create a builder class to add an action row to this executor. For the most part this follows the same implementation as yuyo.components.ActionRowExecutor except with the added detail that yuyo.components.ChildActionRowExecutor.add_to_parent must be called to add the action row to the parent executor. RETURNS DESCRIPTION ChildActionRowExecutor [ Self ] A builder class to add an action row to this executor. yuyo.components.ChildActionRowExecutor.add_to_parent should be called to finalise the action row and will return the parent executor for chained calls. add_builder # add_builder ( builder ) Add a non-executable component builder to this executor. This is useful for adding components that are not meant to be executed, such as a a row of link buttons. PARAMETER DESCRIPTION builder The component builder to add. TYPE: hikari . api . ComponentBuilder RETURNS DESCRIPTION Self add_executor # add_executor ( executor ) Add a component executor to this multi-component executor. This method is internally used by the add_{component} methods. PARAMETER DESCRIPTION executor The component executor to add. TYPE: AbstractComponentExecutor RETURNS DESCRIPTION Self The multi-component executor instance to enable chained calls. builders property # builders () Sequence of the component builders within this executor. executors property # executors () Sequence of the child executors within this multi-executor. ReactionClient # A class which handles the events for multiple registered reaction handlers. Note For a quicker way to initialise this client from a bot, see yuyo.reactions.ReactionClient.from_gateway_bot . __init__ # __init__ ( * , rest , event_manager , alluka = None , event_managed = True ) Initialise a reaction client. PARAMETER DESCRIPTION rest The REST client to register this reaction client with. TYPE: hikari . api . RESTClient event_manager The event manager client to register this reaction client with. TYPE: hikari . api . EventManager alluka The alluka client to use for callback DI. TYPE: typing . Optional [ alluka_ . abc . Client ] DEFAULT: None event_managed Whether the reaction client should be automatically opened and closed based on the lifetime events dispatched by event_managed . TYPE: bool DEFAULT: True add_handler # add_handler ( message , / , paginator ) Add a reaction handler to this reaction client. Note This does not call yuyo.reactions.AbstractReactionHandler.open . PARAMETER DESCRIPTION message The message ID to add register a reaction handler with. TYPE: hikari . SnowflakeishOr [ hikari . Message ] paginator The object of the opened paginator to register in this reaction client. TYPE: AbstractReactionHandler alluka property # alluka () The Alluka client being used for callback dependency injection. close async # close () Close this client by unregistering any registered tasks and event listeners. from_gateway_bot classmethod # from_gateway_bot ( bot , / , * , event_managed = True ) Build a ReactionClient from a gateway bot. PARAMETER DESCRIPTION bot The bot to build a reaction client for. TYPE: traits . GatewayBotAware event_managed Whether the reaction client should be automatically opened and closed based on the lifetime events dispatched by bot . TYPE: bool DEFAULT: True RETURNS DESCRIPTION ReactionClient The reaction client for the bot. get_handler # get_handler ( message ) Get a reference to a paginator registered in this reaction client. Note This does not call yuyo.reactions.AbstractReactionHandler.close . PARAMETER DESCRIPTION message The message ID to remove a paginator for. TYPE: hikari . SnowflakeishOr [ hikari . Message ] RETURNS DESCRIPTION AbstractReactionHandler | None The object of the registered paginator if found else None . is_closed property # is_closed () Whether this client is closed. open async # open () Start this client by registering the required tasks and event listeners for it to function. remove_handler # remove_handler ( message ) Remove a paginator from this reaction client. Note This does not call yuyo.reactions.AbstractReactionHandler.close . PARAMETER DESCRIPTION message The message ID to remove a paginator for. TYPE: hikari . SnowflakeishOr [ hikari . Message ] RETURNS DESCRIPTION AbstractReactionHandler | None The object of the registered paginator if found else None . ReactionHandler # Bases: AbstractReactionHandler Standard basic implementation of a reaction handler. __init__ # __init__ ( * , authors = (), timeout = datetime . timedelta ( seconds = 30 ), load_from_attributes = True ) Initialise a reaction handler. PARAMETER DESCRIPTION authors An iterable of IDs of the users who can call this paginator. If left empty then all users will be able to call this paginator. TYPE: typing . Iterable [ hikari . SnowflakeishOr [ hikari . User ]] DEFAULT: () timeout How long it should take for this paginator to timeout. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30) add_callback # add_callback ( emoji_identifier , callback ) Add a callback to this reaction handler. PARAMETER DESCRIPTION emoji_identifier Identifier of the emoji this callback is for. This should be a snowfake if this is for a custom emoji or a string if this is for a unicode emoji. TYPE: typing . Union [ str , hikari . SnowflakeishOr [ hikari . CustomEmoji ]] callback The callback to add. This should be a function that accepts a single parameter, which is the event that triggered this reaction. TYPE: CallbackSig authors property # authors () Set of the authors/owner of a enabled handler. Note If this is empty then the handler is considered public and any user will be able to trigger it. remove_callback # remove_callback ( emoji_identifier ) Remove a callback from this reaction handler. PARAMETER DESCRIPTION emoji_identifier Identifier of the emoji the callback to remove is for. This should be a snowfake if this is for a custom emoji or a string if this is for a unicode emoji. TYPE: typing . Union [ str , hikari . SnowflakeishOr [ hikari . CustomEmoji ]] timeout property # timeout () How long this handler will wait since the last event before timing out. with_callback # with_callback ( emoji_identifier ) Add a callback to this reaction handler through a decorator call. PARAMETER DESCRIPTION emoji_identifier Identifier of the emoji this callback is for. This should be a snowfake if this is for a custom emoji or a string if this is for a unicode emoji. TYPE: typing . Union [ str , hikari . SnowflakeishOr [ hikari . CustomEmoji ]] RETURNS DESCRIPTION typing . Callabke [[ CallbackSigT ], CallbackSigT ] A decorator to add a callback to this reaction handler. ReactionPaginator # Bases: ReactionHandler Standard implementation of a reaction handler for pagination. __init__ # __init__ ( iterator , * , authors , triggers = ( pagination . LEFT_TRIANGLE , pagination . STOP_SQUARE , pagination . RIGHT_TRIANGLE ), timeout = datetime . timedelta ( seconds = 30 )) Initialise a reaction paginator. PARAMETER DESCRIPTION iterator Either an asynchronous or synchronous iterator of the entries this should paginate through. entry[0] represents the message's possible content and can either be str or hikari.undefined.UNDEFINED and entry[1] represents the message's possible embed and can either be hikari.embeds.Embed or hikari.undefined.UNDEFINED . TYPE: typing . Iterator [ yuyo . pagination . EntryT ] | typing . AsyncIterator [ yuyo . pagination . EntryT ] authors An iterable of IDs of the users who can call this paginator. If left empty then all users will be able to call this paginator. TYPE: typing . Iterable [ hikari . SnowflakeishOr [ hikari . User ]] timeout How long it should take for this paginator to timeout. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30) add_author # add_author ( user ) Add a author/owner to this handler. PARAMETER DESCRIPTION user The user to add as an owner for this handler. TYPE: hikari . SnowflakeishOr [ hikari . User ] close async # close ( * , remove_reactions = False , max_retries = 5 , max_backoff = 2.0 ) Close this handler and deregister any previously registered message. PARAMETER DESCRIPTION remove_reactions Whether this should remove the reactions that were being used to paginate through this from the previously registered message. TYPE: bool DEFAULT: False create_message async # create_message ( rest , channel_id , / , * , add_reactions = True , max_retries = 5 , max_backoff = 2.0 ) Start this handler and link it to a bot message. Note Calling this multiple times will replace the previously registered message. PARAMETER DESCRIPTION rest Rest client to use to make the response. TYPE: hikari . api . RESTClient channel_id ID of the channel to respond in. TYPE: hikari . SnowflakeishOr [ hikari . TextableChannel ] add_reactions Whether this should add the paginator's reactions to the message after responding. TYPE: bool DEFAULT: True max_retries How many times this should retry to respond if Hikari raises any ratelimit errors. TYPE: int DEFAULT: 5 max_backoff The maximum time this should backoff for before trying if Hikari raises any ratelimit errors. TYPE: float DEFAULT: 2.0 RETURNS DESCRIPTION hikari . messages . Message Object of the message this handler now targets. If message was not supplied then this will be the object of a newly created message, otherwise this will be what was supplied as message . RAISES DESCRIPTION ValueError If the provided iterator didn't yield any content for the first message. remove_author # remove_author ( user ) Remove a author/owner from this handler. Note If the provided user isn't already a registered owner of this paginator then this should pass silently without raising. PARAMETER DESCRIPTION user The user to remove from this handler's owners. TYPE: hikari . SnowflakeishOr [ hikari . User ] WaitForExecutor # Bases: AbstractComponentExecutor Component executor used to wait for a single component interaction. Examples: responses : dict [ str , str ] message = await ctx . respond ( \"hi, pick an option\" , components = [ ... ]) executor = yuyo . components . WaitFor ( authors = ( ctx . author . id ,), timeout = datetime . timedelta ( seconds = 30 )) component_client . set_executor ( message . id , executor ) try : result = await executor . wait_for () except asyncio . TimeoutError : await ctx . respond ( \"timed out\" ) else : await result . respond ( responses [ result . interaction . custom_id ]) __init__ # __init__ ( * , authors , ephemeral_default = False , timeout ) Initialise a wait for executor. PARAMETER DESCRIPTION authors The authors of the entries. If None is passed here then the paginator will be public (meaning that anybody can use it). TYPE: typing . Optional [ typing . Iterable [ hikari . SnowflakeishOr [ hikari . User ]]] ephemeral_default Whether or not the responses made on contexts spawned from this paginator should default to ephemeral (meaning only the author can see them) unless flags is specified on the response method. TYPE: bool DEFAULT: False timeout How long this should wait for a matching component interaction until it times-out. TYPE: datetime . timedelta wait_for async # wait_for () Wait for the next matching interaction. RETURNS DESCRIPTION ComponentContext The next matching interaction. RAISES DESCRIPTION RuntimeError If the executor is already being waited for. asyncio . TimeoutError If the timeout is reached. aenumerate async # aenumerate ( iterable ) Async equivalent of enumerate . PARAMETER DESCRIPTION iterable The async iterable to enumerate. TYPE: typing . AsyncIterable [ _T ] RETURNS DESCRIPTION typing . AsyncIterator [ tuple [ int , _T ]] The enumerated async iterator. async_paginate_string async # async_paginate_string ( lines , * , char_limit = 2000 , line_limit = 25 , wrapper = None ) Lazily paginate an iterator of lines. PARAMETER DESCRIPTION lines The asynchronous iterator of lines to paginate. TYPE: typing . AsyncIterable [ str ] char_limit The limit for how many characters should be included per yielded page. TYPE: int DEFAULT: 2000 line_limit The limit for how many lines should be included per yielded page. TYPE: int DEFAULT: 25 wrapper A wrapper for each yielded page. This should leave \"{}\" in it to be replaced by the page's content. TYPE: typing . Optional [ str ] DEFAULT: None RETURNS DESCRIPTION typing . AsyncIterator [ tuple [ str , int ]] An async iterator of page tuples (string context to int zero-based index). paginate_string # paginate_string ( lines , * , char_limit = 2000 , line_limit = 25 , wrapper = None ) Lazily paginate an iterator of lines. PARAMETER DESCRIPTION lines The iterator of lines to paginate. This iterator may be asynchronous or synchronous. TYPE: typing . Iterator [ str ] | typing . AsyncIterator [ str ] char_limit The limit for how many characters should be included per yielded page. TYPE: int DEFAULT: 2000 line_limit The limit for how many lines should be included per yielded page. TYPE: int DEFAULT: 25 wrapper A wrapper for each yielded page. This should leave \"{}\" in it to be replaced by the page's content. TYPE: typing . Optional [ str ] DEFAULT: None RETURNS DESCRIPTION AsyncIterator [ tuple [ str , int ]] | typing . Iterator [ tuple [ str , int ]] An iterator of page tuples (string context to int zero-based index). sync_paginate_string # sync_paginate_string ( lines , * , char_limit = 2000 , line_limit = 25 , wrapper = None ) Lazily paginate an iterator of lines. PARAMETER DESCRIPTION lines The iterator of lines to paginate. TYPE: typing . Iterable [ str ] char_limit The limit for how many characters should be included per yielded page. TYPE: int DEFAULT: 2000 line_limit The limit for how many lines should be included per yielded page. TYPE: int DEFAULT: 25 wrapper A wrapper for each yielded page. This should leave \"{}\" in it to be replaced by the page's content. TYPE: typing . Optional [ str ] DEFAULT: None RETURNS DESCRIPTION typing . Iterator [ tuple [ str , int ]] An iterator of page tuples (string context to int zero-based index).","title":"yuyo"},{"location":"reference/#yuyo_1","text":"A collection of utility functions and classes designed to enhances Hikari.","title":"yuyo"},{"location":"reference/#yuyo.AbstractComponentExecutor","text":"Bases: abc . ABC Abstract interface of an object which handles the execution of a message component.","title":"AbstractComponentExecutor"},{"location":"reference/#yuyo.components.AbstractComponentExecutor.custom_ids","text":"custom_ids () Collection of the custom IDs this executor is listening for.","title":"custom_ids()"},{"location":"reference/#yuyo.components.AbstractComponentExecutor.has_expired","text":"has_expired () Whether this executor has ended.","title":"has_expired()"},{"location":"reference/#yuyo.AbstractReactionHandler","text":"Bases: abc . ABC The interface for a reaction handler used with yuyo.reactions.ReactionClient .","title":"AbstractReactionHandler"},{"location":"reference/#yuyo.reactions.AbstractReactionHandler.close","text":"close () Close this handler.","title":"close()"},{"location":"reference/#yuyo.reactions.AbstractReactionHandler.has_expired","text":"has_expired () Whether this handler has ended.","title":"has_expired()"},{"location":"reference/#yuyo.reactions.AbstractReactionHandler.last_triggered","text":"last_triggered () When this handler was last triggered. Note If it hasn't ever been triggered then this will be when it was created.","title":"last_triggered()"},{"location":"reference/#yuyo.reactions.AbstractReactionHandler.on_reaction_event","text":"on_reaction_event ( event , / , * , alluka = None ) Handle a reaction event. PARAMETER DESCRIPTION event The event to handle. TYPE: EventT alluka The Alluka client to use for callback dependency injection during callback calls. TYPE: typing . Optional [ alluka_ . abc . Client ] DEFAULT: None RAISES DESCRIPTION HandlerClosed If this reaction handler has been closed.","title":"on_reaction_event()"},{"location":"reference/#yuyo.reactions.AbstractReactionHandler.open","text":"open ( message ) Open this handler. PARAMETER DESCRIPTION message The message to bind this handler to. TYPE: hikari . Message","title":"open()"},{"location":"reference/#yuyo.ActionRowExecutor","text":"Bases: ComponentExecutor , hikari . api . ComponentBuilder Class used for handling the execution of an action row.","title":"ActionRowExecutor"},{"location":"reference/#yuyo.components.ActionRowExecutor.__init__","text":"__init__ ( * , ephemeral_default = False , load_from_attributes = False , timeout = datetime . timedelta ( seconds = 30 )) Initialise an action row executor. PARAMETER DESCRIPTION ephemeral_default Whether this executor's responses should default to being ephemeral. TYPE: bool DEFAULT: False timeout How long this component should last until its marked as timed out. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30)","title":"__init__()"},{"location":"reference/#yuyo.AsgiAdapter","text":"Asgi/3 adapter for Hikari's interaction server interface. For this to work, hikari has to be installed with the optional \"server\" feature (e.g python -m pip install hikari[server] ).","title":"AsgiAdapter"},{"location":"reference/#yuyo.asgi.AsgiAdapter.__call__","text":"__call__ ( scope , receive , send ) Call the adapter. Note This method is called by the ASGI server. PARAMETER DESCRIPTION scope The scope of the request. TYPE: asgiref . Scope receive The receive function to use. TYPE: asgiref . ASGIReceiveCallable send The send function to use. TYPE: asgiref . ASGISendCallable RAISES DESCRIPTION NotImplementedError If this is called with a websocket scope. RuntimeError If an invalid scope event is passed.","title":"__call__()"},{"location":"reference/#yuyo.asgi.AsgiAdapter.__init__","text":"__init__ ( server , / , * , executor = None ) Initialise the adapter. PARAMETER DESCRIPTION server The interaction server to use. TYPE: hikari . api . InteractionServer executor If non- None , then this executor is used instead of the concurrent.futures.ThreadPoolExecutor attached to the asyncio.AbstractEventLoop that the bot will run on. This executor is used primarily for file-IO. While mainly supporting the concurrent.futures.ThreadPoolExecutor implementation in the standard lib, Hikari's file handling systems should also work with concurrent.futures.ProcessPoolExecutor , which relies on all objects used in IPC to be pickle able. Many third-party libraries will not support this fully though, so your mileage may vary on using ProcessPoolExecutor implementations with this parameter. TYPE: typing . Optional [ concurrent . futures . Executor ] DEFAULT: None","title":"__init__()"},{"location":"reference/#yuyo.asgi.AsgiAdapter.add_shutdown_callback","text":"add_shutdown_callback ( callback ) Add a callback to be called when the ASGI server shuts down. Warning These callbacks will block the ASGI server from shutting down until they complete and any raised errors will lead to a failed shutdown. PARAMETER DESCRIPTION callback The shutdown callback to add. TYPE: typing . Callable [[], typing . Union [None, typing . Coroutine [ typing . Any , typing . Any , None]]] RETURNS DESCRIPTION Self This adapter to enable call chaining.","title":"add_shutdown_callback()"},{"location":"reference/#yuyo.asgi.AsgiAdapter.add_startup_callback","text":"add_startup_callback ( callback ) Add a callback to be called when the ASGI server starts up. Warning These callbacks will block the ASGI server from starting until they complete and any raised errors will lead to a failed startup. PARAMETER DESCRIPTION callback The startup callback to add. TYPE: typing . Callable [[], typing . Union [None, typing . Coroutine [ typing . Any , typing . Any , None]]] RETURNS DESCRIPTION Self This adapter to enable call chaining.","title":"add_startup_callback()"},{"location":"reference/#yuyo.asgi.AsgiAdapter.process_lifespan_event","text":"process_lifespan_event ( receive , send ) Process a lifespan ASGI event. Note This function is used internally by the adapter. PARAMETER DESCRIPTION receive The receive function to use. TYPE: asgiref . ASGIReceiveCallable send The send function to use. TYPE: asgiref . ASGISendCallable RAISES DESCRIPTION RuntimeError If an invalid lifespan event is passed.","title":"process_lifespan_event()"},{"location":"reference/#yuyo.asgi.AsgiAdapter.process_request","text":"process_request ( scope , receive , send ) Process an HTTP request. Note This function is used internally by the adapter. PARAMETER DESCRIPTION scope The scope of the request. TYPE: asgiref . HTTPScope receive The receive function to use. TYPE: asgiref . ASGIReceiveCallable send The send function to use. TYPE: asgiref . ASGISendCallable","title":"process_request()"},{"location":"reference/#yuyo.asgi.AsgiAdapter.server","text":"server () The interaction server this adapter is bound to.","title":"server()"},{"location":"reference/#yuyo.AsgiBot","text":"Bases: AsgiAdapter , hikari . RESTBotAware Bot implementation which acts as an ASGI adapter. This bot doesn't initiate a server internally but instead relies on being called as an ASGI app. For this to work, hikari has to be installed with the optional \"server\" feature (e.g python -m pip install hikari[server] ).","title":"AsgiBot"},{"location":"reference/#yuyo.asgi.AsgiBot.__init__","text":"__init__ ( token , token_type = None , public_key = None , * , asgi_managed = True , executor = None , http_settings = None , max_rate_limit = 300.0 , max_retries = 3 , proxy_settings = None , rest_url = None ) Initialise a new ASGI bot. PARAMETER DESCRIPTION token The bot or bearer token. If no token is to be used, this can be undefined. TYPE: typing . Union [ str , hikari . api . TokenStrategy ] token_type The type of token in use. This should only be passed when str is passed for token , can be \"Bot\" or \"Bearer\" and will be defaulted to \"Bearer\" in this situation. This should be left as None when either hikari.api.rest.TokenStrategy or None is passed for token . TYPE: typing . Union [ hikari . TokenType , str , None] DEFAULT: None asgi_managed Whether this bot's internal components should be automatically started and stopped based on the Asgi lifespan events. TYPE: bool DEFAULT: True executor If non- None , then this executor is used instead of the concurrent.futures.ThreadPoolExecutor attached to the asyncio.AbstractEventLoop that the bot will run on. This executor is used primarily for file-IO. While mainly supporting the concurrent.futures.ThreadPoolExecutor implementation in the standard lib, Hikari's file handling systems should also work with concurrent.futures.ProcessPoolExecutor , which relies on all objects used in IPC to be pickle able. Many third-party libraries will not support this fully though, so your mileage may vary on using ProcessPoolExecutor implementations with this parameter. TYPE: typing . Optional [ concurrent . futures . Executor ] DEFAULT: None http_settings Optional custom HTTP configuration settings to use. Allows you to customise functionality such as whether SSL-verification is enabled, what timeouts aiohttp should expect to use for requests, and behavior regarding HTTP-redirects. TYPE: typing . Optional [ hikari . impl . HTTPSettings ] DEFAULT: None max_rate_limit The max number of seconds to backoff for when rate limited. Anything greater than this will instead raise an error. This defaults to five minutes to stop potentially indefinitely waiting on an endpoint, which is almost never what you want to do if giving a response to a user. You can set this to float(\"inf\") to disable this check entirely. Note that this only applies to the REST API component that communicates with Discord, and will not affect sharding or third party HTTP endpoints that may be in use. TYPE: float DEFAULT: 300.0 max_retries Maximum number of times a request will be retried if it fails with a 5xx status. Defaults to 3 if set to None . TYPE: int DEFAULT: 3 proxy_settings Custom proxy settings to use with network-layer logic in your application to get through an HTTP-proxy. TYPE: typing . Optional [ hikari . impl . ProxySettings ] DEFAULT: None public_key The public key to use to verify received interaction requests. This may be a hex encoded str or the raw bytes . If left as None then the client will try to work this value out based on token . TYPE: typing . Union [ bytes , str , None] DEFAULT: None rest_url Defaults to the Discord REST API URL if None . Can be overridden if you are attempting to point to an unofficial endpoint, or if you are attempting to mock/stub the Discord API for any reason. Generally you do not want to change this. TYPE: typing . Optional [ str ] DEFAULT: None RAISES DESCRIPTION ValueError If token_type is provided when a token strategy is passed for token . if token_type is left as None when a string is passed for token .","title":"__init__()"},{"location":"reference/#yuyo.asgi.AsgiBot.close","text":"close () Close the bot's REST client. Warning Unless asgi_managed=False is passed to AsgiBot.__init__ , the bot will be automatically closed based on the ASGI lifespan events and any other calls to this function will raise a RuntimeError . RAISES DESCRIPTION RuntimeError If the client isn't alive. If the client is ASGI managed.","title":"close()"},{"location":"reference/#yuyo.asgi.AsgiBot.run","text":"run () Start the bot's REST client and wait until the bot's closed. Warning Unless asgi_managed=False is passed to yuyo.asgi.AsgiBot. init , the bot will be automatically started and closed based on the ASGI lifespan events and any other calls to this function will raise a RuntimeError . RAISES DESCRIPTION RuntimeError If the client is already alive. If the client is ASGI managed.","title":"run()"},{"location":"reference/#yuyo.asgi.AsgiBot.start","text":"start () Start the bot's REST client. Warning Unless asgi_managed=False is passed to yuyo.asgi.AsgiBot. init , the bot will be automatically started based on the ASGI lifespan events and any other calls to this function will raise a RuntimeError . RAISES DESCRIPTION RuntimeError If the client is already alive. If the client is ASGI managed.","title":"start()"},{"location":"reference/#yuyo.Backoff","text":"Used to exponentially backoff asynchronously. This class acts as an asynchronous iterator and can be iterated over to provide implicit backoff where for every iteration other than the first this will either back off for the time passed to yuyo.backoff.Backoff.set_next_backoff if applicable or a time calculated exponentially. Examples: An example of using this class as an asynchronous iterator may look like the following # While we can directly do `async for _ in Backoff()`, by assigning it to a # variable we allow ourself to provide a specific backoff time in some cases. backoff = Backoff () async for _ in backoff : try : message = await bot . rest . fetch_message ( channel_id , message_id ) except errors . RateLimitedError as exc : # If we have a specific backoff time then set it for the next iteration backoff . set_next_backoff ( exc . retry_after ) except errors . InternalServerError : # Else let the iterator calculate an exponential backoff before the next loop. pass else : # We need to break out of the iterator to make sure it doesn't backoff again. # Alternatively `Backoff.finish()` can be called to break out of the loop. break Alternatively you may want to explicitly call yuyo.backoff.Backoff.backoff , a alternative of the previous example which uses yuyo.backoff.Backoff.backoff may look like the following backoff = Backoff () message : typing . Optional [ messages . Message ] = None while not message : try : message = await bot . rest . fetch_message ( channel_id , message_id ) except errors . RateLimitedError as exc : # If we have a specific backoff time then set it for the next iteration. await backoff . backoff ( exc . retry_after ) except errors . InternalServerError : # Else let the iterator calculate an exponential backoff before the next loop. await backoff . backoff ()","title":"Backoff"},{"location":"reference/#yuyo.backoff.Backoff.__init__","text":"__init__ ( max_retries = None , * , base = 2.0 , maximum = 64.0 , jitter_multiplier = 1.0 , initial_increment = 0 ) Initialise a backoff instance. PARAMETER DESCRIPTION max_retries The maximum amount of times this should iterate for between resets. If left as None then this iterator will be unlimited. This must be greater than or equal to 1. TYPE: typing . Optional [ int ] DEFAULT: None base The base to use. TYPE: float DEFAULT: 2.0 maximum The max value the backoff can be in a single iteration. Anything above this will be capped to this base value plus random jitter. TYPE: float DEFAULT: 64.0 jitter_multiplier The multiplier for the random jitter. Set to 0 to disable jitter. TYPE: float DEFAULT: 1.0 initial_increment The initial increment to start at. TYPE: int DEFAULT: 0 RAISES DESCRIPTION ValueError If an int that's too big to be represented as a float or a non-finite value is passed in place of a field that's annotated as float or if max_retries is less than 1 .","title":"__init__()"},{"location":"reference/#yuyo.backoff.Backoff.backoff","text":"backoff ( backoff_ ) Sleep for the provided backoff or for the next exponent. This provides an alternative to iterating over this class. PARAMETER DESCRIPTION backoff_ The time this should backoff for. If left as None then this will back off for the last time provided with yuyo.backoff.Backoff.set_next_backoff if available or the next exponential time. TYPE: typing . Optional [ float ]","title":"backoff()"},{"location":"reference/#yuyo.backoff.Backoff.finish","text":"finish () Mark the iterator as finished to break out of the current loop.","title":"finish()"},{"location":"reference/#yuyo.backoff.Backoff.is_depleted","text":"is_depleted () Whether \"max_retries\" has been reached. This can be used to workout whether the loop was explicitly broken out of using yuyo.backoff.Backoff.finish / break or if it hit \"max_retries\".","title":"is_depleted()"},{"location":"reference/#yuyo.backoff.Backoff.reset","text":"reset () Reset the backoff to it's original state to reuse it.","title":"reset()"},{"location":"reference/#yuyo.backoff.Backoff.set_next_backoff","text":"set_next_backoff ( backoff_ ) Specify a backoff time for the next iteration or yuyo.backoff.Backoff.backoff call. If this is called then the exponent won't be increased for this iteration. Note Calling this multiple times in a single iteration will overwrite any previously set next backoff.","title":"set_next_backoff()"},{"location":"reference/#yuyo.ChildActionRowExecutor","text":"Bases: ActionRowExecutor , typing . Generic [ _ParentExecutorProtoT ] Extended action row implementation which can be tied to a multi-component executor.","title":"ChildActionRowExecutor"},{"location":"reference/#yuyo.components.ChildActionRowExecutor.add_to_parent","text":"add_to_parent () Add this action row to its parent executor. RETURNS DESCRIPTION _ParentExecutorProtoT The parent executor this action row was added to.","title":"add_to_parent()"},{"location":"reference/#yuyo.ComponentClient","text":"Client used to handle component executors within a REST or gateway flow.","title":"ComponentClient"},{"location":"reference/#yuyo.components.ComponentClient.__init__","text":"__init__ ( * , alluka = None , event_manager = None , event_managed = None , server = None ) Initialise a component client. Note For an easier way to initialise the client from a bot see yuyo.components.ComponentClient.from_gateway_bot and yuyo.components.ComponentClient.from_rest_bot . PARAMETER DESCRIPTION alluka The Alluka client to use for callback dependency injection in this client. If not provided then this will initialise its own Alluka client. TYPE: typing . Optional [ alluka_ . abc . Client ] DEFAULT: None event_manager The event manager this client should listen to dispatched component interactions from if applicable. TYPE: typing . Optional [ hikari . api . EventManager ] DEFAULT: None event_managed Whether this client should be automatically opened and closed based on the lifetime events dispatched by event_manager . Defaults to True if an event manager is passed. TYPE: typing . Optional [ bool ] DEFAULT: None server The server this client should listen to component interactions from if applicable. TYPE: typing . Optional [ hikari . api . InteractionServer ] DEFAULT: None RAISES DESCRIPTION ValueError If event_managed is passed as True when event_manager is None .","title":"__init__()"},{"location":"reference/#yuyo.components.ComponentClient.add_executor","text":"add_executor ( message , executor ) Deprecated alias of yuyo.components.ComponentClient.add_executor .","title":"add_executor()"},{"location":"reference/#yuyo.components.ComponentClient.alluka","text":"alluka () The Alluka client being used for callback dependency injection.","title":"alluka()"},{"location":"reference/#yuyo.components.ComponentClient.close","text":"close () Close the component client.","title":"close()"},{"location":"reference/#yuyo.components.ComponentClient.from_gateway_bot","text":"from_gateway_bot ( bot , / , * , event_managed = True ) Build a component client froma Gateway Bot. PARAMETER DESCRIPTION bot The Gateway bot this component client should be bound to. TYPE: hikari . GatewayBotAware event_managed Whether the component client should be automatically opened and closed based on the lifetime events dispatched by bot . TYPE: bool DEFAULT: True RETURNS DESCRIPTION ComponentClient The initialised component client.","title":"from_gateway_bot()"},{"location":"reference/#yuyo.components.ComponentClient.from_rest_bot","text":"from_rest_bot ( bot ) Build a component client froma REST Bot. PARAMETER DESCRIPTION bot The REST bot this component client should be bound to. TYPE: hikari . RESTBotAware RETURNS DESCRIPTION ComponentClient The initialised component client.","title":"from_rest_bot()"},{"location":"reference/#yuyo.components.ComponentClient.get_constant_id","text":"get_constant_id ( custom_id ) Get a set constant \"custom_id\" callback. PARAMETER DESCRIPTION custom_id The custom_id to get the callback for. TYPE: str RETURNS DESCRIPTION CallbackSig | None The callback for the custom_id, or None if it doesn't exist.","title":"get_constant_id()"},{"location":"reference/#yuyo.components.ComponentClient.get_executor","text":"get_executor ( message ) Get the component executor set for a message. PARAMETER DESCRIPTION message The message to get the executor for. TYPE: hikari . SnowflakeishOr [ hikari . Message ] RETURNS DESCRIPTION yuyo . components . AbstractComponentExecutor | None The executor set for the message or None if none is set.","title":"get_executor()"},{"location":"reference/#yuyo.components.ComponentClient.open","text":"open () Startup the component client.","title":"open()"},{"location":"reference/#yuyo.components.ComponentClient.remove_constant_id","text":"remove_constant_id ( custom_id ) Remove a constant \"custom_id\" callback. PARAMETER DESCRIPTION custom_id The custom_id to remove the callback for. TYPE: str RETURNS DESCRIPTION Self The component client to allow chaining. RAISES DESCRIPTION KeyError If the custom_id is not registered.","title":"remove_constant_id()"},{"location":"reference/#yuyo.components.ComponentClient.remove_executor","text":"remove_executor ( message ) Remove the component executor for a message. PARAMETER DESCRIPTION message The message to remove the executor for. TYPE: hikari . SnowflakeishOr [ hikari . Message ] RETURNS DESCRIPTION Self The component client to allow chaining.","title":"remove_executor()"},{"location":"reference/#yuyo.components.ComponentClient.set_constant_id","text":"set_constant_id ( custom_id , callback , / , * , prefix_match = False ) Add a constant \"custom_id\" callback. These are callbacks which'll always be called for a specific custom_id while taking priority over executors. PARAMETER DESCRIPTION custom_id The custom_id to register the callback for. TYPE: str callback The callback to register. This should take a single argument of type yuyo.components.ComponentContext , be asynchronous and return None . TYPE: CallbackSig prefix_match Whether the custom_id should be treated as a prefix match. This allows for further state to be held in the custom id after the prefix and is lower priority than normal custom id match. TYPE: bool DEFAULT: False RETURNS DESCRIPTION Self The component client to allow chaining. RAISES DESCRIPTION ValueError If the custom_id is already registered.","title":"set_constant_id()"},{"location":"reference/#yuyo.components.ComponentClient.set_executor","text":"set_executor ( message , executor ) Set the component executor for a message. PARAMETER DESCRIPTION message The message to set the executor for. TYPE: hikari . SnowflakeishOr [ hikari . Message ] executor The executor to set. This will be called for every component interaction for the message unless the component's custom_id is registered as a constant id callback. TYPE: AbstractComponentExecutor RETURNS DESCRIPTION Self The component client to allow chaining.","title":"set_executor()"},{"location":"reference/#yuyo.components.ComponentClient.with_constant_id","text":"with_constant_id ( custom_id , / , * , prefix_match = False ) Add a constant \"custom_id\" callback through a decorator call. These are callbacks which'll always be called for a specific custom_id while taking priority over executors. PARAMETER DESCRIPTION custom_id The custom_id to register the callback for. TYPE: str prefix_match Whether the custom_id should be treated as a prefix match. This allows for further state to be held in the custom id after the prefix and is lower priority than normal custom id match. TYPE: bool DEFAULT: False RETURNS DESCRIPTION Callable [[ CallbackSigT ], CallbackSigT ] A decorator to register the callback. RAISES DESCRIPTION KeyError If the custom_id is already registered.","title":"with_constant_id()"},{"location":"reference/#yuyo.ComponentContext","text":"The general context passed around for a component trigger.","title":"ComponentContext"},{"location":"reference/#yuyo.components.ComponentContext.create_followup","text":"create_followup ( content = hikari . UNDEFINED , * , delete_after = None , ephemeral = False , attachment = hikari . UNDEFINED , attachments = hikari . UNDEFINED , component = hikari . UNDEFINED , components = hikari . UNDEFINED , embed = hikari . UNDEFINED , embeds = hikari . UNDEFINED , mentions_everyone = hikari . UNDEFINED , user_mentions = hikari . UNDEFINED , role_mentions = hikari . UNDEFINED , tts = hikari . UNDEFINED , flags = hikari . UNDEFINED ) Create a followup response for this context. Warning Calling this on a context which hasn't had an initial response yet will lead to a hikari.errors.NotFoundError being raised. PARAMETER DESCRIPTION content If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED delete_after If provided, the seconds after which the response message should be deleted. Slash command responses can only be deleted within 15 minutes of the command being received. TYPE: typing . Union [ datetime . timedelta , float , int , None] DEFAULT: None ephemeral Whether the deferred response should be ephemeral. Passing True here is a shorthand for including 1 << 64 in the passed flags. TYPE: bool DEFAULT: False attachment If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL. TYPE: hikari . UndefinedOr [ hikari . Resourceish ] DEFAULT: hikari.UNDEFINED attachments If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . Resourceish ]] DEFAULT: hikari.UNDEFINED component If provided, builder object of the component to include in this message. TYPE: hikari . UndefinedOr [ hikari . api . ComponentBuilder ] DEFAULT: hikari.UNDEFINED components If provided, a sequence of the component builder objects to include in this message. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . api . ComponentBuilder ]] DEFAULT: hikari.UNDEFINED embed If provided, the message embed. TYPE: hikari . UndefinedOr [ hikari . Embed ] DEFAULT: hikari.UNDEFINED embeds If provided, the message embeds. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . Embed ]] DEFAULT: hikari.UNDEFINED mentions_everyone If provided, whether the message should parse @everyone/@here mentions. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED user_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialUser ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED role_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialRole ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED tts If provided, whether the message will be sent as a TTS message. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED flags The flags to set for this response. As of writing this can only flag which can be provided is EPHEMERAL, other flags are just ignored. TYPE: typing . Union [ hikari . UndefinedType , int , hikari . MessageFlag ] DEFAULT: hikari.UNDEFINED RETURNS DESCRIPTION hikari . Message The created message object. RAISES DESCRIPTION hikari . NotFoundError If the current interaction is not found or it hasn't had an initial response yet. hikari . BadRequestError This can be raised if the file is too large; if the embed exceeds the defined limits; if the message content is specified only and empty or greater than 2000 characters; if neither content, file or embeds are specified. If any invalid snowflake IDs are passed; a snowflake may be invalid due to it being outside of the range of a 64 bit integer. ValueError If more than 100 unique objects/entities are passed for role_mentions or `user_mentions. If the interaction will have expired before delete_after is reached. If both attachment and attachments are passed or both component and components are passed or both embed and embeds are passed.","title":"create_followup()"},{"location":"reference/#yuyo.components.ComponentContext.create_initial_response","text":"create_initial_response ( response_type , / , content = hikari . UNDEFINED , * , delete_after = None , ephemeral = False , attachment = hikari . UNDEFINED , attachments = hikari . UNDEFINED , component = hikari . UNDEFINED , components = hikari . UNDEFINED , embed = hikari . UNDEFINED , embeds = hikari . UNDEFINED , mentions_everyone = hikari . UNDEFINED , user_mentions = hikari . UNDEFINED , role_mentions = hikari . UNDEFINED , flags = hikari . UNDEFINED , tts = hikari . UNDEFINED ) Create the initial response for this context. Warning Calling this on a context which already has an initial response will result in this raising a hikari.errors.NotFoundError . This includes if the REST interaction server has already responded to the request and deferrals. PARAMETER DESCRIPTION response_type The type of message response to give. TYPE: hikari . MessageResponseTypesT content The content to edit the last response with. If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED delete_after If provided, the seconds after which the response message should be deleted. Slash command responses can only be deleted within 15 minutes of the command being received. TYPE: typing . Union [ datetime . timedelta , float , int , None] DEFAULT: None ephemeral Whether the deferred response should be ephemeral. Passing True here is a shorthand for including 1 << 64 in the passed flags. TYPE: bool DEFAULT: False content If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED attachment If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL. TYPE: hikari . UndefinedOr [ hikari . Resourceish ] DEFAULT: hikari.UNDEFINED attachments If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . Resourceish ]] DEFAULT: hikari.UNDEFINED component If provided, builder object of the component to include in this message. TYPE: hikari . UndefinedOr [ hikari . api . ComponentBuilder ] DEFAULT: hikari.UNDEFINED components If provided, a sequence of the component builder objects to include in this message. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . api . ComponentBuilder ]] DEFAULT: hikari.UNDEFINED embed If provided, the message embed. TYPE: hikari . UndefinedOr [ hikari . Embed ] DEFAULT: hikari.UNDEFINED embeds If provided, the message embeds. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . Embed ]] DEFAULT: hikari.UNDEFINED flags If provided, the message flags this response should have. As of writing the only message flag which can be set here is hikari.messages.MessageFlag.EPHEMERAL . TYPE: typing . Union [ int , hikari . MessageFlag , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED tts If provided, whether the message will be read out by a screen reader using Discord's TTS (text-to-speech) system. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED mentions_everyone If provided, whether the message should parse @everyone/@here mentions. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED user_mentions If provided, and True , all user mentions will be detected. If provided, and False , all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialUser ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED role_mentions If provided, and True , all role mentions will be detected. If provided, and False , all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of [hikari.snowflakes.Snowflake], or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialRole ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED RAISES DESCRIPTION ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions . If the interaction will have expired before delete_after is reached. If both attachment and attachments are passed or both component and components are passed or both embed and embeds are passed. hikari . BadRequestError This may be raised in several discrete situations, such as messages being empty with no embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; invalid image URLs in embeds. hikari . UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari . NotFoundError If the interaction is not found or if the interaction's initial response has already been created. hikari . RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request. hikari . RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari . InternalServerError If an internal error occurs on Discord while handling the request.","title":"create_initial_response()"},{"location":"reference/#yuyo.components.ComponentContext.defer","text":"defer ( defer_type , / , * , ephemeral = False , flags = hikari . UNDEFINED ) Defer the initial response for this context. Note The ephemeral state of the first response is decided by whether the deferral is ephemeral. PARAMETER DESCRIPTION defer_type The type of deferral this should be. This may any of the following * ResponseType.DEFERRED_MESSAGE_CREATE to indicate that the following up call to yuyo.components.ComponentContext.edit_initial_response or yuyo.components.ComponentContext.respond should create a new message. * ResponseType.DEFERRED_MESSAGE_UPDATE to indicate that the following call to the aforementioned methods should update the existing message. TYPE: hikari . DeferredResponseTypesT ephemeral Whether the deferred response should be ephemeral. Passing True here is a shorthand for including 1 << 64 in the passed flags. TYPE: bool DEFAULT: False flags The flags to use for the initial response. TYPE: typing . Union [ hikari . UndefinedType , int , hikari . MessageFlag ] DEFAULT: hikari.UNDEFINED","title":"defer()"},{"location":"reference/#yuyo.components.ComponentContext.delete_initial_response","text":"delete_initial_response () Delete the initial response after invoking this context. RAISES DESCRIPTION LookupError , hikari . NotFoundError The last context has no initial response.","title":"delete_initial_response()"},{"location":"reference/#yuyo.components.ComponentContext.delete_last_response","text":"delete_last_response () Delete the last response after invoking this context. RAISES DESCRIPTION LookupError , hikari . NotFoundError The last context has no responses.","title":"delete_last_response()"},{"location":"reference/#yuyo.components.ComponentContext.edit_initial_response","text":"edit_initial_response ( content = hikari . UNDEFINED , * , delete_after = None , attachment = hikari . UNDEFINED , attachments = hikari . UNDEFINED , component = hikari . UNDEFINED , components = hikari . UNDEFINED , embed = hikari . UNDEFINED , embeds = hikari . UNDEFINED , replace_attachments = False , mentions_everyone = hikari . UNDEFINED , user_mentions = hikari . UNDEFINED , role_mentions = hikari . UNDEFINED ) Edit the initial response for this context. PARAMETER DESCRIPTION content The content to edit the initial response with. If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED delete_after If provided, the seconds after which the response message should be deleted. Slash command responses can only be deleted within 15 minutes of the command being received. TYPE: typing . Union [ datetime . timedelta , float , int , None] DEFAULT: None attachment A singular attachment to edit the initial response with. TYPE: hikari . UndefinedOr [ hikari . Resourceish ] DEFAULT: hikari.UNDEFINED attachments A sequence of attachments to edit the initial response with. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . Resourceish ]] DEFAULT: hikari.UNDEFINED component If provided, builder object of the component to set for this message. This component will replace any previously set components and passing None will remove all components. TYPE: hikari . UndefinedNoneOr [ hikari . api . ComponentBuilder ] DEFAULT: hikari.UNDEFINED components If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing None or an empty sequence will remove all components. TYPE: hikari . UndefinedNoneOr [ typing . Sequence [ hikari . api . ComponentBuilder ]] DEFAULT: hikari.UNDEFINED embed An embed to replace the initial response with. TYPE: hikari . UndefinedNoneOr [ hikari . Embed ] DEFAULT: hikari.UNDEFINED embeds A sequence of embeds to replace the initial response with. TYPE: hikari . UndefinedNoneOr [ typing . Sequence [ hikari . Embed ]] DEFAULT: hikari.UNDEFINED replace_attachments Whether to replace the attachments of the response or not. TYPE: bool DEFAULT: False mentions_everyone If provided, whether the message should parse @everyone/@here mentions. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED user_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialUser ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED role_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialRole ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED RETURNS DESCRIPTION hikari . Message The message that has been edited. RAISES DESCRIPTION ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions . If delete_after would be more than 15 minutes after the slash command was called. If both attachment and attachments are passed or both component and components are passed or both embed and embeds are passed. hikari . BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components. hikari . UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari . ForbiddenError If you are missing the SEND_MESSAGES in the channel or the person you are trying to message has the DM's disabled. hikari . NotFoundError If the channel is not found. hikari . RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request. hikari . RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari . InternalServerError If an internal error occurs on Discord while handling the request.","title":"edit_initial_response()"},{"location":"reference/#yuyo.components.ComponentContext.edit_last_response","text":"edit_last_response ( content = hikari . UNDEFINED , * , delete_after = None , attachment = hikari . UNDEFINED , attachments = hikari . UNDEFINED , component = hikari . UNDEFINED , components = hikari . UNDEFINED , embed = hikari . UNDEFINED , embeds = hikari . UNDEFINED , replace_attachments = False , mentions_everyone = hikari . UNDEFINED , user_mentions = hikari . UNDEFINED , role_mentions = hikari . UNDEFINED ) Edit the last response for this context. PARAMETER DESCRIPTION content The content to edit the last response with. If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED delete_after If provided, the seconds after which the response message should be deleted. Slash command responses can only be deleted within 15 minutes of the command being received. TYPE: typing . Union [ datetime . timedelta , float , int , None] DEFAULT: None attachment A singular attachment to edit the last response with. TYPE: hikari . UndefinedOr [ hikari . Resourceish ] DEFAULT: hikari.UNDEFINED attachments A sequence of attachments to edit the last response with. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . Resourceish ]] DEFAULT: hikari.UNDEFINED component If provided, builder object of the component to set for this message. This component will replace any previously set components and passing None will remove all components. TYPE: hikari . UndefinedNoneOr [ hikari . api . ComponentBuilder ] DEFAULT: hikari.UNDEFINED components If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing None or an empty sequence will remove all components. TYPE: hikari . UndefinedNoneOr [ typing . Sequence [ hikari . api . ComponentBuilder ]] DEFAULT: hikari.UNDEFINED embed An embed to replace the last response with. TYPE: hikari . UndefinedNoneOr [ hikari . Embed ] DEFAULT: hikari.UNDEFINED embeds A sequence of embeds to replace the last response with. TYPE: hikari . UndefinedNoneOr [ typing . Sequence [ hikari . Embed ]] DEFAULT: hikari.UNDEFINED replace_attachments Whether to replace the attachments of the response or not. TYPE: bool DEFAULT: False mentions_everyone If provided, whether the message should parse @everyone/@here mentions. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED user_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialUser ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED role_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialRole ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED RETURNS DESCRIPTION hikari . Message The message that has been edited. RAISES DESCRIPTION ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions . If delete_after would be more than 15 minutes after the slash command was called. If both attachment and attachments are passed or both component and components are passed or both embed and embeds are passed. hikari . BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components. hikari . UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari . ForbiddenError If you are missing the SEND_MESSAGES in the channel or the person you are trying to message has the DM's disabled. hikari . NotFoundError If the channel is not found. hikari . RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request. hikari . RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari . InternalServerError If an internal error occurs on Discord while handling the request.","title":"edit_last_response()"},{"location":"reference/#yuyo.components.ComponentContext.fetch_initial_response","text":"fetch_initial_response () Fetch the initial response for this context. RETURNS DESCRIPTION hikari . messages . Message The initial response's message object. RAISES DESCRIPTION LookupError , hikari . NotFoundError The response was not found.","title":"fetch_initial_response()"},{"location":"reference/#yuyo.components.ComponentContext.fetch_last_response","text":"fetch_last_response () Fetch the last response for this context. RETURNS DESCRIPTION hikari . messages . Message The most response response's message object. RAISES DESCRIPTION LookupError , hikari . NotFoundError The response was not found.","title":"fetch_last_response()"},{"location":"reference/#yuyo.components.ComponentContext.has_been_deferred","text":"has_been_deferred () Whether this context's initial response has been deferred. This will be true if yuyo.components.ComponentContext.defer has been called.","title":"has_been_deferred()"},{"location":"reference/#yuyo.components.ComponentContext.has_responded","text":"has_responded () Whether an initial response has been made to this context yet. It's worth noting that a context must be either responded to or deferred within 3 seconds from it being received otherwise it'll be marked as failed. This will be true if either yuyo.components.ComponentContext.respond , yuyo.components.ComponentContext.create_initial_response or yuyo.components.ComponentContext.edit_initial_response (after a deferral) has been called.","title":"has_responded()"},{"location":"reference/#yuyo.components.ComponentContext.interaction","text":"interaction () Object of the interaction this context is for.","title":"interaction()"},{"location":"reference/#yuyo.components.ComponentContext.respond","text":"respond ( content = hikari . UNDEFINED , * , ensure_result = False , delete_after = None , attachment = hikari . UNDEFINED , attachments = hikari . UNDEFINED , component = hikari . UNDEFINED , components = hikari . UNDEFINED , embed = hikari . UNDEFINED , embeds = hikari . UNDEFINED , mentions_everyone = hikari . UNDEFINED , user_mentions = hikari . UNDEFINED , role_mentions = hikari . UNDEFINED ) Respond to this context. PARAMETER DESCRIPTION content The content to respond with. If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED ensure_result Ensure that this call will always return a message object. If True then this will always return hikari.messages.Message , otherwise this will return hikari.Message | None . It's worth noting that, under certain scenarios within the slash command flow, this may lead to an extre request being made. TYPE: bool DEFAULT: False delete_after If provided, the seconds after which the response message should be deleted. Slash command responses can only be deleted within 15 minutes of the command being received. TYPE: typing . Union [ datetime . timedelta , float , int , None] DEFAULT: None attachment If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL. TYPE: hikari . UndefinedOr [ hikari . Resourceish ] DEFAULT: hikari.UNDEFINED attachments If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . Resourceish ]] DEFAULT: hikari.UNDEFINED component If provided, builder object of the component to include in this response. TYPE: hikari . UndefinedOr [ hikari . api . ComponentBuilder ] DEFAULT: hikari.UNDEFINED components If provided, a sequence of the component builder objects to include in this response. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . api . ComponentBuilder ]] DEFAULT: hikari.UNDEFINED embed An embed to respond with. TYPE: hikari . UndefinedOr [ hikari . Embed ] DEFAULT: hikari.UNDEFINED embeds A sequence of embeds to respond with. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . Embed ]] DEFAULT: hikari.UNDEFINED mentions_everyone If provided, whether the message should parse @everyone/@here mentions. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED user_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialUser ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED role_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialRole ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED RETURNS DESCRIPTION hikari . Message | None The message that has been created if it was immedieatly available or ensure_result was set to True , else None . RAISES DESCRIPTION ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions . If delete_after would be more than 15 minutes after the slash command was called. If both attachment and attachments are passed or both component and components are passed or both embed and embeds are passed. hikari . BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components. hikari . UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari . ForbiddenError If you are missing the SEND_MESSAGES in the channel or the person you are trying to message has the DM's disabled. hikari . NotFoundError If the channel is not found. hikari . RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request. hikari . RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari . InternalServerError If an internal error occurs on Discord while handling the request.","title":"respond()"},{"location":"reference/#yuyo.components.ComponentContext.set_ephemeral_default","text":"set_ephemeral_default ( state ) Set the ephemeral default state for this context. PARAMETER DESCRIPTION state The new ephemeral default state. If this is True then all calls to the response creating methods on this context will default to being ephemeral. TYPE: bool","title":"set_ephemeral_default()"},{"location":"reference/#yuyo.ComponentExecutor","text":"Bases: AbstractComponentExecutor Basic implementation of a class used for handling the execution of a message component.","title":"ComponentExecutor"},{"location":"reference/#yuyo.components.ComponentExecutor.__init__","text":"__init__ ( * , ephemeral_default = False , load_from_attributes = True , timeout = datetime . timedelta ( seconds = 30 )) Initialise a component executor. PARAMETER DESCRIPTION ephemeral_default Whether this executor's responses should default to being ephemeral. TYPE: bool DEFAULT: False timeout How long this component should last until its marked as timed out. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30)","title":"__init__()"},{"location":"reference/#yuyo.ComponentPaginator","text":"Bases: ActionRowExecutor Standard implementation of an action row executor used for pagination. This is a convenience class that allows you to easily implement a paginator.","title":"ComponentPaginator"},{"location":"reference/#yuyo.components.ComponentPaginator.__init__","text":"__init__ ( iterator , * , authors , ephemeral_default = False , triggers = ( pagination . LEFT_TRIANGLE , pagination . STOP_SQUARE , pagination . RIGHT_TRIANGLE ), load_from_attributes = False , timeout = datetime . timedelta ( seconds = 30 )) Initialise a component paginator. PARAMETER DESCRIPTION iterator The iterator to paginate. This should be an iterator of tuples of (hikari.UndefinedOr[str], hikari.UndefinedOr[hikari.Embed]) . TYPE: typing . Iterator [ yuyo . pagination . EntryT ] | typing . AsyncIterator [ yuyo . pagination . EntryT ] authors The authors of the entries. If None is passed here then the paginator will be public (meaning that anybody can use it). TYPE: typing . Optional [ typing . Iterable [ hikari . SnowflakeishOr [ hikari . User ]]] ephemeral_default Whether or not the responses made on contexts spawned from this paginator should default to ephemeral (meaning only the author can see them) unless flags is specified on the response method. TYPE: bool DEFAULT: False triggers Collection of the unicode emojis that should trigger this paginator. As of current the only usable emojis are yuyo.pagination.LEFT_TRIANGLE , yuyo.pagination.RIGHT_TRIANGLE , yuyo.pagination.STOP_SQUARE , yuyo.pagination.LEFT_DOUBLE_TRIANGLE and yuyo.pagination.LEFT_TRIANGLE . TYPE: typing . Collection [ str ] DEFAULT: (pagination.LEFT_TRIANGLE, pagination.STOP_SQUARE, pagination.RIGHT_TRIANGLE) timeout The amount of time to wait after the component's last execution or creation until it times out. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30)","title":"__init__()"},{"location":"reference/#yuyo.components.ComponentPaginator.builder","text":"builder () Get a sequence of the component builders for this paginator. RETURNS DESCRIPTION typing . Sequence [ hikari . api . ComponentBuilder ] The component builders for this paginator.","title":"builder()"},{"location":"reference/#yuyo.components.ComponentPaginator.get_next_entry","text":"get_next_entry () Get the next entry in this paginator. This is generally helpful for making the message which the paginator will be based off and will still internally store the entry and increment the position of the paginator. Examples: response_paginator = yuyo . ComponentPaginator ( pages , authors = ( ctx . author . id ,) ) first_response = await response_paginator . get_next_entry () assert first_response content , embed = first_response message = await ctx . respond ( content = content , embed = embed , component = response_paginator , ensure_result = True ) component_client . set_executor ( message , response_paginator ) RETURNS DESCRIPTION yuyo . pagination . EntryT | None The next entry in this paginator, or None if there are no more entries.","title":"get_next_entry()"},{"location":"reference/#yuyo.ErrorManager","text":"A context manager provided to allow for more concise error handling with yuyo.backoff.Backoff . Examples: The following is an example of using yuyo.backoff.ErrorManager alongside yuyo.backoff.Backoff in-order to handle the exceptions which may be raised while trying to reply to a message. retry = Backoff () # Rules can either be passed to `ErrorManager`'s initiate as variable arguments # or one at a time to `ErrorManager.with_rule` through possibly chained-calls. error_handler = ( # For the 1st rule we catch two errors which would indicate the bot # no-longer has access to the target channel and break out of the # retry loop using `Backoff.retry`. ErrorManager ((( errors . NotFoundError , errors . ForbiddenError ), lambda _ : retry . finish ())) # For the 2nd rule we catch rate limited errors and set their # `retry` value as the next backoff time before suppressing the # error to allow this to retry the request. . with_rule (( errors . RateLimitedError ,), lambda exc : retry . set_next_backoff ( exc . retry_after )) # For the 3rd rule we suppress the internal server error to allow # backoff to reach the next retry and exponentially backoff as we # don't have any specific retry time for this error. . with_rule (( errors . InternalServerError ,), lambda _ : False ) ) async for _ in retry : # We entre this context manager each iteration to catch errors before # they cause us to break out of the `Backoff` loop. with error_handler : await message . respond ( \"General Kenobi\" ) # We need to break out of `retry` if this request succeeds. break","title":"ErrorManager"},{"location":"reference/#yuyo.backoff.ErrorManager.__init__","text":"__init__ ( * rules ) Initialise an error manager instance. PARAMETER DESCRIPTION *rules Rules to initiate this error context manager with. These are each a 2-length tuple where the tuple[0] is an iterable of types of the exceptions this rule should apply to and tuple[1] is the rule's callback function. The callback function will be called with the raised exception when it matches one of the passed exceptions for the relevant rule and may raise, return True to indicate that the current error should be raised outside of the context manager or False / None to suppress the current error. TYPE: typing . Tuple [ typing . Iterable [ typing . Type [ BaseException ]], typing . Callable [[ typing . Any ], typing . Optional [ bool ]]] DEFAULT: ()","title":"__init__()"},{"location":"reference/#yuyo.backoff.ErrorManager.clear_rules","text":"clear_rules () Clear the rules registered with this handler.","title":"clear_rules()"},{"location":"reference/#yuyo.backoff.ErrorManager.with_rule","text":"with_rule ( exceptions , result ) Add a rule to this exception context manager. PARAMETER DESCRIPTION exceptions An iterable of types of the exceptions this rule should apply to. TYPE: typing . Iterable [ typing . Type [ BaseException ]] result The function called with the raised exception when it matches one of the passed exceptions . This may raise, return True to indicate that the current error should be raised outside of the context manager or False / None to suppress the current error. TYPE: typing . Callable [[ typing . Any ], typing . Optional [ bool ]] RETURNS DESCRIPTION Self This returns the handler a rule was being added to in-order to allow for chained calls.","title":"with_rule()"},{"location":"reference/#yuyo.MultiComponentExecutor","text":"Bases: AbstractComponentExecutor Multi-component implementation of a component executor. This implementation allows for multiple components to be executed as a single view.","title":"MultiComponentExecutor"},{"location":"reference/#yuyo.components.MultiComponentExecutor.__init__","text":"__init__ ( * , load_from_attributes = False , timeout = datetime . timedelta ( seconds = 30 )) Initialise a multi-component executor. PARAMETER DESCRIPTION timeout The amount of time to wait after the component's last execution or creation until it times out. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30)","title":"__init__()"},{"location":"reference/#yuyo.components.MultiComponentExecutor.add_action_row","text":"add_action_row () Create a builder class to add an action row to this executor. For the most part this follows the same implementation as yuyo.components.ActionRowExecutor except with the added detail that yuyo.components.ChildActionRowExecutor.add_to_parent must be called to add the action row to the parent executor. RETURNS DESCRIPTION ChildActionRowExecutor [ Self ] A builder class to add an action row to this executor. yuyo.components.ChildActionRowExecutor.add_to_parent should be called to finalise the action row and will return the parent executor for chained calls.","title":"add_action_row()"},{"location":"reference/#yuyo.components.MultiComponentExecutor.add_builder","text":"add_builder ( builder ) Add a non-executable component builder to this executor. This is useful for adding components that are not meant to be executed, such as a a row of link buttons. PARAMETER DESCRIPTION builder The component builder to add. TYPE: hikari . api . ComponentBuilder RETURNS DESCRIPTION Self","title":"add_builder()"},{"location":"reference/#yuyo.components.MultiComponentExecutor.add_executor","text":"add_executor ( executor ) Add a component executor to this multi-component executor. This method is internally used by the add_{component} methods. PARAMETER DESCRIPTION executor The component executor to add. TYPE: AbstractComponentExecutor RETURNS DESCRIPTION Self The multi-component executor instance to enable chained calls.","title":"add_executor()"},{"location":"reference/#yuyo.components.MultiComponentExecutor.builders","text":"builders () Sequence of the component builders within this executor.","title":"builders()"},{"location":"reference/#yuyo.components.MultiComponentExecutor.executors","text":"executors () Sequence of the child executors within this multi-executor.","title":"executors()"},{"location":"reference/#yuyo.ReactionClient","text":"A class which handles the events for multiple registered reaction handlers. Note For a quicker way to initialise this client from a bot, see yuyo.reactions.ReactionClient.from_gateway_bot .","title":"ReactionClient"},{"location":"reference/#yuyo.reactions.ReactionClient.__init__","text":"__init__ ( * , rest , event_manager , alluka = None , event_managed = True ) Initialise a reaction client. PARAMETER DESCRIPTION rest The REST client to register this reaction client with. TYPE: hikari . api . RESTClient event_manager The event manager client to register this reaction client with. TYPE: hikari . api . EventManager alluka The alluka client to use for callback DI. TYPE: typing . Optional [ alluka_ . abc . Client ] DEFAULT: None event_managed Whether the reaction client should be automatically opened and closed based on the lifetime events dispatched by event_managed . TYPE: bool DEFAULT: True","title":"__init__()"},{"location":"reference/#yuyo.reactions.ReactionClient.add_handler","text":"add_handler ( message , / , paginator ) Add a reaction handler to this reaction client. Note This does not call yuyo.reactions.AbstractReactionHandler.open . PARAMETER DESCRIPTION message The message ID to add register a reaction handler with. TYPE: hikari . SnowflakeishOr [ hikari . Message ] paginator The object of the opened paginator to register in this reaction client. TYPE: AbstractReactionHandler","title":"add_handler()"},{"location":"reference/#yuyo.reactions.ReactionClient.alluka","text":"alluka () The Alluka client being used for callback dependency injection.","title":"alluka()"},{"location":"reference/#yuyo.reactions.ReactionClient.close","text":"close () Close this client by unregistering any registered tasks and event listeners.","title":"close()"},{"location":"reference/#yuyo.reactions.ReactionClient.from_gateway_bot","text":"from_gateway_bot ( bot , / , * , event_managed = True ) Build a ReactionClient from a gateway bot. PARAMETER DESCRIPTION bot The bot to build a reaction client for. TYPE: traits . GatewayBotAware event_managed Whether the reaction client should be automatically opened and closed based on the lifetime events dispatched by bot . TYPE: bool DEFAULT: True RETURNS DESCRIPTION ReactionClient The reaction client for the bot.","title":"from_gateway_bot()"},{"location":"reference/#yuyo.reactions.ReactionClient.get_handler","text":"get_handler ( message ) Get a reference to a paginator registered in this reaction client. Note This does not call yuyo.reactions.AbstractReactionHandler.close . PARAMETER DESCRIPTION message The message ID to remove a paginator for. TYPE: hikari . SnowflakeishOr [ hikari . Message ] RETURNS DESCRIPTION AbstractReactionHandler | None The object of the registered paginator if found else None .","title":"get_handler()"},{"location":"reference/#yuyo.reactions.ReactionClient.is_closed","text":"is_closed () Whether this client is closed.","title":"is_closed()"},{"location":"reference/#yuyo.reactions.ReactionClient.open","text":"open () Start this client by registering the required tasks and event listeners for it to function.","title":"open()"},{"location":"reference/#yuyo.reactions.ReactionClient.remove_handler","text":"remove_handler ( message ) Remove a paginator from this reaction client. Note This does not call yuyo.reactions.AbstractReactionHandler.close . PARAMETER DESCRIPTION message The message ID to remove a paginator for. TYPE: hikari . SnowflakeishOr [ hikari . Message ] RETURNS DESCRIPTION AbstractReactionHandler | None The object of the registered paginator if found else None .","title":"remove_handler()"},{"location":"reference/#yuyo.ReactionHandler","text":"Bases: AbstractReactionHandler Standard basic implementation of a reaction handler.","title":"ReactionHandler"},{"location":"reference/#yuyo.reactions.ReactionHandler.__init__","text":"__init__ ( * , authors = (), timeout = datetime . timedelta ( seconds = 30 ), load_from_attributes = True ) Initialise a reaction handler. PARAMETER DESCRIPTION authors An iterable of IDs of the users who can call this paginator. If left empty then all users will be able to call this paginator. TYPE: typing . Iterable [ hikari . SnowflakeishOr [ hikari . User ]] DEFAULT: () timeout How long it should take for this paginator to timeout. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30)","title":"__init__()"},{"location":"reference/#yuyo.reactions.ReactionHandler.add_callback","text":"add_callback ( emoji_identifier , callback ) Add a callback to this reaction handler. PARAMETER DESCRIPTION emoji_identifier Identifier of the emoji this callback is for. This should be a snowfake if this is for a custom emoji or a string if this is for a unicode emoji. TYPE: typing . Union [ str , hikari . SnowflakeishOr [ hikari . CustomEmoji ]] callback The callback to add. This should be a function that accepts a single parameter, which is the event that triggered this reaction. TYPE: CallbackSig","title":"add_callback()"},{"location":"reference/#yuyo.reactions.ReactionHandler.authors","text":"authors () Set of the authors/owner of a enabled handler. Note If this is empty then the handler is considered public and any user will be able to trigger it.","title":"authors()"},{"location":"reference/#yuyo.reactions.ReactionHandler.remove_callback","text":"remove_callback ( emoji_identifier ) Remove a callback from this reaction handler. PARAMETER DESCRIPTION emoji_identifier Identifier of the emoji the callback to remove is for. This should be a snowfake if this is for a custom emoji or a string if this is for a unicode emoji. TYPE: typing . Union [ str , hikari . SnowflakeishOr [ hikari . CustomEmoji ]]","title":"remove_callback()"},{"location":"reference/#yuyo.reactions.ReactionHandler.timeout","text":"timeout () How long this handler will wait since the last event before timing out.","title":"timeout()"},{"location":"reference/#yuyo.reactions.ReactionHandler.with_callback","text":"with_callback ( emoji_identifier ) Add a callback to this reaction handler through a decorator call. PARAMETER DESCRIPTION emoji_identifier Identifier of the emoji this callback is for. This should be a snowfake if this is for a custom emoji or a string if this is for a unicode emoji. TYPE: typing . Union [ str , hikari . SnowflakeishOr [ hikari . CustomEmoji ]] RETURNS DESCRIPTION typing . Callabke [[ CallbackSigT ], CallbackSigT ] A decorator to add a callback to this reaction handler.","title":"with_callback()"},{"location":"reference/#yuyo.ReactionPaginator","text":"Bases: ReactionHandler Standard implementation of a reaction handler for pagination.","title":"ReactionPaginator"},{"location":"reference/#yuyo.reactions.ReactionPaginator.__init__","text":"__init__ ( iterator , * , authors , triggers = ( pagination . LEFT_TRIANGLE , pagination . STOP_SQUARE , pagination . RIGHT_TRIANGLE ), timeout = datetime . timedelta ( seconds = 30 )) Initialise a reaction paginator. PARAMETER DESCRIPTION iterator Either an asynchronous or synchronous iterator of the entries this should paginate through. entry[0] represents the message's possible content and can either be str or hikari.undefined.UNDEFINED and entry[1] represents the message's possible embed and can either be hikari.embeds.Embed or hikari.undefined.UNDEFINED . TYPE: typing . Iterator [ yuyo . pagination . EntryT ] | typing . AsyncIterator [ yuyo . pagination . EntryT ] authors An iterable of IDs of the users who can call this paginator. If left empty then all users will be able to call this paginator. TYPE: typing . Iterable [ hikari . SnowflakeishOr [ hikari . User ]] timeout How long it should take for this paginator to timeout. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30)","title":"__init__()"},{"location":"reference/#yuyo.reactions.ReactionPaginator.add_author","text":"add_author ( user ) Add a author/owner to this handler. PARAMETER DESCRIPTION user The user to add as an owner for this handler. TYPE: hikari . SnowflakeishOr [ hikari . User ]","title":"add_author()"},{"location":"reference/#yuyo.reactions.ReactionPaginator.close","text":"close ( * , remove_reactions = False , max_retries = 5 , max_backoff = 2.0 ) Close this handler and deregister any previously registered message. PARAMETER DESCRIPTION remove_reactions Whether this should remove the reactions that were being used to paginate through this from the previously registered message. TYPE: bool DEFAULT: False","title":"close()"},{"location":"reference/#yuyo.reactions.ReactionPaginator.create_message","text":"create_message ( rest , channel_id , / , * , add_reactions = True , max_retries = 5 , max_backoff = 2.0 ) Start this handler and link it to a bot message. Note Calling this multiple times will replace the previously registered message. PARAMETER DESCRIPTION rest Rest client to use to make the response. TYPE: hikari . api . RESTClient channel_id ID of the channel to respond in. TYPE: hikari . SnowflakeishOr [ hikari . TextableChannel ] add_reactions Whether this should add the paginator's reactions to the message after responding. TYPE: bool DEFAULT: True max_retries How many times this should retry to respond if Hikari raises any ratelimit errors. TYPE: int DEFAULT: 5 max_backoff The maximum time this should backoff for before trying if Hikari raises any ratelimit errors. TYPE: float DEFAULT: 2.0 RETURNS DESCRIPTION hikari . messages . Message Object of the message this handler now targets. If message was not supplied then this will be the object of a newly created message, otherwise this will be what was supplied as message . RAISES DESCRIPTION ValueError If the provided iterator didn't yield any content for the first message.","title":"create_message()"},{"location":"reference/#yuyo.reactions.ReactionPaginator.remove_author","text":"remove_author ( user ) Remove a author/owner from this handler. Note If the provided user isn't already a registered owner of this paginator then this should pass silently without raising. PARAMETER DESCRIPTION user The user to remove from this handler's owners. TYPE: hikari . SnowflakeishOr [ hikari . User ]","title":"remove_author()"},{"location":"reference/#yuyo.WaitForExecutor","text":"Bases: AbstractComponentExecutor Component executor used to wait for a single component interaction. Examples: responses : dict [ str , str ] message = await ctx . respond ( \"hi, pick an option\" , components = [ ... ]) executor = yuyo . components . WaitFor ( authors = ( ctx . author . id ,), timeout = datetime . timedelta ( seconds = 30 )) component_client . set_executor ( message . id , executor ) try : result = await executor . wait_for () except asyncio . TimeoutError : await ctx . respond ( \"timed out\" ) else : await result . respond ( responses [ result . interaction . custom_id ])","title":"WaitForExecutor"},{"location":"reference/#yuyo.components.WaitForExecutor.__init__","text":"__init__ ( * , authors , ephemeral_default = False , timeout ) Initialise a wait for executor. PARAMETER DESCRIPTION authors The authors of the entries. If None is passed here then the paginator will be public (meaning that anybody can use it). TYPE: typing . Optional [ typing . Iterable [ hikari . SnowflakeishOr [ hikari . User ]]] ephemeral_default Whether or not the responses made on contexts spawned from this paginator should default to ephemeral (meaning only the author can see them) unless flags is specified on the response method. TYPE: bool DEFAULT: False timeout How long this should wait for a matching component interaction until it times-out. TYPE: datetime . timedelta","title":"__init__()"},{"location":"reference/#yuyo.components.WaitForExecutor.wait_for","text":"wait_for () Wait for the next matching interaction. RETURNS DESCRIPTION ComponentContext The next matching interaction. RAISES DESCRIPTION RuntimeError If the executor is already being waited for. asyncio . TimeoutError If the timeout is reached.","title":"wait_for()"},{"location":"reference/#yuyo.aenumerate","text":"aenumerate ( iterable ) Async equivalent of enumerate . PARAMETER DESCRIPTION iterable The async iterable to enumerate. TYPE: typing . AsyncIterable [ _T ] RETURNS DESCRIPTION typing . AsyncIterator [ tuple [ int , _T ]] The enumerated async iterator.","title":"aenumerate()"},{"location":"reference/#yuyo.async_paginate_string","text":"async_paginate_string ( lines , * , char_limit = 2000 , line_limit = 25 , wrapper = None ) Lazily paginate an iterator of lines. PARAMETER DESCRIPTION lines The asynchronous iterator of lines to paginate. TYPE: typing . AsyncIterable [ str ] char_limit The limit for how many characters should be included per yielded page. TYPE: int DEFAULT: 2000 line_limit The limit for how many lines should be included per yielded page. TYPE: int DEFAULT: 25 wrapper A wrapper for each yielded page. This should leave \"{}\" in it to be replaced by the page's content. TYPE: typing . Optional [ str ] DEFAULT: None RETURNS DESCRIPTION typing . AsyncIterator [ tuple [ str , int ]] An async iterator of page tuples (string context to int zero-based index).","title":"async_paginate_string()"},{"location":"reference/#yuyo.paginate_string","text":"paginate_string ( lines , * , char_limit = 2000 , line_limit = 25 , wrapper = None ) Lazily paginate an iterator of lines. PARAMETER DESCRIPTION lines The iterator of lines to paginate. This iterator may be asynchronous or synchronous. TYPE: typing . Iterator [ str ] | typing . AsyncIterator [ str ] char_limit The limit for how many characters should be included per yielded page. TYPE: int DEFAULT: 2000 line_limit The limit for how many lines should be included per yielded page. TYPE: int DEFAULT: 25 wrapper A wrapper for each yielded page. This should leave \"{}\" in it to be replaced by the page's content. TYPE: typing . Optional [ str ] DEFAULT: None RETURNS DESCRIPTION AsyncIterator [ tuple [ str , int ]] | typing . Iterator [ tuple [ str , int ]] An iterator of page tuples (string context to int zero-based index).","title":"paginate_string()"},{"location":"reference/#yuyo.sync_paginate_string","text":"sync_paginate_string ( lines , * , char_limit = 2000 , line_limit = 25 , wrapper = None ) Lazily paginate an iterator of lines. PARAMETER DESCRIPTION lines The iterator of lines to paginate. TYPE: typing . Iterable [ str ] char_limit The limit for how many characters should be included per yielded page. TYPE: int DEFAULT: 2000 line_limit The limit for how many lines should be included per yielded page. TYPE: int DEFAULT: 25 wrapper A wrapper for each yielded page. This should leave \"{}\" in it to be replaced by the page's content. TYPE: typing . Optional [ str ] DEFAULT: None RETURNS DESCRIPTION typing . Iterator [ tuple [ str , int ]] An iterator of page tuples (string context to int zero-based index).","title":"sync_paginate_string()"},{"location":"reference/asgi/","text":"yuyo.asgi # ASGI/3 adapter for Hikari's interaction server. AsgiAdapter # Asgi/3 adapter for Hikari's interaction server interface. For this to work, hikari has to be installed with the optional \"server\" feature (e.g python -m pip install hikari[server] ). __call__ async # __call__ ( scope , receive , send ) Call the adapter. Note This method is called by the ASGI server. PARAMETER DESCRIPTION scope The scope of the request. TYPE: asgiref . Scope receive The receive function to use. TYPE: asgiref . ASGIReceiveCallable send The send function to use. TYPE: asgiref . ASGISendCallable RAISES DESCRIPTION NotImplementedError If this is called with a websocket scope. RuntimeError If an invalid scope event is passed. __init__ # __init__ ( server , / , * , executor = None ) Initialise the adapter. PARAMETER DESCRIPTION server The interaction server to use. TYPE: hikari . api . InteractionServer executor If non- None , then this executor is used instead of the concurrent.futures.ThreadPoolExecutor attached to the asyncio.AbstractEventLoop that the bot will run on. This executor is used primarily for file-IO. While mainly supporting the concurrent.futures.ThreadPoolExecutor implementation in the standard lib, Hikari's file handling systems should also work with concurrent.futures.ProcessPoolExecutor , which relies on all objects used in IPC to be pickle able. Many third-party libraries will not support this fully though, so your mileage may vary on using ProcessPoolExecutor implementations with this parameter. TYPE: typing . Optional [ concurrent . futures . Executor ] DEFAULT: None add_shutdown_callback # add_shutdown_callback ( callback ) Add a callback to be called when the ASGI server shuts down. Warning These callbacks will block the ASGI server from shutting down until they complete and any raised errors will lead to a failed shutdown. PARAMETER DESCRIPTION callback The shutdown callback to add. TYPE: typing . Callable [[], typing . Union [None, typing . Coroutine [ typing . Any , typing . Any , None]]] RETURNS DESCRIPTION Self This adapter to enable call chaining. add_startup_callback # add_startup_callback ( callback ) Add a callback to be called when the ASGI server starts up. Warning These callbacks will block the ASGI server from starting until they complete and any raised errors will lead to a failed startup. PARAMETER DESCRIPTION callback The startup callback to add. TYPE: typing . Callable [[], typing . Union [None, typing . Coroutine [ typing . Any , typing . Any , None]]] RETURNS DESCRIPTION Self This adapter to enable call chaining. process_lifespan_event async # process_lifespan_event ( receive , send ) Process a lifespan ASGI event. Note This function is used internally by the adapter. PARAMETER DESCRIPTION receive The receive function to use. TYPE: asgiref . ASGIReceiveCallable send The send function to use. TYPE: asgiref . ASGISendCallable RAISES DESCRIPTION RuntimeError If an invalid lifespan event is passed. process_request async # process_request ( scope , receive , send ) Process an HTTP request. Note This function is used internally by the adapter. PARAMETER DESCRIPTION scope The scope of the request. TYPE: asgiref . HTTPScope receive The receive function to use. TYPE: asgiref . ASGIReceiveCallable send The send function to use. TYPE: asgiref . ASGISendCallable server property # server () The interaction server this adapter is bound to. AsgiBot # Bases: AsgiAdapter , hikari . RESTBotAware Bot implementation which acts as an ASGI adapter. This bot doesn't initiate a server internally but instead relies on being called as an ASGI app. For this to work, hikari has to be installed with the optional \"server\" feature (e.g python -m pip install hikari[server] ). __init__ # __init__ ( token , token_type = None , public_key = None , * , asgi_managed = True , executor = None , http_settings = None , max_rate_limit = 300.0 , max_retries = 3 , proxy_settings = None , rest_url = None ) Initialise a new ASGI bot. PARAMETER DESCRIPTION token The bot or bearer token. If no token is to be used, this can be undefined. TYPE: typing . Union [ str , hikari . api . TokenStrategy ] token_type The type of token in use. This should only be passed when str is passed for token , can be \"Bot\" or \"Bearer\" and will be defaulted to \"Bearer\" in this situation. This should be left as None when either hikari.api.rest.TokenStrategy or None is passed for token . TYPE: typing . Union [ hikari . TokenType , str , None] DEFAULT: None asgi_managed Whether this bot's internal components should be automatically started and stopped based on the Asgi lifespan events. TYPE: bool DEFAULT: True executor If non- None , then this executor is used instead of the concurrent.futures.ThreadPoolExecutor attached to the asyncio.AbstractEventLoop that the bot will run on. This executor is used primarily for file-IO. While mainly supporting the concurrent.futures.ThreadPoolExecutor implementation in the standard lib, Hikari's file handling systems should also work with concurrent.futures.ProcessPoolExecutor , which relies on all objects used in IPC to be pickle able. Many third-party libraries will not support this fully though, so your mileage may vary on using ProcessPoolExecutor implementations with this parameter. TYPE: typing . Optional [ concurrent . futures . Executor ] DEFAULT: None http_settings Optional custom HTTP configuration settings to use. Allows you to customise functionality such as whether SSL-verification is enabled, what timeouts aiohttp should expect to use for requests, and behavior regarding HTTP-redirects. TYPE: typing . Optional [ hikari . impl . HTTPSettings ] DEFAULT: None max_rate_limit The max number of seconds to backoff for when rate limited. Anything greater than this will instead raise an error. This defaults to five minutes to stop potentially indefinitely waiting on an endpoint, which is almost never what you want to do if giving a response to a user. You can set this to float(\"inf\") to disable this check entirely. Note that this only applies to the REST API component that communicates with Discord, and will not affect sharding or third party HTTP endpoints that may be in use. TYPE: float DEFAULT: 300.0 max_retries Maximum number of times a request will be retried if it fails with a 5xx status. Defaults to 3 if set to None . TYPE: int DEFAULT: 3 proxy_settings Custom proxy settings to use with network-layer logic in your application to get through an HTTP-proxy. TYPE: typing . Optional [ hikari . impl . ProxySettings ] DEFAULT: None public_key The public key to use to verify received interaction requests. This may be a hex encoded str or the raw bytes . If left as None then the client will try to work this value out based on token . TYPE: typing . Union [ bytes , str , None] DEFAULT: None rest_url Defaults to the Discord REST API URL if None . Can be overridden if you are attempting to point to an unofficial endpoint, or if you are attempting to mock/stub the Discord API for any reason. Generally you do not want to change this. TYPE: typing . Optional [ str ] DEFAULT: None RAISES DESCRIPTION ValueError If token_type is provided when a token strategy is passed for token . if token_type is left as None when a string is passed for token . close async # close () Close the bot's REST client. Warning Unless asgi_managed=False is passed to AsgiBot.__init__ , the bot will be automatically closed based on the ASGI lifespan events and any other calls to this function will raise a RuntimeError . RAISES DESCRIPTION RuntimeError If the client isn't alive. If the client is ASGI managed. run # run () Start the bot's REST client and wait until the bot's closed. Warning Unless asgi_managed=False is passed to yuyo.asgi.AsgiBot. init , the bot will be automatically started and closed based on the ASGI lifespan events and any other calls to this function will raise a RuntimeError . RAISES DESCRIPTION RuntimeError If the client is already alive. If the client is ASGI managed. start async # start () Start the bot's REST client. Warning Unless asgi_managed=False is passed to yuyo.asgi.AsgiBot. init , the bot will be automatically started based on the ASGI lifespan events and any other calls to this function will raise a RuntimeError . RAISES DESCRIPTION RuntimeError If the client is already alive. If the client is ASGI managed.","title":"yuyo.asgi"},{"location":"reference/asgi/#yuyoasgi","text":"ASGI/3 adapter for Hikari's interaction server.","title":"yuyo.asgi"},{"location":"reference/asgi/#yuyo.asgi.AsgiAdapter","text":"Asgi/3 adapter for Hikari's interaction server interface. For this to work, hikari has to be installed with the optional \"server\" feature (e.g python -m pip install hikari[server] ).","title":"AsgiAdapter"},{"location":"reference/asgi/#yuyo.asgi.AsgiAdapter.__call__","text":"__call__ ( scope , receive , send ) Call the adapter. Note This method is called by the ASGI server. PARAMETER DESCRIPTION scope The scope of the request. TYPE: asgiref . Scope receive The receive function to use. TYPE: asgiref . ASGIReceiveCallable send The send function to use. TYPE: asgiref . ASGISendCallable RAISES DESCRIPTION NotImplementedError If this is called with a websocket scope. RuntimeError If an invalid scope event is passed.","title":"__call__()"},{"location":"reference/asgi/#yuyo.asgi.AsgiAdapter.__init__","text":"__init__ ( server , / , * , executor = None ) Initialise the adapter. PARAMETER DESCRIPTION server The interaction server to use. TYPE: hikari . api . InteractionServer executor If non- None , then this executor is used instead of the concurrent.futures.ThreadPoolExecutor attached to the asyncio.AbstractEventLoop that the bot will run on. This executor is used primarily for file-IO. While mainly supporting the concurrent.futures.ThreadPoolExecutor implementation in the standard lib, Hikari's file handling systems should also work with concurrent.futures.ProcessPoolExecutor , which relies on all objects used in IPC to be pickle able. Many third-party libraries will not support this fully though, so your mileage may vary on using ProcessPoolExecutor implementations with this parameter. TYPE: typing . Optional [ concurrent . futures . Executor ] DEFAULT: None","title":"__init__()"},{"location":"reference/asgi/#yuyo.asgi.AsgiAdapter.add_shutdown_callback","text":"add_shutdown_callback ( callback ) Add a callback to be called when the ASGI server shuts down. Warning These callbacks will block the ASGI server from shutting down until they complete and any raised errors will lead to a failed shutdown. PARAMETER DESCRIPTION callback The shutdown callback to add. TYPE: typing . Callable [[], typing . Union [None, typing . Coroutine [ typing . Any , typing . Any , None]]] RETURNS DESCRIPTION Self This adapter to enable call chaining.","title":"add_shutdown_callback()"},{"location":"reference/asgi/#yuyo.asgi.AsgiAdapter.add_startup_callback","text":"add_startup_callback ( callback ) Add a callback to be called when the ASGI server starts up. Warning These callbacks will block the ASGI server from starting until they complete and any raised errors will lead to a failed startup. PARAMETER DESCRIPTION callback The startup callback to add. TYPE: typing . Callable [[], typing . Union [None, typing . Coroutine [ typing . Any , typing . Any , None]]] RETURNS DESCRIPTION Self This adapter to enable call chaining.","title":"add_startup_callback()"},{"location":"reference/asgi/#yuyo.asgi.AsgiAdapter.process_lifespan_event","text":"process_lifespan_event ( receive , send ) Process a lifespan ASGI event. Note This function is used internally by the adapter. PARAMETER DESCRIPTION receive The receive function to use. TYPE: asgiref . ASGIReceiveCallable send The send function to use. TYPE: asgiref . ASGISendCallable RAISES DESCRIPTION RuntimeError If an invalid lifespan event is passed.","title":"process_lifespan_event()"},{"location":"reference/asgi/#yuyo.asgi.AsgiAdapter.process_request","text":"process_request ( scope , receive , send ) Process an HTTP request. Note This function is used internally by the adapter. PARAMETER DESCRIPTION scope The scope of the request. TYPE: asgiref . HTTPScope receive The receive function to use. TYPE: asgiref . ASGIReceiveCallable send The send function to use. TYPE: asgiref . ASGISendCallable","title":"process_request()"},{"location":"reference/asgi/#yuyo.asgi.AsgiAdapter.server","text":"server () The interaction server this adapter is bound to.","title":"server()"},{"location":"reference/asgi/#yuyo.asgi.AsgiBot","text":"Bases: AsgiAdapter , hikari . RESTBotAware Bot implementation which acts as an ASGI adapter. This bot doesn't initiate a server internally but instead relies on being called as an ASGI app. For this to work, hikari has to be installed with the optional \"server\" feature (e.g python -m pip install hikari[server] ).","title":"AsgiBot"},{"location":"reference/asgi/#yuyo.asgi.AsgiBot.__init__","text":"__init__ ( token , token_type = None , public_key = None , * , asgi_managed = True , executor = None , http_settings = None , max_rate_limit = 300.0 , max_retries = 3 , proxy_settings = None , rest_url = None ) Initialise a new ASGI bot. PARAMETER DESCRIPTION token The bot or bearer token. If no token is to be used, this can be undefined. TYPE: typing . Union [ str , hikari . api . TokenStrategy ] token_type The type of token in use. This should only be passed when str is passed for token , can be \"Bot\" or \"Bearer\" and will be defaulted to \"Bearer\" in this situation. This should be left as None when either hikari.api.rest.TokenStrategy or None is passed for token . TYPE: typing . Union [ hikari . TokenType , str , None] DEFAULT: None asgi_managed Whether this bot's internal components should be automatically started and stopped based on the Asgi lifespan events. TYPE: bool DEFAULT: True executor If non- None , then this executor is used instead of the concurrent.futures.ThreadPoolExecutor attached to the asyncio.AbstractEventLoop that the bot will run on. This executor is used primarily for file-IO. While mainly supporting the concurrent.futures.ThreadPoolExecutor implementation in the standard lib, Hikari's file handling systems should also work with concurrent.futures.ProcessPoolExecutor , which relies on all objects used in IPC to be pickle able. Many third-party libraries will not support this fully though, so your mileage may vary on using ProcessPoolExecutor implementations with this parameter. TYPE: typing . Optional [ concurrent . futures . Executor ] DEFAULT: None http_settings Optional custom HTTP configuration settings to use. Allows you to customise functionality such as whether SSL-verification is enabled, what timeouts aiohttp should expect to use for requests, and behavior regarding HTTP-redirects. TYPE: typing . Optional [ hikari . impl . HTTPSettings ] DEFAULT: None max_rate_limit The max number of seconds to backoff for when rate limited. Anything greater than this will instead raise an error. This defaults to five minutes to stop potentially indefinitely waiting on an endpoint, which is almost never what you want to do if giving a response to a user. You can set this to float(\"inf\") to disable this check entirely. Note that this only applies to the REST API component that communicates with Discord, and will not affect sharding or third party HTTP endpoints that may be in use. TYPE: float DEFAULT: 300.0 max_retries Maximum number of times a request will be retried if it fails with a 5xx status. Defaults to 3 if set to None . TYPE: int DEFAULT: 3 proxy_settings Custom proxy settings to use with network-layer logic in your application to get through an HTTP-proxy. TYPE: typing . Optional [ hikari . impl . ProxySettings ] DEFAULT: None public_key The public key to use to verify received interaction requests. This may be a hex encoded str or the raw bytes . If left as None then the client will try to work this value out based on token . TYPE: typing . Union [ bytes , str , None] DEFAULT: None rest_url Defaults to the Discord REST API URL if None . Can be overridden if you are attempting to point to an unofficial endpoint, or if you are attempting to mock/stub the Discord API for any reason. Generally you do not want to change this. TYPE: typing . Optional [ str ] DEFAULT: None RAISES DESCRIPTION ValueError If token_type is provided when a token strategy is passed for token . if token_type is left as None when a string is passed for token .","title":"__init__()"},{"location":"reference/asgi/#yuyo.asgi.AsgiBot.close","text":"close () Close the bot's REST client. Warning Unless asgi_managed=False is passed to AsgiBot.__init__ , the bot will be automatically closed based on the ASGI lifespan events and any other calls to this function will raise a RuntimeError . RAISES DESCRIPTION RuntimeError If the client isn't alive. If the client is ASGI managed.","title":"close()"},{"location":"reference/asgi/#yuyo.asgi.AsgiBot.run","text":"run () Start the bot's REST client and wait until the bot's closed. Warning Unless asgi_managed=False is passed to yuyo.asgi.AsgiBot. init , the bot will be automatically started and closed based on the ASGI lifespan events and any other calls to this function will raise a RuntimeError . RAISES DESCRIPTION RuntimeError If the client is already alive. If the client is ASGI managed.","title":"run()"},{"location":"reference/asgi/#yuyo.asgi.AsgiBot.start","text":"start () Start the bot's REST client. Warning Unless asgi_managed=False is passed to yuyo.asgi.AsgiBot. init , the bot will be automatically started based on the ASGI lifespan events and any other calls to this function will raise a RuntimeError . RAISES DESCRIPTION RuntimeError If the client is already alive. If the client is ASGI managed.","title":"start()"},{"location":"reference/backoff/","text":"yuyo.backoff # Utility used for handling automatic back-off. This can be used to cover cases such as hitting rate-limits and failed requests. Backoff # Used to exponentially backoff asynchronously. This class acts as an asynchronous iterator and can be iterated over to provide implicit backoff where for every iteration other than the first this will either back off for the time passed to yuyo.backoff.Backoff.set_next_backoff if applicable or a time calculated exponentially. Examples: An example of using this class as an asynchronous iterator may look like the following # While we can directly do `async for _ in Backoff()`, by assigning it to a # variable we allow ourself to provide a specific backoff time in some cases. backoff = Backoff () async for _ in backoff : try : message = await bot . rest . fetch_message ( channel_id , message_id ) except errors . RateLimitedError as exc : # If we have a specific backoff time then set it for the next iteration backoff . set_next_backoff ( exc . retry_after ) except errors . InternalServerError : # Else let the iterator calculate an exponential backoff before the next loop. pass else : # We need to break out of the iterator to make sure it doesn't backoff again. # Alternatively `Backoff.finish()` can be called to break out of the loop. break Alternatively you may want to explicitly call yuyo.backoff.Backoff.backoff , a alternative of the previous example which uses yuyo.backoff.Backoff.backoff may look like the following backoff = Backoff () message : typing . Optional [ messages . Message ] = None while not message : try : message = await bot . rest . fetch_message ( channel_id , message_id ) except errors . RateLimitedError as exc : # If we have a specific backoff time then set it for the next iteration. await backoff . backoff ( exc . retry_after ) except errors . InternalServerError : # Else let the iterator calculate an exponential backoff before the next loop. await backoff . backoff () __init__ # __init__ ( max_retries = None , * , base = 2.0 , maximum = 64.0 , jitter_multiplier = 1.0 , initial_increment = 0 ) Initialise a backoff instance. PARAMETER DESCRIPTION max_retries The maximum amount of times this should iterate for between resets. If left as None then this iterator will be unlimited. This must be greater than or equal to 1. TYPE: typing . Optional [ int ] DEFAULT: None base The base to use. TYPE: float DEFAULT: 2.0 maximum The max value the backoff can be in a single iteration. Anything above this will be capped to this base value plus random jitter. TYPE: float DEFAULT: 64.0 jitter_multiplier The multiplier for the random jitter. Set to 0 to disable jitter. TYPE: float DEFAULT: 1.0 initial_increment The initial increment to start at. TYPE: int DEFAULT: 0 RAISES DESCRIPTION ValueError If an int that's too big to be represented as a float or a non-finite value is passed in place of a field that's annotated as float or if max_retries is less than 1 . backoff async # backoff ( backoff_ ) Sleep for the provided backoff or for the next exponent. This provides an alternative to iterating over this class. PARAMETER DESCRIPTION backoff_ The time this should backoff for. If left as None then this will back off for the last time provided with yuyo.backoff.Backoff.set_next_backoff if available or the next exponential time. TYPE: typing . Optional [ float ] finish # finish () Mark the iterator as finished to break out of the current loop. is_depleted property # is_depleted () Whether \"max_retries\" has been reached. This can be used to workout whether the loop was explicitly broken out of using yuyo.backoff.Backoff.finish / break or if it hit \"max_retries\". reset # reset () Reset the backoff to it's original state to reuse it. set_next_backoff # set_next_backoff ( backoff_ ) Specify a backoff time for the next iteration or yuyo.backoff.Backoff.backoff call. If this is called then the exponent won't be increased for this iteration. Note Calling this multiple times in a single iteration will overwrite any previously set next backoff. ErrorManager # A context manager provided to allow for more concise error handling with yuyo.backoff.Backoff . Examples: The following is an example of using yuyo.backoff.ErrorManager alongside yuyo.backoff.Backoff in-order to handle the exceptions which may be raised while trying to reply to a message. retry = Backoff () # Rules can either be passed to `ErrorManager`'s initiate as variable arguments # or one at a time to `ErrorManager.with_rule` through possibly chained-calls. error_handler = ( # For the 1st rule we catch two errors which would indicate the bot # no-longer has access to the target channel and break out of the # retry loop using `Backoff.retry`. ErrorManager ((( errors . NotFoundError , errors . ForbiddenError ), lambda _ : retry . finish ())) # For the 2nd rule we catch rate limited errors and set their # `retry` value as the next backoff time before suppressing the # error to allow this to retry the request. . with_rule (( errors . RateLimitedError ,), lambda exc : retry . set_next_backoff ( exc . retry_after )) # For the 3rd rule we suppress the internal server error to allow # backoff to reach the next retry and exponentially backoff as we # don't have any specific retry time for this error. . with_rule (( errors . InternalServerError ,), lambda _ : False ) ) async for _ in retry : # We entre this context manager each iteration to catch errors before # they cause us to break out of the `Backoff` loop. with error_handler : await message . respond ( \"General Kenobi\" ) # We need to break out of `retry` if this request succeeds. break __init__ # __init__ ( * rules ) Initialise an error manager instance. PARAMETER DESCRIPTION *rules Rules to initiate this error context manager with. These are each a 2-length tuple where the tuple[0] is an iterable of types of the exceptions this rule should apply to and tuple[1] is the rule's callback function. The callback function will be called with the raised exception when it matches one of the passed exceptions for the relevant rule and may raise, return True to indicate that the current error should be raised outside of the context manager or False / None to suppress the current error. TYPE: typing . Tuple [ typing . Iterable [ typing . Type [ BaseException ]], typing . Callable [[ typing . Any ], typing . Optional [ bool ]]] DEFAULT: () clear_rules # clear_rules () Clear the rules registered with this handler. with_rule # with_rule ( exceptions , result ) Add a rule to this exception context manager. PARAMETER DESCRIPTION exceptions An iterable of types of the exceptions this rule should apply to. TYPE: typing . Iterable [ typing . Type [ BaseException ]] result The function called with the raised exception when it matches one of the passed exceptions . This may raise, return True to indicate that the current error should be raised outside of the context manager or False / None to suppress the current error. TYPE: typing . Callable [[ typing . Any ], typing . Optional [ bool ]] RETURNS DESCRIPTION Self This returns the handler a rule was being added to in-order to allow for chained calls.","title":"yuyo.backoff"},{"location":"reference/backoff/#yuyobackoff","text":"Utility used for handling automatic back-off. This can be used to cover cases such as hitting rate-limits and failed requests.","title":"yuyo.backoff"},{"location":"reference/backoff/#yuyo.backoff.Backoff","text":"Used to exponentially backoff asynchronously. This class acts as an asynchronous iterator and can be iterated over to provide implicit backoff where for every iteration other than the first this will either back off for the time passed to yuyo.backoff.Backoff.set_next_backoff if applicable or a time calculated exponentially. Examples: An example of using this class as an asynchronous iterator may look like the following # While we can directly do `async for _ in Backoff()`, by assigning it to a # variable we allow ourself to provide a specific backoff time in some cases. backoff = Backoff () async for _ in backoff : try : message = await bot . rest . fetch_message ( channel_id , message_id ) except errors . RateLimitedError as exc : # If we have a specific backoff time then set it for the next iteration backoff . set_next_backoff ( exc . retry_after ) except errors . InternalServerError : # Else let the iterator calculate an exponential backoff before the next loop. pass else : # We need to break out of the iterator to make sure it doesn't backoff again. # Alternatively `Backoff.finish()` can be called to break out of the loop. break Alternatively you may want to explicitly call yuyo.backoff.Backoff.backoff , a alternative of the previous example which uses yuyo.backoff.Backoff.backoff may look like the following backoff = Backoff () message : typing . Optional [ messages . Message ] = None while not message : try : message = await bot . rest . fetch_message ( channel_id , message_id ) except errors . RateLimitedError as exc : # If we have a specific backoff time then set it for the next iteration. await backoff . backoff ( exc . retry_after ) except errors . InternalServerError : # Else let the iterator calculate an exponential backoff before the next loop. await backoff . backoff ()","title":"Backoff"},{"location":"reference/backoff/#yuyo.backoff.Backoff.__init__","text":"__init__ ( max_retries = None , * , base = 2.0 , maximum = 64.0 , jitter_multiplier = 1.0 , initial_increment = 0 ) Initialise a backoff instance. PARAMETER DESCRIPTION max_retries The maximum amount of times this should iterate for between resets. If left as None then this iterator will be unlimited. This must be greater than or equal to 1. TYPE: typing . Optional [ int ] DEFAULT: None base The base to use. TYPE: float DEFAULT: 2.0 maximum The max value the backoff can be in a single iteration. Anything above this will be capped to this base value plus random jitter. TYPE: float DEFAULT: 64.0 jitter_multiplier The multiplier for the random jitter. Set to 0 to disable jitter. TYPE: float DEFAULT: 1.0 initial_increment The initial increment to start at. TYPE: int DEFAULT: 0 RAISES DESCRIPTION ValueError If an int that's too big to be represented as a float or a non-finite value is passed in place of a field that's annotated as float or if max_retries is less than 1 .","title":"__init__()"},{"location":"reference/backoff/#yuyo.backoff.Backoff.backoff","text":"backoff ( backoff_ ) Sleep for the provided backoff or for the next exponent. This provides an alternative to iterating over this class. PARAMETER DESCRIPTION backoff_ The time this should backoff for. If left as None then this will back off for the last time provided with yuyo.backoff.Backoff.set_next_backoff if available or the next exponential time. TYPE: typing . Optional [ float ]","title":"backoff()"},{"location":"reference/backoff/#yuyo.backoff.Backoff.finish","text":"finish () Mark the iterator as finished to break out of the current loop.","title":"finish()"},{"location":"reference/backoff/#yuyo.backoff.Backoff.is_depleted","text":"is_depleted () Whether \"max_retries\" has been reached. This can be used to workout whether the loop was explicitly broken out of using yuyo.backoff.Backoff.finish / break or if it hit \"max_retries\".","title":"is_depleted()"},{"location":"reference/backoff/#yuyo.backoff.Backoff.reset","text":"reset () Reset the backoff to it's original state to reuse it.","title":"reset()"},{"location":"reference/backoff/#yuyo.backoff.Backoff.set_next_backoff","text":"set_next_backoff ( backoff_ ) Specify a backoff time for the next iteration or yuyo.backoff.Backoff.backoff call. If this is called then the exponent won't be increased for this iteration. Note Calling this multiple times in a single iteration will overwrite any previously set next backoff.","title":"set_next_backoff()"},{"location":"reference/backoff/#yuyo.backoff.ErrorManager","text":"A context manager provided to allow for more concise error handling with yuyo.backoff.Backoff . Examples: The following is an example of using yuyo.backoff.ErrorManager alongside yuyo.backoff.Backoff in-order to handle the exceptions which may be raised while trying to reply to a message. retry = Backoff () # Rules can either be passed to `ErrorManager`'s initiate as variable arguments # or one at a time to `ErrorManager.with_rule` through possibly chained-calls. error_handler = ( # For the 1st rule we catch two errors which would indicate the bot # no-longer has access to the target channel and break out of the # retry loop using `Backoff.retry`. ErrorManager ((( errors . NotFoundError , errors . ForbiddenError ), lambda _ : retry . finish ())) # For the 2nd rule we catch rate limited errors and set their # `retry` value as the next backoff time before suppressing the # error to allow this to retry the request. . with_rule (( errors . RateLimitedError ,), lambda exc : retry . set_next_backoff ( exc . retry_after )) # For the 3rd rule we suppress the internal server error to allow # backoff to reach the next retry and exponentially backoff as we # don't have any specific retry time for this error. . with_rule (( errors . InternalServerError ,), lambda _ : False ) ) async for _ in retry : # We entre this context manager each iteration to catch errors before # they cause us to break out of the `Backoff` loop. with error_handler : await message . respond ( \"General Kenobi\" ) # We need to break out of `retry` if this request succeeds. break","title":"ErrorManager"},{"location":"reference/backoff/#yuyo.backoff.ErrorManager.__init__","text":"__init__ ( * rules ) Initialise an error manager instance. PARAMETER DESCRIPTION *rules Rules to initiate this error context manager with. These are each a 2-length tuple where the tuple[0] is an iterable of types of the exceptions this rule should apply to and tuple[1] is the rule's callback function. The callback function will be called with the raised exception when it matches one of the passed exceptions for the relevant rule and may raise, return True to indicate that the current error should be raised outside of the context manager or False / None to suppress the current error. TYPE: typing . Tuple [ typing . Iterable [ typing . Type [ BaseException ]], typing . Callable [[ typing . Any ], typing . Optional [ bool ]]] DEFAULT: ()","title":"__init__()"},{"location":"reference/backoff/#yuyo.backoff.ErrorManager.clear_rules","text":"clear_rules () Clear the rules registered with this handler.","title":"clear_rules()"},{"location":"reference/backoff/#yuyo.backoff.ErrorManager.with_rule","text":"with_rule ( exceptions , result ) Add a rule to this exception context manager. PARAMETER DESCRIPTION exceptions An iterable of types of the exceptions this rule should apply to. TYPE: typing . Iterable [ typing . Type [ BaseException ]] result The function called with the raised exception when it matches one of the passed exceptions . This may raise, return True to indicate that the current error should be raised outside of the context manager or False / None to suppress the current error. TYPE: typing . Callable [[ typing . Any ], typing . Optional [ bool ]] RETURNS DESCRIPTION Self This returns the handler a rule was being added to in-order to allow for chained calls.","title":"with_rule()"},{"location":"reference/components/","text":"yuyo.components # Higher level client for callback based component execution. WaitFor module-attribute # WaitFor = WaitForExecutor Alias of yuyo.components.WaitForExecutor . AbstractComponentExecutor # Bases: abc . ABC Abstract interface of an object which handles the execution of a message component. custom_ids property abstractmethod # custom_ids () Collection of the custom IDs this executor is listening for. has_expired property abstractmethod # has_expired () Whether this executor has ended. ActionRowExecutor # Bases: ComponentExecutor , hikari . api . ComponentBuilder Class used for handling the execution of an action row. __init__ # __init__ ( * , ephemeral_default = False , load_from_attributes = False , timeout = datetime . timedelta ( seconds = 30 )) Initialise an action row executor. PARAMETER DESCRIPTION ephemeral_default Whether this executor's responses should default to being ephemeral. TYPE: bool DEFAULT: False timeout How long this component should last until its marked as timed out. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30) ChildActionRowExecutor # Bases: ActionRowExecutor , typing . Generic [ _ParentExecutorProtoT ] Extended action row implementation which can be tied to a multi-component executor. add_to_parent # add_to_parent () Add this action row to its parent executor. RETURNS DESCRIPTION _ParentExecutorProtoT The parent executor this action row was added to. ComponentClient # Client used to handle component executors within a REST or gateway flow. __init__ # __init__ ( * , alluka = None , event_manager = None , event_managed = None , server = None ) Initialise a component client. Note For an easier way to initialise the client from a bot see yuyo.components.ComponentClient.from_gateway_bot and yuyo.components.ComponentClient.from_rest_bot . PARAMETER DESCRIPTION alluka The Alluka client to use for callback dependency injection in this client. If not provided then this will initialise its own Alluka client. TYPE: typing . Optional [ alluka_ . abc . Client ] DEFAULT: None event_manager The event manager this client should listen to dispatched component interactions from if applicable. TYPE: typing . Optional [ hikari . api . EventManager ] DEFAULT: None event_managed Whether this client should be automatically opened and closed based on the lifetime events dispatched by event_manager . Defaults to True if an event manager is passed. TYPE: typing . Optional [ bool ] DEFAULT: None server The server this client should listen to component interactions from if applicable. TYPE: typing . Optional [ hikari . api . InteractionServer ] DEFAULT: None RAISES DESCRIPTION ValueError If event_managed is passed as True when event_manager is None . add_executor # add_executor ( message , executor ) Deprecated alias of yuyo.components.ComponentClient.add_executor . alluka property # alluka () The Alluka client being used for callback dependency injection. close # close () Close the component client. from_gateway_bot classmethod # from_gateway_bot ( bot , / , * , event_managed = True ) Build a component client froma Gateway Bot. PARAMETER DESCRIPTION bot The Gateway bot this component client should be bound to. TYPE: hikari . GatewayBotAware event_managed Whether the component client should be automatically opened and closed based on the lifetime events dispatched by bot . TYPE: bool DEFAULT: True RETURNS DESCRIPTION ComponentClient The initialised component client. from_rest_bot classmethod # from_rest_bot ( bot ) Build a component client froma REST Bot. PARAMETER DESCRIPTION bot The REST bot this component client should be bound to. TYPE: hikari . RESTBotAware RETURNS DESCRIPTION ComponentClient The initialised component client. get_constant_id # get_constant_id ( custom_id ) Get a set constant \"custom_id\" callback. PARAMETER DESCRIPTION custom_id The custom_id to get the callback for. TYPE: str RETURNS DESCRIPTION CallbackSig | None The callback for the custom_id, or None if it doesn't exist. get_executor # get_executor ( message ) Get the component executor set for a message. PARAMETER DESCRIPTION message The message to get the executor for. TYPE: hikari . SnowflakeishOr [ hikari . Message ] RETURNS DESCRIPTION yuyo . components . AbstractComponentExecutor | None The executor set for the message or None if none is set. open # open () Startup the component client. remove_constant_id # remove_constant_id ( custom_id ) Remove a constant \"custom_id\" callback. PARAMETER DESCRIPTION custom_id The custom_id to remove the callback for. TYPE: str RETURNS DESCRIPTION Self The component client to allow chaining. RAISES DESCRIPTION KeyError If the custom_id is not registered. remove_executor # remove_executor ( message ) Remove the component executor for a message. PARAMETER DESCRIPTION message The message to remove the executor for. TYPE: hikari . SnowflakeishOr [ hikari . Message ] RETURNS DESCRIPTION Self The component client to allow chaining. set_constant_id # set_constant_id ( custom_id , callback , / , * , prefix_match = False ) Add a constant \"custom_id\" callback. These are callbacks which'll always be called for a specific custom_id while taking priority over executors. PARAMETER DESCRIPTION custom_id The custom_id to register the callback for. TYPE: str callback The callback to register. This should take a single argument of type yuyo.components.ComponentContext , be asynchronous and return None . TYPE: CallbackSig prefix_match Whether the custom_id should be treated as a prefix match. This allows for further state to be held in the custom id after the prefix and is lower priority than normal custom id match. TYPE: bool DEFAULT: False RETURNS DESCRIPTION Self The component client to allow chaining. RAISES DESCRIPTION ValueError If the custom_id is already registered. set_executor # set_executor ( message , executor ) Set the component executor for a message. PARAMETER DESCRIPTION message The message to set the executor for. TYPE: hikari . SnowflakeishOr [ hikari . Message ] executor The executor to set. This will be called for every component interaction for the message unless the component's custom_id is registered as a constant id callback. TYPE: AbstractComponentExecutor RETURNS DESCRIPTION Self The component client to allow chaining. with_constant_id # with_constant_id ( custom_id , / , * , prefix_match = False ) Add a constant \"custom_id\" callback through a decorator call. These are callbacks which'll always be called for a specific custom_id while taking priority over executors. PARAMETER DESCRIPTION custom_id The custom_id to register the callback for. TYPE: str prefix_match Whether the custom_id should be treated as a prefix match. This allows for further state to be held in the custom id after the prefix and is lower priority than normal custom id match. TYPE: bool DEFAULT: False RETURNS DESCRIPTION Callable [[ CallbackSigT ], CallbackSigT ] A decorator to register the callback. RAISES DESCRIPTION KeyError If the custom_id is already registered. ComponentContext # The general context passed around for a component trigger. create_followup async # create_followup ( content = hikari . UNDEFINED , * , delete_after = None , ephemeral = False , attachment = hikari . UNDEFINED , attachments = hikari . UNDEFINED , component = hikari . UNDEFINED , components = hikari . UNDEFINED , embed = hikari . UNDEFINED , embeds = hikari . UNDEFINED , mentions_everyone = hikari . UNDEFINED , user_mentions = hikari . UNDEFINED , role_mentions = hikari . UNDEFINED , tts = hikari . UNDEFINED , flags = hikari . UNDEFINED ) Create a followup response for this context. Warning Calling this on a context which hasn't had an initial response yet will lead to a hikari.errors.NotFoundError being raised. PARAMETER DESCRIPTION content If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED delete_after If provided, the seconds after which the response message should be deleted. Slash command responses can only be deleted within 15 minutes of the command being received. TYPE: typing . Union [ datetime . timedelta , float , int , None] DEFAULT: None ephemeral Whether the deferred response should be ephemeral. Passing True here is a shorthand for including 1 << 64 in the passed flags. TYPE: bool DEFAULT: False attachment If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL. TYPE: hikari . UndefinedOr [ hikari . Resourceish ] DEFAULT: hikari.UNDEFINED attachments If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . Resourceish ]] DEFAULT: hikari.UNDEFINED component If provided, builder object of the component to include in this message. TYPE: hikari . UndefinedOr [ hikari . api . ComponentBuilder ] DEFAULT: hikari.UNDEFINED components If provided, a sequence of the component builder objects to include in this message. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . api . ComponentBuilder ]] DEFAULT: hikari.UNDEFINED embed If provided, the message embed. TYPE: hikari . UndefinedOr [ hikari . Embed ] DEFAULT: hikari.UNDEFINED embeds If provided, the message embeds. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . Embed ]] DEFAULT: hikari.UNDEFINED mentions_everyone If provided, whether the message should parse @everyone/@here mentions. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED user_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialUser ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED role_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialRole ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED tts If provided, whether the message will be sent as a TTS message. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED flags The flags to set for this response. As of writing this can only flag which can be provided is EPHEMERAL, other flags are just ignored. TYPE: typing . Union [ hikari . UndefinedType , int , hikari . MessageFlag ] DEFAULT: hikari.UNDEFINED RETURNS DESCRIPTION hikari . Message The created message object. RAISES DESCRIPTION hikari . NotFoundError If the current interaction is not found or it hasn't had an initial response yet. hikari . BadRequestError This can be raised if the file is too large; if the embed exceeds the defined limits; if the message content is specified only and empty or greater than 2000 characters; if neither content, file or embeds are specified. If any invalid snowflake IDs are passed; a snowflake may be invalid due to it being outside of the range of a 64 bit integer. ValueError If more than 100 unique objects/entities are passed for role_mentions or `user_mentions. If the interaction will have expired before delete_after is reached. If both attachment and attachments are passed or both component and components are passed or both embed and embeds are passed. create_initial_response async # create_initial_response ( response_type , / , content = hikari . UNDEFINED , * , delete_after = None , ephemeral = False , attachment = hikari . UNDEFINED , attachments = hikari . UNDEFINED , component = hikari . UNDEFINED , components = hikari . UNDEFINED , embed = hikari . UNDEFINED , embeds = hikari . UNDEFINED , mentions_everyone = hikari . UNDEFINED , user_mentions = hikari . UNDEFINED , role_mentions = hikari . UNDEFINED , flags = hikari . UNDEFINED , tts = hikari . UNDEFINED ) Create the initial response for this context. Warning Calling this on a context which already has an initial response will result in this raising a hikari.errors.NotFoundError . This includes if the REST interaction server has already responded to the request and deferrals. PARAMETER DESCRIPTION response_type The type of message response to give. TYPE: hikari . MessageResponseTypesT content The content to edit the last response with. If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED delete_after If provided, the seconds after which the response message should be deleted. Slash command responses can only be deleted within 15 minutes of the command being received. TYPE: typing . Union [ datetime . timedelta , float , int , None] DEFAULT: None ephemeral Whether the deferred response should be ephemeral. Passing True here is a shorthand for including 1 << 64 in the passed flags. TYPE: bool DEFAULT: False content If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED attachment If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL. TYPE: hikari . UndefinedOr [ hikari . Resourceish ] DEFAULT: hikari.UNDEFINED attachments If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . Resourceish ]] DEFAULT: hikari.UNDEFINED component If provided, builder object of the component to include in this message. TYPE: hikari . UndefinedOr [ hikari . api . ComponentBuilder ] DEFAULT: hikari.UNDEFINED components If provided, a sequence of the component builder objects to include in this message. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . api . ComponentBuilder ]] DEFAULT: hikari.UNDEFINED embed If provided, the message embed. TYPE: hikari . UndefinedOr [ hikari . Embed ] DEFAULT: hikari.UNDEFINED embeds If provided, the message embeds. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . Embed ]] DEFAULT: hikari.UNDEFINED flags If provided, the message flags this response should have. As of writing the only message flag which can be set here is hikari.messages.MessageFlag.EPHEMERAL . TYPE: typing . Union [ int , hikari . MessageFlag , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED tts If provided, whether the message will be read out by a screen reader using Discord's TTS (text-to-speech) system. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED mentions_everyone If provided, whether the message should parse @everyone/@here mentions. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED user_mentions If provided, and True , all user mentions will be detected. If provided, and False , all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialUser ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED role_mentions If provided, and True , all role mentions will be detected. If provided, and False , all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of [hikari.snowflakes.Snowflake], or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialRole ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED RAISES DESCRIPTION ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions . If the interaction will have expired before delete_after is reached. If both attachment and attachments are passed or both component and components are passed or both embed and embeds are passed. hikari . BadRequestError This may be raised in several discrete situations, such as messages being empty with no embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; invalid image URLs in embeds. hikari . UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari . NotFoundError If the interaction is not found or if the interaction's initial response has already been created. hikari . RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request. hikari . RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari . InternalServerError If an internal error occurs on Discord while handling the request. defer async # defer ( defer_type , / , * , ephemeral = False , flags = hikari . UNDEFINED ) Defer the initial response for this context. Note The ephemeral state of the first response is decided by whether the deferral is ephemeral. PARAMETER DESCRIPTION defer_type The type of deferral this should be. This may any of the following * ResponseType.DEFERRED_MESSAGE_CREATE to indicate that the following up call to yuyo.components.ComponentContext.edit_initial_response or yuyo.components.ComponentContext.respond should create a new message. * ResponseType.DEFERRED_MESSAGE_UPDATE to indicate that the following call to the aforementioned methods should update the existing message. TYPE: hikari . DeferredResponseTypesT ephemeral Whether the deferred response should be ephemeral. Passing True here is a shorthand for including 1 << 64 in the passed flags. TYPE: bool DEFAULT: False flags The flags to use for the initial response. TYPE: typing . Union [ hikari . UndefinedType , int , hikari . MessageFlag ] DEFAULT: hikari.UNDEFINED delete_initial_response async # delete_initial_response () Delete the initial response after invoking this context. RAISES DESCRIPTION LookupError , hikari . NotFoundError The last context has no initial response. delete_last_response async # delete_last_response () Delete the last response after invoking this context. RAISES DESCRIPTION LookupError , hikari . NotFoundError The last context has no responses. edit_initial_response async # edit_initial_response ( content = hikari . UNDEFINED , * , delete_after = None , attachment = hikari . UNDEFINED , attachments = hikari . UNDEFINED , component = hikari . UNDEFINED , components = hikari . UNDEFINED , embed = hikari . UNDEFINED , embeds = hikari . UNDEFINED , replace_attachments = False , mentions_everyone = hikari . UNDEFINED , user_mentions = hikari . UNDEFINED , role_mentions = hikari . UNDEFINED ) Edit the initial response for this context. PARAMETER DESCRIPTION content The content to edit the initial response with. If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED delete_after If provided, the seconds after which the response message should be deleted. Slash command responses can only be deleted within 15 minutes of the command being received. TYPE: typing . Union [ datetime . timedelta , float , int , None] DEFAULT: None attachment A singular attachment to edit the initial response with. TYPE: hikari . UndefinedOr [ hikari . Resourceish ] DEFAULT: hikari.UNDEFINED attachments A sequence of attachments to edit the initial response with. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . Resourceish ]] DEFAULT: hikari.UNDEFINED component If provided, builder object of the component to set for this message. This component will replace any previously set components and passing None will remove all components. TYPE: hikari . UndefinedNoneOr [ hikari . api . ComponentBuilder ] DEFAULT: hikari.UNDEFINED components If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing None or an empty sequence will remove all components. TYPE: hikari . UndefinedNoneOr [ typing . Sequence [ hikari . api . ComponentBuilder ]] DEFAULT: hikari.UNDEFINED embed An embed to replace the initial response with. TYPE: hikari . UndefinedNoneOr [ hikari . Embed ] DEFAULT: hikari.UNDEFINED embeds A sequence of embeds to replace the initial response with. TYPE: hikari . UndefinedNoneOr [ typing . Sequence [ hikari . Embed ]] DEFAULT: hikari.UNDEFINED replace_attachments Whether to replace the attachments of the response or not. TYPE: bool DEFAULT: False mentions_everyone If provided, whether the message should parse @everyone/@here mentions. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED user_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialUser ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED role_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialRole ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED RETURNS DESCRIPTION hikari . Message The message that has been edited. RAISES DESCRIPTION ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions . If delete_after would be more than 15 minutes after the slash command was called. If both attachment and attachments are passed or both component and components are passed or both embed and embeds are passed. hikari . BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components. hikari . UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari . ForbiddenError If you are missing the SEND_MESSAGES in the channel or the person you are trying to message has the DM's disabled. hikari . NotFoundError If the channel is not found. hikari . RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request. hikari . RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari . InternalServerError If an internal error occurs on Discord while handling the request. edit_last_response async # edit_last_response ( content = hikari . UNDEFINED , * , delete_after = None , attachment = hikari . UNDEFINED , attachments = hikari . UNDEFINED , component = hikari . UNDEFINED , components = hikari . UNDEFINED , embed = hikari . UNDEFINED , embeds = hikari . UNDEFINED , replace_attachments = False , mentions_everyone = hikari . UNDEFINED , user_mentions = hikari . UNDEFINED , role_mentions = hikari . UNDEFINED ) Edit the last response for this context. PARAMETER DESCRIPTION content The content to edit the last response with. If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED delete_after If provided, the seconds after which the response message should be deleted. Slash command responses can only be deleted within 15 minutes of the command being received. TYPE: typing . Union [ datetime . timedelta , float , int , None] DEFAULT: None attachment A singular attachment to edit the last response with. TYPE: hikari . UndefinedOr [ hikari . Resourceish ] DEFAULT: hikari.UNDEFINED attachments A sequence of attachments to edit the last response with. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . Resourceish ]] DEFAULT: hikari.UNDEFINED component If provided, builder object of the component to set for this message. This component will replace any previously set components and passing None will remove all components. TYPE: hikari . UndefinedNoneOr [ hikari . api . ComponentBuilder ] DEFAULT: hikari.UNDEFINED components If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing None or an empty sequence will remove all components. TYPE: hikari . UndefinedNoneOr [ typing . Sequence [ hikari . api . ComponentBuilder ]] DEFAULT: hikari.UNDEFINED embed An embed to replace the last response with. TYPE: hikari . UndefinedNoneOr [ hikari . Embed ] DEFAULT: hikari.UNDEFINED embeds A sequence of embeds to replace the last response with. TYPE: hikari . UndefinedNoneOr [ typing . Sequence [ hikari . Embed ]] DEFAULT: hikari.UNDEFINED replace_attachments Whether to replace the attachments of the response or not. TYPE: bool DEFAULT: False mentions_everyone If provided, whether the message should parse @everyone/@here mentions. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED user_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialUser ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED role_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialRole ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED RETURNS DESCRIPTION hikari . Message The message that has been edited. RAISES DESCRIPTION ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions . If delete_after would be more than 15 minutes after the slash command was called. If both attachment and attachments are passed or both component and components are passed or both embed and embeds are passed. hikari . BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components. hikari . UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari . ForbiddenError If you are missing the SEND_MESSAGES in the channel or the person you are trying to message has the DM's disabled. hikari . NotFoundError If the channel is not found. hikari . RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request. hikari . RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari . InternalServerError If an internal error occurs on Discord while handling the request. fetch_initial_response async # fetch_initial_response () Fetch the initial response for this context. RETURNS DESCRIPTION hikari . messages . Message The initial response's message object. RAISES DESCRIPTION LookupError , hikari . NotFoundError The response was not found. fetch_last_response async # fetch_last_response () Fetch the last response for this context. RETURNS DESCRIPTION hikari . messages . Message The most response response's message object. RAISES DESCRIPTION LookupError , hikari . NotFoundError The response was not found. has_been_deferred property # has_been_deferred () Whether this context's initial response has been deferred. This will be true if yuyo.components.ComponentContext.defer has been called. has_responded property # has_responded () Whether an initial response has been made to this context yet. It's worth noting that a context must be either responded to or deferred within 3 seconds from it being received otherwise it'll be marked as failed. This will be true if either yuyo.components.ComponentContext.respond , yuyo.components.ComponentContext.create_initial_response or yuyo.components.ComponentContext.edit_initial_response (after a deferral) has been called. interaction property # interaction () Object of the interaction this context is for. respond async # respond ( content = hikari . UNDEFINED , * , ensure_result = False , delete_after = None , attachment = hikari . UNDEFINED , attachments = hikari . UNDEFINED , component = hikari . UNDEFINED , components = hikari . UNDEFINED , embed = hikari . UNDEFINED , embeds = hikari . UNDEFINED , mentions_everyone = hikari . UNDEFINED , user_mentions = hikari . UNDEFINED , role_mentions = hikari . UNDEFINED ) Respond to this context. PARAMETER DESCRIPTION content The content to respond with. If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED ensure_result Ensure that this call will always return a message object. If True then this will always return hikari.messages.Message , otherwise this will return hikari.Message | None . It's worth noting that, under certain scenarios within the slash command flow, this may lead to an extre request being made. TYPE: bool DEFAULT: False delete_after If provided, the seconds after which the response message should be deleted. Slash command responses can only be deleted within 15 minutes of the command being received. TYPE: typing . Union [ datetime . timedelta , float , int , None] DEFAULT: None attachment If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL. TYPE: hikari . UndefinedOr [ hikari . Resourceish ] DEFAULT: hikari.UNDEFINED attachments If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . Resourceish ]] DEFAULT: hikari.UNDEFINED component If provided, builder object of the component to include in this response. TYPE: hikari . UndefinedOr [ hikari . api . ComponentBuilder ] DEFAULT: hikari.UNDEFINED components If provided, a sequence of the component builder objects to include in this response. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . api . ComponentBuilder ]] DEFAULT: hikari.UNDEFINED embed An embed to respond with. TYPE: hikari . UndefinedOr [ hikari . Embed ] DEFAULT: hikari.UNDEFINED embeds A sequence of embeds to respond with. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . Embed ]] DEFAULT: hikari.UNDEFINED mentions_everyone If provided, whether the message should parse @everyone/@here mentions. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED user_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialUser ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED role_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialRole ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED RETURNS DESCRIPTION hikari . Message | None The message that has been created if it was immedieatly available or ensure_result was set to True , else None . RAISES DESCRIPTION ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions . If delete_after would be more than 15 minutes after the slash command was called. If both attachment and attachments are passed or both component and components are passed or both embed and embeds are passed. hikari . BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components. hikari . UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari . ForbiddenError If you are missing the SEND_MESSAGES in the channel or the person you are trying to message has the DM's disabled. hikari . NotFoundError If the channel is not found. hikari . RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request. hikari . RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari . InternalServerError If an internal error occurs on Discord while handling the request. set_ephemeral_default # set_ephemeral_default ( state ) Set the ephemeral default state for this context. PARAMETER DESCRIPTION state The new ephemeral default state. If this is True then all calls to the response creating methods on this context will default to being ephemeral. TYPE: bool ComponentExecutor # Bases: AbstractComponentExecutor Basic implementation of a class used for handling the execution of a message component. __init__ # __init__ ( * , ephemeral_default = False , load_from_attributes = True , timeout = datetime . timedelta ( seconds = 30 )) Initialise a component executor. PARAMETER DESCRIPTION ephemeral_default Whether this executor's responses should default to being ephemeral. TYPE: bool DEFAULT: False timeout How long this component should last until its marked as timed out. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30) ComponentPaginator # Bases: ActionRowExecutor Standard implementation of an action row executor used for pagination. This is a convenience class that allows you to easily implement a paginator. __init__ # __init__ ( iterator , * , authors , ephemeral_default = False , triggers = ( pagination . LEFT_TRIANGLE , pagination . STOP_SQUARE , pagination . RIGHT_TRIANGLE ), load_from_attributes = False , timeout = datetime . timedelta ( seconds = 30 )) Initialise a component paginator. PARAMETER DESCRIPTION iterator The iterator to paginate. This should be an iterator of tuples of (hikari.UndefinedOr[str], hikari.UndefinedOr[hikari.Embed]) . TYPE: typing . Iterator [ yuyo . pagination . EntryT ] | typing . AsyncIterator [ yuyo . pagination . EntryT ] authors The authors of the entries. If None is passed here then the paginator will be public (meaning that anybody can use it). TYPE: typing . Optional [ typing . Iterable [ hikari . SnowflakeishOr [ hikari . User ]]] ephemeral_default Whether or not the responses made on contexts spawned from this paginator should default to ephemeral (meaning only the author can see them) unless flags is specified on the response method. TYPE: bool DEFAULT: False triggers Collection of the unicode emojis that should trigger this paginator. As of current the only usable emojis are yuyo.pagination.LEFT_TRIANGLE , yuyo.pagination.RIGHT_TRIANGLE , yuyo.pagination.STOP_SQUARE , yuyo.pagination.LEFT_DOUBLE_TRIANGLE and yuyo.pagination.LEFT_TRIANGLE . TYPE: typing . Collection [ str ] DEFAULT: (pagination.LEFT_TRIANGLE, pagination.STOP_SQUARE, pagination.RIGHT_TRIANGLE) timeout The amount of time to wait after the component's last execution or creation until it times out. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30) builder # builder () Get a sequence of the component builders for this paginator. RETURNS DESCRIPTION typing . Sequence [ hikari . api . ComponentBuilder ] The component builders for this paginator. get_next_entry async # get_next_entry () Get the next entry in this paginator. This is generally helpful for making the message which the paginator will be based off and will still internally store the entry and increment the position of the paginator. Examples: response_paginator = yuyo . ComponentPaginator ( pages , authors = ( ctx . author . id ,) ) first_response = await response_paginator . get_next_entry () assert first_response content , embed = first_response message = await ctx . respond ( content = content , embed = embed , component = response_paginator , ensure_result = True ) component_client . set_executor ( message , response_paginator ) RETURNS DESCRIPTION yuyo . pagination . EntryT | None The next entry in this paginator, or None if there are no more entries. ExecutorClosed # Bases: Exception Error used to indicate that an executor is now closed during execution. MultiComponentExecutor # Bases: AbstractComponentExecutor Multi-component implementation of a component executor. This implementation allows for multiple components to be executed as a single view. __init__ # __init__ ( * , load_from_attributes = False , timeout = datetime . timedelta ( seconds = 30 )) Initialise a multi-component executor. PARAMETER DESCRIPTION timeout The amount of time to wait after the component's last execution or creation until it times out. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30) add_action_row # add_action_row () Create a builder class to add an action row to this executor. For the most part this follows the same implementation as yuyo.components.ActionRowExecutor except with the added detail that yuyo.components.ChildActionRowExecutor.add_to_parent must be called to add the action row to the parent executor. RETURNS DESCRIPTION ChildActionRowExecutor [ Self ] A builder class to add an action row to this executor. yuyo.components.ChildActionRowExecutor.add_to_parent should be called to finalise the action row and will return the parent executor for chained calls. add_builder # add_builder ( builder ) Add a non-executable component builder to this executor. This is useful for adding components that are not meant to be executed, such as a a row of link buttons. PARAMETER DESCRIPTION builder The component builder to add. TYPE: hikari . api . ComponentBuilder RETURNS DESCRIPTION Self add_executor # add_executor ( executor ) Add a component executor to this multi-component executor. This method is internally used by the add_{component} methods. PARAMETER DESCRIPTION executor The component executor to add. TYPE: AbstractComponentExecutor RETURNS DESCRIPTION Self The multi-component executor instance to enable chained calls. builders property # builders () Sequence of the component builders within this executor. executors property # executors () Sequence of the child executors within this multi-executor. WaitForExecutor # Bases: AbstractComponentExecutor Component executor used to wait for a single component interaction. Examples: responses : dict [ str , str ] message = await ctx . respond ( \"hi, pick an option\" , components = [ ... ]) executor = yuyo . components . WaitFor ( authors = ( ctx . author . id ,), timeout = datetime . timedelta ( seconds = 30 )) component_client . set_executor ( message . id , executor ) try : result = await executor . wait_for () except asyncio . TimeoutError : await ctx . respond ( \"timed out\" ) else : await result . respond ( responses [ result . interaction . custom_id ]) __init__ # __init__ ( * , authors , ephemeral_default = False , timeout ) Initialise a wait for executor. PARAMETER DESCRIPTION authors The authors of the entries. If None is passed here then the paginator will be public (meaning that anybody can use it). TYPE: typing . Optional [ typing . Iterable [ hikari . SnowflakeishOr [ hikari . User ]]] ephemeral_default Whether or not the responses made on contexts spawned from this paginator should default to ephemeral (meaning only the author can see them) unless flags is specified on the response method. TYPE: bool DEFAULT: False timeout How long this should wait for a matching component interaction until it times-out. TYPE: datetime . timedelta wait_for async # wait_for () Wait for the next matching interaction. RETURNS DESCRIPTION ComponentContext The next matching interaction. RAISES DESCRIPTION RuntimeError If the executor is already being waited for. asyncio . TimeoutError If the timeout is reached.","title":"yuyo.components"},{"location":"reference/components/#yuyocomponents","text":"Higher level client for callback based component execution.","title":"yuyo.components"},{"location":"reference/components/#yuyo.components.WaitFor","text":"WaitFor = WaitForExecutor Alias of yuyo.components.WaitForExecutor .","title":"WaitFor"},{"location":"reference/components/#yuyo.components.AbstractComponentExecutor","text":"Bases: abc . ABC Abstract interface of an object which handles the execution of a message component.","title":"AbstractComponentExecutor"},{"location":"reference/components/#yuyo.components.AbstractComponentExecutor.custom_ids","text":"custom_ids () Collection of the custom IDs this executor is listening for.","title":"custom_ids()"},{"location":"reference/components/#yuyo.components.AbstractComponentExecutor.has_expired","text":"has_expired () Whether this executor has ended.","title":"has_expired()"},{"location":"reference/components/#yuyo.components.ActionRowExecutor","text":"Bases: ComponentExecutor , hikari . api . ComponentBuilder Class used for handling the execution of an action row.","title":"ActionRowExecutor"},{"location":"reference/components/#yuyo.components.ActionRowExecutor.__init__","text":"__init__ ( * , ephemeral_default = False , load_from_attributes = False , timeout = datetime . timedelta ( seconds = 30 )) Initialise an action row executor. PARAMETER DESCRIPTION ephemeral_default Whether this executor's responses should default to being ephemeral. TYPE: bool DEFAULT: False timeout How long this component should last until its marked as timed out. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30)","title":"__init__()"},{"location":"reference/components/#yuyo.components.ChildActionRowExecutor","text":"Bases: ActionRowExecutor , typing . Generic [ _ParentExecutorProtoT ] Extended action row implementation which can be tied to a multi-component executor.","title":"ChildActionRowExecutor"},{"location":"reference/components/#yuyo.components.ChildActionRowExecutor.add_to_parent","text":"add_to_parent () Add this action row to its parent executor. RETURNS DESCRIPTION _ParentExecutorProtoT The parent executor this action row was added to.","title":"add_to_parent()"},{"location":"reference/components/#yuyo.components.ComponentClient","text":"Client used to handle component executors within a REST or gateway flow.","title":"ComponentClient"},{"location":"reference/components/#yuyo.components.ComponentClient.__init__","text":"__init__ ( * , alluka = None , event_manager = None , event_managed = None , server = None ) Initialise a component client. Note For an easier way to initialise the client from a bot see yuyo.components.ComponentClient.from_gateway_bot and yuyo.components.ComponentClient.from_rest_bot . PARAMETER DESCRIPTION alluka The Alluka client to use for callback dependency injection in this client. If not provided then this will initialise its own Alluka client. TYPE: typing . Optional [ alluka_ . abc . Client ] DEFAULT: None event_manager The event manager this client should listen to dispatched component interactions from if applicable. TYPE: typing . Optional [ hikari . api . EventManager ] DEFAULT: None event_managed Whether this client should be automatically opened and closed based on the lifetime events dispatched by event_manager . Defaults to True if an event manager is passed. TYPE: typing . Optional [ bool ] DEFAULT: None server The server this client should listen to component interactions from if applicable. TYPE: typing . Optional [ hikari . api . InteractionServer ] DEFAULT: None RAISES DESCRIPTION ValueError If event_managed is passed as True when event_manager is None .","title":"__init__()"},{"location":"reference/components/#yuyo.components.ComponentClient.add_executor","text":"add_executor ( message , executor ) Deprecated alias of yuyo.components.ComponentClient.add_executor .","title":"add_executor()"},{"location":"reference/components/#yuyo.components.ComponentClient.alluka","text":"alluka () The Alluka client being used for callback dependency injection.","title":"alluka()"},{"location":"reference/components/#yuyo.components.ComponentClient.close","text":"close () Close the component client.","title":"close()"},{"location":"reference/components/#yuyo.components.ComponentClient.from_gateway_bot","text":"from_gateway_bot ( bot , / , * , event_managed = True ) Build a component client froma Gateway Bot. PARAMETER DESCRIPTION bot The Gateway bot this component client should be bound to. TYPE: hikari . GatewayBotAware event_managed Whether the component client should be automatically opened and closed based on the lifetime events dispatched by bot . TYPE: bool DEFAULT: True RETURNS DESCRIPTION ComponentClient The initialised component client.","title":"from_gateway_bot()"},{"location":"reference/components/#yuyo.components.ComponentClient.from_rest_bot","text":"from_rest_bot ( bot ) Build a component client froma REST Bot. PARAMETER DESCRIPTION bot The REST bot this component client should be bound to. TYPE: hikari . RESTBotAware RETURNS DESCRIPTION ComponentClient The initialised component client.","title":"from_rest_bot()"},{"location":"reference/components/#yuyo.components.ComponentClient.get_constant_id","text":"get_constant_id ( custom_id ) Get a set constant \"custom_id\" callback. PARAMETER DESCRIPTION custom_id The custom_id to get the callback for. TYPE: str RETURNS DESCRIPTION CallbackSig | None The callback for the custom_id, or None if it doesn't exist.","title":"get_constant_id()"},{"location":"reference/components/#yuyo.components.ComponentClient.get_executor","text":"get_executor ( message ) Get the component executor set for a message. PARAMETER DESCRIPTION message The message to get the executor for. TYPE: hikari . SnowflakeishOr [ hikari . Message ] RETURNS DESCRIPTION yuyo . components . AbstractComponentExecutor | None The executor set for the message or None if none is set.","title":"get_executor()"},{"location":"reference/components/#yuyo.components.ComponentClient.open","text":"open () Startup the component client.","title":"open()"},{"location":"reference/components/#yuyo.components.ComponentClient.remove_constant_id","text":"remove_constant_id ( custom_id ) Remove a constant \"custom_id\" callback. PARAMETER DESCRIPTION custom_id The custom_id to remove the callback for. TYPE: str RETURNS DESCRIPTION Self The component client to allow chaining. RAISES DESCRIPTION KeyError If the custom_id is not registered.","title":"remove_constant_id()"},{"location":"reference/components/#yuyo.components.ComponentClient.remove_executor","text":"remove_executor ( message ) Remove the component executor for a message. PARAMETER DESCRIPTION message The message to remove the executor for. TYPE: hikari . SnowflakeishOr [ hikari . Message ] RETURNS DESCRIPTION Self The component client to allow chaining.","title":"remove_executor()"},{"location":"reference/components/#yuyo.components.ComponentClient.set_constant_id","text":"set_constant_id ( custom_id , callback , / , * , prefix_match = False ) Add a constant \"custom_id\" callback. These are callbacks which'll always be called for a specific custom_id while taking priority over executors. PARAMETER DESCRIPTION custom_id The custom_id to register the callback for. TYPE: str callback The callback to register. This should take a single argument of type yuyo.components.ComponentContext , be asynchronous and return None . TYPE: CallbackSig prefix_match Whether the custom_id should be treated as a prefix match. This allows for further state to be held in the custom id after the prefix and is lower priority than normal custom id match. TYPE: bool DEFAULT: False RETURNS DESCRIPTION Self The component client to allow chaining. RAISES DESCRIPTION ValueError If the custom_id is already registered.","title":"set_constant_id()"},{"location":"reference/components/#yuyo.components.ComponentClient.set_executor","text":"set_executor ( message , executor ) Set the component executor for a message. PARAMETER DESCRIPTION message The message to set the executor for. TYPE: hikari . SnowflakeishOr [ hikari . Message ] executor The executor to set. This will be called for every component interaction for the message unless the component's custom_id is registered as a constant id callback. TYPE: AbstractComponentExecutor RETURNS DESCRIPTION Self The component client to allow chaining.","title":"set_executor()"},{"location":"reference/components/#yuyo.components.ComponentClient.with_constant_id","text":"with_constant_id ( custom_id , / , * , prefix_match = False ) Add a constant \"custom_id\" callback through a decorator call. These are callbacks which'll always be called for a specific custom_id while taking priority over executors. PARAMETER DESCRIPTION custom_id The custom_id to register the callback for. TYPE: str prefix_match Whether the custom_id should be treated as a prefix match. This allows for further state to be held in the custom id after the prefix and is lower priority than normal custom id match. TYPE: bool DEFAULT: False RETURNS DESCRIPTION Callable [[ CallbackSigT ], CallbackSigT ] A decorator to register the callback. RAISES DESCRIPTION KeyError If the custom_id is already registered.","title":"with_constant_id()"},{"location":"reference/components/#yuyo.components.ComponentContext","text":"The general context passed around for a component trigger.","title":"ComponentContext"},{"location":"reference/components/#yuyo.components.ComponentContext.create_followup","text":"create_followup ( content = hikari . UNDEFINED , * , delete_after = None , ephemeral = False , attachment = hikari . UNDEFINED , attachments = hikari . UNDEFINED , component = hikari . UNDEFINED , components = hikari . UNDEFINED , embed = hikari . UNDEFINED , embeds = hikari . UNDEFINED , mentions_everyone = hikari . UNDEFINED , user_mentions = hikari . UNDEFINED , role_mentions = hikari . UNDEFINED , tts = hikari . UNDEFINED , flags = hikari . UNDEFINED ) Create a followup response for this context. Warning Calling this on a context which hasn't had an initial response yet will lead to a hikari.errors.NotFoundError being raised. PARAMETER DESCRIPTION content If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED delete_after If provided, the seconds after which the response message should be deleted. Slash command responses can only be deleted within 15 minutes of the command being received. TYPE: typing . Union [ datetime . timedelta , float , int , None] DEFAULT: None ephemeral Whether the deferred response should be ephemeral. Passing True here is a shorthand for including 1 << 64 in the passed flags. TYPE: bool DEFAULT: False attachment If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL. TYPE: hikari . UndefinedOr [ hikari . Resourceish ] DEFAULT: hikari.UNDEFINED attachments If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . Resourceish ]] DEFAULT: hikari.UNDEFINED component If provided, builder object of the component to include in this message. TYPE: hikari . UndefinedOr [ hikari . api . ComponentBuilder ] DEFAULT: hikari.UNDEFINED components If provided, a sequence of the component builder objects to include in this message. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . api . ComponentBuilder ]] DEFAULT: hikari.UNDEFINED embed If provided, the message embed. TYPE: hikari . UndefinedOr [ hikari . Embed ] DEFAULT: hikari.UNDEFINED embeds If provided, the message embeds. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . Embed ]] DEFAULT: hikari.UNDEFINED mentions_everyone If provided, whether the message should parse @everyone/@here mentions. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED user_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialUser ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED role_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialRole ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED tts If provided, whether the message will be sent as a TTS message. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED flags The flags to set for this response. As of writing this can only flag which can be provided is EPHEMERAL, other flags are just ignored. TYPE: typing . Union [ hikari . UndefinedType , int , hikari . MessageFlag ] DEFAULT: hikari.UNDEFINED RETURNS DESCRIPTION hikari . Message The created message object. RAISES DESCRIPTION hikari . NotFoundError If the current interaction is not found or it hasn't had an initial response yet. hikari . BadRequestError This can be raised if the file is too large; if the embed exceeds the defined limits; if the message content is specified only and empty or greater than 2000 characters; if neither content, file or embeds are specified. If any invalid snowflake IDs are passed; a snowflake may be invalid due to it being outside of the range of a 64 bit integer. ValueError If more than 100 unique objects/entities are passed for role_mentions or `user_mentions. If the interaction will have expired before delete_after is reached. If both attachment and attachments are passed or both component and components are passed or both embed and embeds are passed.","title":"create_followup()"},{"location":"reference/components/#yuyo.components.ComponentContext.create_initial_response","text":"create_initial_response ( response_type , / , content = hikari . UNDEFINED , * , delete_after = None , ephemeral = False , attachment = hikari . UNDEFINED , attachments = hikari . UNDEFINED , component = hikari . UNDEFINED , components = hikari . UNDEFINED , embed = hikari . UNDEFINED , embeds = hikari . UNDEFINED , mentions_everyone = hikari . UNDEFINED , user_mentions = hikari . UNDEFINED , role_mentions = hikari . UNDEFINED , flags = hikari . UNDEFINED , tts = hikari . UNDEFINED ) Create the initial response for this context. Warning Calling this on a context which already has an initial response will result in this raising a hikari.errors.NotFoundError . This includes if the REST interaction server has already responded to the request and deferrals. PARAMETER DESCRIPTION response_type The type of message response to give. TYPE: hikari . MessageResponseTypesT content The content to edit the last response with. If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED delete_after If provided, the seconds after which the response message should be deleted. Slash command responses can only be deleted within 15 minutes of the command being received. TYPE: typing . Union [ datetime . timedelta , float , int , None] DEFAULT: None ephemeral Whether the deferred response should be ephemeral. Passing True here is a shorthand for including 1 << 64 in the passed flags. TYPE: bool DEFAULT: False content If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED attachment If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL. TYPE: hikari . UndefinedOr [ hikari . Resourceish ] DEFAULT: hikari.UNDEFINED attachments If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . Resourceish ]] DEFAULT: hikari.UNDEFINED component If provided, builder object of the component to include in this message. TYPE: hikari . UndefinedOr [ hikari . api . ComponentBuilder ] DEFAULT: hikari.UNDEFINED components If provided, a sequence of the component builder objects to include in this message. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . api . ComponentBuilder ]] DEFAULT: hikari.UNDEFINED embed If provided, the message embed. TYPE: hikari . UndefinedOr [ hikari . Embed ] DEFAULT: hikari.UNDEFINED embeds If provided, the message embeds. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . Embed ]] DEFAULT: hikari.UNDEFINED flags If provided, the message flags this response should have. As of writing the only message flag which can be set here is hikari.messages.MessageFlag.EPHEMERAL . TYPE: typing . Union [ int , hikari . MessageFlag , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED tts If provided, whether the message will be read out by a screen reader using Discord's TTS (text-to-speech) system. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED mentions_everyone If provided, whether the message should parse @everyone/@here mentions. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED user_mentions If provided, and True , all user mentions will be detected. If provided, and False , all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialUser ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED role_mentions If provided, and True , all role mentions will be detected. If provided, and False , all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of [hikari.snowflakes.Snowflake], or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialRole ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED RAISES DESCRIPTION ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions . If the interaction will have expired before delete_after is reached. If both attachment and attachments are passed or both component and components are passed or both embed and embeds are passed. hikari . BadRequestError This may be raised in several discrete situations, such as messages being empty with no embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; invalid image URLs in embeds. hikari . UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari . NotFoundError If the interaction is not found or if the interaction's initial response has already been created. hikari . RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request. hikari . RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari . InternalServerError If an internal error occurs on Discord while handling the request.","title":"create_initial_response()"},{"location":"reference/components/#yuyo.components.ComponentContext.defer","text":"defer ( defer_type , / , * , ephemeral = False , flags = hikari . UNDEFINED ) Defer the initial response for this context. Note The ephemeral state of the first response is decided by whether the deferral is ephemeral. PARAMETER DESCRIPTION defer_type The type of deferral this should be. This may any of the following * ResponseType.DEFERRED_MESSAGE_CREATE to indicate that the following up call to yuyo.components.ComponentContext.edit_initial_response or yuyo.components.ComponentContext.respond should create a new message. * ResponseType.DEFERRED_MESSAGE_UPDATE to indicate that the following call to the aforementioned methods should update the existing message. TYPE: hikari . DeferredResponseTypesT ephemeral Whether the deferred response should be ephemeral. Passing True here is a shorthand for including 1 << 64 in the passed flags. TYPE: bool DEFAULT: False flags The flags to use for the initial response. TYPE: typing . Union [ hikari . UndefinedType , int , hikari . MessageFlag ] DEFAULT: hikari.UNDEFINED","title":"defer()"},{"location":"reference/components/#yuyo.components.ComponentContext.delete_initial_response","text":"delete_initial_response () Delete the initial response after invoking this context. RAISES DESCRIPTION LookupError , hikari . NotFoundError The last context has no initial response.","title":"delete_initial_response()"},{"location":"reference/components/#yuyo.components.ComponentContext.delete_last_response","text":"delete_last_response () Delete the last response after invoking this context. RAISES DESCRIPTION LookupError , hikari . NotFoundError The last context has no responses.","title":"delete_last_response()"},{"location":"reference/components/#yuyo.components.ComponentContext.edit_initial_response","text":"edit_initial_response ( content = hikari . UNDEFINED , * , delete_after = None , attachment = hikari . UNDEFINED , attachments = hikari . UNDEFINED , component = hikari . UNDEFINED , components = hikari . UNDEFINED , embed = hikari . UNDEFINED , embeds = hikari . UNDEFINED , replace_attachments = False , mentions_everyone = hikari . UNDEFINED , user_mentions = hikari . UNDEFINED , role_mentions = hikari . UNDEFINED ) Edit the initial response for this context. PARAMETER DESCRIPTION content The content to edit the initial response with. If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED delete_after If provided, the seconds after which the response message should be deleted. Slash command responses can only be deleted within 15 minutes of the command being received. TYPE: typing . Union [ datetime . timedelta , float , int , None] DEFAULT: None attachment A singular attachment to edit the initial response with. TYPE: hikari . UndefinedOr [ hikari . Resourceish ] DEFAULT: hikari.UNDEFINED attachments A sequence of attachments to edit the initial response with. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . Resourceish ]] DEFAULT: hikari.UNDEFINED component If provided, builder object of the component to set for this message. This component will replace any previously set components and passing None will remove all components. TYPE: hikari . UndefinedNoneOr [ hikari . api . ComponentBuilder ] DEFAULT: hikari.UNDEFINED components If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing None or an empty sequence will remove all components. TYPE: hikari . UndefinedNoneOr [ typing . Sequence [ hikari . api . ComponentBuilder ]] DEFAULT: hikari.UNDEFINED embed An embed to replace the initial response with. TYPE: hikari . UndefinedNoneOr [ hikari . Embed ] DEFAULT: hikari.UNDEFINED embeds A sequence of embeds to replace the initial response with. TYPE: hikari . UndefinedNoneOr [ typing . Sequence [ hikari . Embed ]] DEFAULT: hikari.UNDEFINED replace_attachments Whether to replace the attachments of the response or not. TYPE: bool DEFAULT: False mentions_everyone If provided, whether the message should parse @everyone/@here mentions. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED user_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialUser ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED role_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialRole ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED RETURNS DESCRIPTION hikari . Message The message that has been edited. RAISES DESCRIPTION ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions . If delete_after would be more than 15 minutes after the slash command was called. If both attachment and attachments are passed or both component and components are passed or both embed and embeds are passed. hikari . BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components. hikari . UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari . ForbiddenError If you are missing the SEND_MESSAGES in the channel or the person you are trying to message has the DM's disabled. hikari . NotFoundError If the channel is not found. hikari . RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request. hikari . RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari . InternalServerError If an internal error occurs on Discord while handling the request.","title":"edit_initial_response()"},{"location":"reference/components/#yuyo.components.ComponentContext.edit_last_response","text":"edit_last_response ( content = hikari . UNDEFINED , * , delete_after = None , attachment = hikari . UNDEFINED , attachments = hikari . UNDEFINED , component = hikari . UNDEFINED , components = hikari . UNDEFINED , embed = hikari . UNDEFINED , embeds = hikari . UNDEFINED , replace_attachments = False , mentions_everyone = hikari . UNDEFINED , user_mentions = hikari . UNDEFINED , role_mentions = hikari . UNDEFINED ) Edit the last response for this context. PARAMETER DESCRIPTION content The content to edit the last response with. If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED delete_after If provided, the seconds after which the response message should be deleted. Slash command responses can only be deleted within 15 minutes of the command being received. TYPE: typing . Union [ datetime . timedelta , float , int , None] DEFAULT: None attachment A singular attachment to edit the last response with. TYPE: hikari . UndefinedOr [ hikari . Resourceish ] DEFAULT: hikari.UNDEFINED attachments A sequence of attachments to edit the last response with. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . Resourceish ]] DEFAULT: hikari.UNDEFINED component If provided, builder object of the component to set for this message. This component will replace any previously set components and passing None will remove all components. TYPE: hikari . UndefinedNoneOr [ hikari . api . ComponentBuilder ] DEFAULT: hikari.UNDEFINED components If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing None or an empty sequence will remove all components. TYPE: hikari . UndefinedNoneOr [ typing . Sequence [ hikari . api . ComponentBuilder ]] DEFAULT: hikari.UNDEFINED embed An embed to replace the last response with. TYPE: hikari . UndefinedNoneOr [ hikari . Embed ] DEFAULT: hikari.UNDEFINED embeds A sequence of embeds to replace the last response with. TYPE: hikari . UndefinedNoneOr [ typing . Sequence [ hikari . Embed ]] DEFAULT: hikari.UNDEFINED replace_attachments Whether to replace the attachments of the response or not. TYPE: bool DEFAULT: False mentions_everyone If provided, whether the message should parse @everyone/@here mentions. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED user_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialUser ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED role_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialRole ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED RETURNS DESCRIPTION hikari . Message The message that has been edited. RAISES DESCRIPTION ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions . If delete_after would be more than 15 minutes after the slash command was called. If both attachment and attachments are passed or both component and components are passed or both embed and embeds are passed. hikari . BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components. hikari . UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari . ForbiddenError If you are missing the SEND_MESSAGES in the channel or the person you are trying to message has the DM's disabled. hikari . NotFoundError If the channel is not found. hikari . RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request. hikari . RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari . InternalServerError If an internal error occurs on Discord while handling the request.","title":"edit_last_response()"},{"location":"reference/components/#yuyo.components.ComponentContext.fetch_initial_response","text":"fetch_initial_response () Fetch the initial response for this context. RETURNS DESCRIPTION hikari . messages . Message The initial response's message object. RAISES DESCRIPTION LookupError , hikari . NotFoundError The response was not found.","title":"fetch_initial_response()"},{"location":"reference/components/#yuyo.components.ComponentContext.fetch_last_response","text":"fetch_last_response () Fetch the last response for this context. RETURNS DESCRIPTION hikari . messages . Message The most response response's message object. RAISES DESCRIPTION LookupError , hikari . NotFoundError The response was not found.","title":"fetch_last_response()"},{"location":"reference/components/#yuyo.components.ComponentContext.has_been_deferred","text":"has_been_deferred () Whether this context's initial response has been deferred. This will be true if yuyo.components.ComponentContext.defer has been called.","title":"has_been_deferred()"},{"location":"reference/components/#yuyo.components.ComponentContext.has_responded","text":"has_responded () Whether an initial response has been made to this context yet. It's worth noting that a context must be either responded to or deferred within 3 seconds from it being received otherwise it'll be marked as failed. This will be true if either yuyo.components.ComponentContext.respond , yuyo.components.ComponentContext.create_initial_response or yuyo.components.ComponentContext.edit_initial_response (after a deferral) has been called.","title":"has_responded()"},{"location":"reference/components/#yuyo.components.ComponentContext.interaction","text":"interaction () Object of the interaction this context is for.","title":"interaction()"},{"location":"reference/components/#yuyo.components.ComponentContext.respond","text":"respond ( content = hikari . UNDEFINED , * , ensure_result = False , delete_after = None , attachment = hikari . UNDEFINED , attachments = hikari . UNDEFINED , component = hikari . UNDEFINED , components = hikari . UNDEFINED , embed = hikari . UNDEFINED , embeds = hikari . UNDEFINED , mentions_everyone = hikari . UNDEFINED , user_mentions = hikari . UNDEFINED , role_mentions = hikari . UNDEFINED ) Respond to this context. PARAMETER DESCRIPTION content The content to respond with. If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED ensure_result Ensure that this call will always return a message object. If True then this will always return hikari.messages.Message , otherwise this will return hikari.Message | None . It's worth noting that, under certain scenarios within the slash command flow, this may lead to an extre request being made. TYPE: bool DEFAULT: False delete_after If provided, the seconds after which the response message should be deleted. Slash command responses can only be deleted within 15 minutes of the command being received. TYPE: typing . Union [ datetime . timedelta , float , int , None] DEFAULT: None attachment If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL. TYPE: hikari . UndefinedOr [ hikari . Resourceish ] DEFAULT: hikari.UNDEFINED attachments If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . Resourceish ]] DEFAULT: hikari.UNDEFINED component If provided, builder object of the component to include in this response. TYPE: hikari . UndefinedOr [ hikari . api . ComponentBuilder ] DEFAULT: hikari.UNDEFINED components If provided, a sequence of the component builder objects to include in this response. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . api . ComponentBuilder ]] DEFAULT: hikari.UNDEFINED embed An embed to respond with. TYPE: hikari . UndefinedOr [ hikari . Embed ] DEFAULT: hikari.UNDEFINED embeds A sequence of embeds to respond with. TYPE: hikari . UndefinedOr [ typing . Sequence [ hikari . Embed ]] DEFAULT: hikari.UNDEFINED mentions_everyone If provided, whether the message should parse @everyone/@here mentions. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED user_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialUser ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED role_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialRole ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED RETURNS DESCRIPTION hikari . Message | None The message that has been created if it was immedieatly available or ensure_result was set to True , else None . RAISES DESCRIPTION ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions . If delete_after would be more than 15 minutes after the slash command was called. If both attachment and attachments are passed or both component and components are passed or both embed and embeds are passed. hikari . BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components. hikari . UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari . ForbiddenError If you are missing the SEND_MESSAGES in the channel or the person you are trying to message has the DM's disabled. hikari . NotFoundError If the channel is not found. hikari . RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request. hikari . RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari . InternalServerError If an internal error occurs on Discord while handling the request.","title":"respond()"},{"location":"reference/components/#yuyo.components.ComponentContext.set_ephemeral_default","text":"set_ephemeral_default ( state ) Set the ephemeral default state for this context. PARAMETER DESCRIPTION state The new ephemeral default state. If this is True then all calls to the response creating methods on this context will default to being ephemeral. TYPE: bool","title":"set_ephemeral_default()"},{"location":"reference/components/#yuyo.components.ComponentExecutor","text":"Bases: AbstractComponentExecutor Basic implementation of a class used for handling the execution of a message component.","title":"ComponentExecutor"},{"location":"reference/components/#yuyo.components.ComponentExecutor.__init__","text":"__init__ ( * , ephemeral_default = False , load_from_attributes = True , timeout = datetime . timedelta ( seconds = 30 )) Initialise a component executor. PARAMETER DESCRIPTION ephemeral_default Whether this executor's responses should default to being ephemeral. TYPE: bool DEFAULT: False timeout How long this component should last until its marked as timed out. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30)","title":"__init__()"},{"location":"reference/components/#yuyo.components.ComponentPaginator","text":"Bases: ActionRowExecutor Standard implementation of an action row executor used for pagination. This is a convenience class that allows you to easily implement a paginator.","title":"ComponentPaginator"},{"location":"reference/components/#yuyo.components.ComponentPaginator.__init__","text":"__init__ ( iterator , * , authors , ephemeral_default = False , triggers = ( pagination . LEFT_TRIANGLE , pagination . STOP_SQUARE , pagination . RIGHT_TRIANGLE ), load_from_attributes = False , timeout = datetime . timedelta ( seconds = 30 )) Initialise a component paginator. PARAMETER DESCRIPTION iterator The iterator to paginate. This should be an iterator of tuples of (hikari.UndefinedOr[str], hikari.UndefinedOr[hikari.Embed]) . TYPE: typing . Iterator [ yuyo . pagination . EntryT ] | typing . AsyncIterator [ yuyo . pagination . EntryT ] authors The authors of the entries. If None is passed here then the paginator will be public (meaning that anybody can use it). TYPE: typing . Optional [ typing . Iterable [ hikari . SnowflakeishOr [ hikari . User ]]] ephemeral_default Whether or not the responses made on contexts spawned from this paginator should default to ephemeral (meaning only the author can see them) unless flags is specified on the response method. TYPE: bool DEFAULT: False triggers Collection of the unicode emojis that should trigger this paginator. As of current the only usable emojis are yuyo.pagination.LEFT_TRIANGLE , yuyo.pagination.RIGHT_TRIANGLE , yuyo.pagination.STOP_SQUARE , yuyo.pagination.LEFT_DOUBLE_TRIANGLE and yuyo.pagination.LEFT_TRIANGLE . TYPE: typing . Collection [ str ] DEFAULT: (pagination.LEFT_TRIANGLE, pagination.STOP_SQUARE, pagination.RIGHT_TRIANGLE) timeout The amount of time to wait after the component's last execution or creation until it times out. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30)","title":"__init__()"},{"location":"reference/components/#yuyo.components.ComponentPaginator.builder","text":"builder () Get a sequence of the component builders for this paginator. RETURNS DESCRIPTION typing . Sequence [ hikari . api . ComponentBuilder ] The component builders for this paginator.","title":"builder()"},{"location":"reference/components/#yuyo.components.ComponentPaginator.get_next_entry","text":"get_next_entry () Get the next entry in this paginator. This is generally helpful for making the message which the paginator will be based off and will still internally store the entry and increment the position of the paginator. Examples: response_paginator = yuyo . ComponentPaginator ( pages , authors = ( ctx . author . id ,) ) first_response = await response_paginator . get_next_entry () assert first_response content , embed = first_response message = await ctx . respond ( content = content , embed = embed , component = response_paginator , ensure_result = True ) component_client . set_executor ( message , response_paginator ) RETURNS DESCRIPTION yuyo . pagination . EntryT | None The next entry in this paginator, or None if there are no more entries.","title":"get_next_entry()"},{"location":"reference/components/#yuyo.components.ExecutorClosed","text":"Bases: Exception Error used to indicate that an executor is now closed during execution.","title":"ExecutorClosed"},{"location":"reference/components/#yuyo.components.MultiComponentExecutor","text":"Bases: AbstractComponentExecutor Multi-component implementation of a component executor. This implementation allows for multiple components to be executed as a single view.","title":"MultiComponentExecutor"},{"location":"reference/components/#yuyo.components.MultiComponentExecutor.__init__","text":"__init__ ( * , load_from_attributes = False , timeout = datetime . timedelta ( seconds = 30 )) Initialise a multi-component executor. PARAMETER DESCRIPTION timeout The amount of time to wait after the component's last execution or creation until it times out. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30)","title":"__init__()"},{"location":"reference/components/#yuyo.components.MultiComponentExecutor.add_action_row","text":"add_action_row () Create a builder class to add an action row to this executor. For the most part this follows the same implementation as yuyo.components.ActionRowExecutor except with the added detail that yuyo.components.ChildActionRowExecutor.add_to_parent must be called to add the action row to the parent executor. RETURNS DESCRIPTION ChildActionRowExecutor [ Self ] A builder class to add an action row to this executor. yuyo.components.ChildActionRowExecutor.add_to_parent should be called to finalise the action row and will return the parent executor for chained calls.","title":"add_action_row()"},{"location":"reference/components/#yuyo.components.MultiComponentExecutor.add_builder","text":"add_builder ( builder ) Add a non-executable component builder to this executor. This is useful for adding components that are not meant to be executed, such as a a row of link buttons. PARAMETER DESCRIPTION builder The component builder to add. TYPE: hikari . api . ComponentBuilder RETURNS DESCRIPTION Self","title":"add_builder()"},{"location":"reference/components/#yuyo.components.MultiComponentExecutor.add_executor","text":"add_executor ( executor ) Add a component executor to this multi-component executor. This method is internally used by the add_{component} methods. PARAMETER DESCRIPTION executor The component executor to add. TYPE: AbstractComponentExecutor RETURNS DESCRIPTION Self The multi-component executor instance to enable chained calls.","title":"add_executor()"},{"location":"reference/components/#yuyo.components.MultiComponentExecutor.builders","text":"builders () Sequence of the component builders within this executor.","title":"builders()"},{"location":"reference/components/#yuyo.components.MultiComponentExecutor.executors","text":"executors () Sequence of the child executors within this multi-executor.","title":"executors()"},{"location":"reference/components/#yuyo.components.WaitForExecutor","text":"Bases: AbstractComponentExecutor Component executor used to wait for a single component interaction. Examples: responses : dict [ str , str ] message = await ctx . respond ( \"hi, pick an option\" , components = [ ... ]) executor = yuyo . components . WaitFor ( authors = ( ctx . author . id ,), timeout = datetime . timedelta ( seconds = 30 )) component_client . set_executor ( message . id , executor ) try : result = await executor . wait_for () except asyncio . TimeoutError : await ctx . respond ( \"timed out\" ) else : await result . respond ( responses [ result . interaction . custom_id ])","title":"WaitForExecutor"},{"location":"reference/components/#yuyo.components.WaitForExecutor.__init__","text":"__init__ ( * , authors , ephemeral_default = False , timeout ) Initialise a wait for executor. PARAMETER DESCRIPTION authors The authors of the entries. If None is passed here then the paginator will be public (meaning that anybody can use it). TYPE: typing . Optional [ typing . Iterable [ hikari . SnowflakeishOr [ hikari . User ]]] ephemeral_default Whether or not the responses made on contexts spawned from this paginator should default to ephemeral (meaning only the author can see them) unless flags is specified on the response method. TYPE: bool DEFAULT: False timeout How long this should wait for a matching component interaction until it times-out. TYPE: datetime . timedelta","title":"__init__()"},{"location":"reference/components/#yuyo.components.WaitForExecutor.wait_for","text":"wait_for () Wait for the next matching interaction. RETURNS DESCRIPTION ComponentContext The next matching interaction. RAISES DESCRIPTION RuntimeError If the executor is already being waited for. asyncio . TimeoutError If the timeout is reached.","title":"wait_for()"},{"location":"reference/pagination/","text":"yuyo.pagination # Utilities used for quick pagination handling within reaction and component executors. BLACK_CROSS module-attribute # BLACK_CROSS : typing . Final [ hikari . UnicodeEmoji ] = hikari . UnicodeEmoji ( '\u2716\ufe0f' ) The emoji used to close a menu in a component context. EntryT module-attribute # EntryT = typing . Tuple [ hikari . UndefinedOr [ str ], hikari . UndefinedOr [ hikari . Embed ]] A type hint used to represent a paginator entry. This should be a tuple of the string message content or hikari.undefined.UNDEFINED to the message's embed if set else hikari.undefined.UNDEFINED . LEFT_DOUBLE_TRIANGLE module-attribute # LEFT_DOUBLE_TRIANGLE : typing . Final [ hikari . UnicodeEmoji ] = hikari . UnicodeEmoji ( '\u23ee\ufe0f' ) The emoji used to go back to the first entry. LEFT_TRIANGLE module-attribute # LEFT_TRIANGLE : typing . Final [ hikari . UnicodeEmoji ] = hikari . UnicodeEmoji ( '\u25c0\ufe0f' ) The emoji used to go back an entry. RIGHT_DOUBLE_TRIANGLE module-attribute # RIGHT_DOUBLE_TRIANGLE : typing . Final [ hikari . UnicodeEmoji ] = hikari . UnicodeEmoji ( '\u23ed\ufe0f' ) The emoji used for the lesser-enabled skip to last entry button. RIGHT_TRIANGLE module-attribute # RIGHT_TRIANGLE : typing . Final [ hikari . UnicodeEmoji ] = hikari . UnicodeEmoji ( '\u25b6\ufe0f' ) The emoji used to continue to the next entry. STOP_SQUARE module-attribute # STOP_SQUARE : typing . Final [ hikari . UnicodeEmoji ] = hikari . UnicodeEmoji ( '\u23f9\ufe0f' ) The emoji used to close a menu in a reaction context. aenumerate async # aenumerate ( iterable ) Async equivalent of enumerate . PARAMETER DESCRIPTION iterable The async iterable to enumerate. TYPE: typing . AsyncIterable [ _T ] RETURNS DESCRIPTION typing . AsyncIterator [ tuple [ int , _T ]] The enumerated async iterator. async_paginate_string async # async_paginate_string ( lines , * , char_limit = 2000 , line_limit = 25 , wrapper = None ) Lazily paginate an iterator of lines. PARAMETER DESCRIPTION lines The asynchronous iterator of lines to paginate. TYPE: typing . AsyncIterable [ str ] char_limit The limit for how many characters should be included per yielded page. TYPE: int DEFAULT: 2000 line_limit The limit for how many lines should be included per yielded page. TYPE: int DEFAULT: 25 wrapper A wrapper for each yielded page. This should leave \"{}\" in it to be replaced by the page's content. TYPE: typing . Optional [ str ] DEFAULT: None RETURNS DESCRIPTION typing . AsyncIterator [ tuple [ str , int ]] An async iterator of page tuples (string context to int zero-based index). paginate_string # paginate_string ( lines , * , char_limit = 2000 , line_limit = 25 , wrapper = None ) Lazily paginate an iterator of lines. PARAMETER DESCRIPTION lines The iterator of lines to paginate. This iterator may be asynchronous or synchronous. TYPE: typing . Iterator [ str ] | typing . AsyncIterator [ str ] char_limit The limit for how many characters should be included per yielded page. TYPE: int DEFAULT: 2000 line_limit The limit for how many lines should be included per yielded page. TYPE: int DEFAULT: 25 wrapper A wrapper for each yielded page. This should leave \"{}\" in it to be replaced by the page's content. TYPE: typing . Optional [ str ] DEFAULT: None RETURNS DESCRIPTION AsyncIterator [ tuple [ str , int ]] | typing . Iterator [ tuple [ str , int ]] An iterator of page tuples (string context to int zero-based index). sync_paginate_string # sync_paginate_string ( lines , * , char_limit = 2000 , line_limit = 25 , wrapper = None ) Lazily paginate an iterator of lines. PARAMETER DESCRIPTION lines The iterator of lines to paginate. TYPE: typing . Iterable [ str ] char_limit The limit for how many characters should be included per yielded page. TYPE: int DEFAULT: 2000 line_limit The limit for how many lines should be included per yielded page. TYPE: int DEFAULT: 25 wrapper A wrapper for each yielded page. This should leave \"{}\" in it to be replaced by the page's content. TYPE: typing . Optional [ str ] DEFAULT: None RETURNS DESCRIPTION typing . Iterator [ tuple [ str , int ]] An iterator of page tuples (string context to int zero-based index).","title":"yuyo.pagination"},{"location":"reference/pagination/#yuyopagination","text":"Utilities used for quick pagination handling within reaction and component executors.","title":"yuyo.pagination"},{"location":"reference/pagination/#yuyo.pagination.BLACK_CROSS","text":"BLACK_CROSS : typing . Final [ hikari . UnicodeEmoji ] = hikari . UnicodeEmoji ( '\u2716\ufe0f' ) The emoji used to close a menu in a component context.","title":"BLACK_CROSS"},{"location":"reference/pagination/#yuyo.pagination.EntryT","text":"EntryT = typing . Tuple [ hikari . UndefinedOr [ str ], hikari . UndefinedOr [ hikari . Embed ]] A type hint used to represent a paginator entry. This should be a tuple of the string message content or hikari.undefined.UNDEFINED to the message's embed if set else hikari.undefined.UNDEFINED .","title":"EntryT"},{"location":"reference/pagination/#yuyo.pagination.LEFT_DOUBLE_TRIANGLE","text":"LEFT_DOUBLE_TRIANGLE : typing . Final [ hikari . UnicodeEmoji ] = hikari . UnicodeEmoji ( '\u23ee\ufe0f' ) The emoji used to go back to the first entry.","title":"LEFT_DOUBLE_TRIANGLE"},{"location":"reference/pagination/#yuyo.pagination.LEFT_TRIANGLE","text":"LEFT_TRIANGLE : typing . Final [ hikari . UnicodeEmoji ] = hikari . UnicodeEmoji ( '\u25c0\ufe0f' ) The emoji used to go back an entry.","title":"LEFT_TRIANGLE"},{"location":"reference/pagination/#yuyo.pagination.RIGHT_DOUBLE_TRIANGLE","text":"RIGHT_DOUBLE_TRIANGLE : typing . Final [ hikari . UnicodeEmoji ] = hikari . UnicodeEmoji ( '\u23ed\ufe0f' ) The emoji used for the lesser-enabled skip to last entry button.","title":"RIGHT_DOUBLE_TRIANGLE"},{"location":"reference/pagination/#yuyo.pagination.RIGHT_TRIANGLE","text":"RIGHT_TRIANGLE : typing . Final [ hikari . UnicodeEmoji ] = hikari . UnicodeEmoji ( '\u25b6\ufe0f' ) The emoji used to continue to the next entry.","title":"RIGHT_TRIANGLE"},{"location":"reference/pagination/#yuyo.pagination.STOP_SQUARE","text":"STOP_SQUARE : typing . Final [ hikari . UnicodeEmoji ] = hikari . UnicodeEmoji ( '\u23f9\ufe0f' ) The emoji used to close a menu in a reaction context.","title":"STOP_SQUARE"},{"location":"reference/pagination/#yuyo.pagination.aenumerate","text":"aenumerate ( iterable ) Async equivalent of enumerate . PARAMETER DESCRIPTION iterable The async iterable to enumerate. TYPE: typing . AsyncIterable [ _T ] RETURNS DESCRIPTION typing . AsyncIterator [ tuple [ int , _T ]] The enumerated async iterator.","title":"aenumerate()"},{"location":"reference/pagination/#yuyo.pagination.async_paginate_string","text":"async_paginate_string ( lines , * , char_limit = 2000 , line_limit = 25 , wrapper = None ) Lazily paginate an iterator of lines. PARAMETER DESCRIPTION lines The asynchronous iterator of lines to paginate. TYPE: typing . AsyncIterable [ str ] char_limit The limit for how many characters should be included per yielded page. TYPE: int DEFAULT: 2000 line_limit The limit for how many lines should be included per yielded page. TYPE: int DEFAULT: 25 wrapper A wrapper for each yielded page. This should leave \"{}\" in it to be replaced by the page's content. TYPE: typing . Optional [ str ] DEFAULT: None RETURNS DESCRIPTION typing . AsyncIterator [ tuple [ str , int ]] An async iterator of page tuples (string context to int zero-based index).","title":"async_paginate_string()"},{"location":"reference/pagination/#yuyo.pagination.paginate_string","text":"paginate_string ( lines , * , char_limit = 2000 , line_limit = 25 , wrapper = None ) Lazily paginate an iterator of lines. PARAMETER DESCRIPTION lines The iterator of lines to paginate. This iterator may be asynchronous or synchronous. TYPE: typing . Iterator [ str ] | typing . AsyncIterator [ str ] char_limit The limit for how many characters should be included per yielded page. TYPE: int DEFAULT: 2000 line_limit The limit for how many lines should be included per yielded page. TYPE: int DEFAULT: 25 wrapper A wrapper for each yielded page. This should leave \"{}\" in it to be replaced by the page's content. TYPE: typing . Optional [ str ] DEFAULT: None RETURNS DESCRIPTION AsyncIterator [ tuple [ str , int ]] | typing . Iterator [ tuple [ str , int ]] An iterator of page tuples (string context to int zero-based index).","title":"paginate_string()"},{"location":"reference/pagination/#yuyo.pagination.sync_paginate_string","text":"sync_paginate_string ( lines , * , char_limit = 2000 , line_limit = 25 , wrapper = None ) Lazily paginate an iterator of lines. PARAMETER DESCRIPTION lines The iterator of lines to paginate. TYPE: typing . Iterable [ str ] char_limit The limit for how many characters should be included per yielded page. TYPE: int DEFAULT: 2000 line_limit The limit for how many lines should be included per yielded page. TYPE: int DEFAULT: 25 wrapper A wrapper for each yielded page. This should leave \"{}\" in it to be replaced by the page's content. TYPE: typing . Optional [ str ] DEFAULT: None RETURNS DESCRIPTION typing . Iterator [ tuple [ str , int ]] An iterator of page tuples (string context to int zero-based index).","title":"sync_paginate_string()"},{"location":"reference/reactions/","text":"yuyo.reactions # Client for higher level callback based reaction menu handling. AbstractReactionHandler # Bases: abc . ABC The interface for a reaction handler used with yuyo.reactions.ReactionClient . close abstractmethod async # close () Close this handler. has_expired property abstractmethod # has_expired () Whether this handler has ended. last_triggered property abstractmethod # last_triggered () When this handler was last triggered. Note If it hasn't ever been triggered then this will be when it was created. on_reaction_event abstractmethod async # on_reaction_event ( event , / , * , alluka = None ) Handle a reaction event. PARAMETER DESCRIPTION event The event to handle. TYPE: EventT alluka The Alluka client to use for callback dependency injection during callback calls. TYPE: typing . Optional [ alluka_ . abc . Client ] DEFAULT: None RAISES DESCRIPTION HandlerClosed If this reaction handler has been closed. open abstractmethod async # open ( message ) Open this handler. PARAMETER DESCRIPTION message The message to bind this handler to. TYPE: hikari . Message HandlerClosed # Bases: Exception Error raised when a reaction handler has been closed. ReactionClient # A class which handles the events for multiple registered reaction handlers. Note For a quicker way to initialise this client from a bot, see yuyo.reactions.ReactionClient.from_gateway_bot . __init__ # __init__ ( * , rest , event_manager , alluka = None , event_managed = True ) Initialise a reaction client. PARAMETER DESCRIPTION rest The REST client to register this reaction client with. TYPE: hikari . api . RESTClient event_manager The event manager client to register this reaction client with. TYPE: hikari . api . EventManager alluka The alluka client to use for callback DI. TYPE: typing . Optional [ alluka_ . abc . Client ] DEFAULT: None event_managed Whether the reaction client should be automatically opened and closed based on the lifetime events dispatched by event_managed . TYPE: bool DEFAULT: True add_handler # add_handler ( message , / , paginator ) Add a reaction handler to this reaction client. Note This does not call yuyo.reactions.AbstractReactionHandler.open . PARAMETER DESCRIPTION message The message ID to add register a reaction handler with. TYPE: hikari . SnowflakeishOr [ hikari . Message ] paginator The object of the opened paginator to register in this reaction client. TYPE: AbstractReactionHandler alluka property # alluka () The Alluka client being used for callback dependency injection. close async # close () Close this client by unregistering any registered tasks and event listeners. from_gateway_bot classmethod # from_gateway_bot ( bot , / , * , event_managed = True ) Build a ReactionClient from a gateway bot. PARAMETER DESCRIPTION bot The bot to build a reaction client for. TYPE: traits . GatewayBotAware event_managed Whether the reaction client should be automatically opened and closed based on the lifetime events dispatched by bot . TYPE: bool DEFAULT: True RETURNS DESCRIPTION ReactionClient The reaction client for the bot. get_handler # get_handler ( message ) Get a reference to a paginator registered in this reaction client. Note This does not call yuyo.reactions.AbstractReactionHandler.close . PARAMETER DESCRIPTION message The message ID to remove a paginator for. TYPE: hikari . SnowflakeishOr [ hikari . Message ] RETURNS DESCRIPTION AbstractReactionHandler | None The object of the registered paginator if found else None . is_closed property # is_closed () Whether this client is closed. open async # open () Start this client by registering the required tasks and event listeners for it to function. remove_handler # remove_handler ( message ) Remove a paginator from this reaction client. Note This does not call yuyo.reactions.AbstractReactionHandler.close . PARAMETER DESCRIPTION message The message ID to remove a paginator for. TYPE: hikari . SnowflakeishOr [ hikari . Message ] RETURNS DESCRIPTION AbstractReactionHandler | None The object of the registered paginator if found else None . ReactionHandler # Bases: AbstractReactionHandler Standard basic implementation of a reaction handler. __init__ # __init__ ( * , authors = (), timeout = datetime . timedelta ( seconds = 30 ), load_from_attributes = True ) Initialise a reaction handler. PARAMETER DESCRIPTION authors An iterable of IDs of the users who can call this paginator. If left empty then all users will be able to call this paginator. TYPE: typing . Iterable [ hikari . SnowflakeishOr [ hikari . User ]] DEFAULT: () timeout How long it should take for this paginator to timeout. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30) add_callback # add_callback ( emoji_identifier , callback ) Add a callback to this reaction handler. PARAMETER DESCRIPTION emoji_identifier Identifier of the emoji this callback is for. This should be a snowfake if this is for a custom emoji or a string if this is for a unicode emoji. TYPE: typing . Union [ str , hikari . SnowflakeishOr [ hikari . CustomEmoji ]] callback The callback to add. This should be a function that accepts a single parameter, which is the event that triggered this reaction. TYPE: CallbackSig authors property # authors () Set of the authors/owner of a enabled handler. Note If this is empty then the handler is considered public and any user will be able to trigger it. remove_callback # remove_callback ( emoji_identifier ) Remove a callback from this reaction handler. PARAMETER DESCRIPTION emoji_identifier Identifier of the emoji the callback to remove is for. This should be a snowfake if this is for a custom emoji or a string if this is for a unicode emoji. TYPE: typing . Union [ str , hikari . SnowflakeishOr [ hikari . CustomEmoji ]] timeout property # timeout () How long this handler will wait since the last event before timing out. with_callback # with_callback ( emoji_identifier ) Add a callback to this reaction handler through a decorator call. PARAMETER DESCRIPTION emoji_identifier Identifier of the emoji this callback is for. This should be a snowfake if this is for a custom emoji or a string if this is for a unicode emoji. TYPE: typing . Union [ str , hikari . SnowflakeishOr [ hikari . CustomEmoji ]] RETURNS DESCRIPTION typing . Callabke [[ CallbackSigT ], CallbackSigT ] A decorator to add a callback to this reaction handler. ReactionPaginator # Bases: ReactionHandler Standard implementation of a reaction handler for pagination. __init__ # __init__ ( iterator , * , authors , triggers = ( pagination . LEFT_TRIANGLE , pagination . STOP_SQUARE , pagination . RIGHT_TRIANGLE ), timeout = datetime . timedelta ( seconds = 30 )) Initialise a reaction paginator. PARAMETER DESCRIPTION iterator Either an asynchronous or synchronous iterator of the entries this should paginate through. entry[0] represents the message's possible content and can either be str or hikari.undefined.UNDEFINED and entry[1] represents the message's possible embed and can either be hikari.embeds.Embed or hikari.undefined.UNDEFINED . TYPE: typing . Iterator [ yuyo . pagination . EntryT ] | typing . AsyncIterator [ yuyo . pagination . EntryT ] authors An iterable of IDs of the users who can call this paginator. If left empty then all users will be able to call this paginator. TYPE: typing . Iterable [ hikari . SnowflakeishOr [ hikari . User ]] timeout How long it should take for this paginator to timeout. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30) add_author # add_author ( user ) Add a author/owner to this handler. PARAMETER DESCRIPTION user The user to add as an owner for this handler. TYPE: hikari . SnowflakeishOr [ hikari . User ] close async # close ( * , remove_reactions = False , max_retries = 5 , max_backoff = 2.0 ) Close this handler and deregister any previously registered message. PARAMETER DESCRIPTION remove_reactions Whether this should remove the reactions that were being used to paginate through this from the previously registered message. TYPE: bool DEFAULT: False create_message async # create_message ( rest , channel_id , / , * , add_reactions = True , max_retries = 5 , max_backoff = 2.0 ) Start this handler and link it to a bot message. Note Calling this multiple times will replace the previously registered message. PARAMETER DESCRIPTION rest Rest client to use to make the response. TYPE: hikari . api . RESTClient channel_id ID of the channel to respond in. TYPE: hikari . SnowflakeishOr [ hikari . TextableChannel ] add_reactions Whether this should add the paginator's reactions to the message after responding. TYPE: bool DEFAULT: True max_retries How many times this should retry to respond if Hikari raises any ratelimit errors. TYPE: int DEFAULT: 5 max_backoff The maximum time this should backoff for before trying if Hikari raises any ratelimit errors. TYPE: float DEFAULT: 2.0 RETURNS DESCRIPTION hikari . messages . Message Object of the message this handler now targets. If message was not supplied then this will be the object of a newly created message, otherwise this will be what was supplied as message . RAISES DESCRIPTION ValueError If the provided iterator didn't yield any content for the first message. remove_author # remove_author ( user ) Remove a author/owner from this handler. Note If the provided user isn't already a registered owner of this paginator then this should pass silently without raising. PARAMETER DESCRIPTION user The user to remove from this handler's owners. TYPE: hikari . SnowflakeishOr [ hikari . User ]","title":"yuyo.reactions"},{"location":"reference/reactions/#yuyoreactions","text":"Client for higher level callback based reaction menu handling.","title":"yuyo.reactions"},{"location":"reference/reactions/#yuyo.reactions.AbstractReactionHandler","text":"Bases: abc . ABC The interface for a reaction handler used with yuyo.reactions.ReactionClient .","title":"AbstractReactionHandler"},{"location":"reference/reactions/#yuyo.reactions.AbstractReactionHandler.close","text":"close () Close this handler.","title":"close()"},{"location":"reference/reactions/#yuyo.reactions.AbstractReactionHandler.has_expired","text":"has_expired () Whether this handler has ended.","title":"has_expired()"},{"location":"reference/reactions/#yuyo.reactions.AbstractReactionHandler.last_triggered","text":"last_triggered () When this handler was last triggered. Note If it hasn't ever been triggered then this will be when it was created.","title":"last_triggered()"},{"location":"reference/reactions/#yuyo.reactions.AbstractReactionHandler.on_reaction_event","text":"on_reaction_event ( event , / , * , alluka = None ) Handle a reaction event. PARAMETER DESCRIPTION event The event to handle. TYPE: EventT alluka The Alluka client to use for callback dependency injection during callback calls. TYPE: typing . Optional [ alluka_ . abc . Client ] DEFAULT: None RAISES DESCRIPTION HandlerClosed If this reaction handler has been closed.","title":"on_reaction_event()"},{"location":"reference/reactions/#yuyo.reactions.AbstractReactionHandler.open","text":"open ( message ) Open this handler. PARAMETER DESCRIPTION message The message to bind this handler to. TYPE: hikari . Message","title":"open()"},{"location":"reference/reactions/#yuyo.reactions.HandlerClosed","text":"Bases: Exception Error raised when a reaction handler has been closed.","title":"HandlerClosed"},{"location":"reference/reactions/#yuyo.reactions.ReactionClient","text":"A class which handles the events for multiple registered reaction handlers. Note For a quicker way to initialise this client from a bot, see yuyo.reactions.ReactionClient.from_gateway_bot .","title":"ReactionClient"},{"location":"reference/reactions/#yuyo.reactions.ReactionClient.__init__","text":"__init__ ( * , rest , event_manager , alluka = None , event_managed = True ) Initialise a reaction client. PARAMETER DESCRIPTION rest The REST client to register this reaction client with. TYPE: hikari . api . RESTClient event_manager The event manager client to register this reaction client with. TYPE: hikari . api . EventManager alluka The alluka client to use for callback DI. TYPE: typing . Optional [ alluka_ . abc . Client ] DEFAULT: None event_managed Whether the reaction client should be automatically opened and closed based on the lifetime events dispatched by event_managed . TYPE: bool DEFAULT: True","title":"__init__()"},{"location":"reference/reactions/#yuyo.reactions.ReactionClient.add_handler","text":"add_handler ( message , / , paginator ) Add a reaction handler to this reaction client. Note This does not call yuyo.reactions.AbstractReactionHandler.open . PARAMETER DESCRIPTION message The message ID to add register a reaction handler with. TYPE: hikari . SnowflakeishOr [ hikari . Message ] paginator The object of the opened paginator to register in this reaction client. TYPE: AbstractReactionHandler","title":"add_handler()"},{"location":"reference/reactions/#yuyo.reactions.ReactionClient.alluka","text":"alluka () The Alluka client being used for callback dependency injection.","title":"alluka()"},{"location":"reference/reactions/#yuyo.reactions.ReactionClient.close","text":"close () Close this client by unregistering any registered tasks and event listeners.","title":"close()"},{"location":"reference/reactions/#yuyo.reactions.ReactionClient.from_gateway_bot","text":"from_gateway_bot ( bot , / , * , event_managed = True ) Build a ReactionClient from a gateway bot. PARAMETER DESCRIPTION bot The bot to build a reaction client for. TYPE: traits . GatewayBotAware event_managed Whether the reaction client should be automatically opened and closed based on the lifetime events dispatched by bot . TYPE: bool DEFAULT: True RETURNS DESCRIPTION ReactionClient The reaction client for the bot.","title":"from_gateway_bot()"},{"location":"reference/reactions/#yuyo.reactions.ReactionClient.get_handler","text":"get_handler ( message ) Get a reference to a paginator registered in this reaction client. Note This does not call yuyo.reactions.AbstractReactionHandler.close . PARAMETER DESCRIPTION message The message ID to remove a paginator for. TYPE: hikari . SnowflakeishOr [ hikari . Message ] RETURNS DESCRIPTION AbstractReactionHandler | None The object of the registered paginator if found else None .","title":"get_handler()"},{"location":"reference/reactions/#yuyo.reactions.ReactionClient.is_closed","text":"is_closed () Whether this client is closed.","title":"is_closed()"},{"location":"reference/reactions/#yuyo.reactions.ReactionClient.open","text":"open () Start this client by registering the required tasks and event listeners for it to function.","title":"open()"},{"location":"reference/reactions/#yuyo.reactions.ReactionClient.remove_handler","text":"remove_handler ( message ) Remove a paginator from this reaction client. Note This does not call yuyo.reactions.AbstractReactionHandler.close . PARAMETER DESCRIPTION message The message ID to remove a paginator for. TYPE: hikari . SnowflakeishOr [ hikari . Message ] RETURNS DESCRIPTION AbstractReactionHandler | None The object of the registered paginator if found else None .","title":"remove_handler()"},{"location":"reference/reactions/#yuyo.reactions.ReactionHandler","text":"Bases: AbstractReactionHandler Standard basic implementation of a reaction handler.","title":"ReactionHandler"},{"location":"reference/reactions/#yuyo.reactions.ReactionHandler.__init__","text":"__init__ ( * , authors = (), timeout = datetime . timedelta ( seconds = 30 ), load_from_attributes = True ) Initialise a reaction handler. PARAMETER DESCRIPTION authors An iterable of IDs of the users who can call this paginator. If left empty then all users will be able to call this paginator. TYPE: typing . Iterable [ hikari . SnowflakeishOr [ hikari . User ]] DEFAULT: () timeout How long it should take for this paginator to timeout. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30)","title":"__init__()"},{"location":"reference/reactions/#yuyo.reactions.ReactionHandler.add_callback","text":"add_callback ( emoji_identifier , callback ) Add a callback to this reaction handler. PARAMETER DESCRIPTION emoji_identifier Identifier of the emoji this callback is for. This should be a snowfake if this is for a custom emoji or a string if this is for a unicode emoji. TYPE: typing . Union [ str , hikari . SnowflakeishOr [ hikari . CustomEmoji ]] callback The callback to add. This should be a function that accepts a single parameter, which is the event that triggered this reaction. TYPE: CallbackSig","title":"add_callback()"},{"location":"reference/reactions/#yuyo.reactions.ReactionHandler.authors","text":"authors () Set of the authors/owner of a enabled handler. Note If this is empty then the handler is considered public and any user will be able to trigger it.","title":"authors()"},{"location":"reference/reactions/#yuyo.reactions.ReactionHandler.remove_callback","text":"remove_callback ( emoji_identifier ) Remove a callback from this reaction handler. PARAMETER DESCRIPTION emoji_identifier Identifier of the emoji the callback to remove is for. This should be a snowfake if this is for a custom emoji or a string if this is for a unicode emoji. TYPE: typing . Union [ str , hikari . SnowflakeishOr [ hikari . CustomEmoji ]]","title":"remove_callback()"},{"location":"reference/reactions/#yuyo.reactions.ReactionHandler.timeout","text":"timeout () How long this handler will wait since the last event before timing out.","title":"timeout()"},{"location":"reference/reactions/#yuyo.reactions.ReactionHandler.with_callback","text":"with_callback ( emoji_identifier ) Add a callback to this reaction handler through a decorator call. PARAMETER DESCRIPTION emoji_identifier Identifier of the emoji this callback is for. This should be a snowfake if this is for a custom emoji or a string if this is for a unicode emoji. TYPE: typing . Union [ str , hikari . SnowflakeishOr [ hikari . CustomEmoji ]] RETURNS DESCRIPTION typing . Callabke [[ CallbackSigT ], CallbackSigT ] A decorator to add a callback to this reaction handler.","title":"with_callback()"},{"location":"reference/reactions/#yuyo.reactions.ReactionPaginator","text":"Bases: ReactionHandler Standard implementation of a reaction handler for pagination.","title":"ReactionPaginator"},{"location":"reference/reactions/#yuyo.reactions.ReactionPaginator.__init__","text":"__init__ ( iterator , * , authors , triggers = ( pagination . LEFT_TRIANGLE , pagination . STOP_SQUARE , pagination . RIGHT_TRIANGLE ), timeout = datetime . timedelta ( seconds = 30 )) Initialise a reaction paginator. PARAMETER DESCRIPTION iterator Either an asynchronous or synchronous iterator of the entries this should paginate through. entry[0] represents the message's possible content and can either be str or hikari.undefined.UNDEFINED and entry[1] represents the message's possible embed and can either be hikari.embeds.Embed or hikari.undefined.UNDEFINED . TYPE: typing . Iterator [ yuyo . pagination . EntryT ] | typing . AsyncIterator [ yuyo . pagination . EntryT ] authors An iterable of IDs of the users who can call this paginator. If left empty then all users will be able to call this paginator. TYPE: typing . Iterable [ hikari . SnowflakeishOr [ hikari . User ]] timeout How long it should take for this paginator to timeout. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30)","title":"__init__()"},{"location":"reference/reactions/#yuyo.reactions.ReactionPaginator.add_author","text":"add_author ( user ) Add a author/owner to this handler. PARAMETER DESCRIPTION user The user to add as an owner for this handler. TYPE: hikari . SnowflakeishOr [ hikari . User ]","title":"add_author()"},{"location":"reference/reactions/#yuyo.reactions.ReactionPaginator.close","text":"close ( * , remove_reactions = False , max_retries = 5 , max_backoff = 2.0 ) Close this handler and deregister any previously registered message. PARAMETER DESCRIPTION remove_reactions Whether this should remove the reactions that were being used to paginate through this from the previously registered message. TYPE: bool DEFAULT: False","title":"close()"},{"location":"reference/reactions/#yuyo.reactions.ReactionPaginator.create_message","text":"create_message ( rest , channel_id , / , * , add_reactions = True , max_retries = 5 , max_backoff = 2.0 ) Start this handler and link it to a bot message. Note Calling this multiple times will replace the previously registered message. PARAMETER DESCRIPTION rest Rest client to use to make the response. TYPE: hikari . api . RESTClient channel_id ID of the channel to respond in. TYPE: hikari . SnowflakeishOr [ hikari . TextableChannel ] add_reactions Whether this should add the paginator's reactions to the message after responding. TYPE: bool DEFAULT: True max_retries How many times this should retry to respond if Hikari raises any ratelimit errors. TYPE: int DEFAULT: 5 max_backoff The maximum time this should backoff for before trying if Hikari raises any ratelimit errors. TYPE: float DEFAULT: 2.0 RETURNS DESCRIPTION hikari . messages . Message Object of the message this handler now targets. If message was not supplied then this will be the object of a newly created message, otherwise this will be what was supplied as message . RAISES DESCRIPTION ValueError If the provided iterator didn't yield any content for the first message.","title":"create_message()"},{"location":"reference/reactions/#yuyo.reactions.ReactionPaginator.remove_author","text":"remove_author ( user ) Remove a author/owner from this handler. Note If the provided user isn't already a registered owner of this paginator then this should pass silently without raising. PARAMETER DESCRIPTION user The user to remove from this handler's owners. TYPE: hikari . SnowflakeishOr [ hikari . User ]","title":"remove_author()"}]}