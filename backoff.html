<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>yuyo.backoff API documentation</title>
<meta name="description" content="Utility used for handling automatic back-off â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>yuyo.backoff</code></h1>
</header>
<section id="section-intro">
<p>Utility used for handling automatic back-off.</p>
<p>This can be used to cover cases such as hitting rate-limits and failed requests.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
# cython: language_level=3
# BSD 3-Clause License
#
# Copyright (c) 2020, Faster Speeding
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of the copyright holder nor the names of its
#   contributors may be used to endorse or promote products derived from
#   this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &#34;AS IS&#34;
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
&#34;&#34;&#34;Utility used for handling automatic back-off.

This can be used to cover cases such as hitting rate-limits and failed requests.
&#34;&#34;&#34;

from __future__ import annotations

__all__: typing.Sequence[str] = [&#34;Backoff&#34;]

import asyncio
import typing

from hikari.impl import rate_limits


class Backoff:
    &#34;&#34;&#34;Used to exponentially backoff asynchronously.

    This class acts as an asynchronous iterator and can be iterated over to
    provide implicit backoff where for every iteration other than the first
    this will either back off for the time passed to `Backoff.set_next_backoff`
    if applicable or a time calculated exponentially.

    Parameters
    ----------
    base : builtins.float
        The base to use. Defaults to `2.0`.
    maximum : builtins.float
        The max value the backoff can be in a single iteration. Anything above
        this will be capped to this base value plus random jitter.
    jitter_multiplier : builtins.float
        The multiplier for the random jitter. Defaults to `1.0`.
        Set to `0` to disable jitter.
    initial_increment : builtins.int
        The initial increment to start at. Defaults to `0`.

    Raises
    ------
    ValueError
        If an `builtins.int` that&#39;s too big to be represented as a
        `builtins.float` or a non-finite value is passed in place of a field
        that&#39;s annotated as `builtins.float`.

    Examples
    --------
    An example of using this class as an asynchronous iterator may look like
    the following

    ```py
    # While we can directly do `async for _ in Backoff()`, by assigning it to a
    # variable we allow ourself to provide a specific backoff time in some cases.
    backoff = Backoff()
    async for _ in backoff:
        try:
            message = await bot.rest.fetch_message(channel_id, message_id)
        except errors.RateLimitedError as exc:
            # If we have a specific backoff time then set it for the next iteration
            backoff.set_next_backoff(exc.retry_after)
        except errors.InternalServerError:
            # Else let the iterator calculate an exponential backoff before the next loop.
            pass
        else:
            # We need to break out of the iterator to make sure it doesn&#39;t backoff again.
            # Alternatively `Backoff.finish()` can be called to break out of the loop.
            break
    ```

    Alternatively you may want to explicitly call `Backoff.backoff`, a
    alternative of the previous example which uses `Backoff.backoff` may
    look like the following

    ```py
    backoff = Backoff()
    message: typing.Optional[messages.Message] = None
    while not message:
        try:
            message = await bot.rest.fetch_message(channel_id, message_id)
        except errors.RateLimitedError as exc:
            # If we have a specific backoff time then set it for the next iteration
            await backoff.backoff(exc.retry_after)
        except errors.InternalServerError:
            # Else let the iterator calculate an exponential backoff before the next loop.
            await backoff.backoff()
    ```
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (&#34;_backoff&#34;, &#34;_finished&#34;, &#34;_next_backoff&#34;, &#34;_started&#34;)

    def __init__(
        self, base: float = 2.0, maximum: float = 64.0, jitter_multiplier: float = 1.0, initial_increment: int = 0
    ) -&gt; None:
        self._backoff = rate_limits.ExponentialBackOff(
            base=base, maximum=maximum, jitter_multiplier=jitter_multiplier, initial_increment=initial_increment
        )
        self._finished = False
        self._next_backoff: typing.Optional[float] = None
        self._started = False

    def __aiter__(self) -&gt; Backoff:
        return self

    async def __anext__(self) -&gt; None:
        if self._finished:
            raise StopAsyncIteration

        # We don&#39;t want to backoff on the first iteration.
        if not self._started:
            self._started = True
            return

        backoff_: float
        if self._next_backoff is None:
            backoff_ = next(self._backoff)
        else:
            backoff_ = self._next_backoff
            self._next_backoff = None

        await asyncio.sleep(backoff_)

    async def backoff(self, backoff_: typing.Optional[float], /) -&gt; None:
        &#34;&#34;&#34;Sleep for the provided backoff or for the next exponent.

        This provides an alternative to iterating over this class.

        Parameters
        ----------
        backoff_ : typing.Optional[float]
            The time this should backoff for. If left as `builtins.None` then
            this will back off for the last time provided with
            `Backoff.set_next_backoff` if available or the next exponential time.
        &#34;&#34;&#34;
        self._started = True
        if backoff_ is None and self._next_backoff is not None:
            backoff_ = self._next_backoff
            self._next_backoff = None

        elif backoff_ is None:
            backoff_ = next(self._backoff)

        await asyncio.sleep(backoff_)

    def finish(self) -&gt; None:
        &#34;&#34;&#34;Mark the iterator as finished to break out of the loop.&#34;&#34;&#34;
        self._finished = True

    def reset(self) -&gt; None:
        &#34;&#34;&#34;Reset the backoff to it&#39;s original exponent to reuse it.&#34;&#34;&#34;
        self._backoff.reset()
        self._finished = False
        self._next_backoff = None
        self._started = False

    def set_next_backoff(self, backoff_: float, /) -&gt; None:
        &#34;&#34;&#34;Specify a backoff time for the next iteration or `Backoff.backoff` call.

        If this is called then the exponent won&#39;t be increased for this iteration.

        !!! note
            Calling this multiple times in a single iteration will overwrite any
            previously set next backoff.
        &#34;&#34;&#34;
        self._next_backoff = backoff_</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="yuyo.backoff.Backoff"><code class="flex name class">
<span>class <span class="ident">Backoff</span></span>
<span>(</span><span>base:Â floatÂ =Â 2.0, maximum:Â floatÂ =Â 64.0, jitter_multiplier:Â floatÂ =Â 1.0, initial_increment:Â intÂ =Â 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Used to exponentially backoff asynchronously.</p>
<p>This class acts as an asynchronous iterator and can be iterated over to
provide implicit backoff where for every iteration other than the first
this will either back off for the time passed to <code><a title="yuyo.backoff.Backoff.set_next_backoff" href="#yuyo.backoff.Backoff.set_next_backoff">Backoff.set_next_backoff()</a></code>
if applicable or a time calculated exponentially.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>base</code></strong> :&ensp;<code>builtins.float</code></dt>
<dd>The base to use. Defaults to <code>2.0</code>.</dd>
<dt><strong><code>maximum</code></strong> :&ensp;<code>builtins.float</code></dt>
<dd>The max value the backoff can be in a single iteration. Anything above
this will be capped to this base value plus random jitter.</dd>
<dt><strong><code>jitter_multiplier</code></strong> :&ensp;<code>builtins.float</code></dt>
<dd>The multiplier for the random jitter. Defaults to <code>1.0</code>.
Set to <code>0</code> to disable jitter.</dd>
<dt><strong><code>initial_increment</code></strong> :&ensp;<code>builtins.int</code></dt>
<dd>The initial increment to start at. Defaults to <code>0</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If an <code>builtins.int</code> that's too big to be represented as a
<code>builtins.float</code> or a non-finite value is passed in place of a field
that's annotated as <code>builtins.float</code>.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>An example of using this class as an asynchronous iterator may look like
the following</p>
<pre><code class="language-py"># While we can directly do `async for _ in Backoff()`, by assigning it to a
# variable we allow ourself to provide a specific backoff time in some cases.
backoff = Backoff()
async for _ in backoff:
    try:
        message = await bot.rest.fetch_message(channel_id, message_id)
    except errors.RateLimitedError as exc:
        # If we have a specific backoff time then set it for the next iteration
        backoff.set_next_backoff(exc.retry_after)
    except errors.InternalServerError:
        # Else let the iterator calculate an exponential backoff before the next loop.
        pass
    else:
        # We need to break out of the iterator to make sure it doesn't backoff again.
        # Alternatively `Backoff.finish()` can be called to break out of the loop.
        break
</code></pre>
<p>Alternatively you may want to explicitly call <code><a title="yuyo.backoff.Backoff.backoff" href="#yuyo.backoff.Backoff.backoff">Backoff.backoff()</a></code>, a
alternative of the previous example which uses <code><a title="yuyo.backoff.Backoff.backoff" href="#yuyo.backoff.Backoff.backoff">Backoff.backoff()</a></code> may
look like the following</p>
<pre><code class="language-py">backoff = Backoff()
message: typing.Optional[messages.Message] = None
while not message:
    try:
        message = await bot.rest.fetch_message(channel_id, message_id)
    except errors.RateLimitedError as exc:
        # If we have a specific backoff time then set it for the next iteration
        await backoff.backoff(exc.retry_after)
    except errors.InternalServerError:
        # Else let the iterator calculate an exponential backoff before the next loop.
        await backoff.backoff()
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Backoff:
    &#34;&#34;&#34;Used to exponentially backoff asynchronously.

    This class acts as an asynchronous iterator and can be iterated over to
    provide implicit backoff where for every iteration other than the first
    this will either back off for the time passed to `Backoff.set_next_backoff`
    if applicable or a time calculated exponentially.

    Parameters
    ----------
    base : builtins.float
        The base to use. Defaults to `2.0`.
    maximum : builtins.float
        The max value the backoff can be in a single iteration. Anything above
        this will be capped to this base value plus random jitter.
    jitter_multiplier : builtins.float
        The multiplier for the random jitter. Defaults to `1.0`.
        Set to `0` to disable jitter.
    initial_increment : builtins.int
        The initial increment to start at. Defaults to `0`.

    Raises
    ------
    ValueError
        If an `builtins.int` that&#39;s too big to be represented as a
        `builtins.float` or a non-finite value is passed in place of a field
        that&#39;s annotated as `builtins.float`.

    Examples
    --------
    An example of using this class as an asynchronous iterator may look like
    the following

    ```py
    # While we can directly do `async for _ in Backoff()`, by assigning it to a
    # variable we allow ourself to provide a specific backoff time in some cases.
    backoff = Backoff()
    async for _ in backoff:
        try:
            message = await bot.rest.fetch_message(channel_id, message_id)
        except errors.RateLimitedError as exc:
            # If we have a specific backoff time then set it for the next iteration
            backoff.set_next_backoff(exc.retry_after)
        except errors.InternalServerError:
            # Else let the iterator calculate an exponential backoff before the next loop.
            pass
        else:
            # We need to break out of the iterator to make sure it doesn&#39;t backoff again.
            # Alternatively `Backoff.finish()` can be called to break out of the loop.
            break
    ```

    Alternatively you may want to explicitly call `Backoff.backoff`, a
    alternative of the previous example which uses `Backoff.backoff` may
    look like the following

    ```py
    backoff = Backoff()
    message: typing.Optional[messages.Message] = None
    while not message:
        try:
            message = await bot.rest.fetch_message(channel_id, message_id)
        except errors.RateLimitedError as exc:
            # If we have a specific backoff time then set it for the next iteration
            await backoff.backoff(exc.retry_after)
        except errors.InternalServerError:
            # Else let the iterator calculate an exponential backoff before the next loop.
            await backoff.backoff()
    ```
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (&#34;_backoff&#34;, &#34;_finished&#34;, &#34;_next_backoff&#34;, &#34;_started&#34;)

    def __init__(
        self, base: float = 2.0, maximum: float = 64.0, jitter_multiplier: float = 1.0, initial_increment: int = 0
    ) -&gt; None:
        self._backoff = rate_limits.ExponentialBackOff(
            base=base, maximum=maximum, jitter_multiplier=jitter_multiplier, initial_increment=initial_increment
        )
        self._finished = False
        self._next_backoff: typing.Optional[float] = None
        self._started = False

    def __aiter__(self) -&gt; Backoff:
        return self

    async def __anext__(self) -&gt; None:
        if self._finished:
            raise StopAsyncIteration

        # We don&#39;t want to backoff on the first iteration.
        if not self._started:
            self._started = True
            return

        backoff_: float
        if self._next_backoff is None:
            backoff_ = next(self._backoff)
        else:
            backoff_ = self._next_backoff
            self._next_backoff = None

        await asyncio.sleep(backoff_)

    async def backoff(self, backoff_: typing.Optional[float], /) -&gt; None:
        &#34;&#34;&#34;Sleep for the provided backoff or for the next exponent.

        This provides an alternative to iterating over this class.

        Parameters
        ----------
        backoff_ : typing.Optional[float]
            The time this should backoff for. If left as `builtins.None` then
            this will back off for the last time provided with
            `Backoff.set_next_backoff` if available or the next exponential time.
        &#34;&#34;&#34;
        self._started = True
        if backoff_ is None and self._next_backoff is not None:
            backoff_ = self._next_backoff
            self._next_backoff = None

        elif backoff_ is None:
            backoff_ = next(self._backoff)

        await asyncio.sleep(backoff_)

    def finish(self) -&gt; None:
        &#34;&#34;&#34;Mark the iterator as finished to break out of the loop.&#34;&#34;&#34;
        self._finished = True

    def reset(self) -&gt; None:
        &#34;&#34;&#34;Reset the backoff to it&#39;s original exponent to reuse it.&#34;&#34;&#34;
        self._backoff.reset()
        self._finished = False
        self._next_backoff = None
        self._started = False

    def set_next_backoff(self, backoff_: float, /) -&gt; None:
        &#34;&#34;&#34;Specify a backoff time for the next iteration or `Backoff.backoff` call.

        If this is called then the exponent won&#39;t be increased for this iteration.

        !!! note
            Calling this multiple times in a single iteration will overwrite any
            previously set next backoff.
        &#34;&#34;&#34;
        self._next_backoff = backoff_</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="yuyo.backoff.Backoff.backoff"><code class="name flex">
<span>async def <span class="ident">backoff</span></span>(<span>self, backoff_:Â typing.Optional[float], /) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Sleep for the provided backoff or for the next exponent.</p>
<p>This provides an alternative to iterating over this class.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>backoff_</code></strong> :&ensp;<code>typing.Optional[float]</code></dt>
<dd>The time this should backoff for. If left as <code>builtins.None</code> then
this will back off for the last time provided with
<code><a title="yuyo.backoff.Backoff.set_next_backoff" href="#yuyo.backoff.Backoff.set_next_backoff">Backoff.set_next_backoff()</a></code> if available or the next exponential time.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def backoff(self, backoff_: typing.Optional[float], /) -&gt; None:
    &#34;&#34;&#34;Sleep for the provided backoff or for the next exponent.

    This provides an alternative to iterating over this class.

    Parameters
    ----------
    backoff_ : typing.Optional[float]
        The time this should backoff for. If left as `builtins.None` then
        this will back off for the last time provided with
        `Backoff.set_next_backoff` if available or the next exponential time.
    &#34;&#34;&#34;
    self._started = True
    if backoff_ is None and self._next_backoff is not None:
        backoff_ = self._next_backoff
        self._next_backoff = None

    elif backoff_ is None:
        backoff_ = next(self._backoff)

    await asyncio.sleep(backoff_)</code></pre>
</details>
</dd>
<dt id="yuyo.backoff.Backoff.finish"><code class="name flex">
<span>def <span class="ident">finish</span></span>(<span>self) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Mark the iterator as finished to break out of the loop.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def finish(self) -&gt; None:
    &#34;&#34;&#34;Mark the iterator as finished to break out of the loop.&#34;&#34;&#34;
    self._finished = True</code></pre>
</details>
</dd>
<dt id="yuyo.backoff.Backoff.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Reset the backoff to it's original exponent to reuse it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self) -&gt; None:
    &#34;&#34;&#34;Reset the backoff to it&#39;s original exponent to reuse it.&#34;&#34;&#34;
    self._backoff.reset()
    self._finished = False
    self._next_backoff = None
    self._started = False</code></pre>
</details>
</dd>
<dt id="yuyo.backoff.Backoff.set_next_backoff"><code class="name flex">
<span>def <span class="ident">set_next_backoff</span></span>(<span>self, backoff_:Â float, /) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Specify a backoff time for the next iteration or <code><a title="yuyo.backoff.Backoff.backoff" href="#yuyo.backoff.Backoff.backoff">Backoff.backoff()</a></code> call.</p>
<p>If this is called then the exponent won't be increased for this iteration.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calling this multiple times in a single iteration will overwrite any
previously set next backoff.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_next_backoff(self, backoff_: float, /) -&gt; None:
    &#34;&#34;&#34;Specify a backoff time for the next iteration or `Backoff.backoff` call.

    If this is called then the exponent won&#39;t be increased for this iteration.

    !!! note
        Calling this multiple times in a single iteration will overwrite any
        previously set next backoff.
    &#34;&#34;&#34;
    self._next_backoff = backoff_</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="yuyo" href="index.html">yuyo</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="yuyo.backoff.Backoff" href="#yuyo.backoff.Backoff">Backoff</a></code></h4>
<ul class="">
<li><code><a title="yuyo.backoff.Backoff.backoff" href="#yuyo.backoff.Backoff.backoff">backoff</a></code></li>
<li><code><a title="yuyo.backoff.Backoff.finish" href="#yuyo.backoff.Backoff.finish">finish</a></code></li>
<li><code><a title="yuyo.backoff.Backoff.reset" href="#yuyo.backoff.Backoff.reset">reset</a></code></li>
<li><code><a title="yuyo.backoff.Backoff.set_next_backoff" href="#yuyo.backoff.Backoff.set_next_backoff">set_next_backoff</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>