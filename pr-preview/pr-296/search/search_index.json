{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Yuyo","text":"<p>A collection of utility classes and functions designed to expand Hikari.</p>"},{"location":"#instillation","title":"Instillation","text":"<p>You can install yuyo from PyPI using the following command.</p> <pre><code>python -m pip install -U hikari-yuyo\n</code></pre> <p>The following feature flags ensure feature-specific optional dependencies are also installed:</p> <ul> <li><code>hikari-yuyo[asgi]</code> ensures the dependencies required to run the Asgi RESTBot adapter.</li> <li><code>hikari-yuyo[sake]</code> can be used to ensure the installed Sake version is compatible with   Yuyo's functionality which uses Sake. You should still have a Sake version pinned in your   own requirements as this just provides an accepted range for the dependency.</li> <li><code>hikari-yuyo[tanjun]</code> can be used to ensure the installed Tanjun version is compatible with   Yuyo's Tanjun support (e.g. the <code>from_tanjun</code>) class methods.</li> </ul>"},{"location":"#quick-usage","title":"Quick Usage.","text":"<p>For usage see the the documentation and, more specifically, the usage guide.</p>"},{"location":"#support","title":"Support","text":"<p>Hikari's support guild provides for support for Yuyo.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Before contributing you should read through the contributing guidelines and the code of conduct.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Support for parsing message links to yuyo.links.</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Added support for <code>ptb.</code> and <code>canary.</code> links to yuyo.links.</li> <li>Modals now default the per-field custom IDs (i.e. for text components) to the parameter's   name (attribute name for ModalOptions fields), if set.</li> <li>Renamed the link get and fetch methods:<ul> <li><code>InviteLink.fetch</code> to InviteLink.fetch_invite</li> <li><code>InviteLink.get</code> to InviteLink.get_invite</li> <li><code>MessageLink.fetch</code> to MessageLink.fetch_message</li> <li><code>MessageLink.get</code> to MessageLink.get_message</li> <li><code>TemplateLink.fetch</code> to TemplateLink.fetch_template</li> <li><code>WebhookLink.fetch</code> to WebhookLink.fetch_webhook</li> </ul> </li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>ModalOptions attributes now correctly expose the values passed to   the modal rather internal descriptors.</li> </ul>"},{"location":"changelog/#1111a1-2023-04-05","title":"1.11.1a1 - 2023-04-05","text":""},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li><code>callback</code> and <code>type</code> have been flipped (making <code>type</code> the first argument and <code>callback</code>    the second one) for the following functions:<ul> <li>ActionRowExecutor.add_select_menu</li> <li>ActionColumnExecutor.add_select_menu</li> <li>ActionColumnExecutor.add_static_select_menu</li> <li>with_static_select_menu</li> </ul> </li> <li>Renamed the component context select menu data properties:<ul> <li><code>ComponentContext.select_channels</code> to ComponentContext.selected_channels</li> <li><code>ComponentContext.select_roles</code> to ComponentContext.selected_roles</li> <li><code>ComponentContext.select_texts</code> to ComponentContext.selected_texts</li> <li><code>ComponentContext.select_users</code> to ComponentContext.selected_users</li> <li><code>ComponentContext.select_members</code> to ComponentContext.selected_members</li> </ul> </li> </ul>"},{"location":"changelog/#deprecated","title":"Deprecated","text":"<ul> <li>Passing <code>callback</code> as the first argument when adding a select menu to a component executor or column.</li> <li>The <code>with_{}</code> methods on yuyo.components.ActionColumnExecutor.</li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>yuyo.modals.modal and yuyo.modals.as_modal both now properly support DI for the   modal's callback.</li> <li>yuyo.modals.as_modal and yuyo.modals.as_modal_template both now allow passing   <code>parse_signature</code> typing wise.</li> </ul>"},{"location":"changelog/#1110a1-2023-04-02","title":"1.11.0a1 - 2023-04-02","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>A static timeout implementation.</li> <li>Support for custom ID prefix matching to the Message component executors.</li> <li>Message components have support for loading components from class attributes again.   Support for this has been implemented through yuyo.components.ActionColumnExecutor this time.</li> <li>yuyo.components.SingleExecutor and yuyo.components.as_single_executor   to allow registering a component executor with a single callback.</li> <li>New component handling system to the component client which allows component executors to be   used statelessly. This moves to using the classes in yuyo.timeouts to handle timeouts   (rather than the component executors) and makes binding to a specific message optional.   This consists of ComponentClient.register_executor   and ComponentClient.deregister_executor.</li> <li>yuyo.components.with_static_text_menu decorator for declaring a static text select menu on   a ActionColumnExecutor subclass.</li> <li><code>options</code> parameter to ActionColumnExecutor.add_static_text_select,   ActionColumnExecutor.add_text_select, and   ActionRowExecutor.add_text_select for   passing option builders.</li> <li><code>ComponentContext.id_match</code> and <code>ModalContext.id_metadata</code> convenient properties for getting   the matching and metadata parts of the component's custom ID.</li> <li><code>Modal.id_match</code>, <code>Modal.id_metadata</code> and ModalContext.component_ids   convenience properties for getting the matching and metadata parts of the Modal's top-level   custom ID and the sub-component custom IDs.</li> <li>ComponentExecutor.set_callback and   ComponentExecutor.with_callback now   both raise ValueError if <code>\":\"</code> is present in <code>custom_id</code>.</li> <li><code>id_metadata</code> option to   ActionColumnExecutor.__init__ and   Modal.__init__ to allow for setting the   ID metadata of components per-init.</li> </ul>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Bumped the minimum Hikari version to <code>2.0.0.dev118</code>.   Some of the breaking component changes listed in Hikari's   change log   around the component builders effect Yuyo's component executors.</li> <li>Prefix matching behaviour is now always enabled for both modals and components.</li> <li>Message components now split by <code>\":\"</code> for prefix matching like the modals client.</li> <li>Marked most deprecated timeout class aliases using <code>typing.deprecated</code>.   (only <code>yuyo.modals.AbstractTimeout</code> was skipped).</li> <li>yuyo.components.WaitForExecutor now inherits from yuyo.components.WaitForExecutor   and should also be passed to <code>timeout=</code>.</li> <li>ActionColumnExecutor.rows now returns   hikari.api.MessageActionRowBuilder.</li> <li>Message components will now give a \"timed-out\" ephemeral initial response when   ExecutorClosed is raised without any response.</li> <li>The <code>authors</code> field is now optional (defaulting to public) for   WaitForExecutor.__init__,   ComponentPaginator.__init__, and   ReactionPaginator.__init__.</li> <li>Renamed <code>yuyo.timeouts.BasicTimeout</code> to yuyo.timeouts.SlidingTimeout.</li> <li>Renamed <code>ModalClient.set_modal</code> to Modal.register_modal.</li> <li>Renamed <code>ModalClient.remove_modal</code> to Modal.deregister_modal.</li> <li>Renamed <code>ComponentClient.get_executor</code> to ComponentClient.get_executor_for_message.</li> <li>Renamed <code>ComponentClient.remove_executor</code> to ComponentClient.deregister_message.</li> <li>Renamed <code>add_</code> and <code>with_</code> component methods to better match Hikari's new naming scheme:<ul> <li><code>ActionRowExecutor.add_button</code> to <code>.add_interative_button</code></li> <li><code>ActionRowExecutor.add_channel_select</code> to <code>.add_channel_menu</code></li> <li><code>ActionRowExecutor.add_text_select</code> to <code>.add_text_menu</code></li> <li><code>ActionColumnExecutor.add_button</code> to <code>.add_interative_button</code></li> <li><code>ActionColumnExecutor.add_channel_select</code> to <code>.add_channel_menu</code></li> <li><code>ActionColumnExecutor.add_text_select</code> to <code>.add_text_menu</code></li> <li><code>ActionColumnExecutor.add_static_button</code> to <code>.add_static_interactive_button</code></li> <li><code>ActionColumnExecutor.with_static_button</code> to <code>.with_static_interactive_button</code></li> <li><code>ActionColumnExecutor.add_static_channel_select</code> to <code>.add_static_channel_menu</code></li> <li><code>ActionColumnExecutor.with_static_channel_select</code> to <code>.with_static_channel_menu</code></li> <li><code>ActionColumnExecutor.add_static_text_select</code> to <code>.add_static_text_menu</code></li> <li><code>yuyo.components.with_static_button</code> to <code>.with_static_interactive_button</code></li> <li><code>yuyo.components.with_static_channel_select</code> to <code>.with_static_channel_menu</code></li> </ul> </li> </ul>"},{"location":"changelog/#deprecated_1","title":"Deprecated","text":"<ul> <li>The constant ID component handling system.   This has been replaced with passing yuyo.components.SingleExecutor to   ComponentClient.register_executor.</li> <li>Passing <code>timeout</code> to ComponentExecutor.__init__,   ActionRowExecutor.__init__,   ActionColumnExecutor.__init__, and   ComponentPaginator.__init__.   This has been replaced by passing <code>timeout</code> to   ComponentClient.register_executor   to allow for the stateless reuse of component executors.</li> <li><code>AbstractComponentExecutor.has_expired</code>.</li> <li><code>ActionRowExecutor.is_full</code>.</li> <li>ComponentClient.set_executor,   this has been replaced by Component.register_executor.</li> <li>Passing yuyo.components.ActionRowExecutor to   ActionColumnExecutor.add_row. This   now takes hikari.api.MessageActionRowBuilder.</li> <li>The <code>prefix_match</code> parameter as this is now always enabled.</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li><code>yuyo.modals.NoDefault</code>.</li> </ul>"},{"location":"changelog/#1101a1-2023-03-25","title":"1.10.1a1 - 2023-03-25","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Some convenience properties to ComponentContext for getting select   menu values:<ul> <li>.select_channels</li> <li>.select_roles</li> <li>.select_texts</li> <li>.select_users</li> <li>.select_members</li> </ul> </li> <li>The yuyo.components.Context and yuyo.modals.Context aliases.</li> <li>The yuyo.components.Client, yuyo.modals.Client, and yuyo.reactions.Client aliases.</li> </ul>"},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>A Modal text input's <code>default</code> will now also be used for <code>value</code> when <code>value</code> is left undefined and   <code>default</code> is a string of <code>&lt;=4000</code> characters.</li> <li>Increased the default timeout for modals to 2 minutes.</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Text select menus will no-longer lead to an error being returned by Discord when <code>max_values</code> is   greater then the count of its choices.</li> </ul>"},{"location":"changelog/#1100a1-2023-03-20","title":"1.10.0a1 - 2023-03-20","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Support for declaring modal options in the modal callback's signature.</li> </ul>"},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>Moved <code>yuyo.modals.AbstractTimeout</code>, <code>yuyo.modals.BasicTimeout</code> and <code>yuyo.modals.NeverTimeout</code>   to new yuyo.timeouts module.</li> </ul>"},{"location":"changelog/#deprecated_2","title":"Deprecated","text":"<ul> <li><code>yuyo.modals.AbstractTimeout</code>, <code>yuyo.modals.BasicTimeout</code> and <code>yuyo.modals.NeverTimeout</code> as deprecated aliases</li> </ul>"},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>Modals now correctly default to a timeout duration of 10 seconds rather than 10 days.</li> </ul>"},{"location":"changelog/#removed_1","title":"Removed","text":"<ul> <li>The deprecated <code>yuyo.components.MultiComponentExecutor</code> and <code>yuyo.components.ChildActionRowExecutor</code>   types.</li> <li>ActionRowExecutor.add_button can no-longer be used   to add link buttons.</li> <li>yuyo.modals.Modal subclasses will no-longer inherits fields.</li> </ul>"},{"location":"changelog/#191a1-2023-03-07","title":"1.9.1a1 - 2023-03-07","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Re-exposed <code>yuyo.reactions.EventT</code> as yuyo.reactions.ReactionEventT.</li> </ul>"},{"location":"changelog/#changed_5","title":"Changed","text":"<ul> <li><code>token_type</code> now defaults to <code>\"Bot\"</code> when a string token is passed for   AsgiBot.__init__.</li> </ul>"},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li>yuyo.modals.modal and yuyo.modals.as_modal no-longer lead to Alluka's type-hint introspection   raising an exception.</li> <li>Handling of defaulting empty modal text inputs.</li> <li>Add <code>type</code> property to yuyo.components.ActionRowExecutor and   <code>yuyo.components.ChildActionRowExecutor</code> to fix compatibility with <code>Hikari&gt;=2.0.0.dev117</code>.</li> </ul>"},{"location":"changelog/#190a1-2023-02-27","title":"1.9.0a1 - 2023-02-27","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li><code>from_tanjun</code> convenience classmethods for initialising from a Tanjun client to   ComponentClient, ModalClient,   ReactionClient, and ServiceManager.</li> <li><code>alluka</code> keyword-argument to to <code>from_gateway_bot</code> and <code>from_rest_bot</code> methods on   ComponentClient, ModalClient, and   ReactionClient.</li> </ul>"},{"location":"changelog/#changed_6","title":"Changed","text":"<ul> <li><code>timeout</code> is now keyword-only for ChunkTracker.__init__.</li> <li>The Alluka bound clients (ComponentClient,   ModalClient, and ReactionClient)   now all register themselves as type dependencies when they're not passed a 3rd party client.</li> </ul>"},{"location":"changelog/#fixed_5","title":"Fixed","text":"<ul> <li>Prefix matched custom IDs are now correctly lower priority for modals.</li> <li>AsgiBot.remove_shutdown_callback and   AsgiBot.remove_startup_callback now raise a ValueError   if the callback isn't registered (as per the documented behaviour) instead of silently passing.</li> </ul>"},{"location":"changelog/#removed_2","title":"Removed","text":"<ul> <li>Unnecessary entries from module <code>__all__</code>s (i.e. type hints, abstract classes, base classes and   internal signal error classes).</li> <li>Type variables are no-longer publicly exposed other than a couple callback types.</li> </ul>"},{"location":"changelog/#180a1post1-2023-02-23","title":"1.8.0a1.post1 - 2023-02-23","text":""},{"location":"changelog/#fixed_6","title":"Fixed","text":"<ul> <li>The yuyo.components.ComponentPaginator will no-longer send a new message with \"MESSAGE_UPDATE\" as   the content when the last entry button is pressed for the first time instead of marking it as loading.</li> <li>The yuyo.components.ComponentPaginator will no-longer create a new message with \"MESSAGE_UPDATE\"   as the content instead of giving a noop update response.</li> </ul>"},{"location":"changelog/#180a1-2023-02-23","title":"1.8.0a1 - 2023-02-23","text":""},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li><code>timeout</code> config to ChunkTracker.__init__.</li> <li><code>bot_managed</code> config to ComponentClient.from_rest_bot.</li> <li>ComponentContext.create_modal_response method.</li> <li>Support for modals in <code>yuyo.modals</code>.</li> <li>yuyo.components.ActionColumnExecutor which handles building and executing multiple message   action row components and also introduces a class template system for message components in a similar   fashion to modals.</li> </ul>"},{"location":"changelog/#changed_7","title":"Changed","text":"<ul> <li>The <code>response_type</code> argument is now keyword only and defaults to   ResponseType.MESSAGE_CREATE in   ComponentContext.create_initial_response.</li> <li>The <code>defer_type</code> argument is now keyword only and defaults to   ResponseType.DEFERRED_MESSAGE_CREATE   in ComponentContext.defer.</li> </ul>"},{"location":"changelog/#deprecated_3","title":"Deprecated","text":"<ul> <li><code>yuyo.components.MultiComponentExecutor</code> and <code>yuyo.components.ChildActionRowExecutor</code>.   yuyo.components.ActionColumnExecutor should be used instead.</li> <li>Using ActionRowExecutor.add_button to add   specifically link buttons. ActionRowExecutor.add_link_button   should be used instead.</li> </ul>"},{"location":"changelog/#fixed_7","title":"Fixed","text":"<ul> <li>The <code>add_{}_button</code> methods on ComponentPaginator now ignore   <code>emoji</code> when <code>label</code> is passed to avoid erroring when users don't explicitly unset the   default for <code>emoji</code>.</li> </ul>"},{"location":"changelog/#removed_3","title":"Removed","text":"<ul> <li>The <code>AbstractReactionHandler.last_triggered</code> and <code>ReactionHandler.timeout</code> properties as   these were leaking impl detail.</li> </ul>"},{"location":"changelog/#170a1-2023-02-14","title":"1.7.0a1 - 2023-02-14","text":""},{"location":"changelog/#added_7","title":"Added","text":"<ul> <li>Support for the new select menu types to <code>yuyo.to_builder</code>.</li> <li>ActionRowExecutor.add_channel_select   for adding channel select menus to an action row.</li> <li>ActionRowExecutor.add_select_menu for   adding the other new select menu types to an action row.</li> <li>yuyo.pagination.Page type which can be used to represent a response page in the paginators.   This allows configuring attachments and multiple embeds for a page.</li> <li>Methods for manually setting the buttons for yuyo.components.ComponentPaginator and   yuyo.reactions.ReactionPaginator which allow manually overriding the config for each button   or reaction.</li> </ul>"},{"location":"changelog/#changed_8","title":"Changed","text":"<ul> <li><code>from_gateway_bot</code> classmethods can now also take cache-less <code>ShardAware</code> bots.</li> <li>Bumped minimum Hikari version to <code>2.0.0.dev116</code>.</li> <li>Renamed <code>ErrorManager.with_rule</code> to ErrorManager.add_rule   and made its arguments positional only.</li> <li>The <code>guild</code> argument for yuyo.chunk_tracker.ChunkTracker.request_guild_members is now   positional only.</li> <li><code>iterator</code> is now positional only in   ReactionPaginator.__init__ and   ComponentPaginator.__init__.</li> <li><code>lines</code> is now positional only in yuyo.pagination.async_paginate_string,   yuyo.pagination.sync_paginate_string and yuyo.pagination.paginate_string.</li> <li>Renamed <code>add_callback</code> to <code>set_callback</code> on <code>ComponentExecutor</code> and <code>ReactionHandler</code>.</li> <li>ActionRowExecutor.add_button now takes all   the button's options as arguments.   This also now returns the action row and adds the button to the row immediately (without   any calls to <code>add_to_parent</code>).</li> <li>Renamed the old <code>ActionRowExecutor.add_select_menu</code> to   ActionRowExecutor.add_text_select   and added the other select menu's config as keyword-arguments.</li> <li>Renamed <code>add_handler</code> to ReactionClient.set_handler.</li> <li>ReactionClient.set_handler's arguments are now all   positional-only.</li> <li>ComponentPaginator.get_next_entry and   ReactionPaginator.get_next_entry now both   return yuyo.pagination.Page rather than a tuple.   This can be used to create a response easily by passing the result of   Page.to_kwargs to the create message or execute webhook REST method as <code>**kwargs</code>.</li> </ul>"},{"location":"changelog/#fixed_8","title":"Fixed","text":"<ul> <li><code>Context.create_initial_response</code> (and by extension <code>Context.respond</code> for the initial   response specifically) will no-longer try to pass the attachment, component or embed as   the actual message content when passed for the <code>content</code> argument for REST-based   interaction commands.</li> <li><code>BLACK_CROSS</code> can now be passed to   ComponentPaginator.__init__ and   ReactionPaginator.__init__   in the <code>triggers</code> array to enable the stop button.</li> <li>The configured executor is now used for handling attachments when creating the initial responses   with the ASGI bot.</li> <li>Check the headers before reading the body in the ASGI adapter and bot to avoid unnecessary hold up   on bad requests.</li> </ul>"},{"location":"changelog/#removed_4","title":"Removed","text":"<ul> <li><code>yuyo.InteractiveButtonBuilder</code>/<code>yuyo.components.InteractiveButtonBuilder</code> and   <code>yuyo.SelectMenuBuilder</code>/<code>yuyo.components.SelectMenuBuilder</code>. Hikari's default   implementations should be used instead.</li> <li>The deprecated <code>load_from_attributes</code> arguments and the relevant deprecated <code>as_reaction_callback</code>   and <code>as_component_callback</code> functions.</li> <li>The deprecated <code>WaitForComponent</code> alias of <code>WaitForExecutor</code>.</li> </ul>"},{"location":"changelog/#security","title":"Security","text":"<ul> <li>The yuyo.asgi.AsgiAdapter and yuyo.asgi.AsgiBot both now have a max body size limit to avoid   potential DoS and memory issues. This is configurable using <code>max_body_size</code> in the <code>__init__</code>s.</li> </ul>"},{"location":"changelog/#161a1-2023-01-17","title":"1.6.1a1 - 2023-01-17","text":""},{"location":"changelog/#changed_9","title":"Changed","text":"<ul> <li>Detect/allow invite links which aren't prefixed by <code>https://</code> or <code>https://www.</code> in   InviteLink.find,   InviteLink.find_iter, and   InviteLink.from_link to better match Discord's special invite   embedding logic.</li> <li>All link parsers now allow <code>http://</code> links.</li> <li>The startup and shutdown callbacks on yuyo.asgi.AsgiAdapter now take no arguments.   This change does not effect startup and shutdown callbacks on yuyo.asgi.AsgiBot.</li> </ul>"},{"location":"changelog/#removed_5","title":"Removed","text":"<ul> <li>The <code>process_lifespan_event</code> and <code>process_request</code> methods from yuyo.asgi.AsgiAdapter.</li> <li>yuyo.asgi.AsgiBot no-longer inherits from yuyo.asgi.AsgiAdapter directly but still   functions as one.</li> </ul>"},{"location":"changelog/#160a1-2023-01-12","title":"1.6.0a1 - 2023-01-12","text":""},{"location":"changelog/#added_8","title":"Added","text":"<ul> <li>Helper functions for converting some Hikrai modals to builder objects in yuyo.to_builder.   These support application commands and message components.</li> </ul>"},{"location":"changelog/#changed_10","title":"Changed","text":"<ul> <li>Bumped minimum Hikari version to <code>v2.0.0.dev114</code>.</li> </ul>"},{"location":"changelog/#150a1-2023-01-10","title":"1.5.0a1 - 2023-01-10","text":""},{"location":"changelog/#added_9","title":"Added","text":"<ul> <li>Add classes and functions for handling message, webhook, invite and template links.</li> </ul>"},{"location":"changelog/#changed_11","title":"Changed","text":"<ul> <li>Officially drop support for Python 3.8.</li> </ul>"},{"location":"changelog/#140a1post1-2022-11-20","title":"1.4.0a1.post1 - 2022-11-20","text":""},{"location":"changelog/#changed_12","title":"Changed","text":"<ul> <li>CacheStrategy.__init__ now   takes two arguments <code>(hikari.api.Cache, hikari.ShardAware)</code>.</li> </ul>"},{"location":"changelog/#fixed_9","title":"Fixed","text":"<ul> <li>yuyo.list_status.DiscordBotListService's logging when declaring per-shard stats.</li> <li>Declare bot stats per-shard instead of for the whole bot when list status is using the   standard cache or event strategies.</li> </ul>"},{"location":"changelog/#140a1-2022-11-20","title":"1.4.0a1 - 2022-11-20","text":""},{"location":"changelog/#added_10","title":"Added","text":"<ul> <li>A system for automatically declaring a bot's guild count on the bot lists   top.gg, bots.gg and discordbotlist.com. See yuyo.list_status for more   information.</li> <li><code>\"asgi\"</code> feature flag for ensuring this installs with the dependencies required to run   the Asgi REST bot adapter.</li> </ul>"},{"location":"changelog/#changed_13","title":"Changed","text":"<ul> <li>yuyo.backoff.Backoff now increments the internal counter regardless of whether   yuyo.backoff.Backoff.set_next_backoff has been called.</li> <li>yuyo.backoff.Backoff now iterates over the retry counter (int), starting at 0,   rather than just None.</li> <li>yuyo.backoff.Backoff.backoff now returns the current retry count as int or   None if it has reached max retries or the finished flag has been set.</li> <li>Allow None to be passed for <code>attachment</code> and <code>attachments</code> to edit response methods.</li> <li>Star imports are no-longer used on the top level (at yuyo) so only the attributes present   in <code>yuyo.__all__</code> can be accessed there now.</li> <li>yuyo.components.AbstractComponentExecutor, <code>yuyo.components.ChildActionRowExecutor</code>,   <code>InteractiveButtonBuilder</code>, <code>yuyo.components.as_child_executor</code>,   <code>yuyo.components.as_component_callback</code>, yuyo.reactions.AbstractReactionHandler, and   <code>yuyo.reactions.as_reaction_callback</code> are no longer included in <code>yuyo.__all__</code>/exported   top-level.</li> </ul>"},{"location":"changelog/#deprecated_4","title":"Deprecated","text":"<ul> <li><code>yuyo.components.as_child_executor</code>, <code>yuyo.components.as_component_callback</code>, and   <code>yuyo.components.as_reaction_callback</code> are no longer documented (included in their   relevant module's <code>__all__</code>) as these are considered deprecated and undocumented.</li> </ul>"},{"location":"changelog/#fixed_10","title":"Fixed","text":"<ul> <li>yuyo.backoff.Backoff.backoff now respects the max retires config and finished flag.   For this it will now return None without sleeping when either has been reached.</li> </ul>"},{"location":"changelog/#removed_6","title":"Removed","text":"<ul> <li><code>backoff</code> option from yuyo.backoff.Backoff.backoff to better match the aiter flow.</li> </ul>"},{"location":"changelog/#131a1-2022-11-07","title":"1.3.1a1 - 2022-11-07","text":""},{"location":"changelog/#added_11","title":"Added","text":"<ul> <li>A chunk request tracker implementation.</li> </ul>"},{"location":"changelog/#changed_14","title":"Changed","text":"<ul> <li>Bumped the minimum Hikari version to <code>2.0.0.dev112</code>.</li> <li>yuyo.asgi.AsgiAdapter's startup and shutdown callbacks now take 1 argument,   must return None and must be asynchronous to match the methods added to   hikari.traits.RESTBotAware in   https://github.com/hikari-py/hikari/releases/tag/2.0.0.dev112.</li> </ul> <p>This argument will be of type yuyo.asgi.AsgiAdapter when these methods are   called of an asgi adapter and of type yuyo.asgi.AsgiBot when called on an   asgi bot instance.</p>"},{"location":"changelog/#removed_7","title":"Removed","text":"<ul> <li><code>replace_attachments</code> argument from the relevant context edit response methods.   For more information see https://github.com/hikari-py/hikari/releases/tag/2.0.0.dev112.</li> </ul>"},{"location":"changelog/#121a1-2022-11-04","title":"1.2.1a1 - 2022-11-04","text":""},{"location":"changelog/#added_12","title":"Added","text":"<ul> <li><code>ephemeral</code> keyword-argument to yuyo.components.ComponentContext's <code>create_initial_response</code>,   <code>create_follow_up</code> and <code>defer</code> methods as a shorthand for including <code>1 &lt;&lt; 6</code> in the passed flags.</li> <li><code>delete_after</code> option to yuyo.components.ComponentContext response methods.</li> <li><code>expires_at</code> property to yuyo.components.ComponentContext.</li> <li>Support for dependency injection through Alluka to the reaction and component clients.</li> </ul>"},{"location":"changelog/#changed_15","title":"Changed","text":"<ul> <li><code>ComponentExecutor.execute</code> now takes a context object instead of interaction and future objects.</li> <li>yuyo.pagination.async_paginate_string, yuyo.pagination.sync_paginate_string and   yuyo.pagination.paginate_string now return an (async) iterator of the str pages rather than   an iterator of <code>tuple[str, int]</code>. If you need page counts, use enumerate or   yuyo.pagination.aenumerate.</li> <li>(Async) iterables can now be passed to yuyo.pagination.async_paginate_string,   yuyo.pagination.sync_paginate_string and yuyo.pagination.paginate_string instead of just   iterators.</li> </ul>"},{"location":"changelog/#fixed_11","title":"Fixed","text":"<ul> <li>yuyo.components.BaseContext.respond trying to edit in the initial response instead   of create a follow up if a deferred initial response was deleted.</li> <li>Long running <code>delete_after</code> and component execution tasks will no-longer be cancelled by GC.</li> </ul>"},{"location":"changelog/#removed_8","title":"Removed","text":"<ul> <li>The project metadata dunder attributes from yuyo.   importlib.metadata should be used to get this metadata instead.</li> </ul>"},{"location":"changelog/#111a1-2022-08-28","title":"1.1.1a1 - 2022-08-28","text":""},{"location":"changelog/#added_13","title":"Added","text":"<ul> <li>Support for sending attachments in the initial response to the ASGI server implementation.</li> <li>Support for sending attachments on initial response to the <code>ComponentContext</code>.</li> </ul>"},{"location":"changelog/#changed_16","title":"Changed","text":"<ul> <li>Bumped the minimum hikari version to dev109.</li> <li>Async functions must be typed as returning <code>typing.Coroutine</code>/<code>collections.abc.Coroutine</code>   rather than <code>typing.Awaitable</code> now.</li> </ul>"},{"location":"changelog/#fixed_12","title":"Fixed","text":"<ul> <li>Several bug fixes on handling context response tracking have been copied over from Tanjun   to <code>ComponentContext</code>.</li> </ul>"},{"location":"changelog/#106a1-2022-05-24","title":"1.0.6a1 - 2022-05-24","text":""},{"location":"changelog/#changed_17","title":"Changed","text":"<ul> <li>Bumped the minimum hikari version to dev108.</li> </ul>"},{"location":"changelog/#fixed_13","title":"Fixed","text":"<ul> <li><code>WaitForExecutor</code> now has better semantics/behaviour around being called when it's inactive:<ul> <li>Timeouts are now handled better meaning that a wait for executor timeout will mark it to be de-registered.</li> <li>Execute calls to an executor that hasn't been waited for yet now return a not active message.</li> </ul> </li> </ul>"},{"location":"changelog/#105a1post1-2021-12-21","title":"1.0.5a1.post1 - 2021-12-21","text":""},{"location":"changelog/#changed_18","title":"Changed","text":"<ul> <li><code>AsgiBot</code> is now (by default) started and closed based on the ASGI lifespan events with   the <code>asgi_managed</code> keyword argument to <code>AsgiBot.__init__</code> allowing this to be disabled.</li> </ul>"},{"location":"changelog/#105a1-2021-12-21","title":"1.0.5a1 - 2021-12-21","text":""},{"location":"changelog/#added_14","title":"Added","text":"<ul> <li><code>AsgiBot</code> extension for <code>AsgiAdapter</code> which can be run by itself (manages a rest client).</li> </ul>"},{"location":"changelog/#changed_19","title":"Changed","text":"<ul> <li>Renamed <code>WaitForComponent</code> to <code>WaitForExecutor</code>.</li> </ul>"},{"location":"changelog/#104a1-2021-11-22","title":"1.0.4a1 - 2021-11-22","text":""},{"location":"changelog/#added_15","title":"Added","text":"<ul> <li><code>prefix_match</code> option to ComponentClient custom ids to make storing metadata in custom ids   possible.</li> </ul>"},{"location":"changelog/#fixed_14","title":"Fixed","text":"<ul> <li>custom id methods now raise ValueError on conflict rather than KeyError.</li> </ul>"},{"location":"changelog/#103a1-2021-10-27","title":"1.0.3a1 - 2021-10-27","text":""},{"location":"changelog/#added_16","title":"Added","text":"<ul> <li>An ASGI/3 adapter for Hikari's interaction server.</li> <li>Ability to register a callback for a constant custom_id in the component client.   This takes precedence over any registered component executors.</li> </ul>"},{"location":"changelog/#changed_20","title":"Changed","text":"<ul> <li>Renamed <code>components.WaitFor</code> to <code>WaitForComponent</code> and added it to <code>components.__all__</code> and   <code>yuyo.__all__</code>.</li> </ul>"},{"location":"changelog/#fixed_15","title":"Fixed","text":"<ul> <li><code>Context.defer</code> is now used in the ComponentPaginator instead of   <code>Context.create_initial_response</code> to defer the initial response since before deleting it   as <code>Context.create_initial_response</code> errors in the REST flow when a defer type is passed.</li> <li><code>Context.create_initial_response</code> is no longer typed as taking deferred types.</li> <li>Handling of authors in WaitForComponent.</li> <li>Added timeout handling to the future returned by WaitForComponent.wait_for.</li> </ul>"},{"location":"changelog/#102a1post1-2021-10-02","title":"[1.0.2a1.post1] - 2021-10-02","text":""},{"location":"changelog/#fixed_16","title":"Fixed","text":"<ul> <li>ComponentClient erroneously garbage collecting unexpired executors.</li> <li>ComponentPaginator and ReactionPaginator both starting on index 1 instead of 0.</li> </ul>"},{"location":"changelog/#102a1-2021-10-02","title":"1.0.2a1 - 2021-10-02","text":""},{"location":"changelog/#added_17","title":"Added","text":"<ul> <li>Option to have the ComponentClient be event managed when linked to an event manager.   This is True by default.</li> </ul>"},{"location":"changelog/#changed_21","title":"Changed","text":"<ul> <li>The client now gives a ephemeral timed out response when an unknown message is received.</li> </ul>"},{"location":"changelog/#fixed_17","title":"Fixed","text":"<ul> <li>ComponentClient's gc task not being started when its opened.</li> <li>Handling of access errors in the component client.</li> <li>MultiComponentExecutor slots.</li> </ul>"},{"location":"changelog/#101a1-2021-09-21","title":"1.0.1a1 - 2021-09-21","text":""},{"location":"changelog/#added_18","title":"Added","text":"<ul> <li>Higher level component execution client and a pagination specific implementation of its   executor.</li> </ul>"},{"location":"changelog/#changed_22","title":"Changed","text":"<ul> <li>Totally refactored reaction pagination client to make it more abstract and abstracted away from   pagination where the pagination is just a standard use case specific implementation of its   executor.</li> <li>Renamed module pagnation to pagination.</li> <li>Move the reaction handling logic over to \"reactions.py\"</li> <li>Renamed string_patinator functions to paginate_string</li> </ul>"},{"location":"changelog/#fixed_18","title":"Fixed","text":"<ul> <li>Iffy behaviour around \"locking\" the reaction executor which lead to some requests just being ignored.</li> </ul>"},{"location":"reference/","title":"yuyo","text":"<p>A collection of utility functions and classes designed to expand Hikari.</p>"},{"location":"reference/#yuyo.ActionColumnExecutor","title":"ActionColumnExecutor","text":"<p>         Bases: <code>AbstractComponentExecutor</code></p> <p>Executor which handles columns of action rows.</p> <p>This can be used to declare and handle the components on a message a couple of ways.</p> <p>To send a column's components pass ActionColumnExecutor.rows as <code>components</code> when calling the create message method (e.g. <code>respond</code>/<code>create_message</code>).</p> <p>Examples:</p> <p>Sub-components can be added to an instance of the column executor using chainable methods on it:</p> <pre><code>async def callback_1(ctx: components.ComponentContext) -&gt; None:\n    await ctx.respond(\"meow\")\n\ncomponents = (\n    components.ActionColumnExecutor()\n    .add_interative_button(hikari.ButtonStyle.PRIMARY, chainable, label=\"Button 1\")\n    .add_link_button(\"https://example.com\", label=\"Button 2\",)\n)\n</code></pre> <p>Alternatively, subclasses of ActionColumnExecutor can act as a template where \"static\" fields are included on all instances and subclasses of that class:</p> <p>Note</p> <p>Since decorators are executed from the bottom upwards fields added through decorator calls will follow the same order.</p> <pre><code>async def callback_1(ctx: components.ComponentContext) -&gt; None:\n    await ctx.respond(\"meow\")\n\nasync def callback_2(ctx: components.ComponentContext) -&gt; None:\n    await ctx.respond(\"meow\")\n\n@components.with_static_select_menu(callback_1, hikari.ComponentType.USER_SELECT_MENU, max_values=5)\nclass CustomColumn(components.ActionColumnExecutor):\n    __slots__ = (\"special_string\",)  # ActionColumnExecutor supports slotting.\n\n    # The init can be overridden to store extra data on the column object when subclassing.\n    def __init__(self, special_string: str, timeout: typing.Optional[datetime.timedelta] = None):\n        super().__init__(timeout=timeout)\n        self.special_string = special_string\n\n(\n    CustomColumn.add_static_text_menu(callback_2, min_values=0, max_values=3)\n    # The following calls are all adding options to the added\n    # text select menu.\n    .add_option(\"Option 1\", \"value 1\")\n    .add_option(\"Option 2\", \"value 2\")\n    .add_option(\"Option 3\", \"value 3\")\n)\n</code></pre> <p>There's also class descriptors which can be used to declare static components. The following descriptors work by decorating their component's callback:</p> <ul> <li>as_interactive_button</li> <li>as_select_menu</li> <li>as_channel_menu</li> <li>as_text_menu</li> </ul> <p>link_button returns a descriptor without decorating any callback.</p> <pre><code>class CustomColumn(components.ActionColumnExecutor):\n    @components.as_interactive_button(ButtonStyle.PRIMARY, label=\"label\")\n    async def left_button(self, ctx: components.ComponentContext) -&gt; None:\n        ...\n\n    link_button = components.link_button(url=\"https://example.com\", label=\"Go to page\")\n\n    @components.as_interactive_button(ButtonStyle.SECONDARY, label=\"meow\")\n    async def right_button(self, ctx: components.ComponentContext) -&gt; None:\n        ...\n\n    @components.as_channel_menu(channel_types=[hikari.TextableChannel])\n    async def text_select_menu(self, ctx: components.ComponentContext) -&gt; None:\n        ...\n</code></pre>"},{"location":"reference/#yuyo.components.ActionColumnExecutor.rows","title":"rows  <code>property</code>","text":"<pre><code>rows: collections.Sequence[hikari.api.MessageActionRowBuilder]\n</code></pre> <p>The rows in this column.</p>"},{"location":"reference/#yuyo.components.ActionColumnExecutor.__init__","title":"__init__","text":"<pre><code>__init__(*, id_metadata=None, timeout=_internal.NO_DEFAULT, _stack_level=0)\n</code></pre> <p>Initialise an action column executor.</p> PARAMETER DESCRIPTION <code>id_metadata</code> <p>Mapping of metadata to append to the custom_ids in this column.</p> <p> TYPE: <code>typing.Optional[collections.Mapping[str, str]]</code> DEFAULT: <code>None</code> </p>"},{"location":"reference/#yuyo.components.ActionColumnExecutor.add_button","title":"add_button","text":"<pre><code>add_button(style, callback, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Deprecated alias of .add_interative_button.</p>"},{"location":"reference/#yuyo.components.ActionColumnExecutor.add_channel_menu","title":"add_channel_menu","text":"<pre><code>add_channel_menu(callback, /, *, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a channel select menu to this action column.</p> PARAMETER DESCRIPTION <code>callback</code> <p>Callback which is called when this select menu is used.</p> <p> TYPE: <code>CallbackSig</code> </p> <code>channel_types</code> <p>Sequence of the types of channels this select menu should show as options.</p> <p> TYPE: <code>typing.Optional[collections.Sequence[typing.Union[hikari.ChannelType, type[hikari.PartialChannel]]]]</code> DEFAULT: <code>None</code> </p> <code>custom_id</code> <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>placeholder</code> <p>Placeholder text to show when no entries have been selected.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>min_values</code> <p>The minimum amount of entries which need to be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>max_values</code> <p>The maximum amount of entries which can be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>is_disabled</code> <p>Whether this select menu should be marked as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The action column to enable chained calls.</p>"},{"location":"reference/#yuyo.components.ActionColumnExecutor.add_channel_select","title":"add_channel_select","text":"<pre><code>add_channel_select(callback, /, *, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Deprecated alias of .add_channel_menu.</p>"},{"location":"reference/#yuyo.components.ActionColumnExecutor.add_interative_button","title":"add_interative_button","text":"<pre><code>add_interative_button(style, callback, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add an interactive button to this action column.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> PARAMETER DESCRIPTION <code>style</code> <p>The button's style.</p> <p> TYPE: <code>hikari.InteractiveButtonTypesT</code> </p> <code>callback</code> <p>The button's execution callback.</p> <p> TYPE: <code>CallbackSig</code> </p> <code>custom_id</code> <p>The button's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>emoji</code> <p>The button's emoji.</p> <p> TYPE: <code>typing.Union[hikari.Snowflakeish, hikari.Emoji, str, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>label</code> <p>The button's label.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>is_disabled</code> <p>Whether the button should be marked as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The action column to enable chained calls.</p>"},{"location":"reference/#yuyo.components.ActionColumnExecutor.add_link_button","title":"add_link_button","text":"<pre><code>add_link_button(url, /, *, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add a link button to this action column.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> PARAMETER DESCRIPTION <code>url</code> <p>The button's url.</p> <p> TYPE: <code>str</code> </p> <code>emoji</code> <p>The button's emoji.</p> <p> TYPE: <code>typing.Union[hikari.Snowflakeish, hikari.Emoji, str, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>label</code> <p>The button's label.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>is_disabled</code> <p>Whether the button should be marked as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The action column to enable chained calls.</p>"},{"location":"reference/#yuyo.components.ActionColumnExecutor.add_row","title":"add_row","text":"<pre><code>add_row(row)\n</code></pre> <p>Add an action row executor to this column.</p> PARAMETER DESCRIPTION <code>row</code> <p>The action row executor to add.</p> <p> TYPE: <code>typing.Union[hikari.api.MessageActionRowBuilder, ActionRowExecutor]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The column executor to enable chained calls.</p>"},{"location":"reference/#yuyo.components.ActionColumnExecutor.add_select_menu","title":"add_select_menu","text":"<pre><code>add_select_menu(type_, callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a select menu to this action column.</p> <p>For channel select menus and text select menus see ActionColumnExecutor.add_channel_menu and ActionColumnExecutor.add_text_menu respectively.</p> PARAMETER DESCRIPTION <code>type_</code> <p>The type of select menu to add.</p> <p>Passing callback here is deprecated.</p> <p> TYPE: <code>hikari.components.ComponentType | int</code> </p> <code>callback</code> <p>Callback which is called when this select menu is used.</p> <p>Passing type here is deprecated.</p> <p> TYPE: <code>yuyo.components.CallbackSig</code> </p> <code>custom_id</code> <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>placeholder</code> <p>Placeholder text to show when no entries have been selected.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>min_values</code> <p>The minimum amount of entries which need to be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>max_values</code> <p>The maximum amount of entries which can be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>is_disabled</code> <p>Whether this select menu should be marked as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The action column to enable chained calls.</p>"},{"location":"reference/#yuyo.components.ActionColumnExecutor.add_static_button","title":"add_static_button  <code>classmethod</code>","text":"<pre><code>add_static_button(style, callback, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Deprecated alias of .add_static_interative_button.</p>"},{"location":"reference/#yuyo.components.ActionColumnExecutor.add_static_channel_menu","title":"add_static_channel_menu  <code>classmethod</code>","text":"<pre><code>add_static_channel_menu(callback, /, *, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a channel select menu to all subclasses and instances of this action column class.</p> PARAMETER DESCRIPTION <code>callback</code> <p>Callback which is called when this select menu is used.</p> <p> TYPE: <code>CallbackSig</code> </p> <code>channel_types</code> <p>Sequence of the types of channels this select menu should show as options.</p> <p> TYPE: <code>typing.Optional[collections.Sequence[typing.Union[hikari.ChannelType, type[hikari.PartialChannel]]]]</code> DEFAULT: <code>None</code> </p> <code>custom_id</code> <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>placeholder</code> <p>Placeholder text to show when no entries have been selected.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>min_values</code> <p>The minimum amount of entries which need to be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>max_values</code> <p>The maximum amount of entries which can be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>is_disabled</code> <p>Whether this select menu should be marked as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>type[Self]</code> <p>The action column class to enable chained calls.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>When called directly on components.ActionColumnExecutor (rather than on a subclass).</p>"},{"location":"reference/#yuyo.components.ActionColumnExecutor.add_static_channel_select","title":"add_static_channel_select  <code>classmethod</code>","text":"<pre><code>add_static_channel_select(callback, /, *, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Deprecated alias of .add_static_channel_menu.</p>"},{"location":"reference/#yuyo.components.ActionColumnExecutor.add_static_interative_button","title":"add_static_interative_button  <code>classmethod</code>","text":"<pre><code>add_static_interative_button(style, callback, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add an interactive button to all subclasses and instances of this action column class.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> PARAMETER DESCRIPTION <code>style</code> <p>The button's style.</p> <p> TYPE: <code>hikari.InteractiveButtonTypesT</code> </p> <code>callback</code> <p>The button's execution callback.</p> <p> TYPE: <code>CallbackSig</code> </p> <code>custom_id</code> <p>The button's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>emoji</code> <p>The button's emoji.</p> <p> TYPE: <code>typing.Union[hikari.Snowflakeish, hikari.Emoji, str, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>label</code> <p>The button's label.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>is_disabled</code> <p>Whether the button should be marked as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>type[Self]</code> <p>The action column class to enable chained calls.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>When called directly on components.ActionColumnExecutor (rather than on a subclass).</p>"},{"location":"reference/#yuyo.components.ActionColumnExecutor.add_static_link_button","title":"add_static_link_button  <code>classmethod</code>","text":"<pre><code>add_static_link_button(url, /, *, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add a link button to all subclasses and instances of this action column class.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> PARAMETER DESCRIPTION <code>url</code> <p>The button's url.</p> <p> TYPE: <code>str</code> </p> <code>emoji</code> <p>The button's emoji.</p> <p> TYPE: <code>typing.Union[hikari.Snowflakeish, hikari.Emoji, str, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>label</code> <p>The button's label.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>is_disabled</code> <p>Whether the button should be marked as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>type[Self]</code> <p>The action column class to enable chained calls.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>When called directly on components.ActionColumnExecutor (rather than on a subclass).</p>"},{"location":"reference/#yuyo.components.ActionColumnExecutor.add_static_select_menu","title":"add_static_select_menu  <code>classmethod</code>","text":"<pre><code>add_static_select_menu(type_, callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a select menu to all subclasses and instances of this action column class.</p> <p>For channel select menus and text select menus see ActionColumnExecutor.add_channel_menu and ActionColumnExecutor.add_text_menu respectively.</p> PARAMETER DESCRIPTION <code>type_</code> <p>The type of select menu to add.</p> <p>Passing callback here is deprecated.</p> <p> TYPE: <code>hikari.components.ComponentType | int</code> </p> <code>callback</code> <p>Callback which is called when this select menu is used.</p> <p>Passing type here is deprecated.</p> <p> TYPE: <code>yuyo.components.CallbackSig</code> </p> <code>custom_id</code> <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>placeholder</code> <p>Placeholder text to show when no entries have been selected.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>min_values</code> <p>The minimum amount of entries which need to be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>max_values</code> <p>The maximum amount of entries which can be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>is_disabled</code> <p>Whether this select menu should be marked as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>type[Self]</code> <p>The action column class to enable chained calls.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>When called directly on components.ActionColumnExecutor (rather than on a subclass).</p>"},{"location":"reference/#yuyo.components.ActionColumnExecutor.add_static_text_menu","title":"add_static_text_menu  <code>classmethod</code>","text":"<pre><code>add_static_text_menu(callback, /, *, custom_id=None, options=(), placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a text select menu to all subclasses and instances of this action column class.</p> PARAMETER DESCRIPTION <code>callback</code> <p>Callback which is called when this select menu is used.</p> <p> TYPE: <code>CallbackSig</code> </p> <code>custom_id</code> <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>options</code> <p>The text select's options.</p> <p>These can also be added by calling TextSelectMenuBuilder.add_option.</p> <p> TYPE: <code>collections.Sequence[hikari.api.SelectOptionBuilder]</code> DEFAULT: <code>()</code> </p> <code>placeholder</code> <p>Placeholder text to show when no entries have been selected.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>min_values</code> <p>The minimum amount of entries which need to be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>max_values</code> <p>The maximum amount of entries which can be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>is_disabled</code> <p>Whether this select menu should be marked as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>hikari.api.special_endpoints.TextSelectMenuBuilder</code> <p>Builder for the added text select menu.</p> <p>TextSelectMenuBuilder.add_option should be used to add options to this select menu.</p> <p>And the parent action column can be accessed by calling TextSelectMenuBuilder.parent.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>When called directly on components.ActionColumnExecutor (rather than on a subclass).</p>"},{"location":"reference/#yuyo.components.ActionColumnExecutor.add_static_text_select","title":"add_static_text_select  <code>classmethod</code>","text":"<pre><code>add_static_text_select(callback, /, *, custom_id=None, options=(), placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Deprecated alias of .add_static_text_menu.</p>"},{"location":"reference/#yuyo.components.ActionColumnExecutor.add_text_menu","title":"add_text_menu","text":"<pre><code>add_text_menu(callback, /, *, custom_id=None, options=(), placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a text select menu to this action column.</p> PARAMETER DESCRIPTION <code>callback</code> <p>Callback which is called when this select menu is used.</p> <p> TYPE: <code>CallbackSig</code> </p> <code>custom_id</code> <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>options</code> <p>The text select's options.</p> <p>These can also be added by calling TextSelectMenuBuilder.add_option.</p> <p> TYPE: <code>collections.Sequence[hikari.api.SelectOptionBuilder]</code> DEFAULT: <code>()</code> </p> <code>placeholder</code> <p>Placeholder text to show when no entries have been selected.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>min_values</code> <p>The minimum amount of entries which need to be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>max_values</code> <p>The maximum amount of entries which can be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>is_disabled</code> <p>Whether this select menu should be marked as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>hikari.api.special_endpoints.TextSelectMenuBuilder</code> <p>Builder for the added text select menu.</p> <p>TextSelectMenuBuilder.add_option should be used to add options to this select menu.</p> <p>And the parent action column can be accessed by calling TextSelectMenuBuilder.parent.</p>"},{"location":"reference/#yuyo.components.ActionColumnExecutor.add_text_select","title":"add_text_select","text":"<pre><code>add_text_select(callback, /, *, custom_id=None, options=(), placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Deprecated alias of .add_text_menu.</p>"},{"location":"reference/#yuyo.components.ActionColumnExecutor.with_static_button","title":"with_static_button  <code>classmethod</code>","text":"<pre><code>with_static_button(style, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Deprecated alias of .with_static_interative_button.</p>"},{"location":"reference/#yuyo.components.ActionColumnExecutor.with_static_channel_menu","title":"with_static_channel_menu  <code>classmethod</code>","text":"<pre><code>with_static_channel_menu(*, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Deprecated method.</p> <p>Use .add_static_channel_menu.</p>"},{"location":"reference/#yuyo.components.ActionColumnExecutor.with_static_channel_select","title":"with_static_channel_select  <code>classmethod</code>","text":"<pre><code>with_static_channel_select(*, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Deprecated alias of .with_static_channel_menu.</p>"},{"location":"reference/#yuyo.components.ActionColumnExecutor.with_static_interative_button","title":"with_static_interative_button  <code>classmethod</code>","text":"<pre><code>with_static_interative_button(style, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Deprecated method.</p> <p>Use .add_static_interactive_button.</p>"},{"location":"reference/#yuyo.components.ActionColumnExecutor.with_static_select_menu","title":"with_static_select_menu  <code>classmethod</code>","text":"<pre><code>with_static_select_menu(type_, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Deprecated method.</p> <p>Use .add_static_select_menu.</p>"},{"location":"reference/#yuyo.ActionRowExecutor","title":"ActionRowExecutor","text":"<p>         Bases: <code>ComponentExecutor</code>, <code>hikari.api.ComponentBuilder</code></p> <p>Class used for handling the execution of an action row.</p> <p>You likely want ActionColumnExecutor which provides an interface for handling all the components on a message instead of this.</p>"},{"location":"reference/#yuyo.components.ActionRowExecutor.components","title":"components  <code>property</code>","text":"<pre><code>components: collections.Sequence[hikari.api.ComponentBuilder]\n</code></pre> <p>The sub-components in this row.</p>"},{"location":"reference/#yuyo.components.ActionRowExecutor.__init__","title":"__init__","text":"<pre><code>__init__(*, ephemeral_default=False, timeout=_internal.NO_DEFAULT, _stack_level=0)\n</code></pre> <p>Initialise an action row executor.</p> PARAMETER DESCRIPTION <code>ephemeral_default</code> <p>Whether this executor's responses should default to being ephemeral.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"reference/#yuyo.components.ActionRowExecutor.add_button","title":"add_button","text":"<pre><code>add_button(style, callback, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Deprecated alias of .add_interative_button.</p>"},{"location":"reference/#yuyo.components.ActionRowExecutor.add_channel_menu","title":"add_channel_menu","text":"<pre><code>add_channel_menu(callback, /, *, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a channel select menu to this action row.</p> PARAMETER DESCRIPTION <code>callback</code> <p>Callback which is called when this select menu is used.</p> <p> TYPE: <code>CallbackSig</code> </p> <code>channel_types</code> <p>Sequence of the types of channels this select menu should show as options.</p> <p> TYPE: <code>typing.Optional[collections.Sequence[typing.Union[hikari.ChannelType, _Type[hikari.PartialChannel]]]]</code> DEFAULT: <code>None</code> </p> <code>custom_id</code> <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>placeholder</code> <p>Placeholder text to show when no entries have been selected.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>min_values</code> <p>The minimum amount of entries which need to be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>max_values</code> <p>The maximum amount of entries which can be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>is_disabled</code> <p>Whether this select menu should be marked as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The action row to enable chained calls.</p>"},{"location":"reference/#yuyo.components.ActionRowExecutor.add_channel_select","title":"add_channel_select","text":"<pre><code>add_channel_select(callback, /, *, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Deprecated alias of .add_channel_menu.</p>"},{"location":"reference/#yuyo.components.ActionRowExecutor.add_component","title":"add_component","text":"<pre><code>add_component(component)\n</code></pre> <p>Add a sub-component to this action row.</p> <p>ActionRowExecutor.set_callback should be used to set the callback for this component if it is interactive (has a <code>custom_id</code> field).</p> PARAMETER DESCRIPTION <code>component</code> <p>The sub-component to add.</p> <p> TYPE: <code>hikari.api.ComponentBuilder</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The action row to enable chained calls.</p>"},{"location":"reference/#yuyo.components.ActionRowExecutor.add_interative_button","title":"add_interative_button","text":"<pre><code>add_interative_button(style, callback, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add an interactive button to this action row.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> PARAMETER DESCRIPTION <code>style</code> <p>The interactive button's style.</p> <p> TYPE: <code>hikari.InteractiveButtonTypesT</code> </p> <code>callback</code> <p>The interactive button's callback.</p> <p> TYPE: <code>CallbackSig</code> </p> <code>custom_id</code> <p>The button's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>emoji</code> <p>The button's emoji.</p> <p> TYPE: <code>typing.Union[hikari.Snowflakeish, hikari.Emoji, str, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>label</code> <p>The button's label.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>is_disabled</code> <p>Whether the button should be marked as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The action row to enable chained calls.</p> RAISES DESCRIPTION <code>ValueError</code> <ul> <li>If any of the sub-components in this action row aren't buttons.</li> <li>If a callback is passed for <code>callback_or_url</code> for a url style button.</li> <li>If a string is passed for <code>callback_or_url</code> for an interactive button.</li> </ul>"},{"location":"reference/#yuyo.components.ActionRowExecutor.add_link_button","title":"add_link_button","text":"<pre><code>add_link_button(url, /, *, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add a Link button to this action row.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> PARAMETER DESCRIPTION <code>url</code> <p>The button's url.</p> <p> TYPE: <code>str</code> </p> <code>emoji</code> <p>The button's emoji.</p> <p> TYPE: <code>typing.Union[hikari.Snowflakeish, hikari.Emoji, str, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>label</code> <p>The button's label.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>is_disabled</code> <p>Whether the button should be marked as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The action row to enable chained calls.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If any of the sub-components in this action row aren't buttons.</p>"},{"location":"reference/#yuyo.components.ActionRowExecutor.add_select_menu","title":"add_select_menu","text":"<pre><code>add_select_menu(type_, callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a select menu to this action row.</p> <p>For channel select menus and text select menus see ActionRowExecutor.add_channel_menu and ActionRowExecutor.add_text_menu respectively.</p> PARAMETER DESCRIPTION <code>type_</code> <p>The type of select menu to add.</p> <p>Passing callback here is deprecated.</p> <p> TYPE: <code>hikari.components.ComponentType | int</code> </p> <code>callback</code> <p>Callback which is called when this select menu is used.</p> <p>Passing type here is deprecated.</p> <p> TYPE: <code>yuyo.components.CallbackSig</code> </p> <code>custom_id</code> <p>The select menu's custom ID.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>placeholder</code> <p>Placeholder text to show when no entries have been selected.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>min_values</code> <p>The minimum amount of entries which need to be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>max_values</code> <p>The maximum amount of entries which can be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>is_disabled</code> <p>Whether this select menu should be marked as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The action row to enable chained calls.</p>"},{"location":"reference/#yuyo.components.ActionRowExecutor.add_text_menu","title":"add_text_menu","text":"<pre><code>add_text_menu(callback, /, *, custom_id=None, options=(), placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a text select menu to this action row.</p> PARAMETER DESCRIPTION <code>callback</code> <p>Callback which is called when this select menu is used.</p> <p> TYPE: <code>CallbackSig</code> </p> <code>custom_id</code> <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>options</code> <p>The text select's options.</p> <p>These can also be added by calling TextSelectMenuBuilder.add_option.</p> <p> TYPE: <code>collections.Sequence[hikari.api.SelectOptionBuilder]</code> DEFAULT: <code>()</code> </p> <code>placeholder</code> <p>Placeholder text to show when no entries have been selected.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>min_values</code> <p>The minimum amount of entries which need to be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>max_values</code> <p>The maximum amount of entries which can be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>is_disabled</code> <p>Whether this select menu should be marked as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>hikari.api.special_endpoints.TextSelectMenuBuilder</code> <p>Builder for the added text select menu.</p> <p>And the parent action row can be accessed by calling TextSelectMenuBuilder.parent.</p>"},{"location":"reference/#yuyo.components.ActionRowExecutor.add_text_select","title":"add_text_select","text":"<pre><code>add_text_select(callback, /, *, custom_id=None, options=(), placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Deprecated alias of .add_text_menu.</p>"},{"location":"reference/#yuyo.AsgiAdapter","title":"AsgiAdapter","text":"<p>Asgi/3 adapter for Hikari's interaction server interface.</p> <p>For this to work, hikari has to be installed with the optional \"server\" feature (e.g <code>python -m pip install hikari[server]</code>).</p>"},{"location":"reference/#yuyo.asgi.AsgiAdapter.server","title":"server  <code>property</code>","text":"<pre><code>server: hikari.api.InteractionServer\n</code></pre> <p>The interaction server this adapter is bound to.</p>"},{"location":"reference/#yuyo.asgi.AsgiAdapter.__call__","title":"__call__  <code>async</code>","text":"<pre><code>__call__(scope, receive, send)\n</code></pre> <p>Call the adapter.</p> <p>Note</p> <p>This method is called by the ASGI server.</p> PARAMETER DESCRIPTION <code>scope</code> <p>The scope of the request.</p> <p> TYPE: <code>asgiref.Scope</code> </p> <code>receive</code> <p>The receive function to use.</p> <p> TYPE: <code>asgiref.ASGIReceiveCallable</code> </p> <code>send</code> <p>The send function to use.</p> <p> TYPE: <code>asgiref.ASGISendCallable</code> </p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If this is called with a websocket scope.</p> <code>RuntimeError</code> <p>If an invalid scope event is passed.</p>"},{"location":"reference/#yuyo.asgi.AsgiAdapter.__init__","title":"__init__","text":"<pre><code>__init__(server, /, *, executor=None, max_body_size=1024 ** 2)\n</code></pre> <p>Initialise the adapter.</p> PARAMETER DESCRIPTION <code>server</code> <p>The interaction server to use.</p> <p> TYPE: <code>hikari.api.InteractionServer</code> </p> <code>executor</code> <p>If non-None, then this executor is used instead of the concurrent.futures.ThreadPoolExecutor attached to the asyncio.AbstractEventLoop that the bot will run on. This executor is used primarily for file-IO.</p> <p>While mainly supporting the concurrent.futures.ThreadPoolExecutor implementation in the standard lib, Hikari's file handling systems should also work with concurrent.futures.ProcessPoolExecutor, which relies on all objects used in IPC to be <code>pickle</code>able. Many third-party libraries will not support this fully though, so your mileage may vary on using ProcessPoolExecutor implementations with this parameter.</p> <p> TYPE: <code>typing.Optional[concurrent.futures.Executor]</code> DEFAULT: <code>None</code> </p> <code>max_body_size</code> <p>The maximum body size this should allow received request bodies to be in bytes before failing the request with a 413 - Content Too Large.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1024 ** 2</code> </p>"},{"location":"reference/#yuyo.asgi.AsgiAdapter.add_shutdown_callback","title":"add_shutdown_callback","text":"<pre><code>add_shutdown_callback(callback)\n</code></pre> <p>Add a callback to be called when the ASGI server shuts down.</p> <p>Warning</p> <p>These callbacks will block the ASGI server from shutting down until they complete and any raised errors will lead to a failed shutdown.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The shutdown callback to add.</p> <p> TYPE: <code>collections.Callable[[], collections.Coroutine[typing.Any, typing.Any, None]]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The adapter to enable chained calls.</p>"},{"location":"reference/#yuyo.asgi.AsgiAdapter.add_startup_callback","title":"add_startup_callback","text":"<pre><code>add_startup_callback(callback)\n</code></pre> <p>Add a callback to be called when the ASGI server starts up.</p> <p>Warning</p> <p>These callbacks will block the ASGI server from starting until they complete and any raised errors will lead to a failed startup.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The startup callback to add.</p> <p> TYPE: <code>collections.Callable[[], collections.Coroutine[typing.Any, typing.Any, None]]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The adapter to enable chained calls.</p>"},{"location":"reference/#yuyo.asgi.AsgiAdapter.remove_shutdown_callback","title":"remove_shutdown_callback","text":"<pre><code>remove_shutdown_callback(callback)\n</code></pre> <p>Remove a shutdown callback.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The shutdown callback to remove.</p> <p> TYPE: <code>collections.Callable[[], collections.Coroutine[typing.Any, typing.Any, None]]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The adapter to enable chained calls.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the callback was not registered.</p>"},{"location":"reference/#yuyo.asgi.AsgiAdapter.remove_startup_callback","title":"remove_startup_callback","text":"<pre><code>remove_startup_callback(callback)\n</code></pre> <p>Remove a startup callback.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The startup callback to remove.</p> <p> TYPE: <code>collections.Callable[[], collections.Coroutine[typing.Any, typing.Any, None]]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The adapter to enable chained calls.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the callback was not registered.</p>"},{"location":"reference/#yuyo.AsgiBot","title":"AsgiBot","text":"<p>         Bases: <code>hikari.RESTBotAware</code></p> <p>Bot implementation which acts as an ASGI adapter.</p> <p>This bot doesn't initiate a server internally but instead relies on being called as an ASGI app.</p> <p>For this to work, hikari has to be installed with the optional \"server\" feature (e.g <code>python -m pip install hikari[server]</code>).</p>"},{"location":"reference/#yuyo.asgi.AsgiBot.__call__","title":"__call__  <code>async</code>","text":"<pre><code>__call__(scope, receive, send)\n</code></pre> <p>Call the bot with an ASGI event.</p> <p>Note</p> <p>This method is called by the ASGI server and allows the bot to function like AsgiAdapter.</p> PARAMETER DESCRIPTION <code>scope</code> <p>The scope of the request.</p> <p> TYPE: <code>asgiref.Scope</code> </p> <code>receive</code> <p>The receive function to use.</p> <p> TYPE: <code>asgiref.ASGIReceiveCallable</code> </p> <code>send</code> <p>The send function to use.</p> <p> TYPE: <code>asgiref.ASGISendCallable</code> </p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If this is called with a websocket scope.</p> <code>RuntimeError</code> <p>If an invalid scope event is passed.</p>"},{"location":"reference/#yuyo.asgi.AsgiBot.__init__","title":"__init__","text":"<pre><code>__init__(token, token_type=None, public_key=None, *, asgi_managed=True, executor=None, http_settings=None, max_body_size=1024 ** 2, max_rate_limit=300.0, max_retries=3, proxy_settings=None, rest_url=None)\n</code></pre> <p>Initialise a new ASGI bot.</p> PARAMETER DESCRIPTION <code>token</code> <p>The bot or bearer token. If no token is to be used, this can be undefined.</p> <p> TYPE: <code>typing.Union[str, hikari.api.TokenStrategy]</code> </p> <code>token_type</code> <p>The type of token in use. This should only be passed when <code>str</code> is passed for <code>token</code>, can be <code>\"Bot\"</code> or <code>\"Bearer\"</code> and will be defaulted to <code>\"Bot\"</code> in this situation.</p> <p>This should be left as None when either hikari.api.rest.TokenStrategy or None is passed for <code>token</code>.</p> <p> TYPE: <code>typing.Union[hikari.TokenType, str, None]</code> DEFAULT: <code>None</code> </p> <code>asgi_managed</code> <p>Whether this bot's internal components should be automatically started and stopped based on the Asgi lifespan events.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>executor</code> <p>If non-None, then this executor is used instead of the concurrent.futures.ThreadPoolExecutor attached to the asyncio.AbstractEventLoop that the bot will run on. This executor is used primarily for file-IO.</p> <p>While mainly supporting the concurrent.futures.ThreadPoolExecutor implementation in the standard lib, Hikari's file handling systems should also work with concurrent.futures.ProcessPoolExecutor, which relies on all objects used in IPC to be <code>pickle</code>able. Many third-party libraries will not support this fully though, so your mileage may vary on using ProcessPoolExecutor implementations with this parameter.</p> <p> TYPE: <code>typing.Optional[concurrent.futures.Executor]</code> DEFAULT: <code>None</code> </p> <code>http_settings</code> <p>Optional custom HTTP configuration settings to use. Allows you to customise functionality such as whether SSL-verification is enabled, what timeouts <code>aiohttp</code> should expect to use for requests, and behavior regarding HTTP-redirects.</p> <p> TYPE: <code>typing.Optional[hikari.impl.HTTPSettings]</code> DEFAULT: <code>None</code> </p> <code>max_body_size</code> <p>The maximum body size this should allow received request bodies to be in bytes before failing the request with a 413 - Content Too Large.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1024 ** 2</code> </p> <code>max_rate_limit</code> <p>The max number of seconds to backoff for when rate limited. Anything greater than this will instead raise an error.</p> <p>This defaults to five minutes to stop potentially indefinitely waiting on an endpoint, which is almost never what you want to do if giving a response to a user.</p> <p>You can set this to <code>float(\"inf\")</code> to disable this check entirely. Note that this only applies to the REST API component that communicates with Discord, and will not affect sharding or third party HTTP endpoints that may be in use.</p> <p> TYPE: <code>float</code> DEFAULT: <code>300.0</code> </p> <code>max_retries</code> <p>Maximum number of times a request will be retried if</p> <p>it fails with a <code>5xx</code> status. Defaults to 3 if set to None.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> <code>proxy_settings</code> <p>Custom proxy settings to use with network-layer logic in your application to get through an HTTP-proxy.</p> <p> TYPE: <code>typing.Optional[hikari.impl.ProxySettings]</code> DEFAULT: <code>None</code> </p> <code>public_key</code> <p>The public key to use to verify received interaction requests.</p> <p>This may be a hex encoded <code>str</code> or the raw <code>bytes</code>. If left as None then the client will try to work this value out based on <code>token</code>.</p> <p> TYPE: <code>typing.Union[bytes, str, None]</code> DEFAULT: <code>None</code> </p> <code>rest_url</code> <p>Defaults to the Discord REST API URL if None. Can be overridden if you are attempting to point to an unofficial endpoint, or if you are attempting to mock/stub the Discord API for any reason.</p> <p>Generally you do not want to change this.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <ul> <li>If <code>token_type</code> is provided when a token strategy is passed for <code>token</code>.</li> <li>if <code>token_type</code> is left as None when a string is passed for <code>token</code>.</li> </ul>"},{"location":"reference/#yuyo.asgi.AsgiBot.add_shutdown_callback","title":"add_shutdown_callback","text":"<pre><code>add_shutdown_callback(callback)\n</code></pre> <p>Add a callback to be called when the bot shuts down.</p> <p>Warning</p> <p>These callbacks will block the bot from shutting down until they complete and any raised errors will lead to a failed shutdown.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The shutdown callback to add.</p> <p> TYPE: <code>collections.Callable[[Self], collections.Coroutine[typing.Any, typing.Any, None]]</code> </p>"},{"location":"reference/#yuyo.asgi.AsgiBot.add_startup_callback","title":"add_startup_callback","text":"<pre><code>add_startup_callback(callback)\n</code></pre> <p>Add a callback to be called when the bot starts up.</p> <p>Warning</p> <p>These callbacks will block the bot from starting until they complete and any raised errors will lead to a failed startup.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The startup callback to add.</p> <p> TYPE: <code>collections.Callable[[Self], collections.Coroutine[typing.Any, typing.Any, None]]</code> </p>"},{"location":"reference/#yuyo.asgi.AsgiBot.close","title":"close  <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Close the bot's REST client.</p> <p>Warning</p> <p>Unless <code>asgi_managed=False</code> is passed to <code>AsgiBot.__init__</code>, the bot will be automatically closed based on the ASGI lifespan events and any other calls to this function will raise a RuntimeError.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the client isn't alive. If the client is ASGI managed.</p>"},{"location":"reference/#yuyo.asgi.AsgiBot.remove_shutdown_callback","title":"remove_shutdown_callback","text":"<pre><code>remove_shutdown_callback(callback)\n</code></pre> <p>Remove a shutdown callback.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The shutdown callback to remove.</p> <p> TYPE: <code>collections.Callable[[Self], collections.Coroutine[typing.Any, typing.Any, None]]</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the callback was not registered.</p>"},{"location":"reference/#yuyo.asgi.AsgiBot.remove_startup_callback","title":"remove_startup_callback","text":"<pre><code>remove_startup_callback(callback)\n</code></pre> <p>Remove a startup callback.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The startup callback to remove.</p> <p> TYPE: <code>collections.Callable[[Self], collections.Coroutine[typing.Any, typing.Any, None]]</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the callback was not registered.</p>"},{"location":"reference/#yuyo.asgi.AsgiBot.run","title":"run","text":"<pre><code>run()\n</code></pre> <p>Start the bot's REST client and wait until the bot's closed.</p> <p>Warning</p> <p>Unless <code>asgi_managed=False</code> is passed to AsgiBot.__init__, the bot will be automatically started and closed based on the ASGI lifespan events and any other calls to this function will raise a RuntimeError.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the client is already alive. If the client is ASGI managed.</p>"},{"location":"reference/#yuyo.asgi.AsgiBot.start","title":"start  <code>async</code>","text":"<pre><code>start()\n</code></pre> <p>Start the bot's REST client.</p> <p>Warning</p> <p>Unless <code>asgi_managed=False</code> is passed to AsgiBot.__init__, the bot will be automatically started based on the ASGI lifespan events and any other calls to this function will raise a RuntimeError.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the client is already alive. If the client is ASGI managed.</p>"},{"location":"reference/#yuyo.Backoff","title":"Backoff","text":"<p>Used to exponentially backoff asynchronously.</p> <p>This class acts as an asynchronous iterator and can be iterated over to provide implicit backoff where for every iteration other than the first this will either back off for the time passed to yuyo.backoff.Backoff.set_next_backoff if applicable or a time calculated exponentially.</p> <p>Each iteration yields the current retry count (starting at 0).</p> <p>Examples:</p> <p>An example of using this class as an asynchronous iterator may look like the following</p> <pre><code># While we can directly do `async for _ in Backoff()`, by assigning it to a\n# variable we allow ourself to provide a specific backoff time in some cases.\nbackoff = Backoff()\nasync for _ in backoff:\n    response = await client.fetch(f\"https://example.com/{resource_id}\")\n    if response.status_code == 403:  # Ratelimited\n        # If we have a specific backoff time then set it for the next iteration\n        backoff.set_next_backoff(response.headers.get(\"Retry-After\"))\n\n    elif response.status_code &gt;= 500:  # Internal server error\n        # Else let the iterator calculate an exponential backoff before the next loop.\n        pass\n\n    else:\n        response.raise_for_status()\n        resource = response.json()\n        # We need to break out of the iterator to make sure it doesn't backoff again.\n        # Alternatively `Backoff.finish()` can be called to break out of the loop.\n        break\n</code></pre> <p>Alternatively you may want to explicitly call yuyo.backoff.Backoff.backoff, a alternative of the previous example which uses yuyo.backoff.Backoff.backoff may look like the following</p> <pre><code>backoff = Backoff()\nresource = None\nwhile not resource:\n    response = await client.fetch(f\"https://example.com/{resource_id}\")\n    if response == 403  # Ratelimited\n        # If we have a specific backoff time then set it for the next iteration.\n        backoff.set_next_backoff(response.headers.get(\"Retry-After\"))\n        await backoff.backoff()  # We must explicitly backoff in this flow.\n\n    elif response &gt;= 500:  # Internal server error\n        # Else let the iterator calculate an exponential backoff and explicitly backoff.\n        await backoff.backoff()\n\n    else:\n        response.raise_for_status()\n        resource = response.json()\n</code></pre>"},{"location":"reference/#yuyo.backoff.Backoff.is_depleted","title":"is_depleted  <code>property</code>","text":"<pre><code>is_depleted: bool\n</code></pre> <p>Whether \"max_retries\" has been reached.</p> <p>This can be used to workout whether the loop was explicitly broken out of using yuyo.backoff.Backoff.finish/<code>break</code> or if it hit \"max_retries\".</p>"},{"location":"reference/#yuyo.backoff.Backoff.__init__","title":"__init__","text":"<pre><code>__init__(max_retries=None, *, base=2.0, maximum=64.0, jitter_multiplier=1.0, initial_increment=0)\n</code></pre> <p>Initialise a backoff instance.</p> PARAMETER DESCRIPTION <code>max_retries</code> <p>The maximum amount of times this should iterate for between resets.</p> <p>If left as None then this iterator will be unlimited. This must be greater than or equal to 1.</p> <p> TYPE: <code>typing.Optional[int]</code> DEFAULT: <code>None</code> </p> <code>base</code> <p>The base to use.</p> <p> TYPE: <code>float</code> DEFAULT: <code>2.0</code> </p> <code>maximum</code> <p>The max value the backoff can be in a single iteration. Anything above this will be capped to this base value plus random jitter.</p> <p> TYPE: <code>float</code> DEFAULT: <code>64.0</code> </p> <code>jitter_multiplier</code> <p>The multiplier for the random jitter.</p> <p>Set to <code>0</code> to disable jitter.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> <code>initial_increment</code> <p>The initial increment to start at.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If an int that's too big to be represented as a float or a non-finite value is passed in place of a field that's annotated as float or if <code>max_retries</code> is less than <code>1</code>.</p>"},{"location":"reference/#yuyo.backoff.Backoff.backoff","title":"backoff  <code>async</code>","text":"<pre><code>backoff()\n</code></pre> <p>Sleep for the provided backoff or for the next exponent.</p> <p>This provides an alternative to iterating over this class.</p> RETURNS DESCRIPTION <code>int | None</code> <p>Whether this has reached the end of its iteration.</p> <p>If this returns True then that call didn't sleep as this has been marked as finished or has reached the max retries.</p>"},{"location":"reference/#yuyo.backoff.Backoff.finish","title":"finish","text":"<pre><code>finish()\n</code></pre> <p>Mark the iterator as finished to break out of the current loop.</p>"},{"location":"reference/#yuyo.backoff.Backoff.reset","title":"reset","text":"<pre><code>reset()\n</code></pre> <p>Reset the backoff to it's original state to reuse it.</p>"},{"location":"reference/#yuyo.backoff.Backoff.set_next_backoff","title":"set_next_backoff","text":"<pre><code>set_next_backoff(backoff_)\n</code></pre> <p>Specify a backoff time for the next iteration or yuyo.backoff.Backoff.backoff call.</p> <p>If this is called then the exponent won't be increased for this iteration.</p> <p>Note</p> <p>Calling this multiple times in a single iteration will overwrite any previously set next backoff.</p> PARAMETER DESCRIPTION <code>backoff_</code> <p>The amount of time to backoff for in seconds.</p> <p>If this is None then any previously set next backoff will be unset.</p> <p> TYPE: <code>typing.Union[float, int, None]</code> </p>"},{"location":"reference/#yuyo.BasicTimeout","title":"BasicTimeout","text":"<p>         Bases: <code>SlidingTimeout</code></p> <p>Deprecated alias of SlidingTimeout.</p>"},{"location":"reference/#yuyo.BotsGGService","title":"BotsGGService","text":"<p>https://discord.bots.gg status update service.</p>"},{"location":"reference/#yuyo.list_status.BotsGGService.__init__","title":"__init__","text":"<pre><code>__init__(token)\n</code></pre> <p>Initialise a bots.gg service.</p> PARAMETER DESCRIPTION <code>token</code> <p>Authorization token used to update the bot's status.</p> <p> TYPE: <code>str</code> </p>"},{"location":"reference/#yuyo.ChunkRequestFinishedEvent","title":"ChunkRequestFinishedEvent","text":"<p>         Bases: <code>hikari.ShardEvent</code></p> <p>Event that's dispatched when a specific chunk request has finished.</p> <p>This will be fired for every chunk request which has a nonce.</p>"},{"location":"reference/#yuyo.chunk_tracker.ChunkRequestFinishedEvent.chunk_count","title":"chunk_count  <code>property</code>","text":"<pre><code>chunk_count: int\n</code></pre> <p>The amount of chunk events which should've been received for this request.</p>"},{"location":"reference/#yuyo.chunk_tracker.ChunkRequestFinishedEvent.first_received_at","title":"first_received_at  <code>property</code>","text":"<pre><code>first_received_at: datetime.datetime\n</code></pre> <p>When the first response was received.</p>"},{"location":"reference/#yuyo.chunk_tracker.ChunkRequestFinishedEvent.guild_id","title":"guild_id  <code>property</code>","text":"<pre><code>guild_id: hikari.Snowflake\n</code></pre> <p>Id of the guild this chunk request was for.</p>"},{"location":"reference/#yuyo.chunk_tracker.ChunkRequestFinishedEvent.last_received_at","title":"last_received_at  <code>property</code>","text":"<pre><code>last_received_at: datetime.datetime\n</code></pre> <p>When the last response was received.</p>"},{"location":"reference/#yuyo.chunk_tracker.ChunkRequestFinishedEvent.missed_chunks","title":"missed_chunks  <code>property</code>","text":"<pre><code>missed_chunks: collections.Collection[int]\n</code></pre> <p>Collection of the chunk responses which were missed (if any).</p>"},{"location":"reference/#yuyo.chunk_tracker.ChunkRequestFinishedEvent.not_found_ids","title":"not_found_ids  <code>property</code>","text":"<pre><code>not_found_ids: collections.Collection[hikari.Snowflake]\n</code></pre> <p>Collection of the User IDs which weren't found.</p> <p>This is only relevant when <code>users</code> was specified while requesting the members.</p>"},{"location":"reference/#yuyo.chunk_tracker.ChunkRequestFinishedEvent.__init__","title":"__init__","text":"<pre><code>__init__(app, shard, data)\n</code></pre> <p>Initialise a chunk request finished event.</p> <p>This should never be initialised directly.</p>"},{"location":"reference/#yuyo.ChunkTracker","title":"ChunkTracker","text":"<p>Chunk payload event tracker.</p> <p>This will dispatch ShardFinishedChunkingEvent, FinishedChunkingEvent and ChunkRequestFinishedEvent events.</p> <p>To configure this to automatically request member chunks to fill a member and/or presence cache on startup and guild join see ChunkTracker.set_auto_chunk_members.</p> <p>Note</p> <p>ChunkTracker.request_guild_members ensures a request will be tracked as this only tracks chunk requests with a set nonce.</p>"},{"location":"reference/#yuyo.chunk_tracker.ChunkTracker.__init__","title":"__init__","text":"<pre><code>__init__(event_manager, rest, shards, /, *, timeout=datetime.timedelta(seconds=5))\n</code></pre> <p>Initialise a chunk tracker.</p> <p>For a shorthand for initialising this from a hikari.traits.GatewayBotAware see ChunkTracker.from_gateway_bot.</p> PARAMETER DESCRIPTION <code>event_manager</code> <p>The event manager this chunk tracker should dispatch events over.</p> <p> TYPE: <code>hikari.api.EventManager</code> </p> <code>rest</code> <p>The REST aware object this should use.</p> <p> TYPE: <code>hikari.RESTAware</code> </p> <code>shards</code> <p>The shard aware object this should use.</p> <p> TYPE: <code>hikari.ShardAware</code> </p> <code>timeout</code> <p>How long this should wait between chunks until deciding the request has finished early/incomplete.</p> <p> TYPE: <code>typing.Union[int, float, datetime.timedelta]</code> DEFAULT: <code>datetime.timedelta(seconds=5)</code> </p>"},{"location":"reference/#yuyo.chunk_tracker.ChunkTracker.from_gateway_bot","title":"from_gateway_bot  <code>classmethod</code>","text":"<pre><code>from_gateway_bot(bot, /, *, timeout=datetime.timedelta(seconds=5))\n</code></pre> <p>Initialise a chunk tracker from a gateway bot.</p> PARAMETER DESCRIPTION <code>bot</code> <p>The gateway bot this chunk tracker should use.</p> <p> TYPE: <code>hikari.traits.ShardAware</code> </p> <code>timeout</code> <p>How long this should wait between chunks until deciding the request has finished early/incomplete.</p> <p> TYPE: <code>typing.Union[int, float, datetime.timedelta]</code> DEFAULT: <code>datetime.timedelta(seconds=5)</code> </p>"},{"location":"reference/#yuyo.chunk_tracker.ChunkTracker.request_guild_members","title":"request_guild_members  <code>async</code>","text":"<pre><code>request_guild_members(guild, /, *, include_presences=hikari.UNDEFINED, query='', limit=0, users=hikari.UNDEFINED)\n</code></pre> <p>Request guild members.</p> <p>Note</p> <p>To request the full list of members, leave <code>query</code> as <code>\"\"</code> (empty string) and <code>limit</code> as <code>0</code>.</p> PARAMETER DESCRIPTION <code>guild</code> <p>The guild to request chunk for.</p> <p> TYPE: <code>hikari.SnowflakeishOr[hikari.PartialGuild]</code> </p> <code>include_presences</code> <p>If provided, whether to request presences.</p> <p> TYPE: <code>hikari.UndefinedOr[bool]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>query</code> <p>If not <code>\"\"</code>, request the members who's usernames starts with the string.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>limit</code> <p>Maximum number of members to send matching the query.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>users</code> <p>If provided, the users to request for.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.SnowflakeishSequence[hikari.User]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>When trying to specify <code>users</code> with <code>query</code>/<code>limit</code>, if <code>limit</code> is not between 0 and 100, both inclusive or if <code>users</code> length is over 100.</p> <code>hikari.errors.MissingIntentError</code> <p>When trying to request presences without the <code>GUILD_MEMBERS</code> or when trying to request the full list of members without <code>GUILD_PRESENCES</code>.</p>"},{"location":"reference/#yuyo.chunk_tracker.ChunkTracker.set_auto_chunk_members","title":"set_auto_chunk_members","text":"<pre><code>set_auto_chunk_members(state, /, *, chunk_presences=True)\n</code></pre> <p>Configure whether this should request member chunks in response to GUILD_CREATE.</p> <p>This may be useful for filling 3rd party caches but may conflict with the <code>auto_chunk_members</code> config of hikari.impl.gateway_bot.GatewayBot if it's enabled.</p> <p>Warning</p> <p>This will be ignored if Intents.GUILD_MEMBERS hasn't been declared.</p> PARAMETER DESCRIPTION <code>state</code> <p>Whether this should request member chunks when GUILD_CREATE events are received.</p> <p> TYPE: <code>bool</code> </p> <code>chunk_presences</code> <p>Whether this should also request member presences on these member chunks.</p> <p>This will be ignored if Intents.GUILD_PRESENCES hasn't been declared.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The chunk tracker object to enable call chaining.</p>"},{"location":"reference/#yuyo.ComponentClient","title":"ComponentClient","text":"<p>Client used to handle component executors within a REST or gateway flow.</p>"},{"location":"reference/#yuyo.components.ComponentClient.alluka","title":"alluka  <code>property</code>","text":"<pre><code>alluka: alluka_.abc.Client\n</code></pre> <p>The Alluka client being used for callback dependency injection.</p>"},{"location":"reference/#yuyo.components.ComponentClient.__init__","title":"__init__","text":"<pre><code>__init__(*, alluka=None, event_manager=None, event_managed=None, server=None)\n</code></pre> <p>Initialise a component client.</p> <p>This sets ComponentClient as a type dependency when <code>alluka</code> isn't passed.</p> <p>Note</p> <p>For an easier way to initialise the client from a bot see ComponentClient.from_gateway_bot, ComponentClient.from_rest_bot, and ComponentClient.from_tanjun.</p> PARAMETER DESCRIPTION <code>alluka</code> <p>The Alluka client to use for callback dependency injection in this client.</p> <p>If not provided then this will initialise its own Alluka client.</p> <p> TYPE: <code>typing.Optional[alluka_.abc.Client]</code> DEFAULT: <code>None</code> </p> <code>event_manager</code> <p>The event manager this client should listen to dispatched component interactions from if applicable.</p> <p> TYPE: <code>typing.Optional[hikari.api.EventManager]</code> DEFAULT: <code>None</code> </p> <code>event_managed</code> <p>Whether this client should be automatically opened and closed based on the lifetime events dispatched by <code>event_manager</code>.</p> <p>Defaults to True if an event manager is passed.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>server</code> <p>The server this client should listen to component interactions from if applicable.</p> <p> TYPE: <code>typing.Optional[hikari.api.InteractionServer]</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If <code>event_managed</code> is passed as True when <code>event_manager</code> is None.</p>"},{"location":"reference/#yuyo.components.ComponentClient.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Close the component client.</p>"},{"location":"reference/#yuyo.components.ComponentClient.deregister_executor","title":"deregister_executor","text":"<pre><code>deregister_executor(executor)\n</code></pre> <p>Remove a component executor by its custom IDs.</p> PARAMETER DESCRIPTION <code>executor</code> <p>The executor to remove.</p> <p> TYPE: <code>AbstractComponentExecutor</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The component client to allow chaining.</p>"},{"location":"reference/#yuyo.components.ComponentClient.deregister_message","title":"deregister_message","text":"<pre><code>deregister_message(message)\n</code></pre> <p>Remove a component executor by its message.</p> PARAMETER DESCRIPTION <code>message</code> <p>The message to remove the executor for.</p> <p> TYPE: <code>hikari.SnowflakeishOr[hikari.Message]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The component client to allow chaining.</p>"},{"location":"reference/#yuyo.components.ComponentClient.from_gateway_bot","title":"from_gateway_bot  <code>classmethod</code>","text":"<pre><code>from_gateway_bot(bot, /, *, alluka=None, event_managed=True)\n</code></pre> <p>Build a component client from a Gateway Bot.</p> <p>This sets ComponentClient as a type dependency when <code>alluka</code> isn't passed.</p> PARAMETER DESCRIPTION <code>bot</code> <p>The Gateway bot this component client should be bound to.</p> <p> TYPE: <code>hikari.EventManagerAware</code> </p> <code>alluka</code> <p>The Alluka client to use for callback dependency injection in this client.</p> <p>If not provided then this will initialise its own Alluka client.</p> <p> TYPE: <code>typing.Optional[alluka_.abc.Client]</code> DEFAULT: <code>None</code> </p> <code>event_managed</code> <p>Whether the component client should be automatically opened and closed based on the lifetime events dispatched by <code>bot</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>ComponentClient</code> <p>The initialised component client.</p>"},{"location":"reference/#yuyo.components.ComponentClient.from_rest_bot","title":"from_rest_bot  <code>classmethod</code>","text":"<pre><code>from_rest_bot(bot, /, *, alluka=None, bot_managed=False)\n</code></pre> <p>Build a component client from a REST Bot.</p> <p>This sets ComponentClient as a type dependency when <code>alluka</code> isn't passed.</p> PARAMETER DESCRIPTION <code>bot</code> <p>The REST bot this component client should be bound to.</p> <p> TYPE: <code>hikari.RESTBotAware</code> </p> <code>alluka</code> <p>The Alluka client to use for callback dependency injection in this client.</p> <p>If not provided then this will initialise its own Alluka client.</p> <p> TYPE: <code>typing.Optional[alluka_.abc.Client]</code> DEFAULT: <code>None</code> </p> <code>bot_managed</code> <p>Whether the component client should be automatically opened and closed based on the Bot's startup and shutdown callbacks.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>ComponentClient</code> <p>The initialised component client.</p>"},{"location":"reference/#yuyo.components.ComponentClient.from_tanjun","title":"from_tanjun  <code>classmethod</code>","text":"<pre><code>from_tanjun(tanjun_client, /, *, tanjun_managed=True)\n</code></pre> <p>Build a component client from a Tanjun client.</p> <p>This will use the Tanjun client's alluka client and registers ComponentClient as a type dependency on Tanjun.</p> PARAMETER DESCRIPTION <code>tanjun_client</code> <p>The Tanjun client this component client should be bound to.</p> <p> TYPE: <code>tanjun.abc.Client</code> </p> <code>tanjun_managed</code> <p>Whether the component client should be automatically opened and closed based on the Tanjun client's lifetime client callback.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>ComponentClient</code> <p>The initialised component client.</p>"},{"location":"reference/#yuyo.components.ComponentClient.get_constant_id","title":"get_constant_id","text":"<pre><code>get_constant_id(custom_id)\n</code></pre> <p>Deprecated method for getting the constant callback for a custom ID.</p> <p>These now use the normal executor system through SingleExecutor.</p>"},{"location":"reference/#yuyo.components.ComponentClient.get_executor","title":"get_executor","text":"<pre><code>get_executor(message)\n</code></pre> <p>Deprecated alias of ComponentClient.get_executor_for_message.</p>"},{"location":"reference/#yuyo.components.ComponentClient.get_executor_for_message","title":"get_executor_for_message","text":"<pre><code>get_executor_for_message(message)\n</code></pre> <p>Get the component executor set for a message.</p> PARAMETER DESCRIPTION <code>message</code> <p>The message to get the executor for.</p> <p> TYPE: <code>hikari.SnowflakeishOr[hikari.Message]</code> </p> RETURNS DESCRIPTION <code>yuyo.components.AbstractComponentExecutor | None</code> <p>The executor set for the message or None if none is set.</p>"},{"location":"reference/#yuyo.components.ComponentClient.on_gateway_event","title":"on_gateway_event  <code>async</code>","text":"<pre><code>on_gateway_event(event)\n</code></pre> <p>Process an interaction create gateway event.</p> PARAMETER DESCRIPTION <code>event</code> <p>The interaction create gateway event to process.</p> <p> TYPE: <code>hikari.InteractionCreateEvent</code> </p>"},{"location":"reference/#yuyo.components.ComponentClient.on_rest_request","title":"on_rest_request  <code>async</code>","text":"<pre><code>on_rest_request(interaction)\n</code></pre> <p>Process a component interaction REST request.</p> PARAMETER DESCRIPTION <code>interaction</code> <p>The interaction to process.</p> <p> TYPE: <code>hikari.ComponentInteraction</code> </p> RETURNS DESCRIPTION <code>ResponseT</code> <p>The REST response.</p>"},{"location":"reference/#yuyo.components.ComponentClient.open","title":"open","text":"<pre><code>open()\n</code></pre> <p>Startup the component client.</p>"},{"location":"reference/#yuyo.components.ComponentClient.register_executor","title":"register_executor","text":"<pre><code>register_executor(executor, /, *, message=None, timeout=_internal.NO_DEFAULT)\n</code></pre> <p>Add an executor to this client.</p> PARAMETER DESCRIPTION <code>executor</code> <p>The executor to register.</p> <p> TYPE: <code>AbstractComponentExecutor</code> </p> <code>message</code> <p>The message to register this executor for.</p> <p>If this is left as None then this executor will be registered globally for its custom IDs.</p> <p> TYPE: <code>typing.Optional[hikari.SnowflakeishOr[hikari.Message]]</code> DEFAULT: <code>None</code> </p> <code>timeout</code> <p>The executor's timeout.</p> <p>This defaults to a 30 second sliding timeout.</p> <p> TYPE: <code>typing.Optional[yuyo.timeouts.AbstractTimeout]</code> DEFAULT: <code>_internal.NO_DEFAULT</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The component client to allow chaining.</p>"},{"location":"reference/#yuyo.components.ComponentClient.remove_constant_id","title":"remove_constant_id","text":"<pre><code>remove_constant_id(custom_id)\n</code></pre> <p>Deprecated method for removing a constant callback by custom ID.</p> <p>These now use the normal executor system through SingleExecutor.</p>"},{"location":"reference/#yuyo.components.ComponentClient.remove_executor","title":"remove_executor","text":"<pre><code>remove_executor(message)\n</code></pre> <p>Deprecated alias for ComponentClient.deregister_message.</p>"},{"location":"reference/#yuyo.components.ComponentClient.set_constant_id","title":"set_constant_id","text":"<pre><code>set_constant_id(custom_id, callback, /, *, prefix_match=True)\n</code></pre> <p>Deprecated approach for adding callbacks which'll always be called for a specific custom ID.</p> <p>You should now use SingleExecutor with ComponentClient.register_executor (making sure to pass <code>timeout=None</code>).</p> <p>Examples:</p> <pre><code>@yuyo.components.as_single_executor(\"custom_id\")\nasync def callback(ctx: yuyo.components.Context) -&gt; None:\n    await ctx.respond(\"hi\")\n\n(\n    yuyo.components.Client()\n    .register_executor(SingleExecutor(\"custom_id\", callback), timeout=None)\n)\n</code></pre>"},{"location":"reference/#yuyo.components.ComponentClient.set_executor","title":"set_executor","text":"<pre><code>set_executor(message, executor)\n</code></pre> <p>Deprecated method for setting the component executor for a message.</p> <p>Use ComponentClient.register_executor with the <code>message</code> kwarg instead.</p>"},{"location":"reference/#yuyo.components.ComponentClient.with_constant_id","title":"with_constant_id","text":"<pre><code>with_constant_id(custom_id, /, *, prefix_match=True)\n</code></pre> <p>Deprecated approach for adding callbacks which'll always be called for a specific custom ID.</p> <p>You should now use SingleExecutor with ComponentClient.register_executor (making sure to pass <code>timeout=None</code>).</p> <p>Examples:</p> <pre><code>@yuyo.components.as_single_executor(\"custom_id\")\nasync def callback(ctx: yuyo.components.Context) -&gt; None:\n    await ctx.respond(\"hi\")\n\n(\n    yuyo.components.Client()\n    .register_executor(SingleExecutor(\"custom_id\", callback), timeout=None)\n)\n</code></pre>"},{"location":"reference/#yuyo.ComponentContext","title":"ComponentContext","text":"<p>         Bases: <code>BaseContext[hikari.ComponentInteraction]</code></p> <p>The context used for message component triggers.</p>"},{"location":"reference/#yuyo.components.ComponentContext.client","title":"client  <code>property</code>","text":"<pre><code>client: ComponentClient\n</code></pre> <p>The component client this context is bound to.</p>"},{"location":"reference/#yuyo.components.ComponentContext.select_channels","title":"select_channels  <code>property</code>","text":"<pre><code>select_channels: collections.Mapping[hikari.Snowflake, hikari.InteractionChannel]\n</code></pre> <p>Deprecated alias of .selected_channels.</p>"},{"location":"reference/#yuyo.components.ComponentContext.select_members","title":"select_members  <code>property</code>","text":"<pre><code>select_members: collections.Mapping[hikari.Snowflake, hikari.InteractionMember]\n</code></pre> <p>Deprecated alias of .selected_members.</p>"},{"location":"reference/#yuyo.components.ComponentContext.select_roles","title":"select_roles  <code>property</code>","text":"<pre><code>select_roles: collections.Mapping[hikari.Snowflake, hikari.Role]\n</code></pre> <p>Deprecated alias of .selected_roles.</p>"},{"location":"reference/#yuyo.components.ComponentContext.select_texts","title":"select_texts  <code>property</code>","text":"<pre><code>select_texts: collections.Sequence[str]\n</code></pre> <p>Deprecated alias of .selected_texts.</p>"},{"location":"reference/#yuyo.components.ComponentContext.select_users","title":"select_users  <code>property</code>","text":"<pre><code>select_users: collections.Mapping[hikari.Snowflake, hikari.User]\n</code></pre> <p>Deprecated alias of .selected_users.</p>"},{"location":"reference/#yuyo.components.ComponentContext.selected_channels","title":"selected_channels  <code>property</code>","text":"<pre><code>selected_channels: collections.Mapping[hikari.Snowflake, hikari.InteractionChannel]\n</code></pre> <p>Sequence of the users passed for a channel select menu.</p>"},{"location":"reference/#yuyo.components.ComponentContext.selected_members","title":"selected_members  <code>property</code>","text":"<pre><code>selected_members: collections.Mapping[hikari.Snowflake, hikari.InteractionMember]\n</code></pre> <p>Sequence of the members passed for a user select menu.</p> <p>This will also include some of the values for a mentionable select menu.</p>"},{"location":"reference/#yuyo.components.ComponentContext.selected_roles","title":"selected_roles  <code>property</code>","text":"<pre><code>selected_roles: collections.Mapping[hikari.Snowflake, hikari.Role]\n</code></pre> <p>Sequence of the users passed for a role select menu.</p> <p>This will also include some of the values for a mentionable select menu.</p>"},{"location":"reference/#yuyo.components.ComponentContext.selected_texts","title":"selected_texts  <code>property</code>","text":"<pre><code>selected_texts: collections.Sequence[str]\n</code></pre> <p>Sequence of the values passed for a text select menu.</p>"},{"location":"reference/#yuyo.components.ComponentContext.selected_users","title":"selected_users  <code>property</code>","text":"<pre><code>selected_users: collections.Mapping[hikari.Snowflake, hikari.User]\n</code></pre> <p>Sequence of the users passed for a user select menu.</p> <p>This will also include some of the values for a mentionable select menu.</p> <p>ComponentContext.select_members has the full member objects.</p>"},{"location":"reference/#yuyo.components.ComponentContext.create_initial_response","title":"create_initial_response  <code>async</code>","text":"<pre><code>create_initial_response(content=hikari.UNDEFINED, *, response_type=hikari.ResponseType.MESSAGE_CREATE, delete_after=None, ephemeral=False, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, mentions_everyone=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED, flags=hikari.UNDEFINED, tts=hikari.UNDEFINED)\n</code></pre> <p>Create the initial response for this context.</p> <p>Warning</p> <p>Calling this on a context which already has an initial response will result in this raising a hikari.errors.NotFoundError. This includes if the REST interaction server has already responded to the request and deferrals.</p> PARAMETER DESCRIPTION <code>content</code> <p>The content to edit the last response with.</p> <p>If provided, the message contents. If hikari.undefined.UNDEFINED, then nothing will be sent in the content. Any other value here will be cast to a str.</p> <p>If this is a hikari.embeds.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.files.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> <p> TYPE: <code>hikari.UndefinedOr[typing.Any]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>response_type</code> <p>The type of message response to give.</p> <p> TYPE: <code>hikari.MessageResponseTypesT</code> DEFAULT: <code>hikari.ResponseType.MESSAGE_CREATE</code> </p> <code>delete_after</code> <p>If provided, the seconds after which the response message should be deleted.</p> <p>Slash command responses can only be deleted within 15 minutes of the command being received.</p> <p> TYPE: <code>typing.Union[datetime.timedelta, float, int, None]</code> DEFAULT: <code>None</code> </p> <code>ephemeral</code> <p>Whether the deferred response should be ephemeral.</p> <p>Passing True here is a shorthand for including <code>1 &lt;&lt; 64</code> in the passed flags.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>content</code> <p>If provided, the message contents. If hikari.undefined.UNDEFINED, then nothing will be sent in the content. Any other value here will be cast to a <code>str</code>.</p> <p>If this is a hikari.embeds.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone.</p> <p> TYPE: <code>hikari.UndefinedOr[typing.Any]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>attachment</code> <p>If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.Resourceish]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>attachments</code> <p>If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.</p> <p> TYPE: <code>hikari.UndefinedOr[collections.Sequence[hikari.Resourceish]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>component</code> <p>If provided, builder object of the component to include in this message.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.api.ComponentBuilder]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>components</code> <p>If provided, a sequence of the component builder objects to include in this message.</p> <p> TYPE: <code>hikari.UndefinedOr[collections.Sequence[hikari.api.ComponentBuilder]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>embed</code> <p>If provided, the message embed.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.Embed]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>embeds</code> <p>If provided, the message embeds.</p> <p> TYPE: <code>hikari.UndefinedOr[collections.Sequence[hikari.Embed]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>flags</code> <p>If provided, the message flags this response should have.</p> <p>As of writing the only message flag which can be set here is hikari.messages.MessageFlag.EPHEMERAL.</p> <p> TYPE: <code>typing.Union[int, hikari.MessageFlag, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>tts</code> <p>If provided, whether the message will be read out by a screen reader using Discord's TTS (text-to-speech) system.</p> <p> TYPE: <code>hikari.UndefinedOr[bool]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>mentions_everyone</code> <p>If provided, whether the message should parse @everyone/@here mentions.</p> <p> TYPE: <code>hikari.UndefinedOr[bool]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>user_mentions</code> <p>If provided, and True, all user mentions will be detected. If provided, and False, all user mentions will be ignored if appearing in the message body.</p> <p>Alternatively this may be a collection of hikari.snowflakes.Snowflake, or hikari.users.PartialUser derivatives to enforce mentioning specific users.</p> <p> TYPE: <code>typing.Union[hikari.SnowflakeishSequence[hikari.PartialUser], bool, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>role_mentions</code> <p>If provided, and True, all role mentions will be detected. If provided, and False, all role mentions will be ignored if appearing in the message body.</p> <p>Alternatively this may be a collection of [hikari.snowflakes.Snowflake], or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles.</p> <p> TYPE: <code>typing.Union[hikari.SnowflakeishSequence[hikari.PartialRole], bool, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If more than 100 unique objects/entities are passed for <code>role_mentions</code> or <code>user_mentions</code>.</p> <p>If the interaction will have expired before <code>delete_after</code> is reached.</p> <p>If both <code>attachment</code> and <code>attachments</code> are passed or both <code>component</code> and <code>components</code> are passed or both <code>embed</code> and <code>embeds</code> are passed.</p> <code>hikari.BadRequestError</code> <p>This may be raised in several discrete situations, such as messages being empty with no embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; invalid image URLs in embeds.</p> <code>hikari.UnauthorizedError</code> <p>If you are unauthorized to make the request (invalid/missing token).</p> <code>hikari.NotFoundError</code> <p>If the interaction is not found or if the interaction's initial response has already been created.</p> <code>hikari.RateLimitTooLongError</code> <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> <code>hikari.InternalServerError</code> <p>If an internal error occurs on Discord while handling the request.</p>"},{"location":"reference/#yuyo.components.ComponentContext.create_modal_response","title":"create_modal_response  <code>async</code>","text":"<pre><code>create_modal_response(title, custom_id, /, *, component=hikari.UNDEFINED, components=hikari.UNDEFINED)\n</code></pre> <p>Send a modal as the initial response for this context.</p> <p>Warning</p> <p>This must be called as the first response to a context before any deferring.</p> PARAMETER DESCRIPTION <code>title</code> <p>The title that will show up in the modal.</p> <p> TYPE: <code>str</code> </p> <code>custom_id</code> <p>Developer set custom ID used for identifying interactions with this modal.</p> <p>Yuyo's Component client will only match against <code>custom_id.split(\":\", 1)[0]</code>, allowing metadata to be put after <code>\":\"</code>.</p> <p> TYPE: <code>str</code> </p> <code>component</code> <p>A component builder to send in this modal.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.api.ComponentBuilder]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>components</code> <p>A sequence of component builders to send in this modal.</p> <p> TYPE: <code>hikari.UndefinedOr[collections.Sequence[hikari.api.ComponentBuilder]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If both <code>component</code> and <code>components</code> are specified or if none are specified.</p> <code>hikari.BadRequestError</code> <p>When the requests' data is outside Discord's accept ranges/validation.</p> <code>hikari.UnauthorizedError</code> <p>If you are unauthorized to make the request (invalid/missing token).</p> <code>hikari.NotFoundError</code> <p>If the interaction is not found or if the interaction's initial response has already been created or deferred.</p> <code>hikari.RateLimitTooLongError</code> <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> <code>hikari.InternalServerError</code> <p>If an internal error occurs on Discord while handling the request.</p>"},{"location":"reference/#yuyo.components.ComponentContext.defer","title":"defer  <code>async</code>","text":"<pre><code>defer(*, defer_type=hikari.ResponseType.DEFERRED_MESSAGE_CREATE, ephemeral=False, flags=hikari.UNDEFINED)\n</code></pre> <p>Defer the initial response for this context.</p> <p>Note</p> <p>The ephemeral state of the first response is decided by whether the deferral is ephemeral.</p> PARAMETER DESCRIPTION <code>defer_type</code> <p>The type of deferral this should be.</p> <p>This may any of the following * ResponseType.DEFERRED_MESSAGE_CREATE to indicate that the following up call to yuyo.components.BaseContext.edit_initial_response or yuyo.components.BaseContext.respond should create a new message. * ResponseType.DEFERRED_MESSAGE_UPDATE to indicate that the following call to the aforementioned methods should update the existing message.</p> <p> TYPE: <code>hikari.DeferredResponseTypesT</code> DEFAULT: <code>hikari.ResponseType.DEFERRED_MESSAGE_CREATE</code> </p> <code>ephemeral</code> <p>Whether the deferred response should be ephemeral.</p> <p>Passing True here is a shorthand for including <code>1 &lt;&lt; 64</code> in the passed flags.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>flags</code> <p>The flags to use for the initial response.</p> <p> TYPE: <code>typing.Union[hikari.UndefinedType, int, hikari.MessageFlag]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p>"},{"location":"reference/#yuyo.ComponentExecutor","title":"ComponentExecutor","text":"<p>         Bases: <code>AbstractComponentExecutor</code></p> <p>implementation of a component executor with per-custom ID callbacks.</p>"},{"location":"reference/#yuyo.components.ComponentExecutor.callbacks","title":"callbacks  <code>property</code>","text":"<pre><code>callbacks: collections.Mapping[str, CallbackSig]\n</code></pre> <p>Mapping of custom IDs to their set callbacks.</p>"},{"location":"reference/#yuyo.components.ComponentExecutor.__init__","title":"__init__","text":"<pre><code>__init__(*, ephemeral_default=False, timeout=_internal.NO_DEFAULT, _stack_level=0)\n</code></pre> <p>Initialise a component executor.</p> PARAMETER DESCRIPTION <code>ephemeral_default</code> <p>Whether this executor's responses should default to being ephemeral.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"reference/#yuyo.components.ComponentExecutor.set_callback","title":"set_callback","text":"<pre><code>set_callback(custom_id, callback)\n</code></pre> <p>Set the callback for a custom ID.</p> PARAMETER DESCRIPTION <code>custom_id</code> <p>The custom ID to set the callback for.</p> <p>This will be matched against <code>interaction.custom_id.split(\":\", 1)[0]</code>, allowing metadata to be stored after a <code>\":\"</code>.</p> <p> TYPE: <code>str</code> </p> <code>callback</code> <p>The callback to set.</p> <p> TYPE: <code>CallbackSig</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If <code>\":\"</code> is in the custom ID.</p>"},{"location":"reference/#yuyo.components.ComponentExecutor.with_callback","title":"with_callback","text":"<pre><code>with_callback(custom_id)\n</code></pre> <p>Set the callback for a custom ID through a decorator callback.</p> PARAMETER DESCRIPTION <code>custom_id</code> <p>The custom ID to set the callback for.</p> <p>This will be matched against <code>interaction.custom_id.split(\":\", 1)[0]</code>, allowing metadata to be stored after a <code>\":\"</code>.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[CallbackSig], CallbackSig]</code> <p>Decorator callback used to set a custom ID's callback.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If <code>\":\"</code> is in the custom ID.</p>"},{"location":"reference/#yuyo.ComponentPaginator","title":"ComponentPaginator","text":"<p>         Bases: <code>ActionRowExecutor</code></p> <p>Standard implementation of an action row executor used for pagination.</p> <p>This is a convenience class that allows you to easily implement a paginator.</p>"},{"location":"reference/#yuyo.components.ComponentPaginator.__init__","title":"__init__","text":"<pre><code>__init__(iterator, /, *, authors=None, ephemeral_default=False, triggers=(pagination.LEFT_TRIANGLE, pagination.STOP_SQUARE, pagination.RIGHT_TRIANGLE), timeout=_internal.NO_DEFAULT)\n</code></pre> <p>Initialise a component paginator.</p> PARAMETER DESCRIPTION <code>iterator</code> <p>The iterator to paginate.</p> <p>This should be an iterator of tuples of <code>(hikari.UndefinedOr[str], hikari.UndefinedOr[hikari.Embed])</code>.</p> <p> TYPE: <code>collections.Iterator[yuyo.pagination.EntryT] | collections.AsyncIterator[yuyo.pagination.EntryT]</code> </p> <code>authors</code> <p>The authors of the entries.</p> <p>If None is passed here then the paginator will be public (meaning that anybody can use it).</p> <p> TYPE: <code>typing.Optional[collections.Iterable[hikari.SnowflakeishOr[hikari.User]]]</code> DEFAULT: <code>None</code> </p> <code>ephemeral_default</code> <p>Whether or not the responses made on contexts spawned from this paginator should default to ephemeral (meaning only the author can see them) unless <code>flags</code> is specified on the response method.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>triggers</code> <p>Collection of the unicode emojis that should trigger this paginator.</p> <p>As of current the only usable emojis are yuyo.pagination.LEFT_TRIANGLE, yuyo.pagination.RIGHT_TRIANGLE, yuyo.pagination.STOP_SQUARE, yuyo.pagination.LEFT_DOUBLE_TRIANGLE and yuyo.pagination.LEFT_TRIANGLE.</p> <p> TYPE: <code>collections.Collection[str]</code> DEFAULT: <code>(pagination.LEFT_TRIANGLE, pagination.STOP_SQUARE, pagination.RIGHT_TRIANGLE)</code> </p>"},{"location":"reference/#yuyo.components.ComponentPaginator.add_first_button","title":"add_first_button","text":"<pre><code>add_first_button(*, style=hikari.ButtonStyle.SECONDARY, custom_id=None, emoji=pagination.LEFT_DOUBLE_TRIANGLE, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add the jump to first entry button to this paginator.</p> <p>You should pass <code>triggers=[]</code> to [yuyo.components.ComponentPaginator.init][ComponentPaginator.__init__] before calling this.</p> <p>Note</p> <p>These buttons will appear in the order these methods were called in.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> PARAMETER DESCRIPTION <code>style</code> <p>The button's style.</p> <p> TYPE: <code>hikari.InteractiveButtonTypesT</code> DEFAULT: <code>hikari.ButtonStyle.SECONDARY</code> </p> <code>emoji</code> <p>Emoji to display on this button.</p> <p> TYPE: <code>typing.Union[hikari.Snowflakeish, hikari.Emoji, str, hikari.UndefinedType]</code> DEFAULT: <code>pagination.LEFT_DOUBLE_TRIANGLE</code> </p> <code>label</code> <p>Label to display on this button.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>is_disabled</code> <p>Whether to make this button as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>To enable chained calls.</p>"},{"location":"reference/#yuyo.components.ComponentPaginator.add_last_button","title":"add_last_button","text":"<pre><code>add_last_button(*, style=hikari.ButtonStyle.SECONDARY, custom_id=None, emoji=pagination.RIGHT_DOUBLE_TRIANGLE, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add the jump to last entry button to this paginator.</p> <p>You should pass <code>triggers=[]</code> to [yuyo.components.ComponentPaginator.init][ComponentPaginator.__init__] before calling this.</p> <p>Note</p> <p>These buttons will appear in the order these methods were called in.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> PARAMETER DESCRIPTION <code>style</code> <p>The button's style.</p> <p> TYPE: <code>hikari.InteractiveButtonTypesT</code> DEFAULT: <code>hikari.ButtonStyle.SECONDARY</code> </p> <code>emoji</code> <p>Emoji to display on this button.</p> <p>Either this or <code>label</code> must be provided, but not both.</p> <p> TYPE: <code>typing.Union[hikari.Snowflakeish, hikari.Emoji, str, hikari.UndefinedType]</code> DEFAULT: <code>pagination.RIGHT_DOUBLE_TRIANGLE</code> </p> <code>label</code> <p>Label to display on this button.</p> <p>Either this or <code>emoji</code> must be provided, but not both.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>is_disabled</code> <p>Whether to make this button as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>To enable chained calls.</p>"},{"location":"reference/#yuyo.components.ComponentPaginator.add_next_button","title":"add_next_button","text":"<pre><code>add_next_button(*, style=hikari.ButtonStyle.SECONDARY, custom_id=None, emoji=pagination.RIGHT_TRIANGLE, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add the next entry button to this paginator.</p> <p>You should pass <code>triggers=[]</code> to [yuyo.components.ComponentPaginator.init][ComponentPaginator.__init__] before calling this.</p> <p>Note</p> <p>These buttons will appear in the order these methods were called in.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> PARAMETER DESCRIPTION <code>style</code> <p>The button's style.</p> <p> TYPE: <code>hikari.InteractiveButtonTypesT</code> DEFAULT: <code>hikari.ButtonStyle.SECONDARY</code> </p> <code>emoji</code> <p>Emoji to display on this button.</p> <p>Either this or <code>label</code> must be provided, but not both.</p> <p> TYPE: <code>typing.Union[hikari.Snowflakeish, hikari.Emoji, str, hikari.UndefinedType]</code> DEFAULT: <code>pagination.RIGHT_TRIANGLE</code> </p> <code>label</code> <p>Label to display on this button.</p> <p>Either this or <code>emoji</code> must be provided, but not both.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>is_disabled</code> <p>Whether to make this button as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>To enable chained calls.</p>"},{"location":"reference/#yuyo.components.ComponentPaginator.add_previous_button","title":"add_previous_button","text":"<pre><code>add_previous_button(*, style=hikari.ButtonStyle.SECONDARY, custom_id=None, emoji=pagination.LEFT_TRIANGLE, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add the previous entry button to this paginator.</p> <p>You should pass <code>triggers=[]</code> to [yuyo.components.ComponentPaginator.init][ComponentPaginator.__init__] before calling this.</p> <p>Note</p> <p>These buttons will appear in the order these methods were called in.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> PARAMETER DESCRIPTION <code>style</code> <p>The button's style.</p> <p> TYPE: <code>hikari.InteractiveButtonTypesT</code> DEFAULT: <code>hikari.ButtonStyle.SECONDARY</code> </p> <code>emoji</code> <p>Emoji to display on this button.</p> <p>Either this or <code>label</code> must be provided, but not both.</p> <p> TYPE: <code>typing.Union[hikari.Snowflakeish, hikari.Emoji, str, hikari.UndefinedType]</code> DEFAULT: <code>pagination.LEFT_TRIANGLE</code> </p> <code>label</code> <p>Label to display on this button.</p> <p>Either this or <code>emoji</code> must be provided, but not both.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>is_disabled</code> <p>Whether to make this button as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>To enable chained calls.</p>"},{"location":"reference/#yuyo.components.ComponentPaginator.add_stop_button","title":"add_stop_button","text":"<pre><code>add_stop_button(*, style=hikari.ButtonStyle.DANGER, custom_id=None, emoji=pagination.BLACK_CROSS, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add the stop button to this paginator.</p> <p>You should pass <code>triggers=[]</code> to [yuyo.components.ComponentPaginator.init][ComponentPaginator.__init__] before calling this.</p> <p>Note</p> <p>These buttons will appear in the order these methods were called in.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> PARAMETER DESCRIPTION <code>style</code> <p>The button's style.</p> <p> TYPE: <code>hikari.InteractiveButtonTypesT</code> DEFAULT: <code>hikari.ButtonStyle.DANGER</code> </p> <code>emoji</code> <p>Emoji to display on this button.</p> <p>Either this or <code>label</code> must be provided, but not both.</p> <p> TYPE: <code>typing.Union[hikari.Snowflakeish, hikari.Emoji, str, hikari.UndefinedType]</code> DEFAULT: <code>pagination.BLACK_CROSS</code> </p> <code>label</code> <p>Label to display on this button.</p> <p>Either this or <code>emoji</code> must be provided, but not both.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>is_disabled</code> <p>Whether to make this button as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>To enable chained calls.</p>"},{"location":"reference/#yuyo.components.ComponentPaginator.builder","title":"builder","text":"<pre><code>builder()\n</code></pre> <p>Get a sequence of the component builders for this paginator.</p> RETURNS DESCRIPTION <code>collections.abc.Sequence[hikari.api.ComponentBuilder]</code> <p>The component builders for this paginator.</p>"},{"location":"reference/#yuyo.components.ComponentPaginator.get_next_entry","title":"get_next_entry  <code>async</code>","text":"<pre><code>get_next_entry()\n</code></pre> <p>Get the next entry in this paginator.</p> <p>This is generally helpful for making the message which the paginator will be based off and will still internally store the entry and increment the position of the paginator.</p> <p>Examples:</p> <pre><code>response_paginator = yuyo.ComponentPaginator(pages, authors=[ctx.author.id])\nfirst_response = await response_paginator.get_next_entry()\nassert first_response\nmessage = await ctx.respond(component=response_paginator, **first_response.to_kwargs(), ensure_result=True)\ncomponent_client.register_executor(response_paginator, message=message)\n</code></pre> RETURNS DESCRIPTION <code>yuyo.pagination.Page | None</code> <p>The next entry in this paginator, or None if there are no more entries.</p>"},{"location":"reference/#yuyo.DiscordBotListService","title":"DiscordBotListService","text":"<p>https://discordbotlist.com status update service.</p>"},{"location":"reference/#yuyo.list_status.DiscordBotListService.__init__","title":"__init__","text":"<pre><code>__init__(token)\n</code></pre> <p>Initialise a discordbotlist.com service.</p> PARAMETER DESCRIPTION <code>token</code> <p>Authorization token used to update the bot's status.</p> <p> TYPE: <code>str</code> </p>"},{"location":"reference/#yuyo.ErrorManager","title":"ErrorManager","text":"<p>A context manager provided to allow for more concise error handling with yuyo.backoff.Backoff.</p> <p>Examples:</p> <p>The following is an example of using yuyo.backoff.ErrorManager alongside yuyo.backoff.Backoff in-order to handle the exceptions which may be raised while trying to reply to a message.</p> <pre><code>retry = Backoff()\n# Rules can either be passed to `ErrorManager`'s initiate as variable arguments\n# or one at a time to `ErrorManager.with_rule` through possibly chained-calls.\nerror_handler = (\n    # For the 1st rule we catch two errors which would indicate the bot\n    # no-longer has access to the target channel and break out of the\n    # retry loop using `Backoff.retry`.\n    ErrorManager(((NotFoundError, ForbiddenError), lambda _: retry.finish()))\n        # For the 2nd rule we catch rate limited errors and set their\n        # `retry` value as the next backoff time before suppressing the\n        # error to allow this to retry the request.\n        .with_rule((RateLimitedError,), lambda exc: retry.set_next_backoff(exc.retry_after))\n        # For the 3rd rule we suppress the internal server error to allow\n        # backoff to reach the next retry and exponentially backoff as we\n        # don't have any specific retry time for this error.\n        .with_rule((InternalServerError,), lambda _: False)\n)\nasync for _ in retry:\n    # We entre this context manager each iteration to catch errors before\n    # they cause us to break out of the `Backoff` loop.\n    with error_handler:\n        await post(f\"https://example.com/{resource_id}\", json={\"content\": \"General Kenobi\"})\n        # We need to break out of `retry` if this request succeeds.\n        break\n</code></pre>"},{"location":"reference/#yuyo.backoff.ErrorManager.__init__","title":"__init__","text":"<pre><code>__init__(*rules)\n</code></pre> <p>Initialise an error manager instance.</p> PARAMETER DESCRIPTION <code>*rules</code> <p>Rules to initiate this error context manager with.</p> <p>These are each a 2-length tuple where the <code>tuple[0]</code> is an iterable of types of the exceptions this rule should apply to and <code>tuple[1]</code> is the rule's callback function.</p> <p>The callback function will be called with the raised exception when it matches one of the passed exceptions for the relevant rule and may raise, return True to indicate that the current error should be raised outside of the context manager or False/None to suppress the current error.</p> <p> TYPE: <code>tuple[collections.Iterable[type[BaseException]], collections.Callable[[typing.Any], typing.Optional[bool]]]</code> DEFAULT: <code>()</code> </p>"},{"location":"reference/#yuyo.backoff.ErrorManager.add_rule","title":"add_rule","text":"<pre><code>add_rule(exceptions, result)\n</code></pre> <p>Add a rule to this exception context manager.</p> PARAMETER DESCRIPTION <code>exceptions</code> <p>An iterable of types of the exceptions this rule should apply to.</p> <p> TYPE: <code>collections.Iterable[type[BaseException]]</code> </p> <code>result</code> <p>The function called with the raised exception when it matches one of the passed <code>exceptions</code>. This may raise, return True to indicate that the current error should be raised outside of the context manager or False/None to suppress the current error.</p> <p> TYPE: <code>collections.Callable[[typing.Any], typing.Optional[bool]]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This returns the handler a rule was being added to in-order to allow for chained calls.</p>"},{"location":"reference/#yuyo.backoff.ErrorManager.clear_rules","title":"clear_rules","text":"<pre><code>clear_rules()\n</code></pre> <p>Clear the rules registered with this handler.</p>"},{"location":"reference/#yuyo.FinishedChunkingEvent","title":"FinishedChunkingEvent","text":"<p>         Bases: <code>hikari.Event</code></p> <p>Event that's dispatched when the startup chunking has finished for the bot.</p> <p>This indicates that the member and presence caches should be complete globally.</p> <p>This will only be fired once after bot startups.</p>"},{"location":"reference/#yuyo.chunk_tracker.FinishedChunkingEvent.__init__","title":"__init__","text":"<pre><code>__init__(app)\n</code></pre> <p>Initialise a chunking finished event.</p> <p>This should never be initialised directly.</p>"},{"location":"reference/#yuyo.ModalClient","title":"ModalClient","text":"<p>Client used to handle modals within a REST or gateway flow.</p>"},{"location":"reference/#yuyo.modals.ModalClient.alluka","title":"alluka  <code>property</code>","text":"<pre><code>alluka: alluka_.abc.Client\n</code></pre> <p>The Alluka client being used for callback dependency injection.</p>"},{"location":"reference/#yuyo.modals.ModalClient.__init__","title":"__init__","text":"<pre><code>__init__(*, alluka=None, event_manager=None, event_managed=None, server=None)\n</code></pre> <p>Initialise a modal client.</p> <p>This registers ModalClient as a type dependency when <code>alluka</code> isn't passed.</p> <p>Note</p> <p>For an easier way to initialise the client from a bot see ModalClient.from_gateway_bot, ModalClient.from_rest_bot, and ModalClient.from_tanjun.</p> PARAMETER DESCRIPTION <code>alluka</code> <p>The Alluka client to use for callback dependency injection in this client.</p> <p>If not provided then this will initialise its own Alluka client.</p> <p> TYPE: <code>typing.Optional[alluka_.abc.Client]</code> DEFAULT: <code>None</code> </p> <code>event_manager</code> <p>The event manager this client should listen to dispatched modal interactions from if applicable.</p> <p> TYPE: <code>typing.Optional[hikari.api.EventManager]</code> DEFAULT: <code>None</code> </p> <code>event_managed</code> <p>Whether this client should be automatically opened and closed based on the lifetime events dispatched by <code>event_manager</code>.</p> <p>Defaults to True if an event manager is passed.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>server</code> <p>The server this client should listen to modal interactions from if applicable.</p> <p> TYPE: <code>typing.Optional[hikari.api.InteractionServer]</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If <code>event_managed</code> is passed as True when <code>event_manager</code> is None.</p>"},{"location":"reference/#yuyo.modals.ModalClient.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Close the modal client.</p>"},{"location":"reference/#yuyo.modals.ModalClient.deregister_modal","title":"deregister_modal","text":"<pre><code>deregister_modal(custom_id)\n</code></pre> <p>Remove the modal set for a custom ID.</p> PARAMETER DESCRIPTION <code>custom_id</code> <p>The custom_id to unset the modal for.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The modal client to allow chaining.</p> RAISES DESCRIPTION <code>KeyError</code> <p>If the custom_id is not registered.</p>"},{"location":"reference/#yuyo.modals.ModalClient.from_gateway_bot","title":"from_gateway_bot  <code>classmethod</code>","text":"<pre><code>from_gateway_bot(bot, /, *, alluka=None, event_managed=True)\n</code></pre> <p>Build a modal client from a Gateway Bot.</p> <p>This registers ModalClient as a type dependency when <code>alluka</code> isn't passed.</p> PARAMETER DESCRIPTION <code>bot</code> <p>The Gateway bot this modal client should be bound to.</p> <p> TYPE: <code>hikari.EventManagerAware</code> </p> <code>alluka</code> <p>The Alluka client to use for callback dependency injection in this client.</p> <p>If not provided then this will initialise its own Alluka client.</p> <p> TYPE: <code>typing.Optional[alluka_.abc.Client]</code> DEFAULT: <code>None</code> </p> <code>event_managed</code> <p>Whether the modal client should be automatically opened and closed based on the lifetime events dispatched by <code>bot</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>ModalClient</code> <p>The initialised modal client.</p>"},{"location":"reference/#yuyo.modals.ModalClient.from_rest_bot","title":"from_rest_bot  <code>classmethod</code>","text":"<pre><code>from_rest_bot(bot, /, *, alluka=None, bot_managed=False)\n</code></pre> <p>Build a modal client from a REST Bot.</p> <p>This registers ModalClient as a type dependency when <code>alluka</code> isn't passed.</p> PARAMETER DESCRIPTION <code>bot</code> <p>The REST bot this modal client should be bound to.</p> <p> TYPE: <code>hikari.RESTBotAware</code> </p> <code>alluka</code> <p>The Alluka client to use for callback dependency injection in this client.</p> <p>If not provided then this will initialise its own Alluka client.</p> <p> TYPE: <code>typing.Optional[alluka_.abc.Client]</code> DEFAULT: <code>None</code> </p> <code>bot_managed</code> <p>Whether the modal client should be automatically opened and closed based on the Bot's startup and shutdown callbacks.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>ModalClient</code> <p>The initialised modal client.</p>"},{"location":"reference/#yuyo.modals.ModalClient.from_tanjun","title":"from_tanjun  <code>classmethod</code>","text":"<pre><code>from_tanjun(tanjun_client, /, *, tanjun_managed=True)\n</code></pre> <p>Build a modal client from a Tanjun client.</p> <p>This will use the Tanjun client's alluka client and registers ModalClient as a type dependency on Tanjun.</p> PARAMETER DESCRIPTION <code>tanjun_client</code> <p>The Tanjun client this modal client should be bound to.</p> <p> TYPE: <code>tanjun.abc.Client</code> </p> <code>tanjun_managed</code> <p>Whether the modal client should be automatically opened and closed based on the Tanjun client's lifetime client callback.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>ModalClient</code> <p>The initialised modal client.</p>"},{"location":"reference/#yuyo.modals.ModalClient.get_modal","title":"get_modal","text":"<pre><code>get_modal(custom_id)\n</code></pre> <p>Get the modal set for a custom ID.</p> PARAMETER DESCRIPTION <code>custom_id</code> <p>The custom_id to get the modal for.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>AbstractModal | None</code> <p>The callback for the custom_id, or None if it doesn't exist.</p>"},{"location":"reference/#yuyo.modals.ModalClient.on_gateway_event","title":"on_gateway_event  <code>async</code>","text":"<pre><code>on_gateway_event(event)\n</code></pre> <p>Process an interaction create gateway event.</p> PARAMETER DESCRIPTION <code>event</code> <p>The interaction create gateway event to process.</p> <p> TYPE: <code>hikari.InteractionCreateEvent</code> </p>"},{"location":"reference/#yuyo.modals.ModalClient.on_rest_request","title":"on_rest_request  <code>async</code>","text":"<pre><code>on_rest_request(interaction)\n</code></pre> <p>Process a modal interaction REST request.</p> PARAMETER DESCRIPTION <code>interaction</code> <p>The interaction to process.</p> <p> TYPE: <code>hikari.ModalInteraction</code> </p> RETURNS DESCRIPTION <code>hikari.api.InteractionMessageBuilder | hikari.api.InteractionDeferredBuilder</code> <p>The REST response.</p>"},{"location":"reference/#yuyo.modals.ModalClient.open","title":"open","text":"<pre><code>open()\n</code></pre> <p>Startup the modal client.</p>"},{"location":"reference/#yuyo.modals.ModalClient.register_modal","title":"register_modal","text":"<pre><code>register_modal(custom_id, modal, /, *, timeout=_internal.NO_DEFAULT)\n</code></pre> <p>Register a modal for a custom ID.</p> PARAMETER DESCRIPTION <code>custom_id</code> <p>The custom_id to register the modal for.</p> <p>This will be matched against <code>interaction.custom_id.split(\":\", 1)[0]</code>, allowing metadata to be stored after a <code>\":\"</code>.</p> <p> TYPE: <code>str</code> </p> <code>modal</code> <p>The modal to register.</p> <p> TYPE: <code>AbstractModal</code> </p> <code>timeout</code> <p>Timeout strategy for this modal.</p> <p>Passing None here will set NeverTimeout.</p> <p>This defaults to single use with a 2 minute timeout.</p> <p> TYPE: <code>typing.Union[timeouts.AbstractTimeout, None, _internal.NoDefault]</code> DEFAULT: <code>_internal.NO_DEFAULT</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The modal client to allow chaining.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the custom_id is already registered.</p> <p>If <code>\":\"</code> is in the custom ID.</p>"},{"location":"reference/#yuyo.ModalContext","title":"ModalContext","text":"<p>         Bases: <code>components_.BaseContext[hikari.ModalInteraction]</code></p> <p>The context used for modal triggers.</p>"},{"location":"reference/#yuyo.modals.ModalContext.client","title":"client  <code>property</code>","text":"<pre><code>client: ModalClient\n</code></pre> <p>The modal this context is bound to.</p>"},{"location":"reference/#yuyo.modals.ModalContext.component_ids","title":"component_ids  <code>property</code>","text":"<pre><code>component_ids: collections.abc.Mapping[str, str]\n</code></pre> <p>Mapping of match ID parts to metadata ID parts for the modal's components.</p>"},{"location":"reference/#yuyo.modals.ModalContext.create_initial_response","title":"create_initial_response  <code>async</code>","text":"<pre><code>create_initial_response(content=hikari.UNDEFINED, *, delete_after=None, ephemeral=False, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, mentions_everyone=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED, flags=hikari.UNDEFINED, tts=hikari.UNDEFINED)\n</code></pre> <p>Create the initial response for this context.</p> <p>Warning</p> <p>Calling this on a context which already has an initial response will result in this raising a hikari.errors.NotFoundError. This includes if the REST interaction server has already responded to the request and deferrals.</p> PARAMETER DESCRIPTION <code>content</code> <p>The content to edit the last response with.</p> <p>If provided, the message contents. If hikari.undefined.UNDEFINED, then nothing will be sent in the content. Any other value here will be cast to a str.</p> <p>If this is a hikari.embeds.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.files.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> <p> TYPE: <code>hikari.UndefinedOr[typing.Any]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>delete_after</code> <p>If provided, the seconds after which the response message should be deleted.</p> <p>Slash command responses can only be deleted within 15 minutes of the command being received.</p> <p> TYPE: <code>typing.Union[datetime.timedelta, float, int, None]</code> DEFAULT: <code>None</code> </p> <code>ephemeral</code> <p>Whether the deferred response should be ephemeral.</p> <p>Passing True here is a shorthand for including <code>1 &lt;&lt; 64</code> in the passed flags.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>content</code> <p>If provided, the message contents. If hikari.undefined.UNDEFINED, then nothing will be sent in the content. Any other value here will be cast to a <code>str</code>.</p> <p>If this is a hikari.embeds.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone.</p> <p> TYPE: <code>hikari.UndefinedOr[typing.Any]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>attachment</code> <p>If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.Resourceish]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>attachments</code> <p>If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.</p> <p> TYPE: <code>hikari.UndefinedOr[collections.abc.Sequence[hikari.Resourceish]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>component</code> <p>If provided, builder object of the component to include in this message.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.api.ComponentBuilder]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>components</code> <p>If provided, a sequence of the component builder objects to include in this message.</p> <p> TYPE: <code>hikari.UndefinedOr[collections.abc.Sequence[hikari.api.ComponentBuilder]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>embed</code> <p>If provided, the message embed.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.Embed]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>embeds</code> <p>If provided, the message embeds.</p> <p> TYPE: <code>hikari.UndefinedOr[collections.abc.Sequence[hikari.Embed]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>flags</code> <p>If provided, the message flags this response should have.</p> <p>As of writing the only message flag which can be set here is hikari.messages.MessageFlag.EPHEMERAL.</p> <p> TYPE: <code>typing.Union[int, hikari.MessageFlag, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>tts</code> <p>If provided, whether the message will be read out by a screen reader using Discord's TTS (text-to-speech) system.</p> <p> TYPE: <code>hikari.UndefinedOr[bool]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>mentions_everyone</code> <p>If provided, whether the message should parse @everyone/@here mentions.</p> <p> TYPE: <code>hikari.UndefinedOr[bool]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>user_mentions</code> <p>If provided, and True, all user mentions will be detected. If provided, and False, all user mentions will be ignored if appearing in the message body.</p> <p>Alternatively this may be a collection of hikari.snowflakes.Snowflake, or hikari.users.PartialUser derivatives to enforce mentioning specific users.</p> <p> TYPE: <code>typing.Union[hikari.SnowflakeishSequence[hikari.PartialUser], bool, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>role_mentions</code> <p>If provided, and True, all role mentions will be detected. If provided, and False, all role mentions will be ignored if appearing in the message body.</p> <p>Alternatively this may be a collection of [hikari.snowflakes.Snowflake], or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles.</p> <p> TYPE: <code>typing.Union[hikari.SnowflakeishSequence[hikari.PartialRole], bool, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If more than 100 unique objects/entities are passed for <code>role_mentions</code> or <code>user_mentions</code>.</p> <p>If the interaction will have expired before <code>delete_after</code> is reached.</p> <p>If both <code>attachment</code> and <code>attachments</code> are passed or both <code>component</code> and <code>components</code> are passed or both <code>embed</code> and <code>embeds</code> are passed.</p> <code>hikari.BadRequestError</code> <p>This may be raised in several discrete situations, such as messages being empty with no embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; invalid image URLs in embeds.</p> <code>hikari.UnauthorizedError</code> <p>If you are unauthorized to make the request (invalid/missing token).</p> <code>hikari.NotFoundError</code> <p>If the interaction is not found or if the interaction's initial response has already been created.</p> <code>hikari.RateLimitTooLongError</code> <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> <code>hikari.InternalServerError</code> <p>If an internal error occurs on Discord while handling the request.</p>"},{"location":"reference/#yuyo.modals.ModalContext.defer","title":"defer  <code>async</code>","text":"<pre><code>defer(*, ephemeral=False, flags=hikari.UNDEFINED)\n</code></pre> <p>Defer the initial response for this context.</p> <p>Note</p> <p>The ephemeral state of the first response is decided by whether the deferral is ephemeral.</p> PARAMETER DESCRIPTION <code>ephemeral</code> <p>Whether the deferred response should be ephemeral.</p> <p>Passing True here is a shorthand for including <code>1 &lt;&lt; 64</code> in the passed flags.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>flags</code> <p>The flags to use for the initial response.</p> <p> TYPE: <code>typing.Union[hikari.UndefinedType, int, hikari.MessageFlag]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p>"},{"location":"reference/#yuyo.ReactionClient","title":"ReactionClient","text":"<p>A class which handles the events for multiple registered reaction handlers.</p>"},{"location":"reference/#yuyo.reactions.ReactionClient.alluka","title":"alluka  <code>property</code>","text":"<pre><code>alluka: alluka_.abc.Client\n</code></pre> <p>The Alluka client being used for callback dependency injection.</p>"},{"location":"reference/#yuyo.reactions.ReactionClient.is_closed","title":"is_closed  <code>property</code>","text":"<pre><code>is_closed: bool\n</code></pre> <p>Whether this client is closed.</p>"},{"location":"reference/#yuyo.reactions.ReactionClient.__init__","title":"__init__","text":"<pre><code>__init__(*, rest, event_manager, alluka=None, event_managed=True)\n</code></pre> <p>Initialise a reaction client.</p> <p>This registers ReactionClient as a type dependency when <code>alluka</code> isn't passed.</p> <p>Note</p> <p>For an easier way to initialise the client from a bot see ReactionClient.from_gateway_bot, and ReactionClient.from_tanjun.</p> PARAMETER DESCRIPTION <code>rest</code> <p>The REST client to register this reaction client with.</p> <p> TYPE: <code>hikari.api.RESTClient</code> </p> <code>event_manager</code> <p>The event manager client to register this reaction client with.</p> <p> TYPE: <code>hikari.api.EventManager</code> </p> <code>alluka</code> <p>The Alluka client to use for callback dependency injection in this client.</p> <p>If not provided then this will initialise its own Alluka client.</p> <p> TYPE: <code>typing.Optional[alluka_.abc.Client]</code> DEFAULT: <code>None</code> </p> <code>event_managed</code> <p>Whether the reaction client should be automatically opened and closed based on the lifetime events dispatched by <code>event_managed</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p>"},{"location":"reference/#yuyo.reactions.ReactionClient.close","title":"close  <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Close this client by unregistering any registered tasks and event listeners.</p>"},{"location":"reference/#yuyo.reactions.ReactionClient.from_gateway_bot","title":"from_gateway_bot  <code>classmethod</code>","text":"<pre><code>from_gateway_bot(bot, /, *, alluka=None, event_managed=True)\n</code></pre> <p>Build a <code>ReactionClient</code> from a gateway bot.</p> <p>This registers ReactionClient as a type dependency when <code>alluka</code> isn't passed.</p> PARAMETER DESCRIPTION <code>bot</code> <p>The bot to build a reaction client for.</p> <p> TYPE: <code>hikari.traits.EventManagerAware</code> </p> <code>alluka</code> <p>The Alluka client to use for callback dependency injection in this client.</p> <p>If not provided then this will initialise its own Alluka client.</p> <p> TYPE: <code>typing.Optional[alluka_.abc.Client]</code> DEFAULT: <code>None</code> </p> <code>event_managed</code> <p>Whether the reaction client should be automatically opened and closed based on the lifetime events dispatched by <code>bot</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>ReactionClient</code> <p>The reaction client for the bot.</p>"},{"location":"reference/#yuyo.reactions.ReactionClient.from_tanjun","title":"from_tanjun  <code>classmethod</code>","text":"<pre><code>from_tanjun(tanjun_client, /, *, tanjun_managed=True)\n</code></pre> <p>Build a <code>ReactionClient</code> from a gateway bot.</p> <p>This will use the Tanjun client's alluka client and registers ReactionClient as a type dependency on Tanjun.</p> PARAMETER DESCRIPTION <code>tanjun_client</code> <p>The tanjun client to build a reaction client for.</p> <p> TYPE: <code>tanjun.abc.Client</code> </p> <code>tanjun_managed</code> <p>Whether the reaction client should be automatically opened and closed based on the Tanjun client's lifetime client callback.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>ReactionClient</code> <p>The reaction client for the bot.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If tanjun.abc.Client.events is None.</p>"},{"location":"reference/#yuyo.reactions.ReactionClient.get_handler","title":"get_handler","text":"<pre><code>get_handler(message)\n</code></pre> <p>Get a reference to a paginator registered in this reaction client.</p> <p>Note</p> <p>This does not call yuyo.reactions.AbstractReactionHandler.close.</p> PARAMETER DESCRIPTION <code>message</code> <p>The message ID to remove a paginator for.</p> <p> TYPE: <code>hikari.SnowflakeishOr[hikari.Message]</code> </p> RETURNS DESCRIPTION <code>AbstractReactionHandler | None</code> <p>The object of the registered paginator if found else None.</p>"},{"location":"reference/#yuyo.reactions.ReactionClient.open","title":"open  <code>async</code>","text":"<pre><code>open()\n</code></pre> <p>Start this client by registering the required tasks and event listeners for it to function.</p>"},{"location":"reference/#yuyo.reactions.ReactionClient.remove_handler","title":"remove_handler","text":"<pre><code>remove_handler(message)\n</code></pre> <p>Remove a paginator from this reaction client.</p> <p>Note</p> <p>This does not call yuyo.reactions.AbstractReactionHandler.close.</p> PARAMETER DESCRIPTION <code>message</code> <p>The message ID to remove a paginator for.</p> <p> TYPE: <code>hikari.SnowflakeishOr[hikari.Message]</code> </p> RETURNS DESCRIPTION <code>AbstractReactionHandler | None</code> <p>The object of the registered paginator if found else None.</p>"},{"location":"reference/#yuyo.reactions.ReactionClient.set_handler","title":"set_handler","text":"<pre><code>set_handler(message, handler)\n</code></pre> <p>Add a reaction handler to this reaction client.</p> <p>Note</p> <p>This does not call yuyo.reactions.AbstractReactionHandler.open.</p> PARAMETER DESCRIPTION <code>message</code> <p>The message ID to add register a reaction handler with.</p> <p> TYPE: <code>hikari.SnowflakeishOr[hikari.Message]</code> </p> <code>handler</code> <p>The object of the opened handler to register in this reaction client.</p> <p> TYPE: <code>AbstractReactionHandler</code> </p>"},{"location":"reference/#yuyo.ReactionHandler","title":"ReactionHandler","text":"<p>         Bases: <code>AbstractReactionHandler</code></p> <p>Standard basic implementation of a reaction handler.</p>"},{"location":"reference/#yuyo.reactions.ReactionHandler.authors","title":"authors  <code>property</code>","text":"<pre><code>authors: collections.Set[hikari.Snowflake]\n</code></pre> <p>Set of the authors/owner of a enabled handler.</p> <p>Note</p> <p>If this is empty then the handler is considered public and any user will be able to trigger it.</p>"},{"location":"reference/#yuyo.reactions.ReactionHandler.__init__","title":"__init__","text":"<pre><code>__init__(*, authors=(), timeout=datetime.timedelta(seconds=30))\n</code></pre> <p>Initialise a reaction handler.</p> PARAMETER DESCRIPTION <code>authors</code> <p>An iterable of IDs of the users who can call this paginator.</p> <p>If left empty then all users will be able to call this paginator.</p> <p> TYPE: <code>collections.Iterable[hikari.SnowflakeishOr[hikari.User]]</code> DEFAULT: <code>()</code> </p> <code>timeout</code> <p>How long it should take for this paginator to timeout.</p> <p> TYPE: <code>typing.Optional[datetime.timedelta]</code> DEFAULT: <code>datetime.timedelta(seconds=30)</code> </p>"},{"location":"reference/#yuyo.reactions.ReactionHandler.remove_callback","title":"remove_callback","text":"<pre><code>remove_callback(emoji_identifier)\n</code></pre> <p>Remove a callback from this reaction handler.</p> PARAMETER DESCRIPTION <code>emoji_identifier</code> <p>Identifier of the emoji the callback to remove is for.</p> <p>This should be a snowfake if this is for a custom emoji or a string if this is for a unicode emoji.</p> <p> TYPE: <code>typing.Union[str, hikari.SnowflakeishOr[hikari.CustomEmoji]]</code> </p>"},{"location":"reference/#yuyo.reactions.ReactionHandler.set_callback","title":"set_callback","text":"<pre><code>set_callback(emoji_identifier, callback)\n</code></pre> <p>Add a callback to this reaction handler.</p> PARAMETER DESCRIPTION <code>emoji_identifier</code> <p>Identifier of the emoji this callback is for.</p> <p>This should be a snowfake if this is for a custom emoji or a string if this is for a unicode emoji.</p> <p> TYPE: <code>typing.Union[str, hikari.SnowflakeishOr[hikari.CustomEmoji]]</code> </p> <code>callback</code> <p>The callback to add.</p> <p>This should be a function that accepts a single parameter, which is the event that triggered this reaction.</p> <p> TYPE: <code>CallbackSig</code> </p>"},{"location":"reference/#yuyo.reactions.ReactionHandler.with_callback","title":"with_callback","text":"<pre><code>with_callback(emoji_identifier)\n</code></pre> <p>Add a callback to this reaction handler through a decorator call.</p> PARAMETER DESCRIPTION <code>emoji_identifier</code> <p>Identifier of the emoji this callback is for.</p> <p>This should be a snowfake if this is for a custom emoji or a string if this is for a unicode emoji.</p> <p> TYPE: <code>typing.Union[str, hikari.SnowflakeishOr[hikari.CustomEmoji]]</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callback[[CallbackSig], CallbackSig]</code> <p>A decorator to add a callback to this reaction handler.</p>"},{"location":"reference/#yuyo.ReactionPaginator","title":"ReactionPaginator","text":"<p>         Bases: <code>ReactionHandler</code></p> <p>Standard implementation of a reaction handler for pagination.</p>"},{"location":"reference/#yuyo.reactions.ReactionPaginator.__init__","title":"__init__","text":"<pre><code>__init__(iterator, /, *, authors=(), triggers=(pagination.LEFT_TRIANGLE, pagination.STOP_SQUARE, pagination.RIGHT_TRIANGLE), timeout=datetime.timedelta(seconds=30))\n</code></pre> <p>Initialise a reaction paginator.</p> PARAMETER DESCRIPTION <code>iterator</code> <p>Either an asynchronous or synchronous iterator of the entries this should paginate through.</p> <p><code>entry[0]</code> represents the message's possible content and can either be str or hikari.undefined.UNDEFINED and <code>entry[1]</code> represents the message's possible embed and can either be hikari.embeds.Embed or hikari.undefined.UNDEFINED.</p> <p> TYPE: <code>collections.Iterator[yuyo.pagination.EntryT] | collections.AsyncIterator[yuyo.pagination.EntryT]</code> </p> <code>authors</code> <p>An iterable of IDs of the users who can call this paginator.</p> <p>If left empty then all users will be able to call this paginator.</p> <p> TYPE: <code>collections.Iterable[hikari.SnowflakeishOr[hikari.User]]</code> DEFAULT: <code>()</code> </p> <code>timeout</code> <p>How long it should take for this paginator to timeout.</p> <p> TYPE: <code>typing.Optional[datetime.timedelta]</code> DEFAULT: <code>datetime.timedelta(seconds=30)</code> </p>"},{"location":"reference/#yuyo.reactions.ReactionPaginator.add_author","title":"add_author","text":"<pre><code>add_author(user)\n</code></pre> <p>Add a author/owner to this handler.</p> PARAMETER DESCRIPTION <code>user</code> <p>The user to add as an owner for this handler.</p> <p> TYPE: <code>hikari.SnowflakeishOr[hikari.User]</code> </p>"},{"location":"reference/#yuyo.reactions.ReactionPaginator.add_first_button","title":"add_first_button","text":"<pre><code>add_first_button(*, emoji=pagination.LEFT_DOUBLE_TRIANGLE, add_reaction=True)\n</code></pre> <p>Add the jump to first entry reaction button to this paginator.</p> <p>You should pass <code>triggers=[]</code> to [yuyo.reactions.ReactionPaginator.init][ComponentPaginator.__init__] before calling this.</p> <p>Note</p> <p>These reactions will appear in the order these methods were called in.</p> PARAMETER DESCRIPTION <code>emoji</code> <p>The emoji to react with for this button.</p> <p> TYPE: <code>typing.Union[hikari.CustomEmoji, str]</code> DEFAULT: <code>pagination.LEFT_DOUBLE_TRIANGLE</code> </p> <code>add_reaction</code> <p>Whether the bot should add this reaction to the message when ReactionPaginator.open is called with <code>add_reactions=True</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>To enable chained calls.</p>"},{"location":"reference/#yuyo.reactions.ReactionPaginator.add_last_button","title":"add_last_button","text":"<pre><code>add_last_button(*, emoji=pagination.RIGHT_DOUBLE_TRIANGLE, add_reaction=True)\n</code></pre> <p>Add the jump to last entry reaction button to this paginator.</p> <p>You should pass <code>triggers=[]</code> to [yuyo.reactions.ReactionPaginator.init][ComponentPaginator.__init__] before calling this.</p> <p>Note</p> <p>These reactions will appear in the order these methods were called in.</p> PARAMETER DESCRIPTION <code>emoji</code> <p>The emoji to react with for this button.</p> <p> TYPE: <code>typing.Union[hikari.CustomEmoji, str]</code> DEFAULT: <code>pagination.RIGHT_DOUBLE_TRIANGLE</code> </p> <code>add_reaction</code> <p>Whether the bot should add this reaction to the message when ReactionPaginator.open is called with <code>add_reactions=True</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>To enable chained calls.</p>"},{"location":"reference/#yuyo.reactions.ReactionPaginator.add_next_button","title":"add_next_button","text":"<pre><code>add_next_button(*, emoji=pagination.RIGHT_TRIANGLE, add_reaction=True)\n</code></pre> <p>Add the next entry reaction button to this paginator.</p> <p>You should pass <code>triggers=[]</code> to [yuyo.reactions.ReactionPaginator.init][ComponentPaginator.__init__] before calling this.</p> <p>Note</p> <p>These reactions will appear in the order these methods were called in.</p> PARAMETER DESCRIPTION <code>emoji</code> <p>The emoji to react with for this button.</p> <p> TYPE: <code>typing.Union[hikari.CustomEmoji, str]</code> DEFAULT: <code>pagination.RIGHT_TRIANGLE</code> </p> <code>add_reaction</code> <p>Whether the bot should add this reaction to the message when ReactionPaginator.open is called with <code>add_reactions=True</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>To enable chained calls.</p>"},{"location":"reference/#yuyo.reactions.ReactionPaginator.add_previous_button","title":"add_previous_button","text":"<pre><code>add_previous_button(*, emoji=pagination.LEFT_TRIANGLE, add_reaction=True)\n</code></pre> <p>Add the previous entry reaction button to this paginator.</p> <p>You should pass <code>triggers=[]</code> to [yuyo.reactions.ReactionPaginator.init][ComponentPaginator.__init__] before calling this.</p> <p>Note</p> <p>These reactions will appear in the order these methods were called in.</p> PARAMETER DESCRIPTION <code>emoji</code> <p>The emoji to react with for this button.</p> <p> TYPE: <code>typing.Union[hikari.CustomEmoji, str]</code> DEFAULT: <code>pagination.LEFT_TRIANGLE</code> </p> <code>add_reaction</code> <p>Whether the bot should add this reaction to the message when ReactionPaginator.open is called with <code>add_reactions=True</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>To enable chained calls.</p>"},{"location":"reference/#yuyo.reactions.ReactionPaginator.add_stop_button","title":"add_stop_button","text":"<pre><code>add_stop_button(*, emoji=pagination.STOP_SQUARE, add_reaction=True)\n</code></pre> <p>Add the stop reaction button to this paginator.</p> <p>You should pass <code>triggers=[]</code> to [yuyo.reactions.ReactionPaginator.init][ComponentPaginator.__init__] before calling this.</p> <p>Note</p> <p>These reactions will appear in the order these methods were called in.</p> PARAMETER DESCRIPTION <code>emoji</code> <p>The emoji to react with for this button.</p> <p> TYPE: <code>typing.Union[hikari.CustomEmoji, str]</code> DEFAULT: <code>pagination.STOP_SQUARE</code> </p> <code>add_reaction</code> <p>Whether the bot should add this reaction to the message when ReactionPaginator.open is called with <code>add_reactions=True</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>To enable chained calls.</p>"},{"location":"reference/#yuyo.reactions.ReactionPaginator.close","title":"close  <code>async</code>","text":"<pre><code>close(*, remove_reactions=False)\n</code></pre> <p>Close this handler and deregister any previously registered message.</p> PARAMETER DESCRIPTION <code>remove_reactions</code> <p>Whether this should remove the reactions that were being used to paginate through this from the previously registered message.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"reference/#yuyo.reactions.ReactionPaginator.create_message","title":"create_message  <code>async</code>","text":"<pre><code>create_message(rest, channel_id, /, *, add_reactions=True)\n</code></pre> <p>Start this handler and link it to a bot message.</p> <p>Note</p> <p>Calling this multiple times will replace the previously registered message.</p> PARAMETER DESCRIPTION <code>rest</code> <p>Rest client to use to make the response.</p> <p> TYPE: <code>hikari.api.RESTClient</code> </p> <code>channel_id</code> <p>ID of the channel to respond in.</p> <p> TYPE: <code>hikari.SnowflakeishOr[hikari.TextableChannel]</code> </p> <code>add_reactions</code> <p>Whether this should add the paginator's reactions to the message after responding.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>hikari.messages.Message</code> <p>Object of the message this handler now targets. If <code>message</code> was not supplied then this will be the object of a newly created message, otherwise this will be what was supplied as <code>message</code>.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the provided iterator didn't yield any content for the first message.</p>"},{"location":"reference/#yuyo.reactions.ReactionPaginator.get_next_entry","title":"get_next_entry  <code>async</code>","text":"<pre><code>get_next_entry()\n</code></pre> <p>Get the next entry in this paginator.</p> RETURNS DESCRIPTION <code>yuyo.pagination.Page | None</code> <p>The next entry in this paginator, or None if there are no more entries.</p>"},{"location":"reference/#yuyo.reactions.ReactionPaginator.open","title":"open  <code>async</code>","text":"<pre><code>open(message, /, *, add_reactions=True)\n</code></pre> <p>Start the reaction paginator and start accepting reactions..</p> PARAMETER DESCRIPTION <code>message</code> <p>The message this paginator should target.</p> <p> TYPE: <code>hikari.Message</code> </p> <code>add_reactions</code> <p>Whether this should add the paginator's reactions to the message.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p>"},{"location":"reference/#yuyo.reactions.ReactionPaginator.remove_author","title":"remove_author","text":"<pre><code>remove_author(user)\n</code></pre> <p>Remove a author/owner from this handler.</p> <p>Note</p> <p>If the provided user isn't already a registered owner of this paginator then this should pass silently without raising.</p> PARAMETER DESCRIPTION <code>user</code> <p>The user to remove from this handler's owners.</p> <p> TYPE: <code>hikari.SnowflakeishOr[hikari.User]</code> </p>"},{"location":"reference/#yuyo.ServiceManager","title":"ServiceManager","text":"<p>         Bases: <code>AbstractManager</code></p> <p>Standard service manager.</p>"},{"location":"reference/#yuyo.list_status.ServiceManager.is_alive","title":"is_alive  <code>property</code>","text":"<pre><code>is_alive: bool\n</code></pre> <p>Wwhether this manager is active.</p>"},{"location":"reference/#yuyo.list_status.ServiceManager.__init__","title":"__init__","text":"<pre><code>__init__(rest, /, *, cache=None, event_manager=None, shards=None, event_managed=None, strategy=None, user_agent=None)\n</code></pre> <p>Initialise a service manager.</p> <p>Note</p> <p>For an easier way to initialise the manager from a bot see ServiceManager.from_gateway_bot, and ServiceManager.from_tanjun.</p> PARAMETER DESCRIPTION <code>rest</code> <p>The RESTAware Hikari client to bind this manager to.</p> <p> TYPE: <code>hikari.api.RESTClient</code> </p> <code>cache</code> <p>The cache aware Hikari client this manager should use.</p> <p> TYPE: <code>typing.Optional[hikari.api.Cache]</code> DEFAULT: <code>None</code> </p> <code>event_manager</code> <p>The event manager aware Hikari client this manager should use.</p> <p> TYPE: <code>typing.Optional[hikari.api.EventManager]</code> DEFAULT: <code>None</code> </p> <code>shards</code> <p>The shard aware Hikari client this manager should use.</p> <p> TYPE: <code>typing.Optional[traits.ShardAware]</code> DEFAULT: <code>None</code> </p> <code>event_managed</code> <p>Whether this client should be automatically opened and closed based on <code>event_manager</code>'s lifetime events.</p> <p>Defaults to True when <code>event_manager</code> is passed.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>strategy</code> <p>The counter strategy this manager should expose to services.</p> <p>If this is left as None then the manager will try to pick a suitable standard strategy based on the provided Hikari clients.</p> <p> TYPE: <code>typing.Optional[AbstractCountStrategy]</code> DEFAULT: <code>None</code> </p> <code>user_agent</code> <p>Override the standard user agent used during requests to bot list services.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the manager failed to find a suitable standard strategy to use when <code>strategy</code> was left as None.</p> <p>If <code>event_managed</code> is passed as True when <code>event_manager</code> is None.</p>"},{"location":"reference/#yuyo.list_status.ServiceManager.add_service","title":"add_service","text":"<pre><code>add_service(service, /, *, repeat=datetime.timedelta(hours=1))\n</code></pre> <p>Add a service to this manager.</p> PARAMETER DESCRIPTION <code>service</code> <p>Asynchronous callback used to update this service.</p> <p> TYPE: <code>ServiceSig</code> </p> <code>repeat</code> <p>How often this service should be updated in seconds.</p> <p> TYPE: <code>typing.Union[datetime.timedelta, int, float]</code> DEFAULT: <code>datetime.timedelta(hours=1)</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Object of this service manager.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If repeat is less than 1 second.</p> <code>RuntimeError</code> <p>If the client is already running.</p>"},{"location":"reference/#yuyo.list_status.ServiceManager.close","title":"close  <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Close this manager.</p>"},{"location":"reference/#yuyo.list_status.ServiceManager.from_gateway_bot","title":"from_gateway_bot  <code>classmethod</code>","text":"<pre><code>from_gateway_bot(bot, /, *, event_managed=True, strategy=None, user_agent=None)\n</code></pre> <p>Build a service manager from a gateway bot.</p> PARAMETER DESCRIPTION <code>bot</code> <p>The gateway bot to build a service manager from.</p> <p> TYPE: <code>hikari.traits.ShardAware</code> </p> <code>event_managed</code> <p>Whether this client should be automatically opened and closed based on <code>bot</code>'s lifetime events.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>strategy</code> <p>The counter strategy this manager should expose to services.</p> <p>If this is left as None then the manager will try to pick a suitable standard strategy based on the provided Hikari clients.</p> <p> TYPE: <code>typing.Optional[AbstractCountStrategy]</code> DEFAULT: <code>None</code> </p> <code>user_agent</code> <p>Override the standard user agent used during requests to bot list services.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ServiceManager</code> <p>The build service manager.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the manager failed to find a suitable standard strategy to use when <code>strategy</code> was left as None.</p>"},{"location":"reference/#yuyo.list_status.ServiceManager.from_tanjun","title":"from_tanjun  <code>classmethod</code>","text":"<pre><code>from_tanjun(tanjun_client, /, *, tanjun_managed=True, strategy=None, user_agent=None)\n</code></pre> <p>Build a service manager from a Tanjun client.</p> <p>This will use the Tanjun client's alluka client and registers ServiceManager and AbstractManager as type dependencies on Tanjun.</p> PARAMETER DESCRIPTION <code>tanjun_client</code> <p>The Tanjun client to build a service manager from.</p> <p> TYPE: <code>tanjun.abc.Client</code> </p> <code>tanjun_managed</code> <p>Whether this client should be automatically opened and closed based on the Tanjun client's lifetime client callback.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>strategy</code> <p>The counter strategy this manager should expose to services.</p> <p>If this is left as None then the manager will try to pick a suitable standard strategy based on the provided Hikari clients.</p> <p> TYPE: <code>typing.Optional[AbstractCountStrategy]</code> DEFAULT: <code>None</code> </p> <code>user_agent</code> <p>Override the standard user agent used during requests to bot list services.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ServiceManager</code> <p>The build service manager.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the manager failed to find a suitable standard strategy to use when <code>strategy</code> was left as None.</p>"},{"location":"reference/#yuyo.list_status.ServiceManager.open","title":"open  <code>async</code>","text":"<pre><code>open()\n</code></pre> <p>Start this manager.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If this manager is already running.</p>"},{"location":"reference/#yuyo.list_status.ServiceManager.remove_service","title":"remove_service","text":"<pre><code>remove_service(service)\n</code></pre> <p>Remove the first found entry of the registered service.</p> PARAMETER DESCRIPTION <code>service</code> <p>Service callback to unregister.</p> <p> TYPE: <code>ServiceSig</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If called while the manager is active.</p> <code>ValueError</code> <p>If the service callback isn't found.</p>"},{"location":"reference/#yuyo.list_status.ServiceManager.with_service","title":"with_service","text":"<pre><code>with_service(*, repeat=datetime.timedelta(hours=1))\n</code></pre> <p>Add a service to this manager by decorating a function.</p> PARAMETER DESCRIPTION <code>repeat</code> <p>How often this service should be updated in seconds.</p> <p> TYPE: <code>typing.Union[datetime.timedelta, int, float]</code> DEFAULT: <code>datetime.timedelta(hours=1)</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[ServiceSig], ServiceSig]</code> <p>Decorator callback used to add a service.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If repeat is less than 1 second.</p> <code>RuntimeError</code> <p>If the client is already running.</p>"},{"location":"reference/#yuyo.ShardFinishedChunkingEvent","title":"ShardFinishedChunkingEvent","text":"<p>         Bases: <code>hikari.ShardEvent</code></p> <p>Event that's dispatched when the startup chunking has finished for a shard.</p> <p>This indicates that the member and presence caches should be complete for guilds covered by this shard.</p> <p>This will be fired after every shard identify which triggers chunking (including re-identifies).</p>"},{"location":"reference/#yuyo.chunk_tracker.ShardFinishedChunkingEvent.incomplete_guild_ids","title":"incomplete_guild_ids  <code>property</code>","text":"<pre><code>incomplete_guild_ids: collections.Sequence[hikari.Snowflake]\n</code></pre> <p>Sequence of the IDs of guilds some chunk responses were missed for.</p>"},{"location":"reference/#yuyo.chunk_tracker.ShardFinishedChunkingEvent.missed_guild_ids","title":"missed_guild_ids  <code>property</code>","text":"<pre><code>missed_guild_ids: collections.Sequence[hikari.Snowflake]\n</code></pre> <p>Sequence of the IDs of guilds no chunk responses were received for.</p>"},{"location":"reference/#yuyo.chunk_tracker.ShardFinishedChunkingEvent.__init__","title":"__init__","text":"<pre><code>__init__(app, shard, /, *, incomplete_guild_ids=(), missed_guild_ids=())\n</code></pre> <p>Initialise a shard chunking finished event.</p> <p>This should never be initialised directly.</p>"},{"location":"reference/#yuyo.SlidingTimeout","title":"SlidingTimeout","text":"<p>         Bases: <code>AbstractTimeout</code></p> <p>Timeout strategy which resets every use.</p> <p>This implementation times out if <code>timeout</code> passes since the last call or when <code>max_uses</code> is reached.</p>"},{"location":"reference/#yuyo.timeouts.SlidingTimeout.__init__","title":"__init__","text":"<pre><code>__init__(timeout, /, *, max_uses=1)\n</code></pre> <p>Initialise a sliding timeout.</p> PARAMETER DESCRIPTION <code>timeout</code> <p>How long this should wait between calls before timing-out.</p> <p> TYPE: <code>typing.Union[datetime.timedelta, int, float]</code> </p> <code>max_uses</code> <p>The maximum amount of uses this allows.</p> <p>Setting this to <code>-1</code> marks it as unlimited.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p>"},{"location":"reference/#yuyo.StaticTimeout","title":"StaticTimeout","text":"<p>         Bases: <code>AbstractTimeout</code></p> <p>Timeout at a specific time.</p> <p>This implementation times out when <code>timeout_at</code> is reached or when <code>max_uses</code> is reached.</p>"},{"location":"reference/#yuyo.timeouts.StaticTimeout.__init__","title":"__init__","text":"<pre><code>__init__(timeout_at, /, *, max_uses=1)\n</code></pre> <p>Initialise a static timeout.</p> PARAMETER DESCRIPTION <code>timeout_at</code> <p>When this should time out.</p> <p> TYPE: <code>datetime.datetime</code> </p> <code>max_uses</code> <p>The maximum amount of uses this allows.</p> <p>Setting this to <code>-1</code> marks it as unlimited.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p>"},{"location":"reference/#yuyo.TopGGService","title":"TopGGService","text":"<p>https://top.gg status update service.</p>"},{"location":"reference/#yuyo.list_status.TopGGService.__init__","title":"__init__","text":"<pre><code>__init__(token)\n</code></pre> <p>Initialise a top.gg service.</p> PARAMETER DESCRIPTION <code>token</code> <p>Authorization token used to update the bot's status.</p> <p> TYPE: <code>str</code> </p>"},{"location":"reference/#yuyo.WaitForExecutor","title":"WaitForExecutor","text":"<p>         Bases: <code>AbstractComponentExecutor</code>, <code>timeouts.AbstractTimeout</code></p> <p>Component executor used to wait for a single component interaction.</p> <p>This should also be passed for <code>timeout=</code>.</p> <p>Examples:</p> <pre><code>responses: dict[str, str]\nmessage = await ctx.respond(\"hi, pick an option\", components=[...])\nexecutor = yuyo.components.WaitFor(authors=[ctx.author.id], timeout=datetime.timedelta(seconds=30))\ncomponent_client.register_executor(executor, message=message, timeout=executor)\n\ntry:\n    result = await executor.wait_for()\nexcept asyncio.TimeoutError:\n    await ctx.respond(\"timed out\")\n\nelse:\n    await result.respond(responses[result.interaction.custom_id])\n</code></pre>"},{"location":"reference/#yuyo.components.WaitForExecutor.__init__","title":"__init__","text":"<pre><code>__init__(*, authors=None, ephemeral_default=False, timeout)\n</code></pre> <p>Initialise a wait for executor.</p> PARAMETER DESCRIPTION <code>authors</code> <p>The authors of the entries.</p> <p>If None is passed here then the paginator will be public (meaning that anybody can use it).</p> <p> TYPE: <code>typing.Optional[collections.Iterable[hikari.SnowflakeishOr[hikari.User]]]</code> DEFAULT: <code>None</code> </p> <code>ephemeral_default</code> <p>Whether or not the responses made on contexts spawned from this paginator should default to ephemeral (meaning only the author can see them) unless <code>flags</code> is specified on the response method.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>timeout</code> <p>How long this should wait for a matching component interaction until it times-out.</p> <p> TYPE: <code>typing.Optional[datetime.timedelta]</code> </p>"},{"location":"reference/#yuyo.components.WaitForExecutor.wait_for","title":"wait_for  <code>async</code>","text":"<pre><code>wait_for()\n</code></pre> <p>Wait for the next matching interaction.</p> RETURNS DESCRIPTION <code>ComponentContext</code> <p>The next matching interaction.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the executor is already being waited for.</p> <code>asyncio.TimeoutError</code> <p>If the timeout is reached.</p>"},{"location":"reference/#yuyo.aenumerate","title":"aenumerate  <code>async</code>","text":"<pre><code>aenumerate(iterable)\n</code></pre> <p>Async equivalent of enumerate.</p> PARAMETER DESCRIPTION <code>iterable</code> <p>The async iterable to enumerate.</p> <p> TYPE: <code>collections.AsyncIterable[_T]</code> </p> RETURNS DESCRIPTION <code>collections.abc.AsyncIterator[tuple[int, _T]]</code> <p>The enumerated async iterator.</p>"},{"location":"reference/#yuyo.async_paginate_string","title":"async_paginate_string  <code>async</code>","text":"<pre><code>async_paginate_string(lines, /, *, char_limit=2000, line_limit=25, wrapper=None)\n</code></pre> <p>Lazily paginate an iterator of lines.</p> PARAMETER DESCRIPTION <code>lines</code> <p>The asynchronous iterator of lines to paginate.</p> <p> TYPE: <code>collections.AsyncIterable[str]</code> </p> <code>char_limit</code> <p>The limit for how many characters should be included per yielded page.</p> <p> TYPE: <code>int</code> DEFAULT: <code>2000</code> </p> <code>line_limit</code> <p>The limit for how many lines should be included per yielded page.</p> <p> TYPE: <code>int</code> DEFAULT: <code>25</code> </p> <code>wrapper</code> <p>A wrapper for each yielded page. This should leave \"{}\" in it to be replaced by the page's content.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>collections.abc.AsyncIterator[tuple[str, int]]</code> <p>An async iterator of page tuples (string context to int zero-based index).</p>"},{"location":"reference/#yuyo.paginate_string","title":"paginate_string","text":"<pre><code>paginate_string(lines, /, *, char_limit=2000, line_limit=25, wrapper=None)\n</code></pre> <p>Lazily paginate an iterator of lines.</p> PARAMETER DESCRIPTION <code>lines</code> <p>The iterator of lines to paginate. This iterator may be asynchronous or synchronous.</p> <p> TYPE: <code>collections.abc.Iterator[str] | collections.abc.AsyncIterator[str]</code> </p> <code>char_limit</code> <p>The limit for how many characters should be included per yielded page.</p> <p> TYPE: <code>int</code> DEFAULT: <code>2000</code> </p> <code>line_limit</code> <p>The limit for how many lines should be included per yielded page.</p> <p> TYPE: <code>int</code> DEFAULT: <code>25</code> </p> <code>wrapper</code> <p>A wrapper for each yielded page. This should leave \"{}\" in it to be replaced by the page's content.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>collections.abc.AsyncIterator[tuple[str, int]] | collections.abc.Iterator[tuple[str, int]]</code> <p>An iterator of page tuples (string context to int zero-based index).</p>"},{"location":"reference/#yuyo.sync_paginate_string","title":"sync_paginate_string","text":"<pre><code>sync_paginate_string(lines, /, *, char_limit=2000, line_limit=25, wrapper=None)\n</code></pre> <p>Lazily paginate an iterator of lines.</p> PARAMETER DESCRIPTION <code>lines</code> <p>The iterator of lines to paginate.</p> <p> TYPE: <code>collections.Iterable[str]</code> </p> <code>char_limit</code> <p>The limit for how many characters should be included per yielded page.</p> <p> TYPE: <code>int</code> DEFAULT: <code>2000</code> </p> <code>line_limit</code> <p>The limit for how many lines should be included per yielded page.</p> <p> TYPE: <code>int</code> DEFAULT: <code>25</code> </p> <code>wrapper</code> <p>A wrapper for each yielded page. This should leave \"{}\" in it to be replaced by the page's content.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>collections.abc.Iterator[tuple[str, int]]</code> <p>An iterator of page tuples (string context to int zero-based index).</p>"},{"location":"reference/asgi/","title":"yuyo.asgi","text":"<p>ASGI/3 adapter for Hikari's interaction server.</p>"},{"location":"reference/asgi/#yuyo.asgi.AsgiAdapter","title":"AsgiAdapter","text":"<p>Asgi/3 adapter for Hikari's interaction server interface.</p> <p>For this to work, hikari has to be installed with the optional \"server\" feature (e.g <code>python -m pip install hikari[server]</code>).</p>"},{"location":"reference/asgi/#yuyo.asgi.AsgiAdapter.server","title":"server  <code>property</code>","text":"<pre><code>server: hikari.api.InteractionServer\n</code></pre> <p>The interaction server this adapter is bound to.</p>"},{"location":"reference/asgi/#yuyo.asgi.AsgiAdapter.__call__","title":"__call__  <code>async</code>","text":"<pre><code>__call__(scope, receive, send)\n</code></pre> <p>Call the adapter.</p> <p>Note</p> <p>This method is called by the ASGI server.</p> PARAMETER DESCRIPTION <code>scope</code> <p>The scope of the request.</p> <p> TYPE: <code>asgiref.Scope</code> </p> <code>receive</code> <p>The receive function to use.</p> <p> TYPE: <code>asgiref.ASGIReceiveCallable</code> </p> <code>send</code> <p>The send function to use.</p> <p> TYPE: <code>asgiref.ASGISendCallable</code> </p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If this is called with a websocket scope.</p> <code>RuntimeError</code> <p>If an invalid scope event is passed.</p>"},{"location":"reference/asgi/#yuyo.asgi.AsgiAdapter.__init__","title":"__init__","text":"<pre><code>__init__(server, /, *, executor=None, max_body_size=1024 ** 2)\n</code></pre> <p>Initialise the adapter.</p> PARAMETER DESCRIPTION <code>server</code> <p>The interaction server to use.</p> <p> TYPE: <code>hikari.api.InteractionServer</code> </p> <code>executor</code> <p>If non-None, then this executor is used instead of the concurrent.futures.ThreadPoolExecutor attached to the asyncio.AbstractEventLoop that the bot will run on. This executor is used primarily for file-IO.</p> <p>While mainly supporting the concurrent.futures.ThreadPoolExecutor implementation in the standard lib, Hikari's file handling systems should also work with concurrent.futures.ProcessPoolExecutor, which relies on all objects used in IPC to be <code>pickle</code>able. Many third-party libraries will not support this fully though, so your mileage may vary on using ProcessPoolExecutor implementations with this parameter.</p> <p> TYPE: <code>typing.Optional[concurrent.futures.Executor]</code> DEFAULT: <code>None</code> </p> <code>max_body_size</code> <p>The maximum body size this should allow received request bodies to be in bytes before failing the request with a 413 - Content Too Large.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1024 ** 2</code> </p>"},{"location":"reference/asgi/#yuyo.asgi.AsgiAdapter.add_shutdown_callback","title":"add_shutdown_callback","text":"<pre><code>add_shutdown_callback(callback)\n</code></pre> <p>Add a callback to be called when the ASGI server shuts down.</p> <p>Warning</p> <p>These callbacks will block the ASGI server from shutting down until they complete and any raised errors will lead to a failed shutdown.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The shutdown callback to add.</p> <p> TYPE: <code>collections.Callable[[], collections.Coroutine[typing.Any, typing.Any, None]]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The adapter to enable chained calls.</p>"},{"location":"reference/asgi/#yuyo.asgi.AsgiAdapter.add_startup_callback","title":"add_startup_callback","text":"<pre><code>add_startup_callback(callback)\n</code></pre> <p>Add a callback to be called when the ASGI server starts up.</p> <p>Warning</p> <p>These callbacks will block the ASGI server from starting until they complete and any raised errors will lead to a failed startup.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The startup callback to add.</p> <p> TYPE: <code>collections.Callable[[], collections.Coroutine[typing.Any, typing.Any, None]]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The adapter to enable chained calls.</p>"},{"location":"reference/asgi/#yuyo.asgi.AsgiAdapter.remove_shutdown_callback","title":"remove_shutdown_callback","text":"<pre><code>remove_shutdown_callback(callback)\n</code></pre> <p>Remove a shutdown callback.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The shutdown callback to remove.</p> <p> TYPE: <code>collections.Callable[[], collections.Coroutine[typing.Any, typing.Any, None]]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The adapter to enable chained calls.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the callback was not registered.</p>"},{"location":"reference/asgi/#yuyo.asgi.AsgiAdapter.remove_startup_callback","title":"remove_startup_callback","text":"<pre><code>remove_startup_callback(callback)\n</code></pre> <p>Remove a startup callback.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The startup callback to remove.</p> <p> TYPE: <code>collections.Callable[[], collections.Coroutine[typing.Any, typing.Any, None]]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The adapter to enable chained calls.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the callback was not registered.</p>"},{"location":"reference/asgi/#yuyo.asgi.AsgiBot","title":"AsgiBot","text":"<p>         Bases: <code>hikari.RESTBotAware</code></p> <p>Bot implementation which acts as an ASGI adapter.</p> <p>This bot doesn't initiate a server internally but instead relies on being called as an ASGI app.</p> <p>For this to work, hikari has to be installed with the optional \"server\" feature (e.g <code>python -m pip install hikari[server]</code>).</p>"},{"location":"reference/asgi/#yuyo.asgi.AsgiBot.__call__","title":"__call__  <code>async</code>","text":"<pre><code>__call__(scope, receive, send)\n</code></pre> <p>Call the bot with an ASGI event.</p> <p>Note</p> <p>This method is called by the ASGI server and allows the bot to function like AsgiAdapter.</p> PARAMETER DESCRIPTION <code>scope</code> <p>The scope of the request.</p> <p> TYPE: <code>asgiref.Scope</code> </p> <code>receive</code> <p>The receive function to use.</p> <p> TYPE: <code>asgiref.ASGIReceiveCallable</code> </p> <code>send</code> <p>The send function to use.</p> <p> TYPE: <code>asgiref.ASGISendCallable</code> </p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If this is called with a websocket scope.</p> <code>RuntimeError</code> <p>If an invalid scope event is passed.</p>"},{"location":"reference/asgi/#yuyo.asgi.AsgiBot.__init__","title":"__init__","text":"<pre><code>__init__(token, token_type=None, public_key=None, *, asgi_managed=True, executor=None, http_settings=None, max_body_size=1024 ** 2, max_rate_limit=300.0, max_retries=3, proxy_settings=None, rest_url=None)\n</code></pre> <p>Initialise a new ASGI bot.</p> PARAMETER DESCRIPTION <code>token</code> <p>The bot or bearer token. If no token is to be used, this can be undefined.</p> <p> TYPE: <code>typing.Union[str, hikari.api.TokenStrategy]</code> </p> <code>token_type</code> <p>The type of token in use. This should only be passed when <code>str</code> is passed for <code>token</code>, can be <code>\"Bot\"</code> or <code>\"Bearer\"</code> and will be defaulted to <code>\"Bot\"</code> in this situation.</p> <p>This should be left as None when either hikari.api.rest.TokenStrategy or None is passed for <code>token</code>.</p> <p> TYPE: <code>typing.Union[hikari.TokenType, str, None]</code> DEFAULT: <code>None</code> </p> <code>asgi_managed</code> <p>Whether this bot's internal components should be automatically started and stopped based on the Asgi lifespan events.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>executor</code> <p>If non-None, then this executor is used instead of the concurrent.futures.ThreadPoolExecutor attached to the asyncio.AbstractEventLoop that the bot will run on. This executor is used primarily for file-IO.</p> <p>While mainly supporting the concurrent.futures.ThreadPoolExecutor implementation in the standard lib, Hikari's file handling systems should also work with concurrent.futures.ProcessPoolExecutor, which relies on all objects used in IPC to be <code>pickle</code>able. Many third-party libraries will not support this fully though, so your mileage may vary on using ProcessPoolExecutor implementations with this parameter.</p> <p> TYPE: <code>typing.Optional[concurrent.futures.Executor]</code> DEFAULT: <code>None</code> </p> <code>http_settings</code> <p>Optional custom HTTP configuration settings to use. Allows you to customise functionality such as whether SSL-verification is enabled, what timeouts <code>aiohttp</code> should expect to use for requests, and behavior regarding HTTP-redirects.</p> <p> TYPE: <code>typing.Optional[hikari.impl.HTTPSettings]</code> DEFAULT: <code>None</code> </p> <code>max_body_size</code> <p>The maximum body size this should allow received request bodies to be in bytes before failing the request with a 413 - Content Too Large.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1024 ** 2</code> </p> <code>max_rate_limit</code> <p>The max number of seconds to backoff for when rate limited. Anything greater than this will instead raise an error.</p> <p>This defaults to five minutes to stop potentially indefinitely waiting on an endpoint, which is almost never what you want to do if giving a response to a user.</p> <p>You can set this to <code>float(\"inf\")</code> to disable this check entirely. Note that this only applies to the REST API component that communicates with Discord, and will not affect sharding or third party HTTP endpoints that may be in use.</p> <p> TYPE: <code>float</code> DEFAULT: <code>300.0</code> </p> <code>max_retries</code> <p>Maximum number of times a request will be retried if</p> <p>it fails with a <code>5xx</code> status. Defaults to 3 if set to None.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> <code>proxy_settings</code> <p>Custom proxy settings to use with network-layer logic in your application to get through an HTTP-proxy.</p> <p> TYPE: <code>typing.Optional[hikari.impl.ProxySettings]</code> DEFAULT: <code>None</code> </p> <code>public_key</code> <p>The public key to use to verify received interaction requests.</p> <p>This may be a hex encoded <code>str</code> or the raw <code>bytes</code>. If left as None then the client will try to work this value out based on <code>token</code>.</p> <p> TYPE: <code>typing.Union[bytes, str, None]</code> DEFAULT: <code>None</code> </p> <code>rest_url</code> <p>Defaults to the Discord REST API URL if None. Can be overridden if you are attempting to point to an unofficial endpoint, or if you are attempting to mock/stub the Discord API for any reason.</p> <p>Generally you do not want to change this.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <ul> <li>If <code>token_type</code> is provided when a token strategy is passed for <code>token</code>.</li> <li>if <code>token_type</code> is left as None when a string is passed for <code>token</code>.</li> </ul>"},{"location":"reference/asgi/#yuyo.asgi.AsgiBot.add_shutdown_callback","title":"add_shutdown_callback","text":"<pre><code>add_shutdown_callback(callback)\n</code></pre> <p>Add a callback to be called when the bot shuts down.</p> <p>Warning</p> <p>These callbacks will block the bot from shutting down until they complete and any raised errors will lead to a failed shutdown.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The shutdown callback to add.</p> <p> TYPE: <code>collections.Callable[[Self], collections.Coroutine[typing.Any, typing.Any, None]]</code> </p>"},{"location":"reference/asgi/#yuyo.asgi.AsgiBot.add_startup_callback","title":"add_startup_callback","text":"<pre><code>add_startup_callback(callback)\n</code></pre> <p>Add a callback to be called when the bot starts up.</p> <p>Warning</p> <p>These callbacks will block the bot from starting until they complete and any raised errors will lead to a failed startup.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The startup callback to add.</p> <p> TYPE: <code>collections.Callable[[Self], collections.Coroutine[typing.Any, typing.Any, None]]</code> </p>"},{"location":"reference/asgi/#yuyo.asgi.AsgiBot.close","title":"close  <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Close the bot's REST client.</p> <p>Warning</p> <p>Unless <code>asgi_managed=False</code> is passed to <code>AsgiBot.__init__</code>, the bot will be automatically closed based on the ASGI lifespan events and any other calls to this function will raise a RuntimeError.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the client isn't alive. If the client is ASGI managed.</p>"},{"location":"reference/asgi/#yuyo.asgi.AsgiBot.remove_shutdown_callback","title":"remove_shutdown_callback","text":"<pre><code>remove_shutdown_callback(callback)\n</code></pre> <p>Remove a shutdown callback.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The shutdown callback to remove.</p> <p> TYPE: <code>collections.Callable[[Self], collections.Coroutine[typing.Any, typing.Any, None]]</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the callback was not registered.</p>"},{"location":"reference/asgi/#yuyo.asgi.AsgiBot.remove_startup_callback","title":"remove_startup_callback","text":"<pre><code>remove_startup_callback(callback)\n</code></pre> <p>Remove a startup callback.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The startup callback to remove.</p> <p> TYPE: <code>collections.Callable[[Self], collections.Coroutine[typing.Any, typing.Any, None]]</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the callback was not registered.</p>"},{"location":"reference/asgi/#yuyo.asgi.AsgiBot.run","title":"run","text":"<pre><code>run()\n</code></pre> <p>Start the bot's REST client and wait until the bot's closed.</p> <p>Warning</p> <p>Unless <code>asgi_managed=False</code> is passed to AsgiBot.__init__, the bot will be automatically started and closed based on the ASGI lifespan events and any other calls to this function will raise a RuntimeError.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the client is already alive. If the client is ASGI managed.</p>"},{"location":"reference/asgi/#yuyo.asgi.AsgiBot.start","title":"start  <code>async</code>","text":"<pre><code>start()\n</code></pre> <p>Start the bot's REST client.</p> <p>Warning</p> <p>Unless <code>asgi_managed=False</code> is passed to AsgiBot.__init__, the bot will be automatically started based on the ASGI lifespan events and any other calls to this function will raise a RuntimeError.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the client is already alive. If the client is ASGI managed.</p>"},{"location":"reference/backoff/","title":"yuyo.backoff","text":"<p>Utility used for handling automatic back-off.</p> <p>This can be used to cover cases such as hitting rate-limits and failed requests.</p>"},{"location":"reference/backoff/#yuyo.backoff.Backoff","title":"Backoff","text":"<p>Used to exponentially backoff asynchronously.</p> <p>This class acts as an asynchronous iterator and can be iterated over to provide implicit backoff where for every iteration other than the first this will either back off for the time passed to yuyo.backoff.Backoff.set_next_backoff if applicable or a time calculated exponentially.</p> <p>Each iteration yields the current retry count (starting at 0).</p> <p>Examples:</p> <p>An example of using this class as an asynchronous iterator may look like the following</p> <pre><code># While we can directly do `async for _ in Backoff()`, by assigning it to a\n# variable we allow ourself to provide a specific backoff time in some cases.\nbackoff = Backoff()\nasync for _ in backoff:\n    response = await client.fetch(f\"https://example.com/{resource_id}\")\n    if response.status_code == 403:  # Ratelimited\n        # If we have a specific backoff time then set it for the next iteration\n        backoff.set_next_backoff(response.headers.get(\"Retry-After\"))\n\n    elif response.status_code &gt;= 500:  # Internal server error\n        # Else let the iterator calculate an exponential backoff before the next loop.\n        pass\n\n    else:\n        response.raise_for_status()\n        resource = response.json()\n        # We need to break out of the iterator to make sure it doesn't backoff again.\n        # Alternatively `Backoff.finish()` can be called to break out of the loop.\n        break\n</code></pre> <p>Alternatively you may want to explicitly call yuyo.backoff.Backoff.backoff, a alternative of the previous example which uses yuyo.backoff.Backoff.backoff may look like the following</p> <pre><code>backoff = Backoff()\nresource = None\nwhile not resource:\n    response = await client.fetch(f\"https://example.com/{resource_id}\")\n    if response == 403  # Ratelimited\n        # If we have a specific backoff time then set it for the next iteration.\n        backoff.set_next_backoff(response.headers.get(\"Retry-After\"))\n        await backoff.backoff()  # We must explicitly backoff in this flow.\n\n    elif response &gt;= 500:  # Internal server error\n        # Else let the iterator calculate an exponential backoff and explicitly backoff.\n        await backoff.backoff()\n\n    else:\n        response.raise_for_status()\n        resource = response.json()\n</code></pre>"},{"location":"reference/backoff/#yuyo.backoff.Backoff.is_depleted","title":"is_depleted  <code>property</code>","text":"<pre><code>is_depleted: bool\n</code></pre> <p>Whether \"max_retries\" has been reached.</p> <p>This can be used to workout whether the loop was explicitly broken out of using yuyo.backoff.Backoff.finish/<code>break</code> or if it hit \"max_retries\".</p>"},{"location":"reference/backoff/#yuyo.backoff.Backoff.__init__","title":"__init__","text":"<pre><code>__init__(max_retries=None, *, base=2.0, maximum=64.0, jitter_multiplier=1.0, initial_increment=0)\n</code></pre> <p>Initialise a backoff instance.</p> PARAMETER DESCRIPTION <code>max_retries</code> <p>The maximum amount of times this should iterate for between resets.</p> <p>If left as None then this iterator will be unlimited. This must be greater than or equal to 1.</p> <p> TYPE: <code>typing.Optional[int]</code> DEFAULT: <code>None</code> </p> <code>base</code> <p>The base to use.</p> <p> TYPE: <code>float</code> DEFAULT: <code>2.0</code> </p> <code>maximum</code> <p>The max value the backoff can be in a single iteration. Anything above this will be capped to this base value plus random jitter.</p> <p> TYPE: <code>float</code> DEFAULT: <code>64.0</code> </p> <code>jitter_multiplier</code> <p>The multiplier for the random jitter.</p> <p>Set to <code>0</code> to disable jitter.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> <code>initial_increment</code> <p>The initial increment to start at.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If an int that's too big to be represented as a float or a non-finite value is passed in place of a field that's annotated as float or if <code>max_retries</code> is less than <code>1</code>.</p>"},{"location":"reference/backoff/#yuyo.backoff.Backoff.backoff","title":"backoff  <code>async</code>","text":"<pre><code>backoff()\n</code></pre> <p>Sleep for the provided backoff or for the next exponent.</p> <p>This provides an alternative to iterating over this class.</p> RETURNS DESCRIPTION <code>int | None</code> <p>Whether this has reached the end of its iteration.</p> <p>If this returns True then that call didn't sleep as this has been marked as finished or has reached the max retries.</p>"},{"location":"reference/backoff/#yuyo.backoff.Backoff.finish","title":"finish","text":"<pre><code>finish()\n</code></pre> <p>Mark the iterator as finished to break out of the current loop.</p>"},{"location":"reference/backoff/#yuyo.backoff.Backoff.reset","title":"reset","text":"<pre><code>reset()\n</code></pre> <p>Reset the backoff to it's original state to reuse it.</p>"},{"location":"reference/backoff/#yuyo.backoff.Backoff.set_next_backoff","title":"set_next_backoff","text":"<pre><code>set_next_backoff(backoff_)\n</code></pre> <p>Specify a backoff time for the next iteration or yuyo.backoff.Backoff.backoff call.</p> <p>If this is called then the exponent won't be increased for this iteration.</p> <p>Note</p> <p>Calling this multiple times in a single iteration will overwrite any previously set next backoff.</p> PARAMETER DESCRIPTION <code>backoff_</code> <p>The amount of time to backoff for in seconds.</p> <p>If this is None then any previously set next backoff will be unset.</p> <p> TYPE: <code>typing.Union[float, int, None]</code> </p>"},{"location":"reference/backoff/#yuyo.backoff.ErrorManager","title":"ErrorManager","text":"<p>A context manager provided to allow for more concise error handling with yuyo.backoff.Backoff.</p> <p>Examples:</p> <p>The following is an example of using yuyo.backoff.ErrorManager alongside yuyo.backoff.Backoff in-order to handle the exceptions which may be raised while trying to reply to a message.</p> <pre><code>retry = Backoff()\n# Rules can either be passed to `ErrorManager`'s initiate as variable arguments\n# or one at a time to `ErrorManager.with_rule` through possibly chained-calls.\nerror_handler = (\n    # For the 1st rule we catch two errors which would indicate the bot\n    # no-longer has access to the target channel and break out of the\n    # retry loop using `Backoff.retry`.\n    ErrorManager(((NotFoundError, ForbiddenError), lambda _: retry.finish()))\n        # For the 2nd rule we catch rate limited errors and set their\n        # `retry` value as the next backoff time before suppressing the\n        # error to allow this to retry the request.\n        .with_rule((RateLimitedError,), lambda exc: retry.set_next_backoff(exc.retry_after))\n        # For the 3rd rule we suppress the internal server error to allow\n        # backoff to reach the next retry and exponentially backoff as we\n        # don't have any specific retry time for this error.\n        .with_rule((InternalServerError,), lambda _: False)\n)\nasync for _ in retry:\n    # We entre this context manager each iteration to catch errors before\n    # they cause us to break out of the `Backoff` loop.\n    with error_handler:\n        await post(f\"https://example.com/{resource_id}\", json={\"content\": \"General Kenobi\"})\n        # We need to break out of `retry` if this request succeeds.\n        break\n</code></pre>"},{"location":"reference/backoff/#yuyo.backoff.ErrorManager.__init__","title":"__init__","text":"<pre><code>__init__(*rules)\n</code></pre> <p>Initialise an error manager instance.</p> PARAMETER DESCRIPTION <code>*rules</code> <p>Rules to initiate this error context manager with.</p> <p>These are each a 2-length tuple where the <code>tuple[0]</code> is an iterable of types of the exceptions this rule should apply to and <code>tuple[1]</code> is the rule's callback function.</p> <p>The callback function will be called with the raised exception when it matches one of the passed exceptions for the relevant rule and may raise, return True to indicate that the current error should be raised outside of the context manager or False/None to suppress the current error.</p> <p> TYPE: <code>tuple[collections.Iterable[type[BaseException]], collections.Callable[[typing.Any], typing.Optional[bool]]]</code> DEFAULT: <code>()</code> </p>"},{"location":"reference/backoff/#yuyo.backoff.ErrorManager.add_rule","title":"add_rule","text":"<pre><code>add_rule(exceptions, result)\n</code></pre> <p>Add a rule to this exception context manager.</p> PARAMETER DESCRIPTION <code>exceptions</code> <p>An iterable of types of the exceptions this rule should apply to.</p> <p> TYPE: <code>collections.Iterable[type[BaseException]]</code> </p> <code>result</code> <p>The function called with the raised exception when it matches one of the passed <code>exceptions</code>. This may raise, return True to indicate that the current error should be raised outside of the context manager or False/None to suppress the current error.</p> <p> TYPE: <code>collections.Callable[[typing.Any], typing.Optional[bool]]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This returns the handler a rule was being added to in-order to allow for chained calls.</p>"},{"location":"reference/backoff/#yuyo.backoff.ErrorManager.clear_rules","title":"clear_rules","text":"<pre><code>clear_rules()\n</code></pre> <p>Clear the rules registered with this handler.</p>"},{"location":"reference/chunk_tracker/","title":"yuyo.chunk_tracker","text":"<p>Utility class for tracking request guild member responses.</p>"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ChunkRequestFinishedEvent","title":"ChunkRequestFinishedEvent","text":"<p>         Bases: <code>hikari.ShardEvent</code></p> <p>Event that's dispatched when a specific chunk request has finished.</p> <p>This will be fired for every chunk request which has a nonce.</p>"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ChunkRequestFinishedEvent.chunk_count","title":"chunk_count  <code>property</code>","text":"<pre><code>chunk_count: int\n</code></pre> <p>The amount of chunk events which should've been received for this request.</p>"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ChunkRequestFinishedEvent.first_received_at","title":"first_received_at  <code>property</code>","text":"<pre><code>first_received_at: datetime.datetime\n</code></pre> <p>When the first response was received.</p>"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ChunkRequestFinishedEvent.guild_id","title":"guild_id  <code>property</code>","text":"<pre><code>guild_id: hikari.Snowflake\n</code></pre> <p>Id of the guild this chunk request was for.</p>"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ChunkRequestFinishedEvent.last_received_at","title":"last_received_at  <code>property</code>","text":"<pre><code>last_received_at: datetime.datetime\n</code></pre> <p>When the last response was received.</p>"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ChunkRequestFinishedEvent.missed_chunks","title":"missed_chunks  <code>property</code>","text":"<pre><code>missed_chunks: collections.Collection[int]\n</code></pre> <p>Collection of the chunk responses which were missed (if any).</p>"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ChunkRequestFinishedEvent.not_found_ids","title":"not_found_ids  <code>property</code>","text":"<pre><code>not_found_ids: collections.Collection[hikari.Snowflake]\n</code></pre> <p>Collection of the User IDs which weren't found.</p> <p>This is only relevant when <code>users</code> was specified while requesting the members.</p>"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ChunkRequestFinishedEvent.__init__","title":"__init__","text":"<pre><code>__init__(app, shard, data)\n</code></pre> <p>Initialise a chunk request finished event.</p> <p>This should never be initialised directly.</p>"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ChunkTracker","title":"ChunkTracker","text":"<p>Chunk payload event tracker.</p> <p>This will dispatch ShardFinishedChunkingEvent, FinishedChunkingEvent and ChunkRequestFinishedEvent events.</p> <p>To configure this to automatically request member chunks to fill a member and/or presence cache on startup and guild join see ChunkTracker.set_auto_chunk_members.</p> <p>Note</p> <p>ChunkTracker.request_guild_members ensures a request will be tracked as this only tracks chunk requests with a set nonce.</p>"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ChunkTracker.__init__","title":"__init__","text":"<pre><code>__init__(event_manager, rest, shards, /, *, timeout=datetime.timedelta(seconds=5))\n</code></pre> <p>Initialise a chunk tracker.</p> <p>For a shorthand for initialising this from a hikari.traits.GatewayBotAware see ChunkTracker.from_gateway_bot.</p> PARAMETER DESCRIPTION <code>event_manager</code> <p>The event manager this chunk tracker should dispatch events over.</p> <p> TYPE: <code>hikari.api.EventManager</code> </p> <code>rest</code> <p>The REST aware object this should use.</p> <p> TYPE: <code>hikari.RESTAware</code> </p> <code>shards</code> <p>The shard aware object this should use.</p> <p> TYPE: <code>hikari.ShardAware</code> </p> <code>timeout</code> <p>How long this should wait between chunks until deciding the request has finished early/incomplete.</p> <p> TYPE: <code>typing.Union[int, float, datetime.timedelta]</code> DEFAULT: <code>datetime.timedelta(seconds=5)</code> </p>"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ChunkTracker.from_gateway_bot","title":"from_gateway_bot  <code>classmethod</code>","text":"<pre><code>from_gateway_bot(bot, /, *, timeout=datetime.timedelta(seconds=5))\n</code></pre> <p>Initialise a chunk tracker from a gateway bot.</p> PARAMETER DESCRIPTION <code>bot</code> <p>The gateway bot this chunk tracker should use.</p> <p> TYPE: <code>hikari.traits.ShardAware</code> </p> <code>timeout</code> <p>How long this should wait between chunks until deciding the request has finished early/incomplete.</p> <p> TYPE: <code>typing.Union[int, float, datetime.timedelta]</code> DEFAULT: <code>datetime.timedelta(seconds=5)</code> </p>"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ChunkTracker.request_guild_members","title":"request_guild_members  <code>async</code>","text":"<pre><code>request_guild_members(guild, /, *, include_presences=hikari.UNDEFINED, query='', limit=0, users=hikari.UNDEFINED)\n</code></pre> <p>Request guild members.</p> <p>Note</p> <p>To request the full list of members, leave <code>query</code> as <code>\"\"</code> (empty string) and <code>limit</code> as <code>0</code>.</p> PARAMETER DESCRIPTION <code>guild</code> <p>The guild to request chunk for.</p> <p> TYPE: <code>hikari.SnowflakeishOr[hikari.PartialGuild]</code> </p> <code>include_presences</code> <p>If provided, whether to request presences.</p> <p> TYPE: <code>hikari.UndefinedOr[bool]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>query</code> <p>If not <code>\"\"</code>, request the members who's usernames starts with the string.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>limit</code> <p>Maximum number of members to send matching the query.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>users</code> <p>If provided, the users to request for.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.SnowflakeishSequence[hikari.User]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>When trying to specify <code>users</code> with <code>query</code>/<code>limit</code>, if <code>limit</code> is not between 0 and 100, both inclusive or if <code>users</code> length is over 100.</p> <code>hikari.errors.MissingIntentError</code> <p>When trying to request presences without the <code>GUILD_MEMBERS</code> or when trying to request the full list of members without <code>GUILD_PRESENCES</code>.</p>"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ChunkTracker.set_auto_chunk_members","title":"set_auto_chunk_members","text":"<pre><code>set_auto_chunk_members(state, /, *, chunk_presences=True)\n</code></pre> <p>Configure whether this should request member chunks in response to GUILD_CREATE.</p> <p>This may be useful for filling 3rd party caches but may conflict with the <code>auto_chunk_members</code> config of hikari.impl.gateway_bot.GatewayBot if it's enabled.</p> <p>Warning</p> <p>This will be ignored if Intents.GUILD_MEMBERS hasn't been declared.</p> PARAMETER DESCRIPTION <code>state</code> <p>Whether this should request member chunks when GUILD_CREATE events are received.</p> <p> TYPE: <code>bool</code> </p> <code>chunk_presences</code> <p>Whether this should also request member presences on these member chunks.</p> <p>This will be ignored if Intents.GUILD_PRESENCES hasn't been declared.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The chunk tracker object to enable call chaining.</p>"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.FinishedChunkingEvent","title":"FinishedChunkingEvent","text":"<p>         Bases: <code>hikari.Event</code></p> <p>Event that's dispatched when the startup chunking has finished for the bot.</p> <p>This indicates that the member and presence caches should be complete globally.</p> <p>This will only be fired once after bot startups.</p>"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.FinishedChunkingEvent.__init__","title":"__init__","text":"<pre><code>__init__(app)\n</code></pre> <p>Initialise a chunking finished event.</p> <p>This should never be initialised directly.</p>"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ShardFinishedChunkingEvent","title":"ShardFinishedChunkingEvent","text":"<p>         Bases: <code>hikari.ShardEvent</code></p> <p>Event that's dispatched when the startup chunking has finished for a shard.</p> <p>This indicates that the member and presence caches should be complete for guilds covered by this shard.</p> <p>This will be fired after every shard identify which triggers chunking (including re-identifies).</p>"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ShardFinishedChunkingEvent.incomplete_guild_ids","title":"incomplete_guild_ids  <code>property</code>","text":"<pre><code>incomplete_guild_ids: collections.Sequence[hikari.Snowflake]\n</code></pre> <p>Sequence of the IDs of guilds some chunk responses were missed for.</p>"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ShardFinishedChunkingEvent.missed_guild_ids","title":"missed_guild_ids  <code>property</code>","text":"<pre><code>missed_guild_ids: collections.Sequence[hikari.Snowflake]\n</code></pre> <p>Sequence of the IDs of guilds no chunk responses were received for.</p>"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ShardFinishedChunkingEvent.__init__","title":"__init__","text":"<pre><code>__init__(app, shard, /, *, incomplete_guild_ids=(), missed_guild_ids=())\n</code></pre> <p>Initialise a shard chunking finished event.</p> <p>This should never be initialised directly.</p>"},{"location":"reference/components/","title":"yuyo.components","text":"<p>Higher level client for callback based component execution.</p>"},{"location":"reference/components/#yuyo.components.CallbackSig","title":"CallbackSig  <code>module-attribute</code>","text":"<pre><code>CallbackSig = collections.Callable[Ellipsis, collections.Coroutine[typing.Any, typing.Any, None]]\n</code></pre> <p>Type hint of a component callback.</p>"},{"location":"reference/components/#yuyo.components.Client","title":"Client  <code>module-attribute</code>","text":"<pre><code>Client = ComponentClient\n</code></pre> <p>Alias of ComponentClient.</p>"},{"location":"reference/components/#yuyo.components.Context","title":"Context  <code>module-attribute</code>","text":"<pre><code>Context = ComponentContext\n</code></pre> <p>Alias of ComponentContext.</p>"},{"location":"reference/components/#yuyo.components.WaitFor","title":"WaitFor  <code>module-attribute</code>","text":"<pre><code>WaitFor = WaitForExecutor\n</code></pre> <p>Alias of yuyo.components.WaitForExecutor.</p>"},{"location":"reference/components/#yuyo.components.AbstractComponentExecutor","title":"AbstractComponentExecutor","text":"<p>         Bases: <code>abc.ABC</code></p> <p>Abstract interface of an object which handles the execution of a message component.</p>"},{"location":"reference/components/#yuyo.components.AbstractComponentExecutor.custom_ids","title":"custom_ids  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>custom_ids: collections.Collection[str]\n</code></pre> <p>Collection of the custom IDs this executor is listening for.</p>"},{"location":"reference/components/#yuyo.components.AbstractComponentExecutor.execute","title":"execute  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>execute(ctx)\n</code></pre> <p>Execute this component.</p> PARAMETER DESCRIPTION <code>ctx</code> <p>The context to execute this with.</p> <p> TYPE: <code>ComponentContext</code> </p> RAISES DESCRIPTION <code>ExecutorClosed</code> <p>If the executor is closed.</p>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor","title":"ActionColumnExecutor","text":"<p>         Bases: <code>AbstractComponentExecutor</code></p> <p>Executor which handles columns of action rows.</p> <p>This can be used to declare and handle the components on a message a couple of ways.</p> <p>To send a column's components pass ActionColumnExecutor.rows as <code>components</code> when calling the create message method (e.g. <code>respond</code>/<code>create_message</code>).</p> <p>Examples:</p> <p>Sub-components can be added to an instance of the column executor using chainable methods on it:</p> <pre><code>async def callback_1(ctx: components.ComponentContext) -&gt; None:\n    await ctx.respond(\"meow\")\n\ncomponents = (\n    components.ActionColumnExecutor()\n    .add_interative_button(hikari.ButtonStyle.PRIMARY, chainable, label=\"Button 1\")\n    .add_link_button(\"https://example.com\", label=\"Button 2\",)\n)\n</code></pre> <p>Alternatively, subclasses of ActionColumnExecutor can act as a template where \"static\" fields are included on all instances and subclasses of that class:</p> <p>Note</p> <p>Since decorators are executed from the bottom upwards fields added through decorator calls will follow the same order.</p> <pre><code>async def callback_1(ctx: components.ComponentContext) -&gt; None:\n    await ctx.respond(\"meow\")\n\nasync def callback_2(ctx: components.ComponentContext) -&gt; None:\n    await ctx.respond(\"meow\")\n\n@components.with_static_select_menu(callback_1, hikari.ComponentType.USER_SELECT_MENU, max_values=5)\nclass CustomColumn(components.ActionColumnExecutor):\n    __slots__ = (\"special_string\",)  # ActionColumnExecutor supports slotting.\n\n    # The init can be overridden to store extra data on the column object when subclassing.\n    def __init__(self, special_string: str, timeout: typing.Optional[datetime.timedelta] = None):\n        super().__init__(timeout=timeout)\n        self.special_string = special_string\n\n(\n    CustomColumn.add_static_text_menu(callback_2, min_values=0, max_values=3)\n    # The following calls are all adding options to the added\n    # text select menu.\n    .add_option(\"Option 1\", \"value 1\")\n    .add_option(\"Option 2\", \"value 2\")\n    .add_option(\"Option 3\", \"value 3\")\n)\n</code></pre> <p>There's also class descriptors which can be used to declare static components. The following descriptors work by decorating their component's callback:</p> <ul> <li>as_interactive_button</li> <li>as_select_menu</li> <li>as_channel_menu</li> <li>as_text_menu</li> </ul> <p>link_button returns a descriptor without decorating any callback.</p> <pre><code>class CustomColumn(components.ActionColumnExecutor):\n    @components.as_interactive_button(ButtonStyle.PRIMARY, label=\"label\")\n    async def left_button(self, ctx: components.ComponentContext) -&gt; None:\n        ...\n\n    link_button = components.link_button(url=\"https://example.com\", label=\"Go to page\")\n\n    @components.as_interactive_button(ButtonStyle.SECONDARY, label=\"meow\")\n    async def right_button(self, ctx: components.ComponentContext) -&gt; None:\n        ...\n\n    @components.as_channel_menu(channel_types=[hikari.TextableChannel])\n    async def text_select_menu(self, ctx: components.ComponentContext) -&gt; None:\n        ...\n</code></pre>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.rows","title":"rows  <code>property</code>","text":"<pre><code>rows: collections.Sequence[hikari.api.MessageActionRowBuilder]\n</code></pre> <p>The rows in this column.</p>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.__init__","title":"__init__","text":"<pre><code>__init__(*, id_metadata=None, timeout=_internal.NO_DEFAULT, _stack_level=0)\n</code></pre> <p>Initialise an action column executor.</p> PARAMETER DESCRIPTION <code>id_metadata</code> <p>Mapping of metadata to append to the custom_ids in this column.</p> <p> TYPE: <code>typing.Optional[collections.Mapping[str, str]]</code> DEFAULT: <code>None</code> </p>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.add_button","title":"add_button","text":"<pre><code>add_button(style, callback, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Deprecated alias of .add_interative_button.</p>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.add_channel_menu","title":"add_channel_menu","text":"<pre><code>add_channel_menu(callback, /, *, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a channel select menu to this action column.</p> PARAMETER DESCRIPTION <code>callback</code> <p>Callback which is called when this select menu is used.</p> <p> TYPE: <code>CallbackSig</code> </p> <code>channel_types</code> <p>Sequence of the types of channels this select menu should show as options.</p> <p> TYPE: <code>typing.Optional[collections.Sequence[typing.Union[hikari.ChannelType, type[hikari.PartialChannel]]]]</code> DEFAULT: <code>None</code> </p> <code>custom_id</code> <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>placeholder</code> <p>Placeholder text to show when no entries have been selected.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>min_values</code> <p>The minimum amount of entries which need to be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>max_values</code> <p>The maximum amount of entries which can be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>is_disabled</code> <p>Whether this select menu should be marked as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The action column to enable chained calls.</p>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.add_channel_select","title":"add_channel_select","text":"<pre><code>add_channel_select(callback, /, *, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Deprecated alias of .add_channel_menu.</p>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.add_interative_button","title":"add_interative_button","text":"<pre><code>add_interative_button(style, callback, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add an interactive button to this action column.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> PARAMETER DESCRIPTION <code>style</code> <p>The button's style.</p> <p> TYPE: <code>hikari.InteractiveButtonTypesT</code> </p> <code>callback</code> <p>The button's execution callback.</p> <p> TYPE: <code>CallbackSig</code> </p> <code>custom_id</code> <p>The button's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>emoji</code> <p>The button's emoji.</p> <p> TYPE: <code>typing.Union[hikari.Snowflakeish, hikari.Emoji, str, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>label</code> <p>The button's label.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>is_disabled</code> <p>Whether the button should be marked as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The action column to enable chained calls.</p>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.add_link_button","title":"add_link_button","text":"<pre><code>add_link_button(url, /, *, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add a link button to this action column.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> PARAMETER DESCRIPTION <code>url</code> <p>The button's url.</p> <p> TYPE: <code>str</code> </p> <code>emoji</code> <p>The button's emoji.</p> <p> TYPE: <code>typing.Union[hikari.Snowflakeish, hikari.Emoji, str, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>label</code> <p>The button's label.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>is_disabled</code> <p>Whether the button should be marked as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The action column to enable chained calls.</p>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.add_row","title":"add_row","text":"<pre><code>add_row(row)\n</code></pre> <p>Add an action row executor to this column.</p> PARAMETER DESCRIPTION <code>row</code> <p>The action row executor to add.</p> <p> TYPE: <code>typing.Union[hikari.api.MessageActionRowBuilder, ActionRowExecutor]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The column executor to enable chained calls.</p>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.add_select_menu","title":"add_select_menu","text":"<pre><code>add_select_menu(type_, callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a select menu to this action column.</p> <p>For channel select menus and text select menus see ActionColumnExecutor.add_channel_menu and ActionColumnExecutor.add_text_menu respectively.</p> PARAMETER DESCRIPTION <code>type_</code> <p>The type of select menu to add.</p> <p>Passing callback here is deprecated.</p> <p> TYPE: <code>hikari.components.ComponentType | int</code> </p> <code>callback</code> <p>Callback which is called when this select menu is used.</p> <p>Passing type here is deprecated.</p> <p> TYPE: <code>yuyo.components.CallbackSig</code> </p> <code>custom_id</code> <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>placeholder</code> <p>Placeholder text to show when no entries have been selected.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>min_values</code> <p>The minimum amount of entries which need to be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>max_values</code> <p>The maximum amount of entries which can be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>is_disabled</code> <p>Whether this select menu should be marked as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The action column to enable chained calls.</p>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.add_static_button","title":"add_static_button  <code>classmethod</code>","text":"<pre><code>add_static_button(style, callback, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Deprecated alias of .add_static_interative_button.</p>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.add_static_channel_menu","title":"add_static_channel_menu  <code>classmethod</code>","text":"<pre><code>add_static_channel_menu(callback, /, *, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a channel select menu to all subclasses and instances of this action column class.</p> PARAMETER DESCRIPTION <code>callback</code> <p>Callback which is called when this select menu is used.</p> <p> TYPE: <code>CallbackSig</code> </p> <code>channel_types</code> <p>Sequence of the types of channels this select menu should show as options.</p> <p> TYPE: <code>typing.Optional[collections.Sequence[typing.Union[hikari.ChannelType, type[hikari.PartialChannel]]]]</code> DEFAULT: <code>None</code> </p> <code>custom_id</code> <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>placeholder</code> <p>Placeholder text to show when no entries have been selected.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>min_values</code> <p>The minimum amount of entries which need to be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>max_values</code> <p>The maximum amount of entries which can be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>is_disabled</code> <p>Whether this select menu should be marked as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>type[Self]</code> <p>The action column class to enable chained calls.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>When called directly on components.ActionColumnExecutor (rather than on a subclass).</p>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.add_static_channel_select","title":"add_static_channel_select  <code>classmethod</code>","text":"<pre><code>add_static_channel_select(callback, /, *, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Deprecated alias of .add_static_channel_menu.</p>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.add_static_interative_button","title":"add_static_interative_button  <code>classmethod</code>","text":"<pre><code>add_static_interative_button(style, callback, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add an interactive button to all subclasses and instances of this action column class.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> PARAMETER DESCRIPTION <code>style</code> <p>The button's style.</p> <p> TYPE: <code>hikari.InteractiveButtonTypesT</code> </p> <code>callback</code> <p>The button's execution callback.</p> <p> TYPE: <code>CallbackSig</code> </p> <code>custom_id</code> <p>The button's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>emoji</code> <p>The button's emoji.</p> <p> TYPE: <code>typing.Union[hikari.Snowflakeish, hikari.Emoji, str, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>label</code> <p>The button's label.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>is_disabled</code> <p>Whether the button should be marked as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>type[Self]</code> <p>The action column class to enable chained calls.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>When called directly on components.ActionColumnExecutor (rather than on a subclass).</p>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.add_static_link_button","title":"add_static_link_button  <code>classmethod</code>","text":"<pre><code>add_static_link_button(url, /, *, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add a link button to all subclasses and instances of this action column class.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> PARAMETER DESCRIPTION <code>url</code> <p>The button's url.</p> <p> TYPE: <code>str</code> </p> <code>emoji</code> <p>The button's emoji.</p> <p> TYPE: <code>typing.Union[hikari.Snowflakeish, hikari.Emoji, str, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>label</code> <p>The button's label.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>is_disabled</code> <p>Whether the button should be marked as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>type[Self]</code> <p>The action column class to enable chained calls.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>When called directly on components.ActionColumnExecutor (rather than on a subclass).</p>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.add_static_select_menu","title":"add_static_select_menu  <code>classmethod</code>","text":"<pre><code>add_static_select_menu(type_, callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a select menu to all subclasses and instances of this action column class.</p> <p>For channel select menus and text select menus see ActionColumnExecutor.add_channel_menu and ActionColumnExecutor.add_text_menu respectively.</p> PARAMETER DESCRIPTION <code>type_</code> <p>The type of select menu to add.</p> <p>Passing callback here is deprecated.</p> <p> TYPE: <code>hikari.components.ComponentType | int</code> </p> <code>callback</code> <p>Callback which is called when this select menu is used.</p> <p>Passing type here is deprecated.</p> <p> TYPE: <code>yuyo.components.CallbackSig</code> </p> <code>custom_id</code> <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>placeholder</code> <p>Placeholder text to show when no entries have been selected.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>min_values</code> <p>The minimum amount of entries which need to be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>max_values</code> <p>The maximum amount of entries which can be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>is_disabled</code> <p>Whether this select menu should be marked as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>type[Self]</code> <p>The action column class to enable chained calls.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>When called directly on components.ActionColumnExecutor (rather than on a subclass).</p>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.add_static_text_menu","title":"add_static_text_menu  <code>classmethod</code>","text":"<pre><code>add_static_text_menu(callback, /, *, custom_id=None, options=(), placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a text select menu to all subclasses and instances of this action column class.</p> PARAMETER DESCRIPTION <code>callback</code> <p>Callback which is called when this select menu is used.</p> <p> TYPE: <code>CallbackSig</code> </p> <code>custom_id</code> <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>options</code> <p>The text select's options.</p> <p>These can also be added by calling TextSelectMenuBuilder.add_option.</p> <p> TYPE: <code>collections.Sequence[hikari.api.SelectOptionBuilder]</code> DEFAULT: <code>()</code> </p> <code>placeholder</code> <p>Placeholder text to show when no entries have been selected.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>min_values</code> <p>The minimum amount of entries which need to be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>max_values</code> <p>The maximum amount of entries which can be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>is_disabled</code> <p>Whether this select menu should be marked as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>hikari.api.special_endpoints.TextSelectMenuBuilder</code> <p>Builder for the added text select menu.</p> <p>TextSelectMenuBuilder.add_option should be used to add options to this select menu.</p> <p>And the parent action column can be accessed by calling TextSelectMenuBuilder.parent.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>When called directly on components.ActionColumnExecutor (rather than on a subclass).</p>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.add_static_text_select","title":"add_static_text_select  <code>classmethod</code>","text":"<pre><code>add_static_text_select(callback, /, *, custom_id=None, options=(), placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Deprecated alias of .add_static_text_menu.</p>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.add_text_menu","title":"add_text_menu","text":"<pre><code>add_text_menu(callback, /, *, custom_id=None, options=(), placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a text select menu to this action column.</p> PARAMETER DESCRIPTION <code>callback</code> <p>Callback which is called when this select menu is used.</p> <p> TYPE: <code>CallbackSig</code> </p> <code>custom_id</code> <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>options</code> <p>The text select's options.</p> <p>These can also be added by calling TextSelectMenuBuilder.add_option.</p> <p> TYPE: <code>collections.Sequence[hikari.api.SelectOptionBuilder]</code> DEFAULT: <code>()</code> </p> <code>placeholder</code> <p>Placeholder text to show when no entries have been selected.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>min_values</code> <p>The minimum amount of entries which need to be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>max_values</code> <p>The maximum amount of entries which can be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>is_disabled</code> <p>Whether this select menu should be marked as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>hikari.api.special_endpoints.TextSelectMenuBuilder</code> <p>Builder for the added text select menu.</p> <p>TextSelectMenuBuilder.add_option should be used to add options to this select menu.</p> <p>And the parent action column can be accessed by calling TextSelectMenuBuilder.parent.</p>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.add_text_select","title":"add_text_select","text":"<pre><code>add_text_select(callback, /, *, custom_id=None, options=(), placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Deprecated alias of .add_text_menu.</p>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.with_static_button","title":"with_static_button  <code>classmethod</code>","text":"<pre><code>with_static_button(style, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Deprecated alias of .with_static_interative_button.</p>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.with_static_channel_menu","title":"with_static_channel_menu  <code>classmethod</code>","text":"<pre><code>with_static_channel_menu(*, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Deprecated method.</p> <p>Use .add_static_channel_menu.</p>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.with_static_channel_select","title":"with_static_channel_select  <code>classmethod</code>","text":"<pre><code>with_static_channel_select(*, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Deprecated alias of .with_static_channel_menu.</p>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.with_static_interative_button","title":"with_static_interative_button  <code>classmethod</code>","text":"<pre><code>with_static_interative_button(style, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Deprecated method.</p> <p>Use .add_static_interactive_button.</p>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.with_static_select_menu","title":"with_static_select_menu  <code>classmethod</code>","text":"<pre><code>with_static_select_menu(type_, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Deprecated method.</p> <p>Use .add_static_select_menu.</p>"},{"location":"reference/components/#yuyo.components.ActionRowExecutor","title":"ActionRowExecutor","text":"<p>         Bases: <code>ComponentExecutor</code>, <code>hikari.api.ComponentBuilder</code></p> <p>Class used for handling the execution of an action row.</p> <p>You likely want ActionColumnExecutor which provides an interface for handling all the components on a message instead of this.</p>"},{"location":"reference/components/#yuyo.components.ActionRowExecutor.components","title":"components  <code>property</code>","text":"<pre><code>components: collections.Sequence[hikari.api.ComponentBuilder]\n</code></pre> <p>The sub-components in this row.</p>"},{"location":"reference/components/#yuyo.components.ActionRowExecutor.__init__","title":"__init__","text":"<pre><code>__init__(*, ephemeral_default=False, timeout=_internal.NO_DEFAULT, _stack_level=0)\n</code></pre> <p>Initialise an action row executor.</p> PARAMETER DESCRIPTION <code>ephemeral_default</code> <p>Whether this executor's responses should default to being ephemeral.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"reference/components/#yuyo.components.ActionRowExecutor.add_button","title":"add_button","text":"<pre><code>add_button(style, callback, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Deprecated alias of .add_interative_button.</p>"},{"location":"reference/components/#yuyo.components.ActionRowExecutor.add_channel_menu","title":"add_channel_menu","text":"<pre><code>add_channel_menu(callback, /, *, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a channel select menu to this action row.</p> PARAMETER DESCRIPTION <code>callback</code> <p>Callback which is called when this select menu is used.</p> <p> TYPE: <code>CallbackSig</code> </p> <code>channel_types</code> <p>Sequence of the types of channels this select menu should show as options.</p> <p> TYPE: <code>typing.Optional[collections.Sequence[typing.Union[hikari.ChannelType, _Type[hikari.PartialChannel]]]]</code> DEFAULT: <code>None</code> </p> <code>custom_id</code> <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>placeholder</code> <p>Placeholder text to show when no entries have been selected.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>min_values</code> <p>The minimum amount of entries which need to be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>max_values</code> <p>The maximum amount of entries which can be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>is_disabled</code> <p>Whether this select menu should be marked as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The action row to enable chained calls.</p>"},{"location":"reference/components/#yuyo.components.ActionRowExecutor.add_channel_select","title":"add_channel_select","text":"<pre><code>add_channel_select(callback, /, *, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Deprecated alias of .add_channel_menu.</p>"},{"location":"reference/components/#yuyo.components.ActionRowExecutor.add_component","title":"add_component","text":"<pre><code>add_component(component)\n</code></pre> <p>Add a sub-component to this action row.</p> <p>ActionRowExecutor.set_callback should be used to set the callback for this component if it is interactive (has a <code>custom_id</code> field).</p> PARAMETER DESCRIPTION <code>component</code> <p>The sub-component to add.</p> <p> TYPE: <code>hikari.api.ComponentBuilder</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The action row to enable chained calls.</p>"},{"location":"reference/components/#yuyo.components.ActionRowExecutor.add_interative_button","title":"add_interative_button","text":"<pre><code>add_interative_button(style, callback, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add an interactive button to this action row.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> PARAMETER DESCRIPTION <code>style</code> <p>The interactive button's style.</p> <p> TYPE: <code>hikari.InteractiveButtonTypesT</code> </p> <code>callback</code> <p>The interactive button's callback.</p> <p> TYPE: <code>CallbackSig</code> </p> <code>custom_id</code> <p>The button's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>emoji</code> <p>The button's emoji.</p> <p> TYPE: <code>typing.Union[hikari.Snowflakeish, hikari.Emoji, str, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>label</code> <p>The button's label.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>is_disabled</code> <p>Whether the button should be marked as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The action row to enable chained calls.</p> RAISES DESCRIPTION <code>ValueError</code> <ul> <li>If any of the sub-components in this action row aren't buttons.</li> <li>If a callback is passed for <code>callback_or_url</code> for a url style button.</li> <li>If a string is passed for <code>callback_or_url</code> for an interactive button.</li> </ul>"},{"location":"reference/components/#yuyo.components.ActionRowExecutor.add_link_button","title":"add_link_button","text":"<pre><code>add_link_button(url, /, *, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add a Link button to this action row.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> PARAMETER DESCRIPTION <code>url</code> <p>The button's url.</p> <p> TYPE: <code>str</code> </p> <code>emoji</code> <p>The button's emoji.</p> <p> TYPE: <code>typing.Union[hikari.Snowflakeish, hikari.Emoji, str, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>label</code> <p>The button's label.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>is_disabled</code> <p>Whether the button should be marked as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The action row to enable chained calls.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If any of the sub-components in this action row aren't buttons.</p>"},{"location":"reference/components/#yuyo.components.ActionRowExecutor.add_select_menu","title":"add_select_menu","text":"<pre><code>add_select_menu(type_, callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a select menu to this action row.</p> <p>For channel select menus and text select menus see ActionRowExecutor.add_channel_menu and ActionRowExecutor.add_text_menu respectively.</p> PARAMETER DESCRIPTION <code>type_</code> <p>The type of select menu to add.</p> <p>Passing callback here is deprecated.</p> <p> TYPE: <code>hikari.components.ComponentType | int</code> </p> <code>callback</code> <p>Callback which is called when this select menu is used.</p> <p>Passing type here is deprecated.</p> <p> TYPE: <code>yuyo.components.CallbackSig</code> </p> <code>custom_id</code> <p>The select menu's custom ID.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>placeholder</code> <p>Placeholder text to show when no entries have been selected.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>min_values</code> <p>The minimum amount of entries which need to be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>max_values</code> <p>The maximum amount of entries which can be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>is_disabled</code> <p>Whether this select menu should be marked as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The action row to enable chained calls.</p>"},{"location":"reference/components/#yuyo.components.ActionRowExecutor.add_text_menu","title":"add_text_menu","text":"<pre><code>add_text_menu(callback, /, *, custom_id=None, options=(), placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a text select menu to this action row.</p> PARAMETER DESCRIPTION <code>callback</code> <p>Callback which is called when this select menu is used.</p> <p> TYPE: <code>CallbackSig</code> </p> <code>custom_id</code> <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>options</code> <p>The text select's options.</p> <p>These can also be added by calling TextSelectMenuBuilder.add_option.</p> <p> TYPE: <code>collections.Sequence[hikari.api.SelectOptionBuilder]</code> DEFAULT: <code>()</code> </p> <code>placeholder</code> <p>Placeholder text to show when no entries have been selected.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>min_values</code> <p>The minimum amount of entries which need to be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>max_values</code> <p>The maximum amount of entries which can be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>is_disabled</code> <p>Whether this select menu should be marked as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>hikari.api.special_endpoints.TextSelectMenuBuilder</code> <p>Builder for the added text select menu.</p> <p>And the parent action row can be accessed by calling TextSelectMenuBuilder.parent.</p>"},{"location":"reference/components/#yuyo.components.ActionRowExecutor.add_text_select","title":"add_text_select","text":"<pre><code>add_text_select(callback, /, *, custom_id=None, options=(), placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Deprecated alias of .add_text_menu.</p>"},{"location":"reference/components/#yuyo.components.BaseContext","title":"BaseContext","text":"<p>         Bases: <code>abc.ABC</code>, <code>typing.Generic[_PartialInteractionT]</code></p> <p>Base class for components contexts.</p>"},{"location":"reference/components/#yuyo.components.BaseContext.expires_at","title":"expires_at  <code>property</code>","text":"<pre><code>expires_at: datetime.datetime\n</code></pre> <p>When this application command context expires.</p> <p>After this time is reached, the message/response methods on this context will always raise hikari.errors.NotFoundError.</p>"},{"location":"reference/components/#yuyo.components.BaseContext.has_been_deferred","title":"has_been_deferred  <code>property</code>","text":"<pre><code>has_been_deferred: bool\n</code></pre> <p>Whether this context's initial response has been deferred.</p> <p>This will be true if yuyo.components.BaseContext.defer has been called.</p>"},{"location":"reference/components/#yuyo.components.BaseContext.has_responded","title":"has_responded  <code>property</code>","text":"<pre><code>has_responded: bool\n</code></pre> <p>Whether an initial response has been made to this context yet.</p> <p>It's worth noting that a context must be either responded to or deferred within 3 seconds from it being received otherwise it'll be marked as failed.</p> <p>This will be true if either yuyo.components.BaseContext.respond, yuyo.components.BaseContext.create_initial_response or yuyo.components.BaseContext.edit_initial_response (after a deferral) has been called.</p>"},{"location":"reference/components/#yuyo.components.BaseContext.id_match","title":"id_match  <code>property</code>","text":"<pre><code>id_match: str\n</code></pre> <p>Section of the ID used to identify the relevant executor.</p>"},{"location":"reference/components/#yuyo.components.BaseContext.id_metadata","title":"id_metadata  <code>property</code>","text":"<pre><code>id_metadata: str\n</code></pre> <p>Metadata from the interaction's custom ID.</p>"},{"location":"reference/components/#yuyo.components.BaseContext.interaction","title":"interaction  <code>property</code>","text":"<pre><code>interaction: _PartialInteractionT\n</code></pre> <p>Object of the interaction this context is for.</p>"},{"location":"reference/components/#yuyo.components.BaseContext.create_followup","title":"create_followup  <code>async</code>","text":"<pre><code>create_followup(content=hikari.UNDEFINED, *, delete_after=None, ephemeral=False, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, mentions_everyone=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED, tts=hikari.UNDEFINED, flags=hikari.UNDEFINED)\n</code></pre> <p>Create a followup response for this context.</p> <p>Warning</p> <p>Calling this on a context which hasn't had an initial response yet will lead to a hikari.errors.NotFoundError being raised.</p> PARAMETER DESCRIPTION <code>content</code> <p>If provided, the message contents. If hikari.undefined.UNDEFINED, then nothing will be sent in the content. Any other value here will be cast to a str.</p> <p>If this is a hikari.embeds.Embed and no <code>embed</code> kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.files.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> <p> TYPE: <code>hikari.UndefinedOr[typing.Any]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>delete_after</code> <p>If provided, the seconds after which the response message should be deleted.</p> <p>Slash command responses can only be deleted within 15 minutes of the command being received.</p> <p> TYPE: <code>typing.Union[datetime.timedelta, float, int, None]</code> DEFAULT: <code>None</code> </p> <code>ephemeral</code> <p>Whether the deferred response should be ephemeral. Passing True here is a shorthand for including <code>1 &lt;&lt; 64</code> in the passed flags.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>attachment</code> <p>If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.Resourceish]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>attachments</code> <p>If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.</p> <p> TYPE: <code>hikari.UndefinedOr[collections.Sequence[hikari.Resourceish]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>component</code> <p>If provided, builder object of the component to include in this message.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.api.ComponentBuilder]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>components</code> <p>If provided, a sequence of the component builder objects to include in this message.</p> <p> TYPE: <code>hikari.UndefinedOr[collections.Sequence[hikari.api.ComponentBuilder]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>embed</code> <p>If provided, the message embed.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.Embed]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>embeds</code> <p>If provided, the message embeds.</p> <p> TYPE: <code>hikari.UndefinedOr[collections.Sequence[hikari.Embed]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>mentions_everyone</code> <p>If provided, whether the message should parse @everyone/@here mentions.</p> <p> TYPE: <code>hikari.UndefinedOr[bool]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>user_mentions</code> <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.snowflakes.Snowflake, or hikari.users.PartialUser derivatives to enforce mentioning specific users.</p> <p> TYPE: <code>typing.Union[hikari.SnowflakeishSequence[hikari.PartialUser], bool, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>role_mentions</code> <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.snowflakes.Snowflake, or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles.</p> <p> TYPE: <code>typing.Union[hikari.SnowflakeishSequence[hikari.PartialRole], bool, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>tts</code> <p>If provided, whether the message will be sent as a TTS message.</p> <p> TYPE: <code>hikari.UndefinedOr[bool]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>flags</code> <p>The flags to set for this response.</p> <p>As of writing this can only flag which can be provided is EPHEMERAL, other flags are just ignored.</p> <p> TYPE: <code>typing.Union[hikari.UndefinedType, int, hikari.MessageFlag]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> RETURNS DESCRIPTION <code>hikari.Message</code> <p>The created message object.</p> RAISES DESCRIPTION <code>hikari.NotFoundError</code> <p>If the current interaction is not found or it hasn't had an initial response yet.</p> <code>hikari.BadRequestError</code> <p>This can be raised if the file is too large; if the embed exceeds the defined limits; if the message content is specified only and empty or greater than <code>2000</code> characters; if neither content, file or embeds are specified. If any invalid snowflake IDs are passed; a snowflake may be invalid due to it being outside of the range of a 64 bit integer.</p> <code>ValueError</code> <p>If more than 100 unique objects/entities are passed for <code>role_mentions</code> or `user_mentions.</p> <p>If the interaction will have expired before <code>delete_after</code> is reached.</p> <p>If both <code>attachment</code> and <code>attachments</code> are passed or both <code>component</code> and <code>components</code> are passed or both <code>embed</code> and <code>embeds</code> are passed.</p>"},{"location":"reference/components/#yuyo.components.BaseContext.create_initial_response","title":"create_initial_response  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>create_initial_response(content=hikari.UNDEFINED, *, delete_after=None, ephemeral=False, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, mentions_everyone=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED, flags=hikari.UNDEFINED, tts=hikari.UNDEFINED)\n</code></pre> <p>Create the initial response for this context.</p> <p>Warning</p> <p>Calling this on a context which already has an initial response will result in this raising a hikari.errors.NotFoundError. This includes if the REST interaction server has already responded to the request and deferrals.</p> PARAMETER DESCRIPTION <code>content</code> <p>The content to edit the last response with.</p> <p>If provided, the message contents. If hikari.undefined.UNDEFINED, then nothing will be sent in the content. Any other value here will be cast to a str.</p> <p>If this is a hikari.embeds.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.files.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> <p> TYPE: <code>hikari.UndefinedOr[typing.Any]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>delete_after</code> <p>If provided, the seconds after which the response message should be deleted.</p> <p>Slash command responses can only be deleted within 15 minutes of the command being received.</p> <p> TYPE: <code>typing.Union[datetime.timedelta, float, int, None]</code> DEFAULT: <code>None</code> </p> <code>ephemeral</code> <p>Whether the deferred response should be ephemeral.</p> <p>Passing True here is a shorthand for including <code>1 &lt;&lt; 64</code> in the passed flags.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>content</code> <p>If provided, the message contents. If hikari.undefined.UNDEFINED, then nothing will be sent in the content. Any other value here will be cast to a <code>str</code>.</p> <p>If this is a hikari.embeds.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone.</p> <p> TYPE: <code>hikari.UndefinedOr[typing.Any]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>attachment</code> <p>If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.Resourceish]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>attachments</code> <p>If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.</p> <p> TYPE: <code>hikari.UndefinedOr[collections.Sequence[hikari.Resourceish]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>component</code> <p>If provided, builder object of the component to include in this message.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.api.ComponentBuilder]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>components</code> <p>If provided, a sequence of the component builder objects to include in this message.</p> <p> TYPE: <code>hikari.UndefinedOr[collections.Sequence[hikari.api.ComponentBuilder]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>embed</code> <p>If provided, the message embed.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.Embed]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>embeds</code> <p>If provided, the message embeds.</p> <p> TYPE: <code>hikari.UndefinedOr[collections.Sequence[hikari.Embed]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>flags</code> <p>If provided, the message flags this response should have.</p> <p>As of writing the only message flag which can be set here is hikari.messages.MessageFlag.EPHEMERAL.</p> <p> TYPE: <code>typing.Union[int, hikari.MessageFlag, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>tts</code> <p>If provided, whether the message will be read out by a screen reader using Discord's TTS (text-to-speech) system.</p> <p> TYPE: <code>hikari.UndefinedOr[bool]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>mentions_everyone</code> <p>If provided, whether the message should parse @everyone/@here mentions.</p> <p> TYPE: <code>hikari.UndefinedOr[bool]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>user_mentions</code> <p>If provided, and True, all user mentions will be detected. If provided, and False, all user mentions will be ignored if appearing in the message body.</p> <p>Alternatively this may be a collection of hikari.snowflakes.Snowflake, or hikari.users.PartialUser derivatives to enforce mentioning specific users.</p> <p> TYPE: <code>typing.Union[hikari.SnowflakeishSequence[hikari.PartialUser], bool, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>role_mentions</code> <p>If provided, and True, all role mentions will be detected. If provided, and False, all role mentions will be ignored if appearing in the message body.</p> <p>Alternatively this may be a collection of [hikari.snowflakes.Snowflake], or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles.</p> <p> TYPE: <code>typing.Union[hikari.SnowflakeishSequence[hikari.PartialRole], bool, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If more than 100 unique objects/entities are passed for <code>role_mentions</code> or <code>user_mentions</code>.</p> <p>If the interaction will have expired before <code>delete_after</code> is reached.</p> <p>If both <code>attachment</code> and <code>attachments</code> are passed or both <code>component</code> and <code>components</code> are passed or both <code>embed</code> and <code>embeds</code> are passed.</p> <code>hikari.BadRequestError</code> <p>This may be raised in several discrete situations, such as messages being empty with no embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; invalid image URLs in embeds.</p> <code>hikari.UnauthorizedError</code> <p>If you are unauthorized to make the request (invalid/missing token).</p> <code>hikari.NotFoundError</code> <p>If the interaction is not found or if the interaction's initial response has already been created.</p> <code>hikari.RateLimitTooLongError</code> <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> <code>hikari.InternalServerError</code> <p>If an internal error occurs on Discord while handling the request.</p>"},{"location":"reference/components/#yuyo.components.BaseContext.defer","title":"defer  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>defer(*, ephemeral=False, flags=hikari.UNDEFINED)\n</code></pre> <p>Defer the initial response for this context.</p> <p>Note</p> <p>The ephemeral state of the first response is decided by whether the deferral is ephemeral.</p> PARAMETER DESCRIPTION <code>ephemeral</code> <p>Whether the deferred response should be ephemeral. Passing True here is a shorthand for including <code>1 &lt;&lt; 64</code> in the passed flags.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>flags</code> <p>The flags to use for the initial response.</p> <p> TYPE: <code>typing.Union[hikari.UndefinedType, int, hikari.MessageFlag]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p>"},{"location":"reference/components/#yuyo.components.BaseContext.delete_initial_response","title":"delete_initial_response  <code>async</code>","text":"<pre><code>delete_initial_response()\n</code></pre> <p>Delete the initial response after invoking this context.</p> RAISES DESCRIPTION <code>LookupError, hikari.NotFoundError</code> <p>The last context has no initial response.</p>"},{"location":"reference/components/#yuyo.components.BaseContext.delete_last_response","title":"delete_last_response  <code>async</code>","text":"<pre><code>delete_last_response()\n</code></pre> <p>Delete the last response after invoking this context.</p> RAISES DESCRIPTION <code>LookupError, hikari.NotFoundError</code> <p>The last context has no responses.</p>"},{"location":"reference/components/#yuyo.components.BaseContext.edit_initial_response","title":"edit_initial_response  <code>async</code>","text":"<pre><code>edit_initial_response(content=hikari.UNDEFINED, *, delete_after=None, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, mentions_everyone=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED)\n</code></pre> <p>Edit the initial response for this context.</p> PARAMETER DESCRIPTION <code>content</code> <p>The content to edit the initial response with.</p> <p>If provided, the message contents. If hikari.undefined.UNDEFINED, then nothing will be sent in the content. Any other value here will be cast to a str.</p> <p>If this is a hikari.embeds.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.files.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> <p> TYPE: <code>hikari.UndefinedOr[typing.Any]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>delete_after</code> <p>If provided, the seconds after which the response message should be deleted.</p> <p>Slash command responses can only be deleted within 15 minutes of the command being received.</p> <p> TYPE: <code>typing.Union[datetime.timedelta, float, int, None]</code> DEFAULT: <code>None</code> </p> <code>attachment</code> <p>A singular attachment to edit the initial response with.</p> <p> TYPE: <code>hikari.UndefinedNoneOr[hikari.Resourceish]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>attachments</code> <p>A sequence of attachments to edit the initial response with.</p> <p> TYPE: <code>hikari.UndefinedNoneOr[collections.Sequence[hikari.Resourceish]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>component</code> <p>If provided, builder object of the component to set for this message. This component will replace any previously set components and passing None will remove all components.</p> <p> TYPE: <code>hikari.UndefinedNoneOr[hikari.api.ComponentBuilder]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>components</code> <p>If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing None or an empty sequence will remove all components.</p> <p> TYPE: <code>hikari.UndefinedNoneOr[collections.Sequence[hikari.api.ComponentBuilder]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>embed</code> <p>An embed to replace the initial response with.</p> <p> TYPE: <code>hikari.UndefinedNoneOr[hikari.Embed]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>embeds</code> <p>A sequence of embeds to replace the initial response with.</p> <p> TYPE: <code>hikari.UndefinedNoneOr[collections.Sequence[hikari.Embed]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>mentions_everyone</code> <p>If provided, whether the message should parse @everyone/@here mentions.</p> <p> TYPE: <code>hikari.UndefinedOr[bool]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>user_mentions</code> <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake, or hikari.users.PartialUser derivatives to enforce mentioning specific users.</p> <p> TYPE: <code>typing.Union[hikari.SnowflakeishSequence[hikari.PartialUser], bool, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>role_mentions</code> <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake, or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles.</p> <p> TYPE: <code>typing.Union[hikari.SnowflakeishSequence[hikari.PartialRole], bool, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> RETURNS DESCRIPTION <code>hikari.Message</code> <p>The message that has been edited.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If more than 100 unique objects/entities are passed for <code>role_mentions</code> or <code>user_mentions</code>.</p> <p>If <code>delete_after</code> would be more than 15 minutes after the slash command was called.</p> <p>If both <code>attachment</code> and <code>attachments</code> are passed or both <code>component</code> and <code>components</code> are passed or both <code>embed</code> and <code>embeds</code> are passed.</p> <code>hikari.BadRequestError</code> <p>This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components.</p> <code>hikari.UnauthorizedError</code> <p>If you are unauthorized to make the request (invalid/missing token).</p> <code>hikari.ForbiddenError</code> <p>If you are missing the <code>SEND_MESSAGES</code> in the channel or the person you are trying to message has the DM's disabled.</p> <code>hikari.NotFoundError</code> <p>If the channel is not found.</p> <code>hikari.RateLimitTooLongError</code> <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> <code>hikari.InternalServerError</code> <p>If an internal error occurs on Discord while handling the request.</p>"},{"location":"reference/components/#yuyo.components.BaseContext.edit_last_response","title":"edit_last_response  <code>async</code>","text":"<pre><code>edit_last_response(content=hikari.UNDEFINED, *, delete_after=None, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, mentions_everyone=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED)\n</code></pre> <p>Edit the last response for this context.</p> PARAMETER DESCRIPTION <code>content</code> <p>The content to edit the last response with.</p> <p>If provided, the message contents. If hikari.undefined.UNDEFINED, then nothing will be sent in the content. Any other value here will be cast to a str.</p> <p>If this is a hikari.embeds.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.files.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> <p> TYPE: <code>hikari.UndefinedOr[typing.Any]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>delete_after</code> <p>If provided, the seconds after which the response message should be deleted.</p> <p>Slash command responses can only be deleted within 15 minutes of the command being received.</p> <p> TYPE: <code>typing.Union[datetime.timedelta, float, int, None]</code> DEFAULT: <code>None</code> </p> <code>attachment</code> <p>A singular attachment to edit the last response with.</p> <p> TYPE: <code>hikari.UndefinedNoneOr[hikari.Resourceish]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>attachments</code> <p>A sequence of attachments to edit the last response with.</p> <p> TYPE: <code>hikari.UndefinedNoneOr[collections.Sequence[hikari.Resourceish]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>component</code> <p>If provided, builder object of the component to set for this message. This component will replace any previously set components and passing None will remove all components.</p> <p> TYPE: <code>hikari.UndefinedNoneOr[hikari.api.ComponentBuilder]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>components</code> <p>If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing None or an empty sequence will remove all components.</p> <p> TYPE: <code>hikari.UndefinedNoneOr[collections.Sequence[hikari.api.ComponentBuilder]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>embed</code> <p>An embed to replace the last response with.</p> <p> TYPE: <code>hikari.UndefinedNoneOr[hikari.Embed]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>embeds</code> <p>A sequence of embeds to replace the last response with.</p> <p> TYPE: <code>hikari.UndefinedNoneOr[collections.Sequence[hikari.Embed]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>mentions_everyone</code> <p>If provided, whether the message should parse @everyone/@here mentions.</p> <p> TYPE: <code>hikari.UndefinedOr[bool]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>user_mentions</code> <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.snowflakes.Snowflake, or hikari.users.PartialUser derivatives to enforce mentioning specific users.</p> <p> TYPE: <code>typing.Union[hikari.SnowflakeishSequence[hikari.PartialUser], bool, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>role_mentions</code> <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.snowflakes.Snowflake, or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles.</p> <p> TYPE: <code>typing.Union[hikari.SnowflakeishSequence[hikari.PartialRole], bool, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> RETURNS DESCRIPTION <code>hikari.Message</code> <p>The message that has been edited.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If more than 100 unique objects/entities are passed for <code>role_mentions</code> or <code>user_mentions</code>.</p> <p>If <code>delete_after</code> would be more than 15 minutes after the slash command was called.</p> <p>If both <code>attachment</code> and <code>attachments</code> are passed or both <code>component</code> and <code>components</code> are passed or both <code>embed</code> and <code>embeds</code> are passed.</p> <code>hikari.BadRequestError</code> <p>This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components.</p> <code>hikari.UnauthorizedError</code> <p>If you are unauthorized to make the request (invalid/missing token).</p> <code>hikari.ForbiddenError</code> <p>If you are missing the <code>SEND_MESSAGES</code> in the channel or the person you are trying to message has the DM's disabled.</p> <code>hikari.NotFoundError</code> <p>If the channel is not found.</p> <code>hikari.RateLimitTooLongError</code> <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> <code>hikari.InternalServerError</code> <p>If an internal error occurs on Discord while handling the request.</p>"},{"location":"reference/components/#yuyo.components.BaseContext.fetch_initial_response","title":"fetch_initial_response  <code>async</code>","text":"<pre><code>fetch_initial_response()\n</code></pre> <p>Fetch the initial response for this context.</p> RETURNS DESCRIPTION <code>hikari.messages.Message</code> <p>The initial response's message object.</p> RAISES DESCRIPTION <code>LookupError, hikari.NotFoundError</code> <p>The response was not found.</p>"},{"location":"reference/components/#yuyo.components.BaseContext.fetch_last_response","title":"fetch_last_response  <code>async</code>","text":"<pre><code>fetch_last_response()\n</code></pre> <p>Fetch the last response for this context.</p> RETURNS DESCRIPTION <code>hikari.messages.Message</code> <p>The most response response's message object.</p> RAISES DESCRIPTION <code>LookupError, hikari.NotFoundError</code> <p>The response was not found.</p>"},{"location":"reference/components/#yuyo.components.BaseContext.respond","title":"respond  <code>async</code>","text":"<pre><code>respond(content=hikari.UNDEFINED, *, ensure_result=False, delete_after=None, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, mentions_everyone=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED)\n</code></pre> <p>Respond to this context.</p> PARAMETER DESCRIPTION <code>content</code> <p>The content to respond with.</p> <p>If provided, the message contents. If hikari.undefined.UNDEFINED, then nothing will be sent in the content. Any other value here will be cast to a str.</p> <p>If this is a hikari.embeds.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.files.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> <p> TYPE: <code>hikari.UndefinedOr[typing.Any]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>ensure_result</code> <p>Ensure that this call will always return a message object.</p> <p>If True then this will always return hikari.messages.Message, otherwise this will return <code>hikari.Message | None</code>.</p> <p>It's worth noting that, under certain scenarios within the slash command flow, this may lead to an extre request being made.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>delete_after</code> <p>If provided, the seconds after which the response message should be deleted.</p> <p>Slash command responses can only be deleted within 15 minutes of the command being received.</p> <p> TYPE: <code>typing.Union[datetime.timedelta, float, int, None]</code> DEFAULT: <code>None</code> </p> <code>attachment</code> <p>If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.Resourceish]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>attachments</code> <p>If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.</p> <p> TYPE: <code>hikari.UndefinedOr[collections.Sequence[hikari.Resourceish]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>component</code> <p>If provided, builder object of the component to include in this response.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.api.ComponentBuilder]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>components</code> <p>If provided, a sequence of the component builder objects to include in this response.</p> <p> TYPE: <code>hikari.UndefinedOr[collections.Sequence[hikari.api.ComponentBuilder]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>embed</code> <p>An embed to respond with.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.Embed]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>embeds</code> <p>A sequence of embeds to respond with.</p> <p> TYPE: <code>hikari.UndefinedOr[collections.Sequence[hikari.Embed]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>mentions_everyone</code> <p>If provided, whether the message should parse @everyone/@here mentions.</p> <p> TYPE: <code>hikari.UndefinedOr[bool]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>user_mentions</code> <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.snowflakes.Snowflake, or hikari.users.PartialUser derivatives to enforce mentioning specific users.</p> <p> TYPE: <code>typing.Union[hikari.SnowflakeishSequence[hikari.PartialUser], bool, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>role_mentions</code> <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.snowflakes.Snowflake, or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles.</p> <p> TYPE: <code>typing.Union[hikari.SnowflakeishSequence[hikari.PartialRole], bool, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> RETURNS DESCRIPTION <code>hikari.Message | None</code> <p>The message that has been created if it was immedieatly available or <code>ensure_result</code> was set to True, else None.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If more than 100 unique objects/entities are passed for <code>role_mentions</code> or <code>user_mentions</code>.</p> <p>If <code>delete_after</code> would be more than 15 minutes after the slash command was called.</p> <p>If both <code>attachment</code> and <code>attachments</code> are passed or both <code>component</code> and <code>components</code> are passed or both <code>embed</code> and <code>embeds</code> are passed.</p> <code>hikari.BadRequestError</code> <p>This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components.</p> <code>hikari.UnauthorizedError</code> <p>If you are unauthorized to make the request (invalid/missing token).</p> <code>hikari.ForbiddenError</code> <p>If you are missing the <code>SEND_MESSAGES</code> in the channel or the person you are trying to message has the DM's disabled.</p> <code>hikari.NotFoundError</code> <p>If the channel is not found.</p> <code>hikari.RateLimitTooLongError</code> <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> <code>hikari.InternalServerError</code> <p>If an internal error occurs on Discord while handling the request.</p>"},{"location":"reference/components/#yuyo.components.BaseContext.set_ephemeral_default","title":"set_ephemeral_default","text":"<pre><code>set_ephemeral_default(state)\n</code></pre> <p>Set the ephemeral default state for this context.</p> PARAMETER DESCRIPTION <code>state</code> <p>The new ephemeral default state.</p> <p>If this is True then all calls to the response creating methods on this context will default to being ephemeral.</p> <p> TYPE: <code>bool</code> </p>"},{"location":"reference/components/#yuyo.components.ComponentClient","title":"ComponentClient","text":"<p>Client used to handle component executors within a REST or gateway flow.</p>"},{"location":"reference/components/#yuyo.components.ComponentClient.alluka","title":"alluka  <code>property</code>","text":"<pre><code>alluka: alluka_.abc.Client\n</code></pre> <p>The Alluka client being used for callback dependency injection.</p>"},{"location":"reference/components/#yuyo.components.ComponentClient.__init__","title":"__init__","text":"<pre><code>__init__(*, alluka=None, event_manager=None, event_managed=None, server=None)\n</code></pre> <p>Initialise a component client.</p> <p>This sets ComponentClient as a type dependency when <code>alluka</code> isn't passed.</p> <p>Note</p> <p>For an easier way to initialise the client from a bot see ComponentClient.from_gateway_bot, ComponentClient.from_rest_bot, and ComponentClient.from_tanjun.</p> PARAMETER DESCRIPTION <code>alluka</code> <p>The Alluka client to use for callback dependency injection in this client.</p> <p>If not provided then this will initialise its own Alluka client.</p> <p> TYPE: <code>typing.Optional[alluka_.abc.Client]</code> DEFAULT: <code>None</code> </p> <code>event_manager</code> <p>The event manager this client should listen to dispatched component interactions from if applicable.</p> <p> TYPE: <code>typing.Optional[hikari.api.EventManager]</code> DEFAULT: <code>None</code> </p> <code>event_managed</code> <p>Whether this client should be automatically opened and closed based on the lifetime events dispatched by <code>event_manager</code>.</p> <p>Defaults to True if an event manager is passed.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>server</code> <p>The server this client should listen to component interactions from if applicable.</p> <p> TYPE: <code>typing.Optional[hikari.api.InteractionServer]</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If <code>event_managed</code> is passed as True when <code>event_manager</code> is None.</p>"},{"location":"reference/components/#yuyo.components.ComponentClient.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Close the component client.</p>"},{"location":"reference/components/#yuyo.components.ComponentClient.deregister_executor","title":"deregister_executor","text":"<pre><code>deregister_executor(executor)\n</code></pre> <p>Remove a component executor by its custom IDs.</p> PARAMETER DESCRIPTION <code>executor</code> <p>The executor to remove.</p> <p> TYPE: <code>AbstractComponentExecutor</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The component client to allow chaining.</p>"},{"location":"reference/components/#yuyo.components.ComponentClient.deregister_message","title":"deregister_message","text":"<pre><code>deregister_message(message)\n</code></pre> <p>Remove a component executor by its message.</p> PARAMETER DESCRIPTION <code>message</code> <p>The message to remove the executor for.</p> <p> TYPE: <code>hikari.SnowflakeishOr[hikari.Message]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The component client to allow chaining.</p>"},{"location":"reference/components/#yuyo.components.ComponentClient.from_gateway_bot","title":"from_gateway_bot  <code>classmethod</code>","text":"<pre><code>from_gateway_bot(bot, /, *, alluka=None, event_managed=True)\n</code></pre> <p>Build a component client from a Gateway Bot.</p> <p>This sets ComponentClient as a type dependency when <code>alluka</code> isn't passed.</p> PARAMETER DESCRIPTION <code>bot</code> <p>The Gateway bot this component client should be bound to.</p> <p> TYPE: <code>hikari.EventManagerAware</code> </p> <code>alluka</code> <p>The Alluka client to use for callback dependency injection in this client.</p> <p>If not provided then this will initialise its own Alluka client.</p> <p> TYPE: <code>typing.Optional[alluka_.abc.Client]</code> DEFAULT: <code>None</code> </p> <code>event_managed</code> <p>Whether the component client should be automatically opened and closed based on the lifetime events dispatched by <code>bot</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>ComponentClient</code> <p>The initialised component client.</p>"},{"location":"reference/components/#yuyo.components.ComponentClient.from_rest_bot","title":"from_rest_bot  <code>classmethod</code>","text":"<pre><code>from_rest_bot(bot, /, *, alluka=None, bot_managed=False)\n</code></pre> <p>Build a component client from a REST Bot.</p> <p>This sets ComponentClient as a type dependency when <code>alluka</code> isn't passed.</p> PARAMETER DESCRIPTION <code>bot</code> <p>The REST bot this component client should be bound to.</p> <p> TYPE: <code>hikari.RESTBotAware</code> </p> <code>alluka</code> <p>The Alluka client to use for callback dependency injection in this client.</p> <p>If not provided then this will initialise its own Alluka client.</p> <p> TYPE: <code>typing.Optional[alluka_.abc.Client]</code> DEFAULT: <code>None</code> </p> <code>bot_managed</code> <p>Whether the component client should be automatically opened and closed based on the Bot's startup and shutdown callbacks.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>ComponentClient</code> <p>The initialised component client.</p>"},{"location":"reference/components/#yuyo.components.ComponentClient.from_tanjun","title":"from_tanjun  <code>classmethod</code>","text":"<pre><code>from_tanjun(tanjun_client, /, *, tanjun_managed=True)\n</code></pre> <p>Build a component client from a Tanjun client.</p> <p>This will use the Tanjun client's alluka client and registers ComponentClient as a type dependency on Tanjun.</p> PARAMETER DESCRIPTION <code>tanjun_client</code> <p>The Tanjun client this component client should be bound to.</p> <p> TYPE: <code>tanjun.abc.Client</code> </p> <code>tanjun_managed</code> <p>Whether the component client should be automatically opened and closed based on the Tanjun client's lifetime client callback.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>ComponentClient</code> <p>The initialised component client.</p>"},{"location":"reference/components/#yuyo.components.ComponentClient.get_constant_id","title":"get_constant_id","text":"<pre><code>get_constant_id(custom_id)\n</code></pre> <p>Deprecated method for getting the constant callback for a custom ID.</p> <p>These now use the normal executor system through SingleExecutor.</p>"},{"location":"reference/components/#yuyo.components.ComponentClient.get_executor","title":"get_executor","text":"<pre><code>get_executor(message)\n</code></pre> <p>Deprecated alias of ComponentClient.get_executor_for_message.</p>"},{"location":"reference/components/#yuyo.components.ComponentClient.get_executor_for_message","title":"get_executor_for_message","text":"<pre><code>get_executor_for_message(message)\n</code></pre> <p>Get the component executor set for a message.</p> PARAMETER DESCRIPTION <code>message</code> <p>The message to get the executor for.</p> <p> TYPE: <code>hikari.SnowflakeishOr[hikari.Message]</code> </p> RETURNS DESCRIPTION <code>yuyo.components.AbstractComponentExecutor | None</code> <p>The executor set for the message or None if none is set.</p>"},{"location":"reference/components/#yuyo.components.ComponentClient.on_gateway_event","title":"on_gateway_event  <code>async</code>","text":"<pre><code>on_gateway_event(event)\n</code></pre> <p>Process an interaction create gateway event.</p> PARAMETER DESCRIPTION <code>event</code> <p>The interaction create gateway event to process.</p> <p> TYPE: <code>hikari.InteractionCreateEvent</code> </p>"},{"location":"reference/components/#yuyo.components.ComponentClient.on_rest_request","title":"on_rest_request  <code>async</code>","text":"<pre><code>on_rest_request(interaction)\n</code></pre> <p>Process a component interaction REST request.</p> PARAMETER DESCRIPTION <code>interaction</code> <p>The interaction to process.</p> <p> TYPE: <code>hikari.ComponentInteraction</code> </p> RETURNS DESCRIPTION <code>ResponseT</code> <p>The REST response.</p>"},{"location":"reference/components/#yuyo.components.ComponentClient.open","title":"open","text":"<pre><code>open()\n</code></pre> <p>Startup the component client.</p>"},{"location":"reference/components/#yuyo.components.ComponentClient.register_executor","title":"register_executor","text":"<pre><code>register_executor(executor, /, *, message=None, timeout=_internal.NO_DEFAULT)\n</code></pre> <p>Add an executor to this client.</p> PARAMETER DESCRIPTION <code>executor</code> <p>The executor to register.</p> <p> TYPE: <code>AbstractComponentExecutor</code> </p> <code>message</code> <p>The message to register this executor for.</p> <p>If this is left as None then this executor will be registered globally for its custom IDs.</p> <p> TYPE: <code>typing.Optional[hikari.SnowflakeishOr[hikari.Message]]</code> DEFAULT: <code>None</code> </p> <code>timeout</code> <p>The executor's timeout.</p> <p>This defaults to a 30 second sliding timeout.</p> <p> TYPE: <code>typing.Optional[yuyo.timeouts.AbstractTimeout]</code> DEFAULT: <code>_internal.NO_DEFAULT</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The component client to allow chaining.</p>"},{"location":"reference/components/#yuyo.components.ComponentClient.remove_constant_id","title":"remove_constant_id","text":"<pre><code>remove_constant_id(custom_id)\n</code></pre> <p>Deprecated method for removing a constant callback by custom ID.</p> <p>These now use the normal executor system through SingleExecutor.</p>"},{"location":"reference/components/#yuyo.components.ComponentClient.remove_executor","title":"remove_executor","text":"<pre><code>remove_executor(message)\n</code></pre> <p>Deprecated alias for ComponentClient.deregister_message.</p>"},{"location":"reference/components/#yuyo.components.ComponentClient.set_constant_id","title":"set_constant_id","text":"<pre><code>set_constant_id(custom_id, callback, /, *, prefix_match=True)\n</code></pre> <p>Deprecated approach for adding callbacks which'll always be called for a specific custom ID.</p> <p>You should now use SingleExecutor with ComponentClient.register_executor (making sure to pass <code>timeout=None</code>).</p> <p>Examples:</p> <pre><code>@yuyo.components.as_single_executor(\"custom_id\")\nasync def callback(ctx: yuyo.components.Context) -&gt; None:\n    await ctx.respond(\"hi\")\n\n(\n    yuyo.components.Client()\n    .register_executor(SingleExecutor(\"custom_id\", callback), timeout=None)\n)\n</code></pre>"},{"location":"reference/components/#yuyo.components.ComponentClient.set_executor","title":"set_executor","text":"<pre><code>set_executor(message, executor)\n</code></pre> <p>Deprecated method for setting the component executor for a message.</p> <p>Use ComponentClient.register_executor with the <code>message</code> kwarg instead.</p>"},{"location":"reference/components/#yuyo.components.ComponentClient.with_constant_id","title":"with_constant_id","text":"<pre><code>with_constant_id(custom_id, /, *, prefix_match=True)\n</code></pre> <p>Deprecated approach for adding callbacks which'll always be called for a specific custom ID.</p> <p>You should now use SingleExecutor with ComponentClient.register_executor (making sure to pass <code>timeout=None</code>).</p> <p>Examples:</p> <pre><code>@yuyo.components.as_single_executor(\"custom_id\")\nasync def callback(ctx: yuyo.components.Context) -&gt; None:\n    await ctx.respond(\"hi\")\n\n(\n    yuyo.components.Client()\n    .register_executor(SingleExecutor(\"custom_id\", callback), timeout=None)\n)\n</code></pre>"},{"location":"reference/components/#yuyo.components.ComponentContext","title":"ComponentContext","text":"<p>         Bases: <code>BaseContext[hikari.ComponentInteraction]</code></p> <p>The context used for message component triggers.</p>"},{"location":"reference/components/#yuyo.components.ComponentContext.client","title":"client  <code>property</code>","text":"<pre><code>client: ComponentClient\n</code></pre> <p>The component client this context is bound to.</p>"},{"location":"reference/components/#yuyo.components.ComponentContext.select_channels","title":"select_channels  <code>property</code>","text":"<pre><code>select_channels: collections.Mapping[hikari.Snowflake, hikari.InteractionChannel]\n</code></pre> <p>Deprecated alias of .selected_channels.</p>"},{"location":"reference/components/#yuyo.components.ComponentContext.select_members","title":"select_members  <code>property</code>","text":"<pre><code>select_members: collections.Mapping[hikari.Snowflake, hikari.InteractionMember]\n</code></pre> <p>Deprecated alias of .selected_members.</p>"},{"location":"reference/components/#yuyo.components.ComponentContext.select_roles","title":"select_roles  <code>property</code>","text":"<pre><code>select_roles: collections.Mapping[hikari.Snowflake, hikari.Role]\n</code></pre> <p>Deprecated alias of .selected_roles.</p>"},{"location":"reference/components/#yuyo.components.ComponentContext.select_texts","title":"select_texts  <code>property</code>","text":"<pre><code>select_texts: collections.Sequence[str]\n</code></pre> <p>Deprecated alias of .selected_texts.</p>"},{"location":"reference/components/#yuyo.components.ComponentContext.select_users","title":"select_users  <code>property</code>","text":"<pre><code>select_users: collections.Mapping[hikari.Snowflake, hikari.User]\n</code></pre> <p>Deprecated alias of .selected_users.</p>"},{"location":"reference/components/#yuyo.components.ComponentContext.selected_channels","title":"selected_channels  <code>property</code>","text":"<pre><code>selected_channels: collections.Mapping[hikari.Snowflake, hikari.InteractionChannel]\n</code></pre> <p>Sequence of the users passed for a channel select menu.</p>"},{"location":"reference/components/#yuyo.components.ComponentContext.selected_members","title":"selected_members  <code>property</code>","text":"<pre><code>selected_members: collections.Mapping[hikari.Snowflake, hikari.InteractionMember]\n</code></pre> <p>Sequence of the members passed for a user select menu.</p> <p>This will also include some of the values for a mentionable select menu.</p>"},{"location":"reference/components/#yuyo.components.ComponentContext.selected_roles","title":"selected_roles  <code>property</code>","text":"<pre><code>selected_roles: collections.Mapping[hikari.Snowflake, hikari.Role]\n</code></pre> <p>Sequence of the users passed for a role select menu.</p> <p>This will also include some of the values for a mentionable select menu.</p>"},{"location":"reference/components/#yuyo.components.ComponentContext.selected_texts","title":"selected_texts  <code>property</code>","text":"<pre><code>selected_texts: collections.Sequence[str]\n</code></pre> <p>Sequence of the values passed for a text select menu.</p>"},{"location":"reference/components/#yuyo.components.ComponentContext.selected_users","title":"selected_users  <code>property</code>","text":"<pre><code>selected_users: collections.Mapping[hikari.Snowflake, hikari.User]\n</code></pre> <p>Sequence of the users passed for a user select menu.</p> <p>This will also include some of the values for a mentionable select menu.</p> <p>ComponentContext.select_members has the full member objects.</p>"},{"location":"reference/components/#yuyo.components.ComponentContext.create_initial_response","title":"create_initial_response  <code>async</code>","text":"<pre><code>create_initial_response(content=hikari.UNDEFINED, *, response_type=hikari.ResponseType.MESSAGE_CREATE, delete_after=None, ephemeral=False, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, mentions_everyone=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED, flags=hikari.UNDEFINED, tts=hikari.UNDEFINED)\n</code></pre> <p>Create the initial response for this context.</p> <p>Warning</p> <p>Calling this on a context which already has an initial response will result in this raising a hikari.errors.NotFoundError. This includes if the REST interaction server has already responded to the request and deferrals.</p> PARAMETER DESCRIPTION <code>content</code> <p>The content to edit the last response with.</p> <p>If provided, the message contents. If hikari.undefined.UNDEFINED, then nothing will be sent in the content. Any other value here will be cast to a str.</p> <p>If this is a hikari.embeds.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.files.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> <p> TYPE: <code>hikari.UndefinedOr[typing.Any]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>response_type</code> <p>The type of message response to give.</p> <p> TYPE: <code>hikari.MessageResponseTypesT</code> DEFAULT: <code>hikari.ResponseType.MESSAGE_CREATE</code> </p> <code>delete_after</code> <p>If provided, the seconds after which the response message should be deleted.</p> <p>Slash command responses can only be deleted within 15 minutes of the command being received.</p> <p> TYPE: <code>typing.Union[datetime.timedelta, float, int, None]</code> DEFAULT: <code>None</code> </p> <code>ephemeral</code> <p>Whether the deferred response should be ephemeral.</p> <p>Passing True here is a shorthand for including <code>1 &lt;&lt; 64</code> in the passed flags.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>content</code> <p>If provided, the message contents. If hikari.undefined.UNDEFINED, then nothing will be sent in the content. Any other value here will be cast to a <code>str</code>.</p> <p>If this is a hikari.embeds.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone.</p> <p> TYPE: <code>hikari.UndefinedOr[typing.Any]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>attachment</code> <p>If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.Resourceish]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>attachments</code> <p>If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.</p> <p> TYPE: <code>hikari.UndefinedOr[collections.Sequence[hikari.Resourceish]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>component</code> <p>If provided, builder object of the component to include in this message.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.api.ComponentBuilder]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>components</code> <p>If provided, a sequence of the component builder objects to include in this message.</p> <p> TYPE: <code>hikari.UndefinedOr[collections.Sequence[hikari.api.ComponentBuilder]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>embed</code> <p>If provided, the message embed.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.Embed]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>embeds</code> <p>If provided, the message embeds.</p> <p> TYPE: <code>hikari.UndefinedOr[collections.Sequence[hikari.Embed]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>flags</code> <p>If provided, the message flags this response should have.</p> <p>As of writing the only message flag which can be set here is hikari.messages.MessageFlag.EPHEMERAL.</p> <p> TYPE: <code>typing.Union[int, hikari.MessageFlag, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>tts</code> <p>If provided, whether the message will be read out by a screen reader using Discord's TTS (text-to-speech) system.</p> <p> TYPE: <code>hikari.UndefinedOr[bool]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>mentions_everyone</code> <p>If provided, whether the message should parse @everyone/@here mentions.</p> <p> TYPE: <code>hikari.UndefinedOr[bool]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>user_mentions</code> <p>If provided, and True, all user mentions will be detected. If provided, and False, all user mentions will be ignored if appearing in the message body.</p> <p>Alternatively this may be a collection of hikari.snowflakes.Snowflake, or hikari.users.PartialUser derivatives to enforce mentioning specific users.</p> <p> TYPE: <code>typing.Union[hikari.SnowflakeishSequence[hikari.PartialUser], bool, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>role_mentions</code> <p>If provided, and True, all role mentions will be detected. If provided, and False, all role mentions will be ignored if appearing in the message body.</p> <p>Alternatively this may be a collection of [hikari.snowflakes.Snowflake], or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles.</p> <p> TYPE: <code>typing.Union[hikari.SnowflakeishSequence[hikari.PartialRole], bool, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If more than 100 unique objects/entities are passed for <code>role_mentions</code> or <code>user_mentions</code>.</p> <p>If the interaction will have expired before <code>delete_after</code> is reached.</p> <p>If both <code>attachment</code> and <code>attachments</code> are passed or both <code>component</code> and <code>components</code> are passed or both <code>embed</code> and <code>embeds</code> are passed.</p> <code>hikari.BadRequestError</code> <p>This may be raised in several discrete situations, such as messages being empty with no embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; invalid image URLs in embeds.</p> <code>hikari.UnauthorizedError</code> <p>If you are unauthorized to make the request (invalid/missing token).</p> <code>hikari.NotFoundError</code> <p>If the interaction is not found or if the interaction's initial response has already been created.</p> <code>hikari.RateLimitTooLongError</code> <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> <code>hikari.InternalServerError</code> <p>If an internal error occurs on Discord while handling the request.</p>"},{"location":"reference/components/#yuyo.components.ComponentContext.create_modal_response","title":"create_modal_response  <code>async</code>","text":"<pre><code>create_modal_response(title, custom_id, /, *, component=hikari.UNDEFINED, components=hikari.UNDEFINED)\n</code></pre> <p>Send a modal as the initial response for this context.</p> <p>Warning</p> <p>This must be called as the first response to a context before any deferring.</p> PARAMETER DESCRIPTION <code>title</code> <p>The title that will show up in the modal.</p> <p> TYPE: <code>str</code> </p> <code>custom_id</code> <p>Developer set custom ID used for identifying interactions with this modal.</p> <p>Yuyo's Component client will only match against <code>custom_id.split(\":\", 1)[0]</code>, allowing metadata to be put after <code>\":\"</code>.</p> <p> TYPE: <code>str</code> </p> <code>component</code> <p>A component builder to send in this modal.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.api.ComponentBuilder]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>components</code> <p>A sequence of component builders to send in this modal.</p> <p> TYPE: <code>hikari.UndefinedOr[collections.Sequence[hikari.api.ComponentBuilder]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If both <code>component</code> and <code>components</code> are specified or if none are specified.</p> <code>hikari.BadRequestError</code> <p>When the requests' data is outside Discord's accept ranges/validation.</p> <code>hikari.UnauthorizedError</code> <p>If you are unauthorized to make the request (invalid/missing token).</p> <code>hikari.NotFoundError</code> <p>If the interaction is not found or if the interaction's initial response has already been created or deferred.</p> <code>hikari.RateLimitTooLongError</code> <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> <code>hikari.InternalServerError</code> <p>If an internal error occurs on Discord while handling the request.</p>"},{"location":"reference/components/#yuyo.components.ComponentContext.defer","title":"defer  <code>async</code>","text":"<pre><code>defer(*, defer_type=hikari.ResponseType.DEFERRED_MESSAGE_CREATE, ephemeral=False, flags=hikari.UNDEFINED)\n</code></pre> <p>Defer the initial response for this context.</p> <p>Note</p> <p>The ephemeral state of the first response is decided by whether the deferral is ephemeral.</p> PARAMETER DESCRIPTION <code>defer_type</code> <p>The type of deferral this should be.</p> <p>This may any of the following * ResponseType.DEFERRED_MESSAGE_CREATE to indicate that the following up call to yuyo.components.BaseContext.edit_initial_response or yuyo.components.BaseContext.respond should create a new message. * ResponseType.DEFERRED_MESSAGE_UPDATE to indicate that the following call to the aforementioned methods should update the existing message.</p> <p> TYPE: <code>hikari.DeferredResponseTypesT</code> DEFAULT: <code>hikari.ResponseType.DEFERRED_MESSAGE_CREATE</code> </p> <code>ephemeral</code> <p>Whether the deferred response should be ephemeral.</p> <p>Passing True here is a shorthand for including <code>1 &lt;&lt; 64</code> in the passed flags.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>flags</code> <p>The flags to use for the initial response.</p> <p> TYPE: <code>typing.Union[hikari.UndefinedType, int, hikari.MessageFlag]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p>"},{"location":"reference/components/#yuyo.components.ComponentExecutor","title":"ComponentExecutor","text":"<p>         Bases: <code>AbstractComponentExecutor</code></p> <p>implementation of a component executor with per-custom ID callbacks.</p>"},{"location":"reference/components/#yuyo.components.ComponentExecutor.callbacks","title":"callbacks  <code>property</code>","text":"<pre><code>callbacks: collections.Mapping[str, CallbackSig]\n</code></pre> <p>Mapping of custom IDs to their set callbacks.</p>"},{"location":"reference/components/#yuyo.components.ComponentExecutor.__init__","title":"__init__","text":"<pre><code>__init__(*, ephemeral_default=False, timeout=_internal.NO_DEFAULT, _stack_level=0)\n</code></pre> <p>Initialise a component executor.</p> PARAMETER DESCRIPTION <code>ephemeral_default</code> <p>Whether this executor's responses should default to being ephemeral.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"reference/components/#yuyo.components.ComponentExecutor.set_callback","title":"set_callback","text":"<pre><code>set_callback(custom_id, callback)\n</code></pre> <p>Set the callback for a custom ID.</p> PARAMETER DESCRIPTION <code>custom_id</code> <p>The custom ID to set the callback for.</p> <p>This will be matched against <code>interaction.custom_id.split(\":\", 1)[0]</code>, allowing metadata to be stored after a <code>\":\"</code>.</p> <p> TYPE: <code>str</code> </p> <code>callback</code> <p>The callback to set.</p> <p> TYPE: <code>CallbackSig</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If <code>\":\"</code> is in the custom ID.</p>"},{"location":"reference/components/#yuyo.components.ComponentExecutor.with_callback","title":"with_callback","text":"<pre><code>with_callback(custom_id)\n</code></pre> <p>Set the callback for a custom ID through a decorator callback.</p> PARAMETER DESCRIPTION <code>custom_id</code> <p>The custom ID to set the callback for.</p> <p>This will be matched against <code>interaction.custom_id.split(\":\", 1)[0]</code>, allowing metadata to be stored after a <code>\":\"</code>.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[CallbackSig], CallbackSig]</code> <p>Decorator callback used to set a custom ID's callback.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If <code>\":\"</code> is in the custom ID.</p>"},{"location":"reference/components/#yuyo.components.ComponentPaginator","title":"ComponentPaginator","text":"<p>         Bases: <code>ActionRowExecutor</code></p> <p>Standard implementation of an action row executor used for pagination.</p> <p>This is a convenience class that allows you to easily implement a paginator.</p>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.__init__","title":"__init__","text":"<pre><code>__init__(iterator, /, *, authors=None, ephemeral_default=False, triggers=(pagination.LEFT_TRIANGLE, pagination.STOP_SQUARE, pagination.RIGHT_TRIANGLE), timeout=_internal.NO_DEFAULT)\n</code></pre> <p>Initialise a component paginator.</p> PARAMETER DESCRIPTION <code>iterator</code> <p>The iterator to paginate.</p> <p>This should be an iterator of tuples of <code>(hikari.UndefinedOr[str], hikari.UndefinedOr[hikari.Embed])</code>.</p> <p> TYPE: <code>collections.Iterator[yuyo.pagination.EntryT] | collections.AsyncIterator[yuyo.pagination.EntryT]</code> </p> <code>authors</code> <p>The authors of the entries.</p> <p>If None is passed here then the paginator will be public (meaning that anybody can use it).</p> <p> TYPE: <code>typing.Optional[collections.Iterable[hikari.SnowflakeishOr[hikari.User]]]</code> DEFAULT: <code>None</code> </p> <code>ephemeral_default</code> <p>Whether or not the responses made on contexts spawned from this paginator should default to ephemeral (meaning only the author can see them) unless <code>flags</code> is specified on the response method.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>triggers</code> <p>Collection of the unicode emojis that should trigger this paginator.</p> <p>As of current the only usable emojis are yuyo.pagination.LEFT_TRIANGLE, yuyo.pagination.RIGHT_TRIANGLE, yuyo.pagination.STOP_SQUARE, yuyo.pagination.LEFT_DOUBLE_TRIANGLE and yuyo.pagination.LEFT_TRIANGLE.</p> <p> TYPE: <code>collections.Collection[str]</code> DEFAULT: <code>(pagination.LEFT_TRIANGLE, pagination.STOP_SQUARE, pagination.RIGHT_TRIANGLE)</code> </p>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.add_first_button","title":"add_first_button","text":"<pre><code>add_first_button(*, style=hikari.ButtonStyle.SECONDARY, custom_id=None, emoji=pagination.LEFT_DOUBLE_TRIANGLE, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add the jump to first entry button to this paginator.</p> <p>You should pass <code>triggers=[]</code> to [yuyo.components.ComponentPaginator.init][ComponentPaginator.__init__] before calling this.</p> <p>Note</p> <p>These buttons will appear in the order these methods were called in.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> PARAMETER DESCRIPTION <code>style</code> <p>The button's style.</p> <p> TYPE: <code>hikari.InteractiveButtonTypesT</code> DEFAULT: <code>hikari.ButtonStyle.SECONDARY</code> </p> <code>emoji</code> <p>Emoji to display on this button.</p> <p> TYPE: <code>typing.Union[hikari.Snowflakeish, hikari.Emoji, str, hikari.UndefinedType]</code> DEFAULT: <code>pagination.LEFT_DOUBLE_TRIANGLE</code> </p> <code>label</code> <p>Label to display on this button.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>is_disabled</code> <p>Whether to make this button as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>To enable chained calls.</p>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.add_last_button","title":"add_last_button","text":"<pre><code>add_last_button(*, style=hikari.ButtonStyle.SECONDARY, custom_id=None, emoji=pagination.RIGHT_DOUBLE_TRIANGLE, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add the jump to last entry button to this paginator.</p> <p>You should pass <code>triggers=[]</code> to [yuyo.components.ComponentPaginator.init][ComponentPaginator.__init__] before calling this.</p> <p>Note</p> <p>These buttons will appear in the order these methods were called in.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> PARAMETER DESCRIPTION <code>style</code> <p>The button's style.</p> <p> TYPE: <code>hikari.InteractiveButtonTypesT</code> DEFAULT: <code>hikari.ButtonStyle.SECONDARY</code> </p> <code>emoji</code> <p>Emoji to display on this button.</p> <p>Either this or <code>label</code> must be provided, but not both.</p> <p> TYPE: <code>typing.Union[hikari.Snowflakeish, hikari.Emoji, str, hikari.UndefinedType]</code> DEFAULT: <code>pagination.RIGHT_DOUBLE_TRIANGLE</code> </p> <code>label</code> <p>Label to display on this button.</p> <p>Either this or <code>emoji</code> must be provided, but not both.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>is_disabled</code> <p>Whether to make this button as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>To enable chained calls.</p>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.add_next_button","title":"add_next_button","text":"<pre><code>add_next_button(*, style=hikari.ButtonStyle.SECONDARY, custom_id=None, emoji=pagination.RIGHT_TRIANGLE, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add the next entry button to this paginator.</p> <p>You should pass <code>triggers=[]</code> to [yuyo.components.ComponentPaginator.init][ComponentPaginator.__init__] before calling this.</p> <p>Note</p> <p>These buttons will appear in the order these methods were called in.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> PARAMETER DESCRIPTION <code>style</code> <p>The button's style.</p> <p> TYPE: <code>hikari.InteractiveButtonTypesT</code> DEFAULT: <code>hikari.ButtonStyle.SECONDARY</code> </p> <code>emoji</code> <p>Emoji to display on this button.</p> <p>Either this or <code>label</code> must be provided, but not both.</p> <p> TYPE: <code>typing.Union[hikari.Snowflakeish, hikari.Emoji, str, hikari.UndefinedType]</code> DEFAULT: <code>pagination.RIGHT_TRIANGLE</code> </p> <code>label</code> <p>Label to display on this button.</p> <p>Either this or <code>emoji</code> must be provided, but not both.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>is_disabled</code> <p>Whether to make this button as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>To enable chained calls.</p>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.add_previous_button","title":"add_previous_button","text":"<pre><code>add_previous_button(*, style=hikari.ButtonStyle.SECONDARY, custom_id=None, emoji=pagination.LEFT_TRIANGLE, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add the previous entry button to this paginator.</p> <p>You should pass <code>triggers=[]</code> to [yuyo.components.ComponentPaginator.init][ComponentPaginator.__init__] before calling this.</p> <p>Note</p> <p>These buttons will appear in the order these methods were called in.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> PARAMETER DESCRIPTION <code>style</code> <p>The button's style.</p> <p> TYPE: <code>hikari.InteractiveButtonTypesT</code> DEFAULT: <code>hikari.ButtonStyle.SECONDARY</code> </p> <code>emoji</code> <p>Emoji to display on this button.</p> <p>Either this or <code>label</code> must be provided, but not both.</p> <p> TYPE: <code>typing.Union[hikari.Snowflakeish, hikari.Emoji, str, hikari.UndefinedType]</code> DEFAULT: <code>pagination.LEFT_TRIANGLE</code> </p> <code>label</code> <p>Label to display on this button.</p> <p>Either this or <code>emoji</code> must be provided, but not both.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>is_disabled</code> <p>Whether to make this button as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>To enable chained calls.</p>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.add_stop_button","title":"add_stop_button","text":"<pre><code>add_stop_button(*, style=hikari.ButtonStyle.DANGER, custom_id=None, emoji=pagination.BLACK_CROSS, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add the stop button to this paginator.</p> <p>You should pass <code>triggers=[]</code> to [yuyo.components.ComponentPaginator.init][ComponentPaginator.__init__] before calling this.</p> <p>Note</p> <p>These buttons will appear in the order these methods were called in.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> PARAMETER DESCRIPTION <code>style</code> <p>The button's style.</p> <p> TYPE: <code>hikari.InteractiveButtonTypesT</code> DEFAULT: <code>hikari.ButtonStyle.DANGER</code> </p> <code>emoji</code> <p>Emoji to display on this button.</p> <p>Either this or <code>label</code> must be provided, but not both.</p> <p> TYPE: <code>typing.Union[hikari.Snowflakeish, hikari.Emoji, str, hikari.UndefinedType]</code> DEFAULT: <code>pagination.BLACK_CROSS</code> </p> <code>label</code> <p>Label to display on this button.</p> <p>Either this or <code>emoji</code> must be provided, but not both.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>is_disabled</code> <p>Whether to make this button as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>To enable chained calls.</p>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.builder","title":"builder","text":"<pre><code>builder()\n</code></pre> <p>Get a sequence of the component builders for this paginator.</p> RETURNS DESCRIPTION <code>collections.abc.Sequence[hikari.api.ComponentBuilder]</code> <p>The component builders for this paginator.</p>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.get_next_entry","title":"get_next_entry  <code>async</code>","text":"<pre><code>get_next_entry()\n</code></pre> <p>Get the next entry in this paginator.</p> <p>This is generally helpful for making the message which the paginator will be based off and will still internally store the entry and increment the position of the paginator.</p> <p>Examples:</p> <pre><code>response_paginator = yuyo.ComponentPaginator(pages, authors=[ctx.author.id])\nfirst_response = await response_paginator.get_next_entry()\nassert first_response\nmessage = await ctx.respond(component=response_paginator, **first_response.to_kwargs(), ensure_result=True)\ncomponent_client.register_executor(response_paginator, message=message)\n</code></pre> RETURNS DESCRIPTION <code>yuyo.pagination.Page | None</code> <p>The next entry in this paginator, or None if there are no more entries.</p>"},{"location":"reference/components/#yuyo.components.ExecutorClosed","title":"ExecutorClosed","text":"<p>         Bases: <code>Exception</code></p> <p>Error used to indicate that an executor is now closed during execution.</p>"},{"location":"reference/components/#yuyo.components.ExecutorClosed.__init__","title":"__init__","text":"<pre><code>__init__(*, already_closed=True)\n</code></pre> <p>Initialise an executor closed error.</p> PARAMETER DESCRIPTION <code>already_closed</code> <p>Whether this error is a result of the executor having been in a closed state when it was called.</p> <p>If so then this will lead to a \"timed-out\" message being sent as the initial response.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p>"},{"location":"reference/components/#yuyo.components.SingleExecutor","title":"SingleExecutor","text":"<p>         Bases: <code>AbstractComponentExecutor</code></p> <p>Component executor with a single callback.</p>"},{"location":"reference/components/#yuyo.components.SingleExecutor.__init__","title":"__init__","text":"<pre><code>__init__(custom_id, callback, /, *, ephemeral_default=False)\n</code></pre> <p>Initialise an executor with a single callback.</p> PARAMETER DESCRIPTION <code>custom_id</code> <p>The custom ID this executor is triggered for.</p> <p>This will be matched against <code>interaction.custom_id.split(\":\", 1)[0]</code>, allowing metadata to be stored after a <code>\":\"</code>.</p> <p> TYPE: <code>str</code> </p> <code>callback</code> <p>The executor's  callback.</p> <p> TYPE: <code>CallbackSig</code> </p> <code>ephemeral_default</code> <p>Whether this executor's responses should default to being ephemeral.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If <code>\":\"</code> is in the custom ID.</p>"},{"location":"reference/components/#yuyo.components.WaitForExecutor","title":"WaitForExecutor","text":"<p>         Bases: <code>AbstractComponentExecutor</code>, <code>timeouts.AbstractTimeout</code></p> <p>Component executor used to wait for a single component interaction.</p> <p>This should also be passed for <code>timeout=</code>.</p> <p>Examples:</p> <pre><code>responses: dict[str, str]\nmessage = await ctx.respond(\"hi, pick an option\", components=[...])\nexecutor = yuyo.components.WaitFor(authors=[ctx.author.id], timeout=datetime.timedelta(seconds=30))\ncomponent_client.register_executor(executor, message=message, timeout=executor)\n\ntry:\n    result = await executor.wait_for()\nexcept asyncio.TimeoutError:\n    await ctx.respond(\"timed out\")\n\nelse:\n    await result.respond(responses[result.interaction.custom_id])\n</code></pre>"},{"location":"reference/components/#yuyo.components.WaitForExecutor.__init__","title":"__init__","text":"<pre><code>__init__(*, authors=None, ephemeral_default=False, timeout)\n</code></pre> <p>Initialise a wait for executor.</p> PARAMETER DESCRIPTION <code>authors</code> <p>The authors of the entries.</p> <p>If None is passed here then the paginator will be public (meaning that anybody can use it).</p> <p> TYPE: <code>typing.Optional[collections.Iterable[hikari.SnowflakeishOr[hikari.User]]]</code> DEFAULT: <code>None</code> </p> <code>ephemeral_default</code> <p>Whether or not the responses made on contexts spawned from this paginator should default to ephemeral (meaning only the author can see them) unless <code>flags</code> is specified on the response method.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>timeout</code> <p>How long this should wait for a matching component interaction until it times-out.</p> <p> TYPE: <code>typing.Optional[datetime.timedelta]</code> </p>"},{"location":"reference/components/#yuyo.components.WaitForExecutor.wait_for","title":"wait_for  <code>async</code>","text":"<pre><code>wait_for()\n</code></pre> <p>Wait for the next matching interaction.</p> RETURNS DESCRIPTION <code>ComponentContext</code> <p>The next matching interaction.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the executor is already being waited for.</p> <code>asyncio.TimeoutError</code> <p>If the timeout is reached.</p>"},{"location":"reference/components/#yuyo.components.as_channel_menu","title":"as_channel_menu","text":"<pre><code>as_channel_menu(callback=None, /, *, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Declare a channel select menu on an action column class.</p> PARAMETER DESCRIPTION <code>channel_types</code> <p>Sequence of the types of channels this select menu should show as options.</p> <p> TYPE: <code>typing.Optional[collections.Sequence[typing.Union[hikari.ChannelType, type[hikari.PartialChannel]]]]</code> DEFAULT: <code>None</code> </p> <code>custom_id</code> <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>placeholder</code> <p>Placeholder text to show when no entries have been selected.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>min_values</code> <p>The minimum amount of entries which need to be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>max_values</code> <p>The maximum amount of entries which can be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>is_disabled</code> <p>Whether this select menu should be marked as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Examples:</p> <pre><code>class CustomColumn(components.ActionColumnExecutor):\n    @components.as_channel_menu(channel_types=[hikari.TextableChannel])\n    async def on_channel_menu(self, ctx: components.ComponentContext) -&gt; None:\n        ...\n</code></pre>"},{"location":"reference/components/#yuyo.components.as_interactive_button","title":"as_interactive_button","text":"<pre><code>as_interactive_button(style, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Declare an interactive button on an action column class.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> PARAMETER DESCRIPTION <code>style</code> <p>The button's style.</p> <p> TYPE: <code>hikari.InteractiveButtonTypesT</code> </p> <code>custom_id</code> <p>The button's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>emoji</code> <p>The button's emoji.</p> <p> TYPE: <code>typing.Union[hikari.Snowflakeish, hikari.Emoji, str, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>label</code> <p>The button's label.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>is_disabled</code> <p>Whether the button should be marked as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Examples:</p> <pre><code>class CustomColumn(components.ActionColumnExecutor):\n    @components.as_interactive_button(ButtonStyle.DANGER, label=\"label\")\n    async def on_button(self, ctx: components.ComponentContext) -&gt; None:\n        ...\n</code></pre>"},{"location":"reference/components/#yuyo.components.as_select_menu","title":"as_select_menu","text":"<pre><code>as_select_menu(type_, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Declare a select menu on an action column class.</p> <p>For channel select menus and text select menus see as_channel_menu and as_text_menu respectively.</p> PARAMETER DESCRIPTION <code>type_</code> <p>The type of select menu to add.</p> <p> TYPE: <code>typing.Union[hikari.ComponentType, int]</code> </p> <code>custom_id</code> <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>placeholder</code> <p>Placeholder text to show when no entries have been selected.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>min_values</code> <p>The minimum amount of entries which need to be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>max_values</code> <p>The maximum amount of entries which can be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>is_disabled</code> <p>Whether this select menu should be marked as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Examples:</p> <pre><code>class CustomColumn(components.ActionColumnExecutor):\n    @components.as_select_menu(ComponentType.USER_SELECT_MENU, max_values=5)\n    async def on_select_menu(self, ctx: components.ComponentContext) -&gt; None:\n        ...\n</code></pre>"},{"location":"reference/components/#yuyo.components.as_single_executor","title":"as_single_executor","text":"<pre><code>as_single_executor(custom_id, /, *, ephemeral_default=False)\n</code></pre> <p>Create an executor with a single callback by decorating the callback.</p> PARAMETER DESCRIPTION <code>custom_id</code> <p>The custom ID this executor is triggered for.</p> <p>This will be matched against <code>interaction.custom_id.split(\":\", 1)[0]</code>, allowing metadata to be stored after a <code>\":\"</code>.</p> <p> TYPE: <code>str</code> </p> <code>ephemeral_default</code> <p>Whether this executor's responses should default to being ephemeral.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>SingleExecutor</code> <p>The created executor.</p>"},{"location":"reference/components/#yuyo.components.as_text_menu","title":"as_text_menu","text":"<pre><code>as_text_menu(callback=None, /, *, custom_id=None, options=(), placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Declare a text select menu on an action column class.</p> PARAMETER DESCRIPTION <code>custom_id</code> <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>options</code> <p>The text select's options.</p> <p>These can also be added by using yuyo.components.with_option.</p> <p> TYPE: <code>collections.Sequence[hikari.api.SelectOptionBuilder]</code> DEFAULT: <code>()</code> </p> <code>placeholder</code> <p>Placeholder text to show when no entries have been selected.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>min_values</code> <p>The minimum amount of entries which need to be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>max_values</code> <p>The maximum amount of entries which can be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>is_disabled</code> <p>Whether this select menu should be marked as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Examples:</p> <pre><code>class CustomColumn(components.ActionColumnExecutor):\n    @components.with_option(\"label\", \"value\")\n    @components.as_text_menu(\n        options=[special_endpoints.SelectOptionBuilder(label=\"label\", value=\"value\")]\n    )\n    async def on_text_menu(self, ctx: components.ComponentContext) -&gt; None:\n        ...\n</code></pre>"},{"location":"reference/components/#yuyo.components.link_button","title":"link_button","text":"<pre><code>link_button(url, /, *, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Declare an link button on an action column class.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> PARAMETER DESCRIPTION <code>url</code> <p>The button's url.</p> <p> TYPE: <code>str</code> </p> <code>emoji</code> <p>The button's emoji.</p> <p> TYPE: <code>typing.Union[hikari.Snowflakeish, hikari.Emoji, str, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>label</code> <p>The button's label.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>is_disabled</code> <p>Whether the button should be marked as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Examples:</p> <pre><code>class CustomColumn(components.ActionColumnExecutor):\n    link_button = components.link_button(\"https://example.com\", label=\"label\")\n</code></pre>"},{"location":"reference/components/#yuyo.components.with_option","title":"with_option","text":"<pre><code>with_option(label, value, /, *, description=hikari.UNDEFINED, emoji=hikari.UNDEFINED, is_default=False)\n</code></pre> <p>Add an option to a text select menu descriptor through a decorator call.</p> PARAMETER DESCRIPTION <code>label</code> <p>The option's label.</p> <p> TYPE: <code>str</code> </p> <code>value</code> <p>The option's value.</p> <p> TYPE: <code>str</code> </p> <code>description</code> <p>The option's description.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>emoji</code> <p>Emoji to display for the option.</p> <p> TYPE: <code>typing.Union[hikari.Snowflakeish, hikari.Emoji, str, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>is_default</code> <p>Whether the option should be marked as selected by default.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Examples:</p> <pre><code>    @components.with_option(\"other label\", \"other value\")\n    @components.with_option(\"label\", \"value\")\n    @components.as_text_menu\n    async def on_text_menu(self, ctx: components.ComponentContext) -&gt; None:\n        ...\n</code></pre>"},{"location":"reference/components/#yuyo.components.with_static_button","title":"with_static_button","text":"<pre><code>with_static_button(style, callback, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Deprecated alias of with_static_interative_button.</p>"},{"location":"reference/components/#yuyo.components.with_static_channel_menu","title":"with_static_channel_menu","text":"<pre><code>with_static_channel_menu(callback, /, *, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a static channel select menu to the decorated action column class.</p> PARAMETER DESCRIPTION <code>callback</code> <p>Callback which is called when this select menu is used.</p> <p> TYPE: <code>CallbackSig</code> </p> <code>channel_types</code> <p>Sequence of the types of channels this select menu should show as options.</p> <p> TYPE: <code>typing.Optional[collections.Sequence[typing.Union[hikari.ChannelType, type[hikari.PartialChannel]]]]</code> DEFAULT: <code>None</code> </p> <code>custom_id</code> <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>placeholder</code> <p>Placeholder text to show when no entries have been selected.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>min_values</code> <p>The minimum amount of entries which need to be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>max_values</code> <p>The maximum amount of entries which can be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>is_disabled</code> <p>Whether this select menu should be marked as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>type[tanjun.components.ActionColumnExecutor]</code> <p>The decorated action column class.</p>"},{"location":"reference/components/#yuyo.components.with_static_channel_select","title":"with_static_channel_select","text":"<pre><code>with_static_channel_select(callback, /, *, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Deprecated alias of with_static_channel_menu.</p>"},{"location":"reference/components/#yuyo.components.with_static_interative_button","title":"with_static_interative_button","text":"<pre><code>with_static_interative_button(style, callback, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add a static interactive button to the decorated action column class.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> PARAMETER DESCRIPTION <code>style</code> <p>The button's style.</p> <p> TYPE: <code>hikari.InteractiveButtonTypesT</code> </p> <code>callback</code> <p>The button's execution callback.</p> <p> TYPE: <code>CallbackSig</code> </p> <code>custom_id</code> <p>The button's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>emoji</code> <p>The button's emoji.</p> <p> TYPE: <code>typing.Union[hikari.Snowflakeish, hikari.Emoji, str, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>label</code> <p>The button's label.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>is_disabled</code> <p>Whether the button should be marked as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>type[tanjun.components.ActionColumnExecutor]</code> <p>The decorated action column class.</p>"},{"location":"reference/components/#yuyo.components.with_static_link_button","title":"with_static_link_button","text":"<pre><code>with_static_link_button(url, /, *, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add a static link button to the decorated action column class.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> PARAMETER DESCRIPTION <code>url</code> <p>The button's url.</p> <p> TYPE: <code>str</code> </p> <code>emoji</code> <p>The button's emoji.</p> <p> TYPE: <code>typing.Union[hikari.Snowflakeish, hikari.Emoji, str, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>label</code> <p>The button's label.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>is_disabled</code> <p>Whether the button should be marked as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>type[tanjun.components.ActionColumnExecutor]</code> <p>The decorated action column class.</p>"},{"location":"reference/components/#yuyo.components.with_static_select_menu","title":"with_static_select_menu","text":"<pre><code>with_static_select_menu(type_, callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a static select menu to the decorated action column class.</p> <p>For channel select menus and text select menus see yuyo.components.with_static_channel_menu and yuyo.components.with_static_text_menu respectively.</p> PARAMETER DESCRIPTION <code>type_</code> <p>The type of select menu to add.</p> <p>Passing callback here is deprecated.</p> <p> TYPE: <code>hikari.components..ComponentType | int</code> </p> <code>callback</code> <p>Callback which is called when this select menu is used.</p> <p>Passing type here is deprecated.</p> <p> TYPE: <code>yuyo.components.CallbackSig</code> </p> <code>custom_id</code> <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>placeholder</code> <p>Placeholder text to show when no entries have been selected.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>min_values</code> <p>The minimum amount of entries which need to be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>max_values</code> <p>The maximum amount of entries which can be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>is_disabled</code> <p>Whether this select menu should be marked as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>type[tanjun.components.ActionColumnExecutor]</code> <p>The decorated action column class.</p>"},{"location":"reference/components/#yuyo.components.with_static_text_menu","title":"with_static_text_menu","text":"<pre><code>with_static_text_menu(callback, /, *, custom_id=None, options=(), placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a static text select menu to the decorated action column class.</p> PARAMETER DESCRIPTION <code>callback</code> <p>Callback which is called when this select menu is used.</p> <p> TYPE: <code>CallbackSig</code> </p> <code>custom_id</code> <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>options</code> <p>The text select's options.</p> <p> TYPE: <code>collections.Sequence[hikari.api.SelectOptionBuilder]</code> DEFAULT: <code>()</code> </p> <code>placeholder</code> <p>Placeholder text to show when no entries have been selected.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>min_values</code> <p>The minimum amount of entries which need to be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>max_values</code> <p>The maximum amount of entries which can be selected.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>is_disabled</code> <p>Whether this select menu should be marked as disabled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>type[tanjun.components.ActionColumnExecutor]</code> <p>The decorated action column class.</p>"},{"location":"reference/links/","title":"yuyo.links","text":"<p>Classes and functions for handling Discord Links.</p>"},{"location":"reference/links/#yuyo.links.BaseLink","title":"BaseLink","text":"<p>         Bases: <code>abc.ABC</code></p> <p>Base class for all link objects.</p>"},{"location":"reference/links/#yuyo.links.BaseLink.find","title":"find  <code>classmethod</code>","text":"<pre><code>find(app, content)\n</code></pre> <p>Find the first link in a string.</p> PARAMETER DESCRIPTION <code>app</code> <p>The Hikari bot or REST app this should be bound to.</p> <p> TYPE: <code>hikari.RESTAware</code> </p> <code>content</code> <p>The string to searh in.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Self | None</code> <p>Object of the found link or None.</p>"},{"location":"reference/links/#yuyo.links.BaseLink.find_iter","title":"find_iter  <code>classmethod</code>","text":"<pre><code>find_iter(app, content)\n</code></pre> <p>Iterate over the links in a string.</p> PARAMETER DESCRIPTION <code>app</code> <p>The Hikari bot or REST app this should be bound to.</p> <p> TYPE: <code>hikari.RESTAware</code> </p> <code>content</code> <p>The string to searh in.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>collections.abc.Iterator[Self]</code> <p>Iterator of the link objects in the passed string.</p>"},{"location":"reference/links/#yuyo.links.BaseLink.from_link","title":"from_link  <code>classmethod</code>","text":"<pre><code>from_link(app, link)\n</code></pre> <p>Create a link object from a raw link.</p> PARAMETER DESCRIPTION <code>app</code> <p>The Hikari bot or REST app this should be bound to.</p> <p> TYPE: <code>hikari.RESTAware</code> </p> <code>link</code> <p>The string link to use.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The created link object.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the string doesn't match the expected link format.</p>"},{"location":"reference/links/#yuyo.links.ChannelLink","title":"ChannelLink  <code>dataclass</code>","text":"<p>         Bases: <code>BaseLink</code></p> <p>Represents a link to a channel.</p> <p>The following class methods are used to initialise this:</p> <ul> <li>InviteLink.from_link to create this from   a raw channel link.</li> <li>InviteLink.find to find the first channel link   in a string.</li> <li>InviteLink.find_iter to iterate over the   channel links in a string.</li> </ul>"},{"location":"reference/links/#yuyo.links.ChannelLink.channel_id","title":"channel_id  <code>property</code>","text":"<pre><code>channel_id: hikari.Snowflake\n</code></pre> <p>ID of the channel this links to.</p>"},{"location":"reference/links/#yuyo.links.ChannelLink.guild_id","title":"guild_id  <code>property</code>","text":"<pre><code>guild_id: typing.Optional[hikari.Snowflake]\n</code></pre> <p>ID of the guild this links to.</p> <p>Will be None for DM links.</p>"},{"location":"reference/links/#yuyo.links.ChannelLink.is_dm_link","title":"is_dm_link  <code>property</code>","text":"<pre><code>is_dm_link: bool\n</code></pre> <p>Whether this links to a DM channel.</p>"},{"location":"reference/links/#yuyo.links.ChannelLink.__str__","title":"__str__","text":"<pre><code>__str__()\n</code></pre> <p>Create a raw string representation of this link.</p>"},{"location":"reference/links/#yuyo.links.ChannelLink.fetch_channel","title":"fetch_channel  <code>async</code>","text":"<pre><code>fetch_channel()\n</code></pre> <p>Fetch the channel this links to.</p> RETURNS DESCRIPTION <code>hikari.channels.PartialChannel</code> <p>The this links to channel. This will be a derivative of <code>hikari.channels.PartialChannel</code>, depending on the type of channel you request for.</p> RAISES DESCRIPTION <code>hikari.errors.UnauthorizedError</code> <p>If you are unauthorized to make the request (invalid/missing token).</p> <code>hikari.errors.ForbiddenError</code> <p>If you are missing the <code>READ_MESSAGES</code> permission in the channel.</p> <code>hikari.errors.NotFoundError</code> <p>If the channel is not found.</p> <code>hikari.errors.RateLimitTooLongError</code> <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> <code>hikari.errors.InternalServerError</code> <p>If an internal error occurs on Discord while handling the request.</p>"},{"location":"reference/links/#yuyo.links.ChannelLink.fetch_guild","title":"fetch_guild  <code>async</code>","text":"<pre><code>fetch_guild()\n</code></pre> <p>Fetch the guild this links to.</p> RETURNS DESCRIPTION <code>hikari.guilds.RESTGuild | None</code> <p>Object of the guild this links to.</p> <p>Will be None if this links to a DM channel.</p> RAISES DESCRIPTION <code>hikari.errors.ForbiddenError</code> <p>If you are not part of the guild.</p> <code>hikari.errors.NotFoundError</code> <p>If the guild is not found.</p> <code>hikari.errors.UnauthorizedError</code> <p>If you are unauthorized to make the request (invalid/missing token).</p> <code>hikari.errors.RateLimitTooLongError</code> <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> <code>hikari.errors.InternalServerError</code> <p>If an internal error occurs on Discord while handling the request.</p>"},{"location":"reference/links/#yuyo.links.ChannelLink.get_channel","title":"get_channel","text":"<pre><code>get_channel()\n</code></pre> <p>Get the channel this links to from the cache.</p> RETURNS DESCRIPTION <code>hikari.channels.GuildChannel | None</code> <p>Object of the guild channel that was found in the cache or None.</p>"},{"location":"reference/links/#yuyo.links.ChannelLink.get_guild","title":"get_guild","text":"<pre><code>get_guild()\n</code></pre> <p>Get the guild this links to from the cache.</p> RETURNS DESCRIPTION <code>hikari.channels.GuildChannel | None</code> <p>Object of the guild that was found in the cache or None.</p> <p>This will also be None if this links to a DM channel.</p>"},{"location":"reference/links/#yuyo.links.InviteLink","title":"InviteLink  <code>dataclass</code>","text":"<p>         Bases: <code>hikari.InviteCode</code>, <code>BaseLink</code></p> <p>Represents a Discord invite link.</p> <p>The following class methods are used to initialise this:</p> <ul> <li>InviteLink.from_link to create this from   a raw invite link.</li> <li>InviteLink.find to find the first invite link   in a string.</li> <li>InviteLink.find_iter to iterate over the   invite links in a string.</li> </ul>"},{"location":"reference/links/#yuyo.links.InviteLink.code","title":"code  <code>property</code>","text":"<pre><code>code: str\n</code></pre> <p>The invite's code.</p>"},{"location":"reference/links/#yuyo.links.InviteLink.fetch","title":"fetch  <code>async</code>","text":"<pre><code>fetch()\n</code></pre> <p>Deprecated alias of InviteLink.fetch_invite.</p>"},{"location":"reference/links/#yuyo.links.InviteLink.fetch_invite","title":"fetch_invite  <code>async</code>","text":"<pre><code>fetch_invite()\n</code></pre> <p>Fetch the invite this links to.</p> RETURNS DESCRIPTION <code>hikari.invites.Invite</code> <p>Object of the invite this links to.</p> RAISES DESCRIPTION <code>hikari.errors.UnauthorizedError</code> <p>If you are unauthorized to make the request (invalid/missing token).</p> <code>hikari.errors.NotFoundError</code> <p>If the invite is not found.</p> <code>hikari.errors.RateLimitTooLongError</code> <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> <code>hikari.errors.InternalServerError</code> <p>If an internal error occurs on Discord while handling the request.</p>"},{"location":"reference/links/#yuyo.links.InviteLink.get","title":"get","text":"<pre><code>get()\n</code></pre> <p>Deprecated alias of InviteLink.get_invite.</p>"},{"location":"reference/links/#yuyo.links.InviteLink.get_invite","title":"get_invite","text":"<pre><code>get_invite()\n</code></pre> <p>Get the invite this links to from the cache.</p> RETURNS DESCRIPTION <code>hikari.invites.InviteWithMetadata | None</code> <p>Object of the invite that was found in the cache or None.</p>"},{"location":"reference/links/#yuyo.links.MessageLink","title":"MessageLink  <code>dataclass</code>","text":"<p>         Bases: <code>ChannelLink</code></p> <p>Represents a link to a message on Discord.</p> <p>The following class methods are used to initialise this:</p> <ul> <li>MessageLink.from_link to create this   from a raw message link.</li> <li>MessageLink.find to find the first invite   link in a string.</li> <li>MessageLink.find_iter to iterate over   the message links in a string.</li> </ul>"},{"location":"reference/links/#yuyo.links.MessageLink.message_id","title":"message_id  <code>property</code>","text":"<pre><code>message_id: hikari.Snowflake\n</code></pre> <p>ID of the message this links to.</p>"},{"location":"reference/links/#yuyo.links.MessageLink.__str__","title":"__str__","text":"<pre><code>__str__()\n</code></pre> <p>Create a raw string representation of this link.</p>"},{"location":"reference/links/#yuyo.links.MessageLink.fetch","title":"fetch  <code>async</code>","text":"<pre><code>fetch()\n</code></pre> <p>Deprecated alias of MessageLink.fetch_message.</p>"},{"location":"reference/links/#yuyo.links.MessageLink.fetch_message","title":"fetch_message  <code>async</code>","text":"<pre><code>fetch_message()\n</code></pre> <p>Fetch a the message this links to.</p> RETURNS DESCRIPTION <code>hikari.messages.Message</code> <p>Object of the message this links to.</p> RAISES DESCRIPTION <code>hikari.errors.UnauthorizedError</code> <p>If you are unauthorized to make the request (invalid/missing token).</p> <code>hikari.errors.ForbiddenError</code> <p>If you are missing the <code>READ_MESSAGE_HISTORY</code> in the channel.</p> <code>hikari.errors.NotFoundError</code> <p>If the channel is not found or the message is not found in the given text channel.</p> <code>hikari.errors.RateLimitTooLongError</code> <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> <code>hikari.errors.InternalServerError</code> <p>If an internal error occurs on Discord while handling the request.</p>"},{"location":"reference/links/#yuyo.links.MessageLink.get","title":"get","text":"<pre><code>get()\n</code></pre> <p>Deprecated alias of MessageLink.get_message.</p>"},{"location":"reference/links/#yuyo.links.MessageLink.get_message","title":"get_message","text":"<pre><code>get_message()\n</code></pre> <p>Get the message this links to from the cache.</p> RETURNS DESCRIPTION <code>hikari.messages.Message | None</code> <p>Object of the message that was found in the cache or None.</p>"},{"location":"reference/links/#yuyo.links.TemplateLink","title":"TemplateLink  <code>dataclass</code>","text":"<p>         Bases: <code>BaseLink</code></p> <p>Represents a link to a guild template.</p> <p>The following class methods are used to initialise this:</p> <ul> <li>TemplateLink.from_link to create this   from a raw template link.</li> <li>TemplateLink.find to find the first template   link in a string.</li> <li>TemplateLink.find_iter to iterate over   the template links in a string.</li> </ul>"},{"location":"reference/links/#yuyo.links.TemplateLink.code","title":"code  <code>property</code>","text":"<pre><code>code: str\n</code></pre> <p>The template's code.</p>"},{"location":"reference/links/#yuyo.links.TemplateLink.__str__","title":"__str__","text":"<pre><code>__str__()\n</code></pre> <p>Create a raw string representation of this link.</p>"},{"location":"reference/links/#yuyo.links.TemplateLink.fetch","title":"fetch  <code>async</code>","text":"<pre><code>fetch()\n</code></pre> <p>Deprecated alias of TemplateLink.fetch_template.</p>"},{"location":"reference/links/#yuyo.links.TemplateLink.fetch_template","title":"fetch_template  <code>async</code>","text":"<pre><code>fetch_template()\n</code></pre> <p>Fetch the guild template this links to.</p> RETURNS DESCRIPTION <code>hikari.templates.Template</code> <p>Object of the guild template this links to.</p> RAISES DESCRIPTION <code>hikari.errors.NotFoundError</code> <p>If the template was not found.</p> <code>hikari.errors.UnauthorizedError</code> <p>If you are unauthorized to make the request (invalid/missing token).</p> <code>hikari.errors.RateLimitTooLongError</code> <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> <code>hikari.errors.InternalServerError</code> <p>If an internal error occurs on Discord while handling the request.</p>"},{"location":"reference/links/#yuyo.links.WebhookLink","title":"WebhookLink  <code>dataclass</code>","text":"<p>         Bases: <code>hikari.ExecutableWebhook</code>, <code>BaseLink</code></p> <p>Represents a link to an incoming webhook.</p> <p>The following class methods are used to initialise this:</p> <ul> <li>WebhookLink.from_link to create this   from a raw webhook link.</li> <li>WebhookLink.find to find the first webhook   link in a string.</li> <li>WebhookLink.find_iter to iterate over   the webhook links in a string.</li> </ul>"},{"location":"reference/links/#yuyo.links.WebhookLink.app","title":"app  <code>property</code>","text":"<pre><code>app: hikari.RESTAware\n</code></pre> <p>The bot or REST client this is bound to.</p>"},{"location":"reference/links/#yuyo.links.WebhookLink.token","title":"token  <code>property</code>","text":"<pre><code>token: str\n</code></pre> <p>The webhook's token.</p>"},{"location":"reference/links/#yuyo.links.WebhookLink.webhook_id","title":"webhook_id  <code>property</code>","text":"<pre><code>webhook_id: hikari.Snowflake\n</code></pre> <p>ID of the webhook this links to.</p>"},{"location":"reference/links/#yuyo.links.WebhookLink.__str__","title":"__str__","text":"<pre><code>__str__()\n</code></pre> <p>Create a raw string representation of this link.</p>"},{"location":"reference/links/#yuyo.links.WebhookLink.fetch","title":"fetch  <code>async</code>","text":"<pre><code>fetch()\n</code></pre> <p>Deprecated alias of WebhookLink.fetch_webhook.</p>"},{"location":"reference/links/#yuyo.links.WebhookLink.fetch_webhook","title":"fetch_webhook  <code>async</code>","text":"<pre><code>fetch_webhook()\n</code></pre> <p>Fetch the incoming webhook this links to.</p> RETURNS DESCRIPTION <code>hikari.webhooks.IncomingWebhook</code> <p>Object of the incoming webhook this links to.</p> RAISES DESCRIPTION <code>hikari.errors.UnauthorizedError</code> <p>If you are unauthorized to make the request (invalid/missing token).</p> <code>hikari.errors.NotFoundError</code> <p>If the webhook is not found.</p> <code>hikari.errors.RateLimitTooLongError</code> <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> <code>hikari.errors.InternalServerError</code> <p>If an internal error occurs on Discord while handling the request.</p>"},{"location":"reference/links/#yuyo.links.make_channel_link","title":"make_channel_link","text":"<pre><code>make_channel_link(channel, /, *, guild=None)\n</code></pre> <p>Make a raw link for a channel.</p> PARAMETER DESCRIPTION <code>channel</code> <p>Object or ID of the channel to link to.</p> <p> TYPE: <code>hikari.SnowflakeishOr[hikari.PartialChannel]</code> </p> <code>guild</code> <p>Object or ID of the guild the channel is in.</p> <p>This should be provided for guild links.</p> <p> TYPE: <code>typing.Optional[hikari.SnowflakeishOr[hikari.PartialGuild]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The raw channel link.</p>"},{"location":"reference/links/#yuyo.links.make_invite_link","title":"make_invite_link","text":"<pre><code>make_invite_link(invite)\n</code></pre> <p>Make a raw link for an invite.</p> PARAMETER DESCRIPTION <code>invite</code> <p>Object or string code of the invite to make a raw link for.</p> <p> TYPE: <code>typing.Union[str, hikari.InviteCode]</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The raw invite link.</p>"},{"location":"reference/links/#yuyo.links.make_message_link","title":"make_message_link","text":"<pre><code>make_message_link(channel, message, /, *, guild=None)\n</code></pre> <p>Make a raw link for a message.</p> PARAMETER DESCRIPTION <code>channel</code> <p>Object or ID of the channel the message is in.</p> <p> TYPE: <code>hikari.SnowflakeishOr[hikari.PartialChannel]</code> </p> <code>message</code> <p>Object or ID of the message to link to.</p> <p> TYPE: <code>hikari.SnowflakeishOr[hikari.PartialMessage]</code> </p> <code>guild</code> <p>Object or ID of the guild the message is in.</p> <p>This should be provided for messages in guilds.</p> <p> TYPE: <code>typing.Optional[hikari.SnowflakeishOr[hikari.PartialGuild]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The raw message link.</p>"},{"location":"reference/links/#yuyo.links.make_template_link","title":"make_template_link","text":"<pre><code>make_template_link(template)\n</code></pre> <p>Make a raw link for a guild template.</p> PARAMETER DESCRIPTION <code>template</code> <p>Object or string code of the template to make a raw link to.</p> <p> TYPE: <code>typing.Union[hikari.Template, str]</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The raw template link.</p>"},{"location":"reference/links/#yuyo.links.make_webhook_link","title":"make_webhook_link","text":"<pre><code>make_webhook_link(webhook, token)\n</code></pre> <p>Make a raw link for an incoming webhook.</p> PARAMETER DESCRIPTION <code>webhook</code> <p>Object or ID of the webhook to make a link for.</p> <p> TYPE: <code>hikari.SnowflakeishOr[hikari.PartialWebhook]</code> </p> <code>token</code> <p>The webhook's token.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The raw webhook link.</p>"},{"location":"reference/list_status/","title":"yuyo.list_status","text":"<p>Utility classes for updating a bot's guild count on several bot list services.</p>"},{"location":"reference/list_status/#yuyo.list_status.ServiceSig","title":"ServiceSig  <code>module-attribute</code>","text":"<pre><code>ServiceSig = collections.Callable[['AbstractManager'], collections.Coroutine[typing.Any, typing.Any, None]]\n</code></pre> <p>Signature of a callback used to update a service.</p>"},{"location":"reference/list_status/#yuyo.list_status.AbstractCountStrategy","title":"AbstractCountStrategy","text":"<p>         Bases: <code>abc.ABC</code></p> <p>Protocol of a class used for calculating the bot's guild count.</p>"},{"location":"reference/list_status/#yuyo.list_status.AbstractCountStrategy.is_shard_bound","title":"is_shard_bound  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>is_shard_bound: bool\n</code></pre> <p>Whether this count is just for the current shards.</p>"},{"location":"reference/list_status/#yuyo.list_status.AbstractCountStrategy.close","title":"close  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Close the counter.</p>"},{"location":"reference/list_status/#yuyo.list_status.AbstractCountStrategy.count","title":"count  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>count()\n</code></pre> <p>Get a possibly cached guild count from this counter.</p> RETURNS DESCRIPTION <code>int</code> <p>The current guild count(s).</p> <p>If this is an int then this is a global count. If this is a mapping then this is shard-specific counts.</p> RAISES DESCRIPTION <code>CountUnknownError</code> <p>If the count is currently unknown.</p>"},{"location":"reference/list_status/#yuyo.list_status.AbstractCountStrategy.open","title":"open  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>open()\n</code></pre> <p>Open the counter.</p>"},{"location":"reference/list_status/#yuyo.list_status.AbstractManager","title":"AbstractManager","text":"<p>         Bases: <code>typing.Protocol</code></p> <p>Abstract class used for managing services.</p>"},{"location":"reference/list_status/#yuyo.list_status.AbstractManager.cache","title":"cache  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>cache: typing.Optional[hikari.api.Cache]\n</code></pre> <p>The cache service this manager is bound to.</p>"},{"location":"reference/list_status/#yuyo.list_status.AbstractManager.counter","title":"counter  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>counter: AbstractCountStrategy\n</code></pre> <p>The country strategy this manager was initialised with.</p>"},{"location":"reference/list_status/#yuyo.list_status.AbstractManager.event_manager","title":"event_manager  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>event_manager: typing.Optional[hikari.api.EventManager]\n</code></pre> <p>The event manager this manager is bound to.</p>"},{"location":"reference/list_status/#yuyo.list_status.AbstractManager.rest","title":"rest  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>rest: hikari.api.RESTClient\n</code></pre> <p>The REST client this manager is bound to.</p>"},{"location":"reference/list_status/#yuyo.list_status.AbstractManager.shards","title":"shards  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>shards: typing.Optional[hikari.ShardAware]\n</code></pre> <p>The shard aware client this manager is bound to.</p>"},{"location":"reference/list_status/#yuyo.list_status.AbstractManager.user_agent","title":"user_agent  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>user_agent: str\n</code></pre> <p>User agent services within this manager should use for requests.</p>"},{"location":"reference/list_status/#yuyo.list_status.AbstractManager.get_me","title":"get_me  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get_me()\n</code></pre> <p>Get user object of the bot this manager is bound to.</p> RETURNS DESCRIPTION <code>hikari.users.User</code> <p>User object of the bot this manager is bound to.</p>"},{"location":"reference/list_status/#yuyo.list_status.AbstractManager.get_session","title":"get_session  <code>abstractmethod</code>","text":"<pre><code>get_session()\n</code></pre> <p>Get an aiohttp session to use to make requests within the services.</p> RETURNS DESCRIPTION <code>aiohttp.ClientSession</code> <p>an aiohttp session to use to make requests within the services.</p> RAISES DESCRIPTION <code>RuntimeError</code> <ul> <li>If this is called in an environment with no running event loop.</li> <li>If the client isn't running.</li> </ul>"},{"location":"reference/list_status/#yuyo.list_status.BotsGGService","title":"BotsGGService","text":"<p>https://discord.bots.gg status update service.</p>"},{"location":"reference/list_status/#yuyo.list_status.BotsGGService.__init__","title":"__init__","text":"<pre><code>__init__(token)\n</code></pre> <p>Initialise a bots.gg service.</p> PARAMETER DESCRIPTION <code>token</code> <p>Authorization token used to update the bot's status.</p> <p> TYPE: <code>str</code> </p>"},{"location":"reference/list_status/#yuyo.list_status.CacheStrategy","title":"CacheStrategy","text":"<p>         Bases: <code>_LoadableStrategy</code></p> <p>Cache based implementation of yuyo.list_status.AbstractCountStrategy.</p> <p>This tracks per-shard guild counts.</p> <p>Warning</p> <p>This will only function properly if GUILD intents are declared and the guild cache resource is enabled.</p>"},{"location":"reference/list_status/#yuyo.list_status.CacheStrategy.__init__","title":"__init__","text":"<pre><code>__init__(cache, shards)\n</code></pre> <p>Initialise a cache strategy.</p> PARAMETER DESCRIPTION <code>cache</code> <p>The cache object this should use for getting the guild count.</p> <p> TYPE: <code>hikari.api.Cache</code> </p> <code>shards</code> <p>The shard aware client this should use for grouping counts per-shard.</p> <p> TYPE: <code>hikari.ShardAware</code> </p>"},{"location":"reference/list_status/#yuyo.list_status.CountUnknownError","title":"CountUnknownError","text":"<p>         Bases: <code>RuntimeError</code></p> <p>Error raised when the count is currently unknown.</p>"},{"location":"reference/list_status/#yuyo.list_status.DiscordBotListService","title":"DiscordBotListService","text":"<p>https://discordbotlist.com status update service.</p>"},{"location":"reference/list_status/#yuyo.list_status.DiscordBotListService.__init__","title":"__init__","text":"<pre><code>__init__(token)\n</code></pre> <p>Initialise a discordbotlist.com service.</p> PARAMETER DESCRIPTION <code>token</code> <p>Authorization token used to update the bot's status.</p> <p> TYPE: <code>str</code> </p>"},{"location":"reference/list_status/#yuyo.list_status.EventStrategy","title":"EventStrategy","text":"<p>         Bases: <code>_LoadableStrategy</code></p> <p>Cache based implementation of yuyo.list_status.AbstractCountStrategy.</p> <p>This tracks per-guild counts.</p> <p>Warning</p> <p>This will only function properly if GUILD intents are declared.</p>"},{"location":"reference/list_status/#yuyo.list_status.EventStrategy.__init__","title":"__init__","text":"<pre><code>__init__(event_manager, shards)\n</code></pre> <p>Initialise an event etrategy.</p> <p>Note</p> <p>You usually won't need to initialise this yourself as yuyo.list_status.ServiceManager will automatically pick this strategy if the bot config matches it.</p> PARAMETER DESCRIPTION <code>event_manager</code> <p>The event manager this should use to track shard guild counts.</p> <p> TYPE: <code>hikari.api.EventManager</code> </p> <code>shards</code> <p>The shard manager this should use to track shard guild counts.</p> <p> TYPE: <code>hikari.ShardAware</code> </p>"},{"location":"reference/list_status/#yuyo.list_status.SakeStrategy","title":"SakeStrategy","text":"<p>         Bases: <code>AbstractCountStrategy</code></p> <p>Async cache based implementation of yuyo.list_status.AbstractCountStrategy.</p> <p>This relies on Sake and tracks the global guild count.</p>"},{"location":"reference/list_status/#yuyo.list_status.SakeStrategy.__init__","title":"__init__","text":"<pre><code>__init__(cache)\n</code></pre> <p>Initialise a Sake strategy.</p> <p>Unlike CacheStrategy and EventStrategy this strategy must be directly initialised and passed to ServiceManager.__init__ as <code>strategy=</code>.</p> PARAMETER DESCRIPTION <code>cache</code> <p>The Sake guild cache to use to get the guild count.</p> <p> TYPE: <code>sake.abc.GuildCache</code> </p>"},{"location":"reference/list_status/#yuyo.list_status.ServiceManager","title":"ServiceManager","text":"<p>         Bases: <code>AbstractManager</code></p> <p>Standard service manager.</p>"},{"location":"reference/list_status/#yuyo.list_status.ServiceManager.is_alive","title":"is_alive  <code>property</code>","text":"<pre><code>is_alive: bool\n</code></pre> <p>Wwhether this manager is active.</p>"},{"location":"reference/list_status/#yuyo.list_status.ServiceManager.__init__","title":"__init__","text":"<pre><code>__init__(rest, /, *, cache=None, event_manager=None, shards=None, event_managed=None, strategy=None, user_agent=None)\n</code></pre> <p>Initialise a service manager.</p> <p>Note</p> <p>For an easier way to initialise the manager from a bot see ServiceManager.from_gateway_bot, and ServiceManager.from_tanjun.</p> PARAMETER DESCRIPTION <code>rest</code> <p>The RESTAware Hikari client to bind this manager to.</p> <p> TYPE: <code>hikari.api.RESTClient</code> </p> <code>cache</code> <p>The cache aware Hikari client this manager should use.</p> <p> TYPE: <code>typing.Optional[hikari.api.Cache]</code> DEFAULT: <code>None</code> </p> <code>event_manager</code> <p>The event manager aware Hikari client this manager should use.</p> <p> TYPE: <code>typing.Optional[hikari.api.EventManager]</code> DEFAULT: <code>None</code> </p> <code>shards</code> <p>The shard aware Hikari client this manager should use.</p> <p> TYPE: <code>typing.Optional[traits.ShardAware]</code> DEFAULT: <code>None</code> </p> <code>event_managed</code> <p>Whether this client should be automatically opened and closed based on <code>event_manager</code>'s lifetime events.</p> <p>Defaults to True when <code>event_manager</code> is passed.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>strategy</code> <p>The counter strategy this manager should expose to services.</p> <p>If this is left as None then the manager will try to pick a suitable standard strategy based on the provided Hikari clients.</p> <p> TYPE: <code>typing.Optional[AbstractCountStrategy]</code> DEFAULT: <code>None</code> </p> <code>user_agent</code> <p>Override the standard user agent used during requests to bot list services.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the manager failed to find a suitable standard strategy to use when <code>strategy</code> was left as None.</p> <p>If <code>event_managed</code> is passed as True when <code>event_manager</code> is None.</p>"},{"location":"reference/list_status/#yuyo.list_status.ServiceManager.add_service","title":"add_service","text":"<pre><code>add_service(service, /, *, repeat=datetime.timedelta(hours=1))\n</code></pre> <p>Add a service to this manager.</p> PARAMETER DESCRIPTION <code>service</code> <p>Asynchronous callback used to update this service.</p> <p> TYPE: <code>ServiceSig</code> </p> <code>repeat</code> <p>How often this service should be updated in seconds.</p> <p> TYPE: <code>typing.Union[datetime.timedelta, int, float]</code> DEFAULT: <code>datetime.timedelta(hours=1)</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Object of this service manager.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If repeat is less than 1 second.</p> <code>RuntimeError</code> <p>If the client is already running.</p>"},{"location":"reference/list_status/#yuyo.list_status.ServiceManager.close","title":"close  <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Close this manager.</p>"},{"location":"reference/list_status/#yuyo.list_status.ServiceManager.from_gateway_bot","title":"from_gateway_bot  <code>classmethod</code>","text":"<pre><code>from_gateway_bot(bot, /, *, event_managed=True, strategy=None, user_agent=None)\n</code></pre> <p>Build a service manager from a gateway bot.</p> PARAMETER DESCRIPTION <code>bot</code> <p>The gateway bot to build a service manager from.</p> <p> TYPE: <code>hikari.traits.ShardAware</code> </p> <code>event_managed</code> <p>Whether this client should be automatically opened and closed based on <code>bot</code>'s lifetime events.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>strategy</code> <p>The counter strategy this manager should expose to services.</p> <p>If this is left as None then the manager will try to pick a suitable standard strategy based on the provided Hikari clients.</p> <p> TYPE: <code>typing.Optional[AbstractCountStrategy]</code> DEFAULT: <code>None</code> </p> <code>user_agent</code> <p>Override the standard user agent used during requests to bot list services.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ServiceManager</code> <p>The build service manager.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the manager failed to find a suitable standard strategy to use when <code>strategy</code> was left as None.</p>"},{"location":"reference/list_status/#yuyo.list_status.ServiceManager.from_tanjun","title":"from_tanjun  <code>classmethod</code>","text":"<pre><code>from_tanjun(tanjun_client, /, *, tanjun_managed=True, strategy=None, user_agent=None)\n</code></pre> <p>Build a service manager from a Tanjun client.</p> <p>This will use the Tanjun client's alluka client and registers ServiceManager and AbstractManager as type dependencies on Tanjun.</p> PARAMETER DESCRIPTION <code>tanjun_client</code> <p>The Tanjun client to build a service manager from.</p> <p> TYPE: <code>tanjun.abc.Client</code> </p> <code>tanjun_managed</code> <p>Whether this client should be automatically opened and closed based on the Tanjun client's lifetime client callback.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>strategy</code> <p>The counter strategy this manager should expose to services.</p> <p>If this is left as None then the manager will try to pick a suitable standard strategy based on the provided Hikari clients.</p> <p> TYPE: <code>typing.Optional[AbstractCountStrategy]</code> DEFAULT: <code>None</code> </p> <code>user_agent</code> <p>Override the standard user agent used during requests to bot list services.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ServiceManager</code> <p>The build service manager.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the manager failed to find a suitable standard strategy to use when <code>strategy</code> was left as None.</p>"},{"location":"reference/list_status/#yuyo.list_status.ServiceManager.open","title":"open  <code>async</code>","text":"<pre><code>open()\n</code></pre> <p>Start this manager.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If this manager is already running.</p>"},{"location":"reference/list_status/#yuyo.list_status.ServiceManager.remove_service","title":"remove_service","text":"<pre><code>remove_service(service)\n</code></pre> <p>Remove the first found entry of the registered service.</p> PARAMETER DESCRIPTION <code>service</code> <p>Service callback to unregister.</p> <p> TYPE: <code>ServiceSig</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If called while the manager is active.</p> <code>ValueError</code> <p>If the service callback isn't found.</p>"},{"location":"reference/list_status/#yuyo.list_status.ServiceManager.with_service","title":"with_service","text":"<pre><code>with_service(*, repeat=datetime.timedelta(hours=1))\n</code></pre> <p>Add a service to this manager by decorating a function.</p> PARAMETER DESCRIPTION <code>repeat</code> <p>How often this service should be updated in seconds.</p> <p> TYPE: <code>typing.Union[datetime.timedelta, int, float]</code> DEFAULT: <code>datetime.timedelta(hours=1)</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[ServiceSig], ServiceSig]</code> <p>Decorator callback used to add a service.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If repeat is less than 1 second.</p> <code>RuntimeError</code> <p>If the client is already running.</p>"},{"location":"reference/list_status/#yuyo.list_status.TopGGService","title":"TopGGService","text":"<p>https://top.gg status update service.</p>"},{"location":"reference/list_status/#yuyo.list_status.TopGGService.__init__","title":"__init__","text":"<pre><code>__init__(token)\n</code></pre> <p>Initialise a top.gg service.</p> PARAMETER DESCRIPTION <code>token</code> <p>Authorization token used to update the bot's status.</p> <p> TYPE: <code>str</code> </p>"},{"location":"reference/modals/","title":"yuyo.modals","text":"<p>Higher level client for modal execution.</p>"},{"location":"reference/modals/#yuyo.modals.AbstractTimeout","title":"AbstractTimeout  <code>module-attribute</code>","text":"<pre><code>AbstractTimeout = timeouts.AbstractTimeout\n</code></pre> <p>Deprecated alias of yuyo.timeouts.AbstractTimeout.</p>"},{"location":"reference/modals/#yuyo.modals.Client","title":"Client  <code>module-attribute</code>","text":"<pre><code>Client = ModalClient\n</code></pre> <p>Alias of ModalClient.</p>"},{"location":"reference/modals/#yuyo.modals.Context","title":"Context  <code>module-attribute</code>","text":"<pre><code>Context = ModalContext\n</code></pre> <p>Alias of ModalContext.</p>"},{"location":"reference/modals/#yuyo.modals.NO_DEFAULT","title":"NO_DEFAULT  <code>module-attribute</code>","text":"<pre><code>NO_DEFAULT: typing.Literal[_NoDefaultEnum.VALUE] = _NoDefaultEnum.VALUE\n</code></pre> <p>Singleton used to signify when a field has no default.</p>"},{"location":"reference/modals/#yuyo.modals.AbstractModal","title":"AbstractModal","text":"<p>         Bases: <code>abc.ABC</code></p> <p>Base class for a modal execution handler.</p>"},{"location":"reference/modals/#yuyo.modals.AbstractModal.execute","title":"execute  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>execute(ctx)\n</code></pre> <p>Execute this modal.</p> PARAMETER DESCRIPTION <code>ctx</code> <p>The context to execute this with.</p> <p> TYPE: <code>ModalContext</code> </p>"},{"location":"reference/modals/#yuyo.modals.BasicTimeout","title":"BasicTimeout","text":"<p>         Bases: <code>timeouts.SlidingTimeout</code></p> <p>Deprecated alias of yuyo.timeouts.SlidingTimeout.</p>"},{"location":"reference/modals/#yuyo.modals.Modal","title":"Modal","text":"<p>         Bases: <code>AbstractModal</code></p> <p>Standard implementation of a modal executor.</p> <p>To send this modal pass Modal.rows as <code>components</code> when calling <code>create_modal_response</code>.</p> <p>Examples:</p> <p>There's a few different ways this can be used to create a modal.</p> <p>Sub-components can be added to an instance of a modal using chainable methods:</p> <pre><code>async def callback(\n    ctx: modals.ModalContext, field: str, other_field: str | None\n) -&gt; None:\n    await ctx.respond(\"hi\")\n\nmodal = (\n    modals.modal(callback, ephemeral_default=True)\n    .add_text_input(\"Title A\", parameter=\"field\")\n    .add_text_input(\n        \"Title B\",\n        style=hikari.TextInputStyle.PARAGRAPH,\n        parameter=\"other_field\",\n        default=None,\n    )\n)\n</code></pre> <p>or using decorator methods:</p> <pre><code>@modals.with_text_input(\n    \"Title B\",\n    style=hikari.TextInputStyle.PARAGRAPH,\n    parameter=\"other_field\",\n    default=None,\n)\n@modals.with_text_input(\"Title A\", parameter=\"field\")\n@modals.as_modal(ephemeral_default=True)\nasync def callback(\n    ctx: modals.ModalContext, field: str, other_field: str | None\n) -&gt; None:\n    await ctx.respond(\"bye\")\n</code></pre> <p>Note</p> <p>Since decorators are executed from the bottom upwards fields added through decorator calls will follow the same order.</p> <p>Subclasses of Modal can act as a template where \"static\" fields are included on all instances and subclasses of that class:</p> <pre><code>@modals.with_static_text_input(\n    \"Title B\",\n    style=hikari.TextInputStyle.PARAGRAPH,\n    parameter=\"other_field\",\n    default=None,\n)\n@modals.with_static_text_input(\"Title A\", parameter=\"field\")\nclass CustomModal(modals.Modal):\n    # The init can be overridden to store extra data on the column object when subclassing.\n    def __init__(self, special_string: str, ephemeral_default: bool = False):\n        super().__init__(ephemeral_default=ephemeral_default)\n        self.special_string = special_string\n\n    async def callback(\n        ctx: modals.ModalContext,\n        field: str,\n        other_field: str | None,\n        value: str\n    ) -&gt; None:\n        await ctx.respond(\"Good job\")\n</code></pre> <p>Templates can be made by subclassing Modal and defining the method <code>callback</code> for handling context  menu execution (this must be valid for the signature signature <code>(modals.ModalContext, ...) -&gt; Coroutine[Any, Any, None]</code>).</p> <pre><code>@modals.with_static_text_input(\n    \"Title B\",\n    style=hikari.TextInputStyle.PARAGRAPH,\n    parameter=\"other_field\",\n    default=None,\n)\n@modals.with_static_text_input(\"Title A\", parameter=\"field\")\n@modals.as_modal_template\nasync def custom_modal(\n    ctx: modals.ModalContext,\n    field: str,\n    other_field: str | None,\n    value: str,\n) -&gt; None:\n    await ctx.respond(\"Bye\")\n</code></pre> <p>or by using as_modal_template (which returns a class which functions like a Modal subclass) The chainable <code>add_static_{}()</code> classmethods can also be used to add static fields to a Modal subclass.</p> <p>Modals also support declaring entries using the following parameter descriptors:</p> <ul> <li>text_input</li> </ul> <pre><code>class ModalOptions(modals.ModalOptions):\n    foo: str = modals.text_input(\"label\")\n    bar: str | None = modals.text_unput(\n        \"label\", style=hikari.TextInputStyle.PARAGRAPH, default=None\n    )\n\n@yuyo.modals.as_modal_template\nasync def callback(\n    ctx: modals.ModalContext,\n    options: ModalOptions,\n    field: str = modals.text_input(\"label\", value=\"yeet\")\n)\n</code></pre> <p>These can either be applied to the default of an argument or defined as an attribute on a ModalOptions subclass ( <code>ModalOptions</code> should then be used as an argument's type-hint). This also works for Modal subclasses which have a <code>Modal.callback</code> method.</p>"},{"location":"reference/modals/#yuyo.modals.Modal.rows","title":"rows  <code>property</code>","text":"<pre><code>rows: collections.abc.Sequence[hikari.api.ModalActionRowBuilder]\n</code></pre> <p>Builder objects of the rows in this modal.</p>"},{"location":"reference/modals/#yuyo.modals.Modal.__init__","title":"__init__","text":"<pre><code>__init__(*, ephemeral_default=False, id_metadata=None)\n</code></pre> <p>Initialise a component executor.</p> PARAMETER DESCRIPTION <code>ephemeral_default</code> <p>Whether this executor's responses should default to being ephemeral.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>id_metadata</code> <p>Mapping of metadata to append to the custom_ids in this modal.</p> <p> TYPE: <code>typing.Union[collections.abc.Mapping[str, str], None]</code> DEFAULT: <code>None</code> </p>"},{"location":"reference/modals/#yuyo.modals.Modal.add_static_text_input","title":"add_static_text_input  <code>classmethod</code>","text":"<pre><code>add_static_text_input(label, /, *, custom_id=None, style=hikari.TextInputStyle.SHORT, placeholder=hikari.UNDEFINED, value=hikari.UNDEFINED, default=NO_DEFAULT, min_length=0, max_length=4000, prefix_match=None, parameter=None)\n</code></pre> <p>Add a text input field to all instances and subclasses of this modal class.</p> PARAMETER DESCRIPTION <code>label</code> <p>The text input field's display label.</p> <p>This cannot be greater than 45 characters long.</p> <p> TYPE: <code>str</code> </p> <code>custom_id</code> <p>The field's custom ID.</p> <p>Defaults to <code>parameter</code>, if provided, or a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>style</code> <p>The text input's style.</p> <p> TYPE: <code>hikari.TextInputStyle</code> DEFAULT: <code>hikari.TextInputStyle.SHORT</code> </p> <code>placeholder</code> <p>Placeholder text to display when the text input is empty.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>value</code> <p>Default text to pre-fill the field with.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>default</code> <p>Default value to pass if this text input field was not provided.</p> <p>The field will be marked as required unless this is supplied.</p> <p>This will also be used for <code>value</code> when it has been left undefined and the default is a string that's &lt;=4000 characters in length.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>NO_DEFAULT</code> </p> <code>min_length</code> <p>Minimum length the input text can be.</p> <p>This can be greater than or equal to 0 and less than or equal to 4000.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>max_length</code> <p>Maximum length the input text can be.</p> <p>This can be greater than or equal to 1 and less than or equal to 4000.</p> <p> TYPE: <code>int</code> DEFAULT: <code>4000</code> </p> <code>prefix_match</code> <p>Deprecated config.</p> <p>This behaviour is now always enabled.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>parameter</code> <p>Name of the parameter the text for this field should be passed to.</p> <p>This will be of type str and may also be the value passed for <code>default</code>.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>type[Self]</code> <p>The class to enable call chaining.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>When called directly on modals.Modal (rather than on a subclass).</p>"},{"location":"reference/modals/#yuyo.modals.Modal.add_text_input","title":"add_text_input","text":"<pre><code>add_text_input(label, /, *, custom_id=None, style=hikari.TextInputStyle.SHORT, placeholder=hikari.UNDEFINED, value=hikari.UNDEFINED, default=NO_DEFAULT, min_length=0, max_length=4000, prefix_match=None, parameter=None)\n</code></pre> <p>Add a text input field to this modal instance.</p> PARAMETER DESCRIPTION <code>label</code> <p>The text input field's display label.</p> <p>This cannot be greater than 45 characters long.</p> <p> TYPE: <code>str</code> </p> <code>custom_id</code> <p>The field's custom ID.</p> <p>Defaults to <code>parameter</code>, if provided, or a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>style</code> <p>The text input's style.</p> <p> TYPE: <code>hikari.TextInputStyle</code> DEFAULT: <code>hikari.TextInputStyle.SHORT</code> </p> <code>placeholder</code> <p>Placeholder text to display when the text input is empty.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>value</code> <p>Default text to pre-fill the field with.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>default</code> <p>Default value to pass if this text input field was not provided.</p> <p>The field will be marked as required unless this is supplied.</p> <p>This will also be used for <code>value</code> when it has been left undefined and the default is a string that's &lt;=4000 characters in length.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>NO_DEFAULT</code> </p> <code>min_length</code> <p>Minimum length the input text can be.</p> <p>This can be greater than or equal to 0 and less than or equal to 4000.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>max_length</code> <p>Maximum length the input text can be.</p> <p>This can be greater than or equal to 1 and less than or equal to 4000.</p> <p> TYPE: <code>int</code> DEFAULT: <code>4000</code> </p> <code>prefix_match</code> <p>Deprecated config.</p> <p>This behaviour is now always enabled.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>parameter</code> <p>Name of the parameter the text for this field should be passed to.</p> <p>This will be of type str and may also be the value passed for <code>default</code>.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The modal instance to enable call chaining.</p>"},{"location":"reference/modals/#yuyo.modals.ModalClient","title":"ModalClient","text":"<p>Client used to handle modals within a REST or gateway flow.</p>"},{"location":"reference/modals/#yuyo.modals.ModalClient.alluka","title":"alluka  <code>property</code>","text":"<pre><code>alluka: alluka_.abc.Client\n</code></pre> <p>The Alluka client being used for callback dependency injection.</p>"},{"location":"reference/modals/#yuyo.modals.ModalClient.__init__","title":"__init__","text":"<pre><code>__init__(*, alluka=None, event_manager=None, event_managed=None, server=None)\n</code></pre> <p>Initialise a modal client.</p> <p>This registers ModalClient as a type dependency when <code>alluka</code> isn't passed.</p> <p>Note</p> <p>For an easier way to initialise the client from a bot see ModalClient.from_gateway_bot, ModalClient.from_rest_bot, and ModalClient.from_tanjun.</p> PARAMETER DESCRIPTION <code>alluka</code> <p>The Alluka client to use for callback dependency injection in this client.</p> <p>If not provided then this will initialise its own Alluka client.</p> <p> TYPE: <code>typing.Optional[alluka_.abc.Client]</code> DEFAULT: <code>None</code> </p> <code>event_manager</code> <p>The event manager this client should listen to dispatched modal interactions from if applicable.</p> <p> TYPE: <code>typing.Optional[hikari.api.EventManager]</code> DEFAULT: <code>None</code> </p> <code>event_managed</code> <p>Whether this client should be automatically opened and closed based on the lifetime events dispatched by <code>event_manager</code>.</p> <p>Defaults to True if an event manager is passed.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>server</code> <p>The server this client should listen to modal interactions from if applicable.</p> <p> TYPE: <code>typing.Optional[hikari.api.InteractionServer]</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If <code>event_managed</code> is passed as True when <code>event_manager</code> is None.</p>"},{"location":"reference/modals/#yuyo.modals.ModalClient.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Close the modal client.</p>"},{"location":"reference/modals/#yuyo.modals.ModalClient.deregister_modal","title":"deregister_modal","text":"<pre><code>deregister_modal(custom_id)\n</code></pre> <p>Remove the modal set for a custom ID.</p> PARAMETER DESCRIPTION <code>custom_id</code> <p>The custom_id to unset the modal for.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The modal client to allow chaining.</p> RAISES DESCRIPTION <code>KeyError</code> <p>If the custom_id is not registered.</p>"},{"location":"reference/modals/#yuyo.modals.ModalClient.from_gateway_bot","title":"from_gateway_bot  <code>classmethod</code>","text":"<pre><code>from_gateway_bot(bot, /, *, alluka=None, event_managed=True)\n</code></pre> <p>Build a modal client from a Gateway Bot.</p> <p>This registers ModalClient as a type dependency when <code>alluka</code> isn't passed.</p> PARAMETER DESCRIPTION <code>bot</code> <p>The Gateway bot this modal client should be bound to.</p> <p> TYPE: <code>hikari.EventManagerAware</code> </p> <code>alluka</code> <p>The Alluka client to use for callback dependency injection in this client.</p> <p>If not provided then this will initialise its own Alluka client.</p> <p> TYPE: <code>typing.Optional[alluka_.abc.Client]</code> DEFAULT: <code>None</code> </p> <code>event_managed</code> <p>Whether the modal client should be automatically opened and closed based on the lifetime events dispatched by <code>bot</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>ModalClient</code> <p>The initialised modal client.</p>"},{"location":"reference/modals/#yuyo.modals.ModalClient.from_rest_bot","title":"from_rest_bot  <code>classmethod</code>","text":"<pre><code>from_rest_bot(bot, /, *, alluka=None, bot_managed=False)\n</code></pre> <p>Build a modal client from a REST Bot.</p> <p>This registers ModalClient as a type dependency when <code>alluka</code> isn't passed.</p> PARAMETER DESCRIPTION <code>bot</code> <p>The REST bot this modal client should be bound to.</p> <p> TYPE: <code>hikari.RESTBotAware</code> </p> <code>alluka</code> <p>The Alluka client to use for callback dependency injection in this client.</p> <p>If not provided then this will initialise its own Alluka client.</p> <p> TYPE: <code>typing.Optional[alluka_.abc.Client]</code> DEFAULT: <code>None</code> </p> <code>bot_managed</code> <p>Whether the modal client should be automatically opened and closed based on the Bot's startup and shutdown callbacks.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>ModalClient</code> <p>The initialised modal client.</p>"},{"location":"reference/modals/#yuyo.modals.ModalClient.from_tanjun","title":"from_tanjun  <code>classmethod</code>","text":"<pre><code>from_tanjun(tanjun_client, /, *, tanjun_managed=True)\n</code></pre> <p>Build a modal client from a Tanjun client.</p> <p>This will use the Tanjun client's alluka client and registers ModalClient as a type dependency on Tanjun.</p> PARAMETER DESCRIPTION <code>tanjun_client</code> <p>The Tanjun client this modal client should be bound to.</p> <p> TYPE: <code>tanjun.abc.Client</code> </p> <code>tanjun_managed</code> <p>Whether the modal client should be automatically opened and closed based on the Tanjun client's lifetime client callback.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>ModalClient</code> <p>The initialised modal client.</p>"},{"location":"reference/modals/#yuyo.modals.ModalClient.get_modal","title":"get_modal","text":"<pre><code>get_modal(custom_id)\n</code></pre> <p>Get the modal set for a custom ID.</p> PARAMETER DESCRIPTION <code>custom_id</code> <p>The custom_id to get the modal for.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>AbstractModal | None</code> <p>The callback for the custom_id, or None if it doesn't exist.</p>"},{"location":"reference/modals/#yuyo.modals.ModalClient.on_gateway_event","title":"on_gateway_event  <code>async</code>","text":"<pre><code>on_gateway_event(event)\n</code></pre> <p>Process an interaction create gateway event.</p> PARAMETER DESCRIPTION <code>event</code> <p>The interaction create gateway event to process.</p> <p> TYPE: <code>hikari.InteractionCreateEvent</code> </p>"},{"location":"reference/modals/#yuyo.modals.ModalClient.on_rest_request","title":"on_rest_request  <code>async</code>","text":"<pre><code>on_rest_request(interaction)\n</code></pre> <p>Process a modal interaction REST request.</p> PARAMETER DESCRIPTION <code>interaction</code> <p>The interaction to process.</p> <p> TYPE: <code>hikari.ModalInteraction</code> </p> RETURNS DESCRIPTION <code>hikari.api.InteractionMessageBuilder | hikari.api.InteractionDeferredBuilder</code> <p>The REST response.</p>"},{"location":"reference/modals/#yuyo.modals.ModalClient.open","title":"open","text":"<pre><code>open()\n</code></pre> <p>Startup the modal client.</p>"},{"location":"reference/modals/#yuyo.modals.ModalClient.register_modal","title":"register_modal","text":"<pre><code>register_modal(custom_id, modal, /, *, timeout=_internal.NO_DEFAULT)\n</code></pre> <p>Register a modal for a custom ID.</p> PARAMETER DESCRIPTION <code>custom_id</code> <p>The custom_id to register the modal for.</p> <p>This will be matched against <code>interaction.custom_id.split(\":\", 1)[0]</code>, allowing metadata to be stored after a <code>\":\"</code>.</p> <p> TYPE: <code>str</code> </p> <code>modal</code> <p>The modal to register.</p> <p> TYPE: <code>AbstractModal</code> </p> <code>timeout</code> <p>Timeout strategy for this modal.</p> <p>Passing None here will set NeverTimeout.</p> <p>This defaults to single use with a 2 minute timeout.</p> <p> TYPE: <code>typing.Union[timeouts.AbstractTimeout, None, _internal.NoDefault]</code> DEFAULT: <code>_internal.NO_DEFAULT</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The modal client to allow chaining.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the custom_id is already registered.</p> <p>If <code>\":\"</code> is in the custom ID.</p>"},{"location":"reference/modals/#yuyo.modals.ModalContext","title":"ModalContext","text":"<p>         Bases: <code>components_.BaseContext[hikari.ModalInteraction]</code></p> <p>The context used for modal triggers.</p>"},{"location":"reference/modals/#yuyo.modals.ModalContext.client","title":"client  <code>property</code>","text":"<pre><code>client: ModalClient\n</code></pre> <p>The modal this context is bound to.</p>"},{"location":"reference/modals/#yuyo.modals.ModalContext.component_ids","title":"component_ids  <code>property</code>","text":"<pre><code>component_ids: collections.abc.Mapping[str, str]\n</code></pre> <p>Mapping of match ID parts to metadata ID parts for the modal's components.</p>"},{"location":"reference/modals/#yuyo.modals.ModalContext.create_initial_response","title":"create_initial_response  <code>async</code>","text":"<pre><code>create_initial_response(content=hikari.UNDEFINED, *, delete_after=None, ephemeral=False, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, mentions_everyone=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED, flags=hikari.UNDEFINED, tts=hikari.UNDEFINED)\n</code></pre> <p>Create the initial response for this context.</p> <p>Warning</p> <p>Calling this on a context which already has an initial response will result in this raising a hikari.errors.NotFoundError. This includes if the REST interaction server has already responded to the request and deferrals.</p> PARAMETER DESCRIPTION <code>content</code> <p>The content to edit the last response with.</p> <p>If provided, the message contents. If hikari.undefined.UNDEFINED, then nothing will be sent in the content. Any other value here will be cast to a str.</p> <p>If this is a hikari.embeds.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.files.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> <p> TYPE: <code>hikari.UndefinedOr[typing.Any]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>delete_after</code> <p>If provided, the seconds after which the response message should be deleted.</p> <p>Slash command responses can only be deleted within 15 minutes of the command being received.</p> <p> TYPE: <code>typing.Union[datetime.timedelta, float, int, None]</code> DEFAULT: <code>None</code> </p> <code>ephemeral</code> <p>Whether the deferred response should be ephemeral.</p> <p>Passing True here is a shorthand for including <code>1 &lt;&lt; 64</code> in the passed flags.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>content</code> <p>If provided, the message contents. If hikari.undefined.UNDEFINED, then nothing will be sent in the content. Any other value here will be cast to a <code>str</code>.</p> <p>If this is a hikari.embeds.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone.</p> <p> TYPE: <code>hikari.UndefinedOr[typing.Any]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>attachment</code> <p>If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.Resourceish]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>attachments</code> <p>If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.</p> <p> TYPE: <code>hikari.UndefinedOr[collections.abc.Sequence[hikari.Resourceish]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>component</code> <p>If provided, builder object of the component to include in this message.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.api.ComponentBuilder]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>components</code> <p>If provided, a sequence of the component builder objects to include in this message.</p> <p> TYPE: <code>hikari.UndefinedOr[collections.abc.Sequence[hikari.api.ComponentBuilder]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>embed</code> <p>If provided, the message embed.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.Embed]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>embeds</code> <p>If provided, the message embeds.</p> <p> TYPE: <code>hikari.UndefinedOr[collections.abc.Sequence[hikari.Embed]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>flags</code> <p>If provided, the message flags this response should have.</p> <p>As of writing the only message flag which can be set here is hikari.messages.MessageFlag.EPHEMERAL.</p> <p> TYPE: <code>typing.Union[int, hikari.MessageFlag, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>tts</code> <p>If provided, whether the message will be read out by a screen reader using Discord's TTS (text-to-speech) system.</p> <p> TYPE: <code>hikari.UndefinedOr[bool]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>mentions_everyone</code> <p>If provided, whether the message should parse @everyone/@here mentions.</p> <p> TYPE: <code>hikari.UndefinedOr[bool]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>user_mentions</code> <p>If provided, and True, all user mentions will be detected. If provided, and False, all user mentions will be ignored if appearing in the message body.</p> <p>Alternatively this may be a collection of hikari.snowflakes.Snowflake, or hikari.users.PartialUser derivatives to enforce mentioning specific users.</p> <p> TYPE: <code>typing.Union[hikari.SnowflakeishSequence[hikari.PartialUser], bool, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>role_mentions</code> <p>If provided, and True, all role mentions will be detected. If provided, and False, all role mentions will be ignored if appearing in the message body.</p> <p>Alternatively this may be a collection of [hikari.snowflakes.Snowflake], or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles.</p> <p> TYPE: <code>typing.Union[hikari.SnowflakeishSequence[hikari.PartialRole], bool, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If more than 100 unique objects/entities are passed for <code>role_mentions</code> or <code>user_mentions</code>.</p> <p>If the interaction will have expired before <code>delete_after</code> is reached.</p> <p>If both <code>attachment</code> and <code>attachments</code> are passed or both <code>component</code> and <code>components</code> are passed or both <code>embed</code> and <code>embeds</code> are passed.</p> <code>hikari.BadRequestError</code> <p>This may be raised in several discrete situations, such as messages being empty with no embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; invalid image URLs in embeds.</p> <code>hikari.UnauthorizedError</code> <p>If you are unauthorized to make the request (invalid/missing token).</p> <code>hikari.NotFoundError</code> <p>If the interaction is not found or if the interaction's initial response has already been created.</p> <code>hikari.RateLimitTooLongError</code> <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> <code>hikari.InternalServerError</code> <p>If an internal error occurs on Discord while handling the request.</p>"},{"location":"reference/modals/#yuyo.modals.ModalContext.defer","title":"defer  <code>async</code>","text":"<pre><code>defer(*, ephemeral=False, flags=hikari.UNDEFINED)\n</code></pre> <p>Defer the initial response for this context.</p> <p>Note</p> <p>The ephemeral state of the first response is decided by whether the deferral is ephemeral.</p> PARAMETER DESCRIPTION <code>ephemeral</code> <p>Whether the deferred response should be ephemeral.</p> <p>Passing True here is a shorthand for including <code>1 &lt;&lt; 64</code> in the passed flags.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>flags</code> <p>The flags to use for the initial response.</p> <p> TYPE: <code>typing.Union[hikari.UndefinedType, int, hikari.MessageFlag]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p>"},{"location":"reference/modals/#yuyo.modals.ModalOptions","title":"ModalOptions","text":"<p>Data class used to define a modal's options.</p> <p>Examples:</p> <pre><code>class ModalOptions(modals.ModalOptions):\n    field: str = modals.text_input(\"label\")\n    optional_field: str | None = modals.text_input(\"label\", default=None)\n\n@modals.as_modal_template\nasync def modal_template(\n    ctx: modals.ModalContext, fields: ModalOptions,\n) -&gt; None:\n    ...\n</code></pre>"},{"location":"reference/modals/#yuyo.modals.NeverTimeout","title":"NeverTimeout","text":"<p>         Bases: <code>timeouts.NeverTimeout</code></p> <p>Deprecated alias of yuyo.timeouts.NeverTimeout.</p>"},{"location":"reference/modals/#yuyo.modals.as_modal","title":"as_modal","text":"<pre><code>as_modal(callback=None, /, *, ephemeral_default=False, parse_signature=False)\n</code></pre> <p>Create a modal instance through a decorator call.</p> <p>Info</p> <p>This won't parse the callback for parameter descriptors and ModalOptions unless <code>parse_signature=True</code> is passed, unlike as_modal_template and Modal subclasses.</p> PARAMETER DESCRIPTION <code>ephemeral_default</code> <p>Whether this modal's responses should default to ephemeral.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>parse_signature</code> <p>Whether to parse the signature for parameter descriptors and ModalOptions type-hints.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Modal</code> <p>The new decorated modal.</p>"},{"location":"reference/modals/#yuyo.modals.as_modal_template","title":"as_modal_template","text":"<pre><code>as_modal_template(callback=None, /, *, ephemeral_default=False, parse_signature=True)\n</code></pre> <p>Create a modal template through a decorator callback.</p> <p>This supports the same decorators and parameter descriptors for declaring the modal's entries as a normal modal class.</p> PARAMETER DESCRIPTION <code>ephemeral_default</code> <p>Whether this modal's responses should default to ephemeral.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>parse_signature</code> <p>Whether to parse the signature for parameter descriptors and ModalOptions type-hints.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>type[Modal]</code> <p>The new decorated modal class.</p>"},{"location":"reference/modals/#yuyo.modals.modal","title":"modal","text":"<pre><code>modal(callback, /, *, ephemeral_default=False, parse_signature=False)\n</code></pre> <p>Create a modal instance for a callback.</p> <p>Info</p> <p>This won't parse the callback for parameter descriptors and ModalOptions unless <code>parse_signature=True</code> is passed, unlike as_modal_template and Modal subclasses.</p> PARAMETER DESCRIPTION <code>callback</code> <p>Callback to use for modal execution.</p> <p> TYPE: <code>collections.abc.Callable[_P, _CoroT[None]]</code> </p> <code>ephemeral_default</code> <p>Whether this modal's responses should default to ephemeral.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>parse_signature</code> <p>Whether to parse the signature for parameter descriptors and ModalOptions type-hints.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Modal</code> <p>The created modal.</p>"},{"location":"reference/modals/#yuyo.modals.text_input","title":"text_input","text":"<pre><code>text_input(label, /, *, custom_id=None, style=hikari.TextInputStyle.SHORT, placeholder=hikari.UNDEFINED, value=hikari.UNDEFINED, default=NO_DEFAULT, min_length=0, max_length=4000, prefix_match=None)\n</code></pre> <p>Descriptor used to declare a text input field.</p> PARAMETER DESCRIPTION <code>label</code> <p>The text input field's display label.</p> <p>This cannot be greater than 45 characters long.</p> <p> TYPE: <code>str</code> </p> <code>custom_id</code> <p>The field's custom ID.</p> <p>Defaults to the name of the parameter/attribute this is assigned to.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>style</code> <p>The text input's style.</p> <p> TYPE: <code>hikari.TextInputStyle</code> DEFAULT: <code>hikari.TextInputStyle.SHORT</code> </p> <code>placeholder</code> <p>Placeholder text to display when the text input is empty.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>value</code> <p>Default text to pre-fill the field with.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>default</code> <p>Default value to pass if this text input field was not provided.</p> <p>The field will be marked as required unless this is supplied.</p> <p>This will also be used for <code>value</code> when it has been left undefined and the default is a string that's &lt;=4000 characters in length.</p> <p> TYPE: <code>typing.Union[_T, typing.Literal[_NoDefaultEnum.VALUE]]</code> DEFAULT: <code>NO_DEFAULT</code> </p> <code>min_length</code> <p>Minimum length the input text can be.</p> <p>This can be greater than or equal to 0 and less than or equal to 4000.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>max_length</code> <p>Maximum length the input text can be.</p> <p>This can be greater than or equal to 1 and less than or equal to 4000.</p> <p> TYPE: <code>int</code> DEFAULT: <code>4000</code> </p> <code>prefix_match</code> <p>Deprecated config.</p> <p>This behaviour is now always enabled.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <p>This can either be applied to an argument's default</p> <pre><code>@modals.as_modal_template\nasync def modal_template(\n    ctx: modals.ModalContext,\n    text_field: str = modals.text_input(\"label\"),\n    optional_field: str | None = modals.text_input(\"label\", default=None)\n) -&gt; None:\n    ...\n</code></pre> <p>Or as an attribute to a ModalOptions dataclass.</p> <pre><code>class ModalOptions(modals.ModalOptions):\n    field: str = modals.text_input(\"label\")\n    optional_field: str | None = modals.text_input(\"label\", default=None)\n\n@modals.as_modal_template\nasync def modal_template(\n    ctx: modals.ModalContext, fields: ModalOptions,\n) -&gt; None:\n    ...\n</code></pre>"},{"location":"reference/modals/#yuyo.modals.with_static_text_input","title":"with_static_text_input","text":"<pre><code>with_static_text_input(label, /, *, custom_id=None, style=hikari.TextInputStyle.SHORT, placeholder=hikari.UNDEFINED, value=hikari.UNDEFINED, default=NO_DEFAULT, min_length=0, max_length=4000, prefix_match=None, parameter=None)\n</code></pre> <p>Add a static text input field to the decorated modal subclass.</p> PARAMETER DESCRIPTION <code>label</code> <p>The text input field's display label.</p> <p>This cannot be greater than 45 characters long.</p> <p> TYPE: <code>str</code> </p> <code>custom_id</code> <p>The field's custom ID.</p> <p>Defaults to <code>parameter</code>, if provided, or a UUID and cannot be longer than 100 characters.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>style</code> <p>The text input's style.</p> <p> TYPE: <code>hikari.TextInputStyle</code> DEFAULT: <code>hikari.TextInputStyle.SHORT</code> </p> <code>placeholder</code> <p>Placeholder text to display when the text input is empty.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>value</code> <p>Default text to pre-fill the field with.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>default</code> <p>Default value to pass if this text input field was not provided.</p> <p>The field will be marked as required unless this is supplied.</p> <p>This will also be used for <code>value</code> when it has been left undefined and the default is a string that's &lt;=4000 characters in length.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>NO_DEFAULT</code> </p> <code>min_length</code> <p>Minimum length the input text can be.</p> <p>This can be greater than or equal to 0 and less than or equal to 4000.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>max_length</code> <p>Maximum length the input text can be.</p> <p>This can be greater than or equal to 1 and less than or equal to 4000.</p> <p> TYPE: <code>int</code> DEFAULT: <code>4000</code> </p> <code>prefix_match</code> <p>Deprecated config.</p> <p>This behaviour is now always enabled.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>parameter</code> <p>Name of the parameter the text for this field should be passed to.</p> <p>This will be of type str and may also be the value passed for <code>default</code>.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>type[Modal]</code> <p>The decorated modal class.</p>"},{"location":"reference/modals/#yuyo.modals.with_text_input","title":"with_text_input","text":"<pre><code>with_text_input(label, /, *, custom_id=None, style=hikari.TextInputStyle.SHORT, placeholder=hikari.UNDEFINED, value=hikari.UNDEFINED, default=NO_DEFAULT, min_length=0, max_length=4000, prefix_match=None, parameter=None)\n</code></pre> <p>Add a text input field to the decorated modal instance.</p> PARAMETER DESCRIPTION <code>label</code> <p>The text input field's display label.</p> <p>This cannot be greater than 45 characters long.</p> <p> TYPE: <code>str</code> </p> <code>custom_id</code> <p>The field's custom ID.</p> <p>Defaults to <code>parameter</code>, if provided, or a UUID and cannot be longer than 100 characters.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>style</code> <p>The text input's style.</p> <p> TYPE: <code>hikari.TextInputStyle</code> DEFAULT: <code>hikari.TextInputStyle.SHORT</code> </p> <code>placeholder</code> <p>Placeholder text to display when the text input is empty.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>value</code> <p>Default text to pre-fill the field with.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>default</code> <p>Default value to pass if this text input field was not provided.</p> <p>The field will be marked as required unless this is supplied.</p> <p>This will also be used for <code>value</code> when it has been left undefined and the default is a string that's &lt;=4000 characters in length.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>NO_DEFAULT</code> </p> <code>min_length</code> <p>Minimum length the input text can be.</p> <p>This can be greater than or equal to 0 and less than or equal to 4000.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>max_length</code> <p>Maximum length the input text can be.</p> <p>This can be greater than or equal to 1 and less than or equal to 4000.</p> <p> TYPE: <code>int</code> DEFAULT: <code>4000</code> </p> <code>prefix_match</code> <p>Deprecated config.</p> <p>This behaviour is now always enabled.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>parameter</code> <p>Name of the parameter the text for this field should be passed to.</p> <p>This will be of type str and may also be the value passed for <code>default</code>.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Modal</code> <p>The decorated modal instance.</p>"},{"location":"reference/pagination/","title":"yuyo.pagination","text":"<p>Utilities used for quick pagination handling within reaction and component executors.</p>"},{"location":"reference/pagination/#yuyo.pagination.BLACK_CROSS","title":"BLACK_CROSS  <code>module-attribute</code>","text":"<pre><code>BLACK_CROSS: typing.Final[hikari.UnicodeEmoji] = hikari.UnicodeEmoji('\u2716\ufe0f')\n</code></pre> <p>The emoji used to close a menu in a component context.</p>"},{"location":"reference/pagination/#yuyo.pagination.EntryT","title":"EntryT  <code>module-attribute</code>","text":"<pre><code>EntryT = typing.Union[tuple[hikari.UndefinedOr[str], hikari.UndefinedOr[hikari.Embed]], 'Page']\n</code></pre> <p>A type hint used to represent a paginator entry.</p> <p>This may be either Page or <code>tuple[hikari.UndefinedOr[str], hikari.UndefinedOr[hikari.Embed]]</code> where tuple[0] is the message content and tuple[1] is an embed to send.</p>"},{"location":"reference/pagination/#yuyo.pagination.LEFT_DOUBLE_TRIANGLE","title":"LEFT_DOUBLE_TRIANGLE  <code>module-attribute</code>","text":"<pre><code>LEFT_DOUBLE_TRIANGLE: typing.Final[hikari.UnicodeEmoji] = hikari.UnicodeEmoji('\u23ee\ufe0f')\n</code></pre> <p>The emoji used to go back to the first entry.</p>"},{"location":"reference/pagination/#yuyo.pagination.LEFT_TRIANGLE","title":"LEFT_TRIANGLE  <code>module-attribute</code>","text":"<pre><code>LEFT_TRIANGLE: typing.Final[hikari.UnicodeEmoji] = hikari.UnicodeEmoji('\u25c0\ufe0f')\n</code></pre> <p>The emoji used to go back an entry.</p>"},{"location":"reference/pagination/#yuyo.pagination.RIGHT_DOUBLE_TRIANGLE","title":"RIGHT_DOUBLE_TRIANGLE  <code>module-attribute</code>","text":"<pre><code>RIGHT_DOUBLE_TRIANGLE: typing.Final[hikari.UnicodeEmoji] = hikari.UnicodeEmoji('\u23ed\ufe0f')\n</code></pre> <p>The emoji used for the (not enabled by default) skip to last entry button.</p>"},{"location":"reference/pagination/#yuyo.pagination.RIGHT_TRIANGLE","title":"RIGHT_TRIANGLE  <code>module-attribute</code>","text":"<pre><code>RIGHT_TRIANGLE: typing.Final[hikari.UnicodeEmoji] = hikari.UnicodeEmoji('\u25b6\ufe0f')\n</code></pre> <p>The emoji used to continue to the next entry.</p>"},{"location":"reference/pagination/#yuyo.pagination.STOP_SQUARE","title":"STOP_SQUARE  <code>module-attribute</code>","text":"<pre><code>STOP_SQUARE: typing.Final[hikari.UnicodeEmoji] = hikari.UnicodeEmoji('\u23f9\ufe0f')\n</code></pre> <p>The emoji used to close a menu in a reaction context.</p>"},{"location":"reference/pagination/#yuyo.pagination.Page","title":"Page","text":"<p>Represents a pagianted response.</p>"},{"location":"reference/pagination/#yuyo.pagination.Page.__init__","title":"__init__","text":"<pre><code>__init__(content=hikari.UNDEFINED, *, attachments=hikari.UNDEFINED, embeds=hikari.UNDEFINED)\n</code></pre> <p>Initialise a response page.</p> PARAMETER DESCRIPTION <code>content</code> <p>The message content to send.</p> <p> TYPE: <code>hikari.UndefinedOr[str]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>attachments</code> <p>Up to 10 attachments to include in the response..</p> <p> TYPE: <code>hikari.UndefinedOr[collections.Sequence[hikari.Resourceish]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>embeds</code> <p>Up to 10 embeds to include in the response.</p> <p> TYPE: <code>hikari.UndefinedOr[collections.Sequence[hikari.Embed]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p>"},{"location":"reference/pagination/#yuyo.pagination.Page.from_entry","title":"from_entry  <code>classmethod</code>","text":"<pre><code>from_entry(entry)\n</code></pre> <p>Create a Page from a yuyo.pagination.EntryT.</p> PARAMETER DESCRIPTION <code>entry</code> <p>The yuyo.pagination.EntryT to make a page from.</p> <p> TYPE: <code>EntryT</code> </p> RETURNS DESCRIPTION <code>Page</code> <p>The created page.</p>"},{"location":"reference/pagination/#yuyo.pagination.Page.to_kwargs","title":"to_kwargs","text":"<pre><code>to_kwargs()\n</code></pre> <p>Form create message <code>**kwargs</code> for this page.</p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>The create message kwargs for this page.</p>"},{"location":"reference/pagination/#yuyo.pagination.aenumerate","title":"aenumerate  <code>async</code>","text":"<pre><code>aenumerate(iterable)\n</code></pre> <p>Async equivalent of enumerate.</p> PARAMETER DESCRIPTION <code>iterable</code> <p>The async iterable to enumerate.</p> <p> TYPE: <code>collections.AsyncIterable[_T]</code> </p> RETURNS DESCRIPTION <code>collections.abc.AsyncIterator[tuple[int, _T]]</code> <p>The enumerated async iterator.</p>"},{"location":"reference/pagination/#yuyo.pagination.async_paginate_string","title":"async_paginate_string  <code>async</code>","text":"<pre><code>async_paginate_string(lines, /, *, char_limit=2000, line_limit=25, wrapper=None)\n</code></pre> <p>Lazily paginate an iterator of lines.</p> PARAMETER DESCRIPTION <code>lines</code> <p>The asynchronous iterator of lines to paginate.</p> <p> TYPE: <code>collections.AsyncIterable[str]</code> </p> <code>char_limit</code> <p>The limit for how many characters should be included per yielded page.</p> <p> TYPE: <code>int</code> DEFAULT: <code>2000</code> </p> <code>line_limit</code> <p>The limit for how many lines should be included per yielded page.</p> <p> TYPE: <code>int</code> DEFAULT: <code>25</code> </p> <code>wrapper</code> <p>A wrapper for each yielded page. This should leave \"{}\" in it to be replaced by the page's content.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>collections.abc.AsyncIterator[tuple[str, int]]</code> <p>An async iterator of page tuples (string context to int zero-based index).</p>"},{"location":"reference/pagination/#yuyo.pagination.paginate_string","title":"paginate_string","text":"<pre><code>paginate_string(lines, /, *, char_limit=2000, line_limit=25, wrapper=None)\n</code></pre> <p>Lazily paginate an iterator of lines.</p> PARAMETER DESCRIPTION <code>lines</code> <p>The iterator of lines to paginate. This iterator may be asynchronous or synchronous.</p> <p> TYPE: <code>collections.abc.Iterator[str] | collections.abc.AsyncIterator[str]</code> </p> <code>char_limit</code> <p>The limit for how many characters should be included per yielded page.</p> <p> TYPE: <code>int</code> DEFAULT: <code>2000</code> </p> <code>line_limit</code> <p>The limit for how many lines should be included per yielded page.</p> <p> TYPE: <code>int</code> DEFAULT: <code>25</code> </p> <code>wrapper</code> <p>A wrapper for each yielded page. This should leave \"{}\" in it to be replaced by the page's content.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>collections.abc.AsyncIterator[tuple[str, int]] | collections.abc.Iterator[tuple[str, int]]</code> <p>An iterator of page tuples (string context to int zero-based index).</p>"},{"location":"reference/pagination/#yuyo.pagination.sync_paginate_string","title":"sync_paginate_string","text":"<pre><code>sync_paginate_string(lines, /, *, char_limit=2000, line_limit=25, wrapper=None)\n</code></pre> <p>Lazily paginate an iterator of lines.</p> PARAMETER DESCRIPTION <code>lines</code> <p>The iterator of lines to paginate.</p> <p> TYPE: <code>collections.Iterable[str]</code> </p> <code>char_limit</code> <p>The limit for how many characters should be included per yielded page.</p> <p> TYPE: <code>int</code> DEFAULT: <code>2000</code> </p> <code>line_limit</code> <p>The limit for how many lines should be included per yielded page.</p> <p> TYPE: <code>int</code> DEFAULT: <code>25</code> </p> <code>wrapper</code> <p>A wrapper for each yielded page. This should leave \"{}\" in it to be replaced by the page's content.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>collections.abc.Iterator[tuple[str, int]]</code> <p>An iterator of page tuples (string context to int zero-based index).</p>"},{"location":"reference/reactions/","title":"yuyo.reactions","text":"<p>Client for higher level callback based reaction menu handling.</p>"},{"location":"reference/reactions/#yuyo.reactions.CallbackSig","title":"CallbackSig  <code>module-attribute</code>","text":"<pre><code>CallbackSig = collections.Callable[Ellipsis, collections.Coroutine[typing.Any, typing.Any, None]]\n</code></pre> <p>Type-hint of a callback used to handle matching reactions events.</p>"},{"location":"reference/reactions/#yuyo.reactions.Client","title":"Client  <code>module-attribute</code>","text":"<pre><code>Client = ReactionHandler\n</code></pre> <p>Alias of ReactionHandler.</p>"},{"location":"reference/reactions/#yuyo.reactions.ReactionEventT","title":"ReactionEventT  <code>module-attribute</code>","text":"<pre><code>ReactionEventT = typing.Union[hikari.ReactionAddEvent, hikari.ReactionDeleteEvent]\n</code></pre> <p>Type hint of the event types CallbackSig takes as its first argument.</p>"},{"location":"reference/reactions/#yuyo.reactions.AbstractReactionHandler","title":"AbstractReactionHandler","text":"<p>         Bases: <code>abc.ABC</code></p> <p>The interface for a reaction handler used with yuyo.reactions.ReactionClient.</p>"},{"location":"reference/reactions/#yuyo.reactions.AbstractReactionHandler.has_expired","title":"has_expired  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>has_expired: bool\n</code></pre> <p>Whether this handler has ended.</p>"},{"location":"reference/reactions/#yuyo.reactions.AbstractReactionHandler.close","title":"close  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Close this handler.</p>"},{"location":"reference/reactions/#yuyo.reactions.AbstractReactionHandler.on_reaction_event","title":"on_reaction_event  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>on_reaction_event(event, /, *, alluka=None)\n</code></pre> <p>Handle a reaction event.</p> PARAMETER DESCRIPTION <code>event</code> <p>The event to handle.</p> <p> TYPE: <code>ReactionEventT</code> </p> <code>alluka</code> <p>The Alluka client to use for callback dependency injection during callback calls.</p> <p> TYPE: <code>typing.Optional[alluka_.abc.Client]</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>HandlerClosed</code> <p>If this reaction handler has been closed.</p>"},{"location":"reference/reactions/#yuyo.reactions.AbstractReactionHandler.open","title":"open  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>open(message)\n</code></pre> <p>Open this handler.</p> PARAMETER DESCRIPTION <code>message</code> <p>The message to bind this handler to.</p> <p> TYPE: <code>hikari.Message</code> </p>"},{"location":"reference/reactions/#yuyo.reactions.HandlerClosed","title":"HandlerClosed","text":"<p>         Bases: <code>Exception</code></p> <p>Error raised when a reaction handler has been closed.</p>"},{"location":"reference/reactions/#yuyo.reactions.ReactionClient","title":"ReactionClient","text":"<p>A class which handles the events for multiple registered reaction handlers.</p>"},{"location":"reference/reactions/#yuyo.reactions.ReactionClient.alluka","title":"alluka  <code>property</code>","text":"<pre><code>alluka: alluka_.abc.Client\n</code></pre> <p>The Alluka client being used for callback dependency injection.</p>"},{"location":"reference/reactions/#yuyo.reactions.ReactionClient.is_closed","title":"is_closed  <code>property</code>","text":"<pre><code>is_closed: bool\n</code></pre> <p>Whether this client is closed.</p>"},{"location":"reference/reactions/#yuyo.reactions.ReactionClient.__init__","title":"__init__","text":"<pre><code>__init__(*, rest, event_manager, alluka=None, event_managed=True)\n</code></pre> <p>Initialise a reaction client.</p> <p>This registers ReactionClient as a type dependency when <code>alluka</code> isn't passed.</p> <p>Note</p> <p>For an easier way to initialise the client from a bot see ReactionClient.from_gateway_bot, and ReactionClient.from_tanjun.</p> PARAMETER DESCRIPTION <code>rest</code> <p>The REST client to register this reaction client with.</p> <p> TYPE: <code>hikari.api.RESTClient</code> </p> <code>event_manager</code> <p>The event manager client to register this reaction client with.</p> <p> TYPE: <code>hikari.api.EventManager</code> </p> <code>alluka</code> <p>The Alluka client to use for callback dependency injection in this client.</p> <p>If not provided then this will initialise its own Alluka client.</p> <p> TYPE: <code>typing.Optional[alluka_.abc.Client]</code> DEFAULT: <code>None</code> </p> <code>event_managed</code> <p>Whether the reaction client should be automatically opened and closed based on the lifetime events dispatched by <code>event_managed</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p>"},{"location":"reference/reactions/#yuyo.reactions.ReactionClient.close","title":"close  <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Close this client by unregistering any registered tasks and event listeners.</p>"},{"location":"reference/reactions/#yuyo.reactions.ReactionClient.from_gateway_bot","title":"from_gateway_bot  <code>classmethod</code>","text":"<pre><code>from_gateway_bot(bot, /, *, alluka=None, event_managed=True)\n</code></pre> <p>Build a <code>ReactionClient</code> from a gateway bot.</p> <p>This registers ReactionClient as a type dependency when <code>alluka</code> isn't passed.</p> PARAMETER DESCRIPTION <code>bot</code> <p>The bot to build a reaction client for.</p> <p> TYPE: <code>hikari.traits.EventManagerAware</code> </p> <code>alluka</code> <p>The Alluka client to use for callback dependency injection in this client.</p> <p>If not provided then this will initialise its own Alluka client.</p> <p> TYPE: <code>typing.Optional[alluka_.abc.Client]</code> DEFAULT: <code>None</code> </p> <code>event_managed</code> <p>Whether the reaction client should be automatically opened and closed based on the lifetime events dispatched by <code>bot</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>ReactionClient</code> <p>The reaction client for the bot.</p>"},{"location":"reference/reactions/#yuyo.reactions.ReactionClient.from_tanjun","title":"from_tanjun  <code>classmethod</code>","text":"<pre><code>from_tanjun(tanjun_client, /, *, tanjun_managed=True)\n</code></pre> <p>Build a <code>ReactionClient</code> from a gateway bot.</p> <p>This will use the Tanjun client's alluka client and registers ReactionClient as a type dependency on Tanjun.</p> PARAMETER DESCRIPTION <code>tanjun_client</code> <p>The tanjun client to build a reaction client for.</p> <p> TYPE: <code>tanjun.abc.Client</code> </p> <code>tanjun_managed</code> <p>Whether the reaction client should be automatically opened and closed based on the Tanjun client's lifetime client callback.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>ReactionClient</code> <p>The reaction client for the bot.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If tanjun.abc.Client.events is None.</p>"},{"location":"reference/reactions/#yuyo.reactions.ReactionClient.get_handler","title":"get_handler","text":"<pre><code>get_handler(message)\n</code></pre> <p>Get a reference to a paginator registered in this reaction client.</p> <p>Note</p> <p>This does not call yuyo.reactions.AbstractReactionHandler.close.</p> PARAMETER DESCRIPTION <code>message</code> <p>The message ID to remove a paginator for.</p> <p> TYPE: <code>hikari.SnowflakeishOr[hikari.Message]</code> </p> RETURNS DESCRIPTION <code>AbstractReactionHandler | None</code> <p>The object of the registered paginator if found else None.</p>"},{"location":"reference/reactions/#yuyo.reactions.ReactionClient.open","title":"open  <code>async</code>","text":"<pre><code>open()\n</code></pre> <p>Start this client by registering the required tasks and event listeners for it to function.</p>"},{"location":"reference/reactions/#yuyo.reactions.ReactionClient.remove_handler","title":"remove_handler","text":"<pre><code>remove_handler(message)\n</code></pre> <p>Remove a paginator from this reaction client.</p> <p>Note</p> <p>This does not call yuyo.reactions.AbstractReactionHandler.close.</p> PARAMETER DESCRIPTION <code>message</code> <p>The message ID to remove a paginator for.</p> <p> TYPE: <code>hikari.SnowflakeishOr[hikari.Message]</code> </p> RETURNS DESCRIPTION <code>AbstractReactionHandler | None</code> <p>The object of the registered paginator if found else None.</p>"},{"location":"reference/reactions/#yuyo.reactions.ReactionClient.set_handler","title":"set_handler","text":"<pre><code>set_handler(message, handler)\n</code></pre> <p>Add a reaction handler to this reaction client.</p> <p>Note</p> <p>This does not call yuyo.reactions.AbstractReactionHandler.open.</p> PARAMETER DESCRIPTION <code>message</code> <p>The message ID to add register a reaction handler with.</p> <p> TYPE: <code>hikari.SnowflakeishOr[hikari.Message]</code> </p> <code>handler</code> <p>The object of the opened handler to register in this reaction client.</p> <p> TYPE: <code>AbstractReactionHandler</code> </p>"},{"location":"reference/reactions/#yuyo.reactions.ReactionHandler","title":"ReactionHandler","text":"<p>         Bases: <code>AbstractReactionHandler</code></p> <p>Standard basic implementation of a reaction handler.</p>"},{"location":"reference/reactions/#yuyo.reactions.ReactionHandler.authors","title":"authors  <code>property</code>","text":"<pre><code>authors: collections.Set[hikari.Snowflake]\n</code></pre> <p>Set of the authors/owner of a enabled handler.</p> <p>Note</p> <p>If this is empty then the handler is considered public and any user will be able to trigger it.</p>"},{"location":"reference/reactions/#yuyo.reactions.ReactionHandler.__init__","title":"__init__","text":"<pre><code>__init__(*, authors=(), timeout=datetime.timedelta(seconds=30))\n</code></pre> <p>Initialise a reaction handler.</p> PARAMETER DESCRIPTION <code>authors</code> <p>An iterable of IDs of the users who can call this paginator.</p> <p>If left empty then all users will be able to call this paginator.</p> <p> TYPE: <code>collections.Iterable[hikari.SnowflakeishOr[hikari.User]]</code> DEFAULT: <code>()</code> </p> <code>timeout</code> <p>How long it should take for this paginator to timeout.</p> <p> TYPE: <code>typing.Optional[datetime.timedelta]</code> DEFAULT: <code>datetime.timedelta(seconds=30)</code> </p>"},{"location":"reference/reactions/#yuyo.reactions.ReactionHandler.remove_callback","title":"remove_callback","text":"<pre><code>remove_callback(emoji_identifier)\n</code></pre> <p>Remove a callback from this reaction handler.</p> PARAMETER DESCRIPTION <code>emoji_identifier</code> <p>Identifier of the emoji the callback to remove is for.</p> <p>This should be a snowfake if this is for a custom emoji or a string if this is for a unicode emoji.</p> <p> TYPE: <code>typing.Union[str, hikari.SnowflakeishOr[hikari.CustomEmoji]]</code> </p>"},{"location":"reference/reactions/#yuyo.reactions.ReactionHandler.set_callback","title":"set_callback","text":"<pre><code>set_callback(emoji_identifier, callback)\n</code></pre> <p>Add a callback to this reaction handler.</p> PARAMETER DESCRIPTION <code>emoji_identifier</code> <p>Identifier of the emoji this callback is for.</p> <p>This should be a snowfake if this is for a custom emoji or a string if this is for a unicode emoji.</p> <p> TYPE: <code>typing.Union[str, hikari.SnowflakeishOr[hikari.CustomEmoji]]</code> </p> <code>callback</code> <p>The callback to add.</p> <p>This should be a function that accepts a single parameter, which is the event that triggered this reaction.</p> <p> TYPE: <code>CallbackSig</code> </p>"},{"location":"reference/reactions/#yuyo.reactions.ReactionHandler.with_callback","title":"with_callback","text":"<pre><code>with_callback(emoji_identifier)\n</code></pre> <p>Add a callback to this reaction handler through a decorator call.</p> PARAMETER DESCRIPTION <code>emoji_identifier</code> <p>Identifier of the emoji this callback is for.</p> <p>This should be a snowfake if this is for a custom emoji or a string if this is for a unicode emoji.</p> <p> TYPE: <code>typing.Union[str, hikari.SnowflakeishOr[hikari.CustomEmoji]]</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callback[[CallbackSig], CallbackSig]</code> <p>A decorator to add a callback to this reaction handler.</p>"},{"location":"reference/reactions/#yuyo.reactions.ReactionPaginator","title":"ReactionPaginator","text":"<p>         Bases: <code>ReactionHandler</code></p> <p>Standard implementation of a reaction handler for pagination.</p>"},{"location":"reference/reactions/#yuyo.reactions.ReactionPaginator.__init__","title":"__init__","text":"<pre><code>__init__(iterator, /, *, authors=(), triggers=(pagination.LEFT_TRIANGLE, pagination.STOP_SQUARE, pagination.RIGHT_TRIANGLE), timeout=datetime.timedelta(seconds=30))\n</code></pre> <p>Initialise a reaction paginator.</p> PARAMETER DESCRIPTION <code>iterator</code> <p>Either an asynchronous or synchronous iterator of the entries this should paginate through.</p> <p><code>entry[0]</code> represents the message's possible content and can either be str or hikari.undefined.UNDEFINED and <code>entry[1]</code> represents the message's possible embed and can either be hikari.embeds.Embed or hikari.undefined.UNDEFINED.</p> <p> TYPE: <code>collections.Iterator[yuyo.pagination.EntryT] | collections.AsyncIterator[yuyo.pagination.EntryT]</code> </p> <code>authors</code> <p>An iterable of IDs of the users who can call this paginator.</p> <p>If left empty then all users will be able to call this paginator.</p> <p> TYPE: <code>collections.Iterable[hikari.SnowflakeishOr[hikari.User]]</code> DEFAULT: <code>()</code> </p> <code>timeout</code> <p>How long it should take for this paginator to timeout.</p> <p> TYPE: <code>typing.Optional[datetime.timedelta]</code> DEFAULT: <code>datetime.timedelta(seconds=30)</code> </p>"},{"location":"reference/reactions/#yuyo.reactions.ReactionPaginator.add_author","title":"add_author","text":"<pre><code>add_author(user)\n</code></pre> <p>Add a author/owner to this handler.</p> PARAMETER DESCRIPTION <code>user</code> <p>The user to add as an owner for this handler.</p> <p> TYPE: <code>hikari.SnowflakeishOr[hikari.User]</code> </p>"},{"location":"reference/reactions/#yuyo.reactions.ReactionPaginator.add_first_button","title":"add_first_button","text":"<pre><code>add_first_button(*, emoji=pagination.LEFT_DOUBLE_TRIANGLE, add_reaction=True)\n</code></pre> <p>Add the jump to first entry reaction button to this paginator.</p> <p>You should pass <code>triggers=[]</code> to [yuyo.reactions.ReactionPaginator.init][ComponentPaginator.__init__] before calling this.</p> <p>Note</p> <p>These reactions will appear in the order these methods were called in.</p> PARAMETER DESCRIPTION <code>emoji</code> <p>The emoji to react with for this button.</p> <p> TYPE: <code>typing.Union[hikari.CustomEmoji, str]</code> DEFAULT: <code>pagination.LEFT_DOUBLE_TRIANGLE</code> </p> <code>add_reaction</code> <p>Whether the bot should add this reaction to the message when ReactionPaginator.open is called with <code>add_reactions=True</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>To enable chained calls.</p>"},{"location":"reference/reactions/#yuyo.reactions.ReactionPaginator.add_last_button","title":"add_last_button","text":"<pre><code>add_last_button(*, emoji=pagination.RIGHT_DOUBLE_TRIANGLE, add_reaction=True)\n</code></pre> <p>Add the jump to last entry reaction button to this paginator.</p> <p>You should pass <code>triggers=[]</code> to [yuyo.reactions.ReactionPaginator.init][ComponentPaginator.__init__] before calling this.</p> <p>Note</p> <p>These reactions will appear in the order these methods were called in.</p> PARAMETER DESCRIPTION <code>emoji</code> <p>The emoji to react with for this button.</p> <p> TYPE: <code>typing.Union[hikari.CustomEmoji, str]</code> DEFAULT: <code>pagination.RIGHT_DOUBLE_TRIANGLE</code> </p> <code>add_reaction</code> <p>Whether the bot should add this reaction to the message when ReactionPaginator.open is called with <code>add_reactions=True</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>To enable chained calls.</p>"},{"location":"reference/reactions/#yuyo.reactions.ReactionPaginator.add_next_button","title":"add_next_button","text":"<pre><code>add_next_button(*, emoji=pagination.RIGHT_TRIANGLE, add_reaction=True)\n</code></pre> <p>Add the next entry reaction button to this paginator.</p> <p>You should pass <code>triggers=[]</code> to [yuyo.reactions.ReactionPaginator.init][ComponentPaginator.__init__] before calling this.</p> <p>Note</p> <p>These reactions will appear in the order these methods were called in.</p> PARAMETER DESCRIPTION <code>emoji</code> <p>The emoji to react with for this button.</p> <p> TYPE: <code>typing.Union[hikari.CustomEmoji, str]</code> DEFAULT: <code>pagination.RIGHT_TRIANGLE</code> </p> <code>add_reaction</code> <p>Whether the bot should add this reaction to the message when ReactionPaginator.open is called with <code>add_reactions=True</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>To enable chained calls.</p>"},{"location":"reference/reactions/#yuyo.reactions.ReactionPaginator.add_previous_button","title":"add_previous_button","text":"<pre><code>add_previous_button(*, emoji=pagination.LEFT_TRIANGLE, add_reaction=True)\n</code></pre> <p>Add the previous entry reaction button to this paginator.</p> <p>You should pass <code>triggers=[]</code> to [yuyo.reactions.ReactionPaginator.init][ComponentPaginator.__init__] before calling this.</p> <p>Note</p> <p>These reactions will appear in the order these methods were called in.</p> PARAMETER DESCRIPTION <code>emoji</code> <p>The emoji to react with for this button.</p> <p> TYPE: <code>typing.Union[hikari.CustomEmoji, str]</code> DEFAULT: <code>pagination.LEFT_TRIANGLE</code> </p> <code>add_reaction</code> <p>Whether the bot should add this reaction to the message when ReactionPaginator.open is called with <code>add_reactions=True</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>To enable chained calls.</p>"},{"location":"reference/reactions/#yuyo.reactions.ReactionPaginator.add_stop_button","title":"add_stop_button","text":"<pre><code>add_stop_button(*, emoji=pagination.STOP_SQUARE, add_reaction=True)\n</code></pre> <p>Add the stop reaction button to this paginator.</p> <p>You should pass <code>triggers=[]</code> to [yuyo.reactions.ReactionPaginator.init][ComponentPaginator.__init__] before calling this.</p> <p>Note</p> <p>These reactions will appear in the order these methods were called in.</p> PARAMETER DESCRIPTION <code>emoji</code> <p>The emoji to react with for this button.</p> <p> TYPE: <code>typing.Union[hikari.CustomEmoji, str]</code> DEFAULT: <code>pagination.STOP_SQUARE</code> </p> <code>add_reaction</code> <p>Whether the bot should add this reaction to the message when ReactionPaginator.open is called with <code>add_reactions=True</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>To enable chained calls.</p>"},{"location":"reference/reactions/#yuyo.reactions.ReactionPaginator.close","title":"close  <code>async</code>","text":"<pre><code>close(*, remove_reactions=False)\n</code></pre> <p>Close this handler and deregister any previously registered message.</p> PARAMETER DESCRIPTION <code>remove_reactions</code> <p>Whether this should remove the reactions that were being used to paginate through this from the previously registered message.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"reference/reactions/#yuyo.reactions.ReactionPaginator.create_message","title":"create_message  <code>async</code>","text":"<pre><code>create_message(rest, channel_id, /, *, add_reactions=True)\n</code></pre> <p>Start this handler and link it to a bot message.</p> <p>Note</p> <p>Calling this multiple times will replace the previously registered message.</p> PARAMETER DESCRIPTION <code>rest</code> <p>Rest client to use to make the response.</p> <p> TYPE: <code>hikari.api.RESTClient</code> </p> <code>channel_id</code> <p>ID of the channel to respond in.</p> <p> TYPE: <code>hikari.SnowflakeishOr[hikari.TextableChannel]</code> </p> <code>add_reactions</code> <p>Whether this should add the paginator's reactions to the message after responding.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>hikari.messages.Message</code> <p>Object of the message this handler now targets. If <code>message</code> was not supplied then this will be the object of a newly created message, otherwise this will be what was supplied as <code>message</code>.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the provided iterator didn't yield any content for the first message.</p>"},{"location":"reference/reactions/#yuyo.reactions.ReactionPaginator.get_next_entry","title":"get_next_entry  <code>async</code>","text":"<pre><code>get_next_entry()\n</code></pre> <p>Get the next entry in this paginator.</p> RETURNS DESCRIPTION <code>yuyo.pagination.Page | None</code> <p>The next entry in this paginator, or None if there are no more entries.</p>"},{"location":"reference/reactions/#yuyo.reactions.ReactionPaginator.open","title":"open  <code>async</code>","text":"<pre><code>open(message, /, *, add_reactions=True)\n</code></pre> <p>Start the reaction paginator and start accepting reactions..</p> PARAMETER DESCRIPTION <code>message</code> <p>The message this paginator should target.</p> <p> TYPE: <code>hikari.Message</code> </p> <code>add_reactions</code> <p>Whether this should add the paginator's reactions to the message.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p>"},{"location":"reference/reactions/#yuyo.reactions.ReactionPaginator.remove_author","title":"remove_author","text":"<pre><code>remove_author(user)\n</code></pre> <p>Remove a author/owner from this handler.</p> <p>Note</p> <p>If the provided user isn't already a registered owner of this paginator then this should pass silently without raising.</p> PARAMETER DESCRIPTION <code>user</code> <p>The user to remove from this handler's owners.</p> <p> TYPE: <code>hikari.SnowflakeishOr[hikari.User]</code> </p>"},{"location":"reference/timeouts/","title":"yuyo.timeouts","text":"<p>Classes used for handling timing out components and reaction handlers.</p>"},{"location":"reference/timeouts/#yuyo.timeouts.AbstractTimeout","title":"AbstractTimeout","text":"<p>         Bases: <code>abc.ABC</code></p> <p>Abstract interface used to manage timing out a modals and components.</p>"},{"location":"reference/timeouts/#yuyo.timeouts.AbstractTimeout.has_expired","title":"has_expired  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>has_expired: bool\n</code></pre> <p>Whether this has timed-out.</p>"},{"location":"reference/timeouts/#yuyo.timeouts.AbstractTimeout.increment_uses","title":"increment_uses  <code>abstractmethod</code>","text":"<pre><code>increment_uses()\n</code></pre> <p>Add a use to this.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this has now timed-out.</p>"},{"location":"reference/timeouts/#yuyo.timeouts.BasicTimeout","title":"BasicTimeout","text":"<p>         Bases: <code>SlidingTimeout</code></p> <p>Deprecated alias of SlidingTimeout.</p>"},{"location":"reference/timeouts/#yuyo.timeouts.NeverTimeout","title":"NeverTimeout","text":"<p>         Bases: <code>AbstractTimeout</code></p> <p>Timeout implementation which never expires.</p>"},{"location":"reference/timeouts/#yuyo.timeouts.SlidingTimeout","title":"SlidingTimeout","text":"<p>         Bases: <code>AbstractTimeout</code></p> <p>Timeout strategy which resets every use.</p> <p>This implementation times out if <code>timeout</code> passes since the last call or when <code>max_uses</code> is reached.</p>"},{"location":"reference/timeouts/#yuyo.timeouts.SlidingTimeout.__init__","title":"__init__","text":"<pre><code>__init__(timeout, /, *, max_uses=1)\n</code></pre> <p>Initialise a sliding timeout.</p> PARAMETER DESCRIPTION <code>timeout</code> <p>How long this should wait between calls before timing-out.</p> <p> TYPE: <code>typing.Union[datetime.timedelta, int, float]</code> </p> <code>max_uses</code> <p>The maximum amount of uses this allows.</p> <p>Setting this to <code>-1</code> marks it as unlimited.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p>"},{"location":"reference/timeouts/#yuyo.timeouts.StaticTimeout","title":"StaticTimeout","text":"<p>         Bases: <code>AbstractTimeout</code></p> <p>Timeout at a specific time.</p> <p>This implementation times out when <code>timeout_at</code> is reached or when <code>max_uses</code> is reached.</p>"},{"location":"reference/timeouts/#yuyo.timeouts.StaticTimeout.__init__","title":"__init__","text":"<pre><code>__init__(timeout_at, /, *, max_uses=1)\n</code></pre> <p>Initialise a static timeout.</p> PARAMETER DESCRIPTION <code>timeout_at</code> <p>When this should time out.</p> <p> TYPE: <code>datetime.datetime</code> </p> <code>max_uses</code> <p>The maximum amount of uses this allows.</p> <p>Setting this to <code>-1</code> marks it as unlimited.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p>"},{"location":"reference/to_builder/","title":"yuyo.to_builder","text":"<p>Utility functions for converting Hikari data modals to builders.</p>"},{"location":"reference/to_builder/#yuyo.to_builder.to_button_builder","title":"to_button_builder","text":"<pre><code>to_button_builder(button)\n</code></pre> <p>Convert a button component to a builder.</p> PARAMETER DESCRIPTION <code>button</code> <p>The button component to convert to a builder.</p> <p> TYPE: <code>hikari.ButtonComponent</code> </p> RETURNS DESCRIPTION <code>hikari.api.LinkButtonBuilder | hikari.api.InteractiveButtonBuilder</code> <p>The buttion builder.</p>"},{"location":"reference/to_builder/#yuyo.to_builder.to_channel_select_menu_builder","title":"to_channel_select_menu_builder","text":"<pre><code>to_channel_select_menu_builder(select_menu)\n</code></pre> <p>Convert a channel select menu component to a builder.</p> PARAMETER DESCRIPTION <code>select_menu</code> <p>The select menu to convert to a builder.</p> <p> TYPE: <code>hikari.ChannelSelectMenuComponent</code> </p> RETURNS DESCRIPTION <code>hikari.api.ChannelSelectMenuBuilder</code> <p>The select menu builder.</p>"},{"location":"reference/to_builder/#yuyo.to_builder.to_cmd_builder","title":"to_cmd_builder","text":"<pre><code>to_cmd_builder(cmd)\n</code></pre> <p>Convert a partial command to a command builder.</p> PARAMETER DESCRIPTION <code>cmd</code> <p>The command to convert to a builder.</p> <p> TYPE: <code>hikari.PartialCommand</code> </p> RETURNS DESCRIPTION <code>hikari.api.CommandBuilder</code> <p>The command builder.</p> <p>This will always be a subclass.</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If an unsupported command type is passed.</p> <p>Currently hikari.commands.SlashCommand and hikari.commands.ContextMenuCommand are supported.</p>"},{"location":"reference/to_builder/#yuyo.to_builder.to_context_menu_builder","title":"to_context_menu_builder","text":"<pre><code>to_context_menu_builder(cmd)\n</code></pre> <p>Convert a context menu command to a builder.</p> PARAMETER DESCRIPTION <code>cmd</code> <p>The context menu command to convert to a builder.</p> <p> TYPE: <code>hikari.ContextMenuCommand</code> </p> RETURNS DESCRIPTION <code>hikari.api.ContextMenuCommandBuilder</code> <p>The context menu command builder.</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If an unsupported context menu type is passed.</p> <p>Currently hikari.commands.CommandType.MESSAGE and hikari.commands.CommandType.USER are supported.</p>"},{"location":"reference/to_builder/#yuyo.to_builder.to_msg_action_row_builder","title":"to_msg_action_row_builder","text":"<pre><code>to_msg_action_row_builder(action_row)\n</code></pre> <p>Convert a message action row component to a builder.</p> PARAMETER DESCRIPTION <code>action_row</code> <p>The message action row to convert to a builder.</p> <p> TYPE: <code>hikari.MessageActionRowComponent</code> </p> RETURNS DESCRIPTION <code>hikari.api.MessageActionRowBuilder</code> <p>The message action row builder.</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If the action row contains an unsupported component type.</p> <p>The following are currently supported:</p> <ul> <li>ACTION_ROW</li> <li>BUTTON</li> <li>TEXT_SELECT_MENU</li> <li>USER_SELECT_MENU</li> <li>ROLE_SELECT_MENU</li> <li>MENTIONABLE_SELECT_MENU</li> <li>CHANNEL_SELECT_MENU</li> </ul>"},{"location":"reference/to_builder/#yuyo.to_builder.to_select_menu_builder","title":"to_select_menu_builder","text":"<pre><code>to_select_menu_builder(select_menu)\n</code></pre> <p>Convert a select menu component to a builder.</p> PARAMETER DESCRIPTION <code>select_menu</code> <p>The select menu to convert to a builder.</p> <p> TYPE: <code>hikari.SelectMenuComponent</code> </p> RETURNS DESCRIPTION <code>hikari.api.SelectMenuBuilder</code> <p>The select menu builder.</p>"},{"location":"reference/to_builder/#yuyo.to_builder.to_slash_cmd_builder","title":"to_slash_cmd_builder","text":"<pre><code>to_slash_cmd_builder(cmd)\n</code></pre> <p>Convert a slash command to a builder.</p> PARAMETER DESCRIPTION <code>cmd</code> <p>The command to convert to a builder.</p> <p> TYPE: <code>hikari.SlashCommand</code> </p> RETURNS DESCRIPTION <code>hikari.api.SlashCommandBuilder</code> <p>The slash command builder.</p>"},{"location":"reference/to_builder/#yuyo.to_builder.to_text_select_menu_builder","title":"to_text_select_menu_builder","text":"<pre><code>to_text_select_menu_builder(select_menu)\n</code></pre> <p>Convert a text select menu component to a builder.</p> PARAMETER DESCRIPTION <code>select_menu</code> <p>The select menu to convert to a builder.</p> <p> TYPE: <code>hikari.TextSelectMenuComponent</code> </p> RETURNS DESCRIPTION <code>hikari.api.TextSelectMenuBuilder</code> <p>The select menu builder.</p>"},{"location":"usage/","title":"Usage guide","text":"<p>This usage guide goes into detail about how to use Yuyo with Hikari.</p> <p>A more general Hikari guide which includes some basic examples of how to use Yuyo for component and modal execution can be found here.</p>"},{"location":"usage/asgi/","title":"Asgi","text":"<p>The AsgiBot acts as an ASGI application which will handle the interaction requests received from Discord for slash commands, context menus, message components and modals as part of an ASGI server.</p> <pre><code>import os\n\nimport tanjun\n\nimport yuyo\n\nrest_bot = yuyo.asgi.AsgiBot(os.environ[\"TOKEN\"])\ntanjun.Client.from_rest_bot(rest_bot)\n\n# ... more setup\n</code></pre> <p>If the above example was saved in the file \"bot.py\" (within the current working directory) then the following may be run in the command line to run this bot using Uvicorn:</p> <pre><code>uvicorn bot:rest_bot\n</code></pre> <p>But since ASGI is a generic standard, you can also run this bot in other tooling such as using FastAPI's sub-applications to mount this bot within an existing FastAPI server on a specific route:</p> <pre><code>import fastapi\n\napp = fastapi.FastAPI()\n\napp.mount(\"/bot\", rest_bot)\n</code></pre>"},{"location":"usage/builders/","title":"Builders","text":"<p>Yuyo provides several methods for converting Hikari data objects to writeable builder objects.</p>"},{"location":"usage/builders/#commands","title":"Commands","text":"<pre><code>builder = yuyo.to_builder.to_cmd_builder(cmd)\n</code></pre> <p>to_cmd_builder converts a hikari.PartialCommand object to the relevant builder object.</p> <p>to_slash_cmd_builder and to_context_menu_builder can be used to convert command objects where the command type is already known without losing this information typing wise.</p>"},{"location":"usage/builders/#message-components","title":"Message components","text":"<pre><code>builder = yuyo.to_builder.to_msg_action_row_builder(row)\n</code></pre> <p>to_msg_action_row_builder converts a hikari.MessageActionRowComponent object to a hikari.api.MessageActionRowBuilder object.</p> <p>There's several other methods which can be used to convert the sub-component objects found in message action rows to builder objects:</p> <ul> <li>to_select_menu_builder</li> <li>to_channel_select_menu_builder</li> <li>to_text_select_menu_builder</li> <li>to_button_builder</li> </ul>"},{"location":"usage/chunk_tracker/","title":"Chunk Tracker","text":"<p>The chunk tracker in yuyo.chunk_tracker dispatches custom chunk request tracking events. This can be a useful way to work out when the cache will be reliable for a guild or globally (when combined with checking the intent and cache config).</p> <pre><code>yuyo.chunk_tracker.ChunkTracker.from_gateway_bot(bot)\n</code></pre> <p>While this is easy to setup, there are some things you need to account for. This will only track chunk requests (including startup chunk requests) as long if have a set nonce (luckily Hikari's startup requests include nonces). ChunkTracker.request_guild_members ensures that a nonce is always set.</p> <p>The chunk tracker can be configured to automatically send chunk requests (with nonces) on guild join itself using ChunkTracker.set_auto_chunk_members. This can be useful if you need auto chunking in scenarios where it otherwise would be disabled (e.g. when using a separate async cache instead of Hikari's builtin cache).</p>"},{"location":"usage/chunk_tracker/#events","title":"Events","text":""},{"location":"usage/chunk_tracker/#chunk-request-finished-event","title":"Chunk Request Finished Event","text":"<p>ChunkRequestFinishedEvent is dispatched when a specific chunk request has finished.</p> <pre><code>@bot.listen()\nasync def on_chunk_request_finished(event: yuyo.chunk_tracker.ChunkRequestFinishedEvent) -&gt; None:\n    event.app\n    event.shard  # type: hikari.api.GatewayShard\n    event.chunk_count  # type: int\n    event.first_received_at  # type: datetime.datetime\n    event.guild_id  # type: hikari.Snowflake\n    event.last_received_at  # type: datetime.datetime\n    event.missed_chunks  # type: collections.abc.Collection[int]\n    event.not_found_ids  # type: collections.abc.Collection[hikari.Snowflake]\n</code></pre> <p>This is only dispatch for chunk requests where a <code>nonce</code> has been set.</p>"},{"location":"usage/chunk_tracker/#finished-chunking-event","title":"Finished Chunking Event","text":"<p>FinishedChunkingEvent is dispatched when the startup chunking has finished for the bot to indicate that the member and presence caches should be complete (if enabled).</p> <pre><code>@bot.listen()\nasync def on_finished_chunking(event: yuyo.chunk_tracker.FinishedChunkingEvent) -&gt; None:\n    event.app\n</code></pre> <p>This is only dispatched once per-bot lifetime.</p>"},{"location":"usage/chunk_tracker/#shard-finished-chunking-event","title":"Shard Finished Chunking Event","text":"<p>ShardFinishedChunkingEvent is dispatched when the startup chunking has finished for a specific shard to indicate that the member and presence caches should be complete for the guilds covered by this shard.</p> <pre><code>@bot.listen()\nasync def on_shard_finished_chunking(event: yuyo.chunk_tracker.ShardFinishedChunkingEvent) -&gt; None:\n    event.app\n    event.shard  # type: hikari.api.GatewayShard\n    event.incomplete_guild_ids  # collections.abc.Sequence[hikari.Snowflake]\n    event.missed_guild_ids  # collections.abc.Sequence[hikari.Snowflake]\n</code></pre>"},{"location":"usage/components/","title":"Message Components","text":""},{"location":"usage/links/","title":"Links","text":"<p>Yuyo provides some utilities for handling Discord links in yuyo.links.</p>"},{"location":"usage/links/#baselink","title":"BaseLink","text":"<p>All BaseLink implementations come with 3 classmethods for parsing them from strings.</p> <p>All of these methods take a Hikari \"app\" (Bot or REST app object) as their first argument.</p> <pre><code>link = links.TemplateLink.from_link(app, \"https://discord.new/aaaaaaaaaa\")\n</code></pre> <p>BaseLink.from_link lets you parse a raw link string. This is strict about validation and will raise a ValueError if the full passed string isn't a match for the expected link structure.</p> <pre><code>if link := links.InviteLink.find(app, \"meow you can nyaa us at discord.gg/nekosmeowers\"):\n    ...\n</code></pre> <p>BaseLink.find lets you extract the first link in a string. This will search for a link at any point in the string and returns the parsed link object or None if no link was found.</p> <pre><code>for link in links.MessageLink.find_iter(app, \"message content\"):\n    ...\n</code></pre> <p>BaseLink.find_iter lets you iterate over the matching links in a string by iterating over link objects which were parsed from the string.</p>"},{"location":"usage/links/#baselink-implementations","title":"BaseLink implementations","text":"<p>There are 5 implementations of BaseLink provided by Yuyo (which all support the parsing methods listed above):</p>"},{"location":"usage/links/#channel-links","title":"Channel links","text":"<pre><code>link = links.ChannelLink.from_link(app, \"https://discord.com/channels/453123/67765564\")\n\nlink.is_dm_link  # value: False\nlink.guild_id  # value: 453123\nlink.channel_id  # value: 67765564\nawait link.fetch_channel()  # hikari.PartialChannel\nlink.get_channel()  # hikari.GuildChannel | None\nawait link.fetch_guild()  # hikari.RESTGuild | None\nlink.get_guild()  # hikari.GatewayGuild | None\nstr(link)  # value: \"https://discord.com/channels/453123/67765564\"\n</code></pre> <p>ChannelLink handles parsing channel links.</p> <p>ChannelLink.guild_id will be None for DM channels.</p> <pre><code>link = links.make_channel_link(123312, guild=6534234)\nlink  # value: \"https://discord.com/channels/6534234/123312\"\nlink = links.make_channel_link(543123)\nlink  # value: \"https://discord.com/channels/@me/543123\"\n</code></pre> <p>links.make_channel_link offers an alternative way to make a channel link string which doesn't require having a Bot or REST app in scope.</p>"},{"location":"usage/links/#invite-links","title":"Invite links","text":"<pre><code>link = links.InviteLink.from_link(app, \"https://discord.gg/nekosmeowers\")\n\nlink.code  # value: \"nekosmeowers\"\nawait link.fetch_invite()  # type: hikari.Invite\nlink.get_invite()  # type: hikari.InviteWithMetadata | None\nstr(link)  # value: \"https://discord.gg/nekosmeowers\"\n</code></pre> <p>InviteLink handles parsing invite links.</p> <pre><code>link = links.make_invite_link(\"codecode\")\nlink  # value: \"https://discord.gg/codecode\"\n</code></pre> <p>links.make_invite_link offers an alternative way to make an invite link string which doesn't require having a Bot or REST app in scope.</p>"},{"location":"usage/links/#message-links","title":"Message links","text":"<pre><code>link = links.MessageLink.from_link(app, \"https://discord.com/channels/54123123321123/2134432234342/56445234124\")\n\nlink.is_dm_link  # value: False\nlink.guild_id  # value: 54123123321123\nlink.channel_id  # value: 2134432234342\nlink.message_id  # value: 56445234124\nawait link.fetch_message()  # type: hikari.Message\nlink.get_message()  # type: hikari.Message | None\nawait link.fetch_channel()  # hikari.PartialChannel\nlink.get_channel()  # hikari.GuildChannel | None\nawait link.fetch_guild()  # hikari.RESTGuild | None\nlink.get_guild()  # hikari.GatewayGuild | None\nstr(link)  # value: \"https://discord.com/channels/54123123321123/2134432234342/56445234124\"\n</code></pre> <p>MessageLink handles parsing message links.</p> <p>MessageLink.guild_id will be None for DM messages.</p> <pre><code>#                             (channel_id, message_id)\nlink = links.make_message_link(654323412, 4534512332, guild=123321)\nlink  # value: \"https://discord.com/channels/123321/654323412/4534512332\"\nlink = links.make_message_link(333333333, 5555555555)\nlink  # value: \"https://discord.com/channels/@me/333333333/5555555555\"\n</code></pre> <p>links.make_message_link offers an alternative way to make a message link string which doesn't require having a Bot or REST app in scope.</p>"},{"location":"usage/links/#guild-template-links","title":"Guild template links","text":"<pre><code>link = links.TemplateLink.from_link(app, \"https://discord.new/aaaaaaaaaa\")\n\nlink.code  # value: \"aaaaaaaaaa\"\nawait link.fetch_template()  # type: hikari.Template\nstr(link)  # value: \"https://discord.new/aaaaaaaaaa\"\n</code></pre> <p>TemplateLink handles parsing guild template links.</p> <pre><code>raw_link = links.make_template_link(\"cododododoe\")\nraw_link  # value: \"https://discord.new/aaaaaaaaaa\"\n</code></pre> <p>links.make_template_link offers an alternative way to make a template link string which doesn't require having a Bot or REST app in scope.</p>"},{"location":"usage/links/#webhook-links","title":"Webhook links","text":"<pre><code>link = links.WebhookLink.from_link(app, \"https://discord.com/api/webhooks/123321123/efsdfasdsa\")\n\nlink.webhook_id  # value: 123321123\nlink.token  # value: \"efsdfasdsa\"\nawait link.fetch_webhook()  # type: hikari.IncomingWebhook\nstr(link)  # value: \"https://discord.com/api/webhooks/123321123/efsdfasdsa\"\n</code></pre> <p>WebhookLink handles parsing webhook links.</p> <p>This class inherits from hikari.ExecutableWebhook and therefore has all the webhook execute methods you'll find on interaction and webhook objects.</p> <pre><code>raw_link = links.make_webhook_link(123321, \"hfdssdasd\")\nraw_link  # value: \"https://discord.com/api/webhooks/123321123/efsdfasdsa\"\n</code></pre> <p>links.make_webhook_link offers an alternative way to make a webhook link string which doesn't require having a Bot or REST app in scope.</p>"},{"location":"usage/list_status/","title":"List Status","text":"<p>yuyo.list_status provides an easy way to update a Bot's stats on bot lists.</p> <p>By default this will track the count per-shard, meaning that this'll have to be running on each shard cluster instance to properly keep track of the count. This will also be relying on the GUILDS intent being declared unless a custom counting strategy is passed.</p>"},{"location":"usage/list_status/#usage","title":"Usage","text":"<pre><code>manager = list_status.ServiceManager.from_gateway_bot(bot)\nmanager.add_service(list_status.TopGGService(\"TOKEN\"))\n</code></pre> <p>TopGGService is used to set https://top.gg as one of the targets for updating the bot's guild count.</p> <p>Top.GG API tokens are found in the \"webhooks\" tab while editing the bot's entry.</p> <pre><code>manager = list_status.ServiceManager.from_gateway_bot(bot)\nmanager.add_service(list_status.DiscordBotListService(\"TOKEN\"))\n</code></pre> <p>DiscordBotListService is used to set https://discordbotlist.com as one of the targets for updating the bot's guild count.</p> <pre><code>manager = list_status.ServiceManager.from_gateway_bot(bot)\nmanager.add_service(list_status.BotsGGService(\"TOKEN\"))\n</code></pre> <p>BotsGGService is used to set https://discord.bots.gg as one of the targets for updating the bot's guild count.</p> <p>Bots.gg API tokens are found at https://discord.bots.gg/docs (when logged in).</p>"},{"location":"usage/list_status/#custom-service","title":"Custom service","text":"<pre><code>manager = list_status.ServiceManager.from_gateway_bot(bot)\n\n@manager.with_service()\nasync def service(client: list_status.AbstractManager, /) -&gt; None:\n    count = await client.counter.count()\n\n    if isinstance(count, int):\n        ...  # This is a global count of how many guilds the bot is in.\n\n    else:\n        # This is a mapping of shard IDs to guild counts.\n        count  # type: collections.abc.Mapping[int, int]\n</code></pre> <p>Services are simply asynchronous callbacks which call <code>AbstractManager.counter.count</code> to get the most recent count(s) then pass it on.</p> <p><code>AbstractManager.counter.count</code> may raise CountUnknownError to indicate an unknown state and will return either int to indicate a global guild count or <code>Mapping[int, int]</code> to give per-shard guild counts.</p>"},{"location":"usage/list_status/#counting-strategies","title":"Counting Strategies","text":""},{"location":"usage/list_status/#sake-counting","title":"Sake counting","text":"<pre><code>cache  # type: sake.abc.GuildCache\ncounter = list_status.SakeStrategy(cache)\nmanager = list_status.ServiceManager.from_gateway_bot(bot, strategy=counter)\n</code></pre> <p>The Sake strategy lets this be used with an asynchronous Redis guild cache. This strategy will only be keeping track of a global guild count (rather than per-shard like the default counters) and therefore you should only ever need to have one instance of this running with Sake.</p>"},{"location":"usage/modals/","title":"Modals","text":""}]}