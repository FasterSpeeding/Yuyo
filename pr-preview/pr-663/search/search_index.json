{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Yuyo","text":"<p>A collection of utility classes and functions designed to expand Hikari.</p>"},{"location":"#instillation","title":"Instillation","text":"<p>You can install yuyo from PyPI using the following command.</p> <pre><code>python -m pip install -U hikari-yuyo\n</code></pre> <p>The following feature flags ensure feature-specific optional dependencies are also installed:</p> <ul> <li><code>hikari-yuyo[asgi]</code> ensures the dependencies required to run the Asgi RESTBot adapter.</li> <li><code>hikari-yuyo[cli]</code> ensures the dependencies required to use the provided CLI commands are   installed.</li> <li><code>hikari-yuyo[sake]</code> can be used to ensure the installed Sake version is compatible with   Yuyo's functionality which uses Sake. You should still have a Sake version pinned in your   own requirements as this just provides an accepted range for the dependency.</li> <li><code>hikari-yuyo[tanjun]</code> can be used to ensure the installed Tanjun version is compatible with   Yuyo's Tanjun support (i.e. the <code>from_tanjun</code>) class methods.</li> </ul>"},{"location":"#quick-usage","title":"Quick Usage.","text":"<p>For usage see the the documentation and, more specifically, the usage guide.</p>"},{"location":"#support","title":"Support","text":"<p>Hikari's support guild provides for support for Yuyo.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Before contributing you should read through the contributing guidelines and the code of conduct.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Bumped the minimum Alluka version to v0.4.0</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Moved away from using <code>typing.runtime_checkable</code> as this is unreliable in   newer Python versions.</li> <li>List status' successfully post logging call.</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>Support for Python 3.9 and 3.10.</li> </ul>"},{"location":"changelog/#1231-2024-10-07","title":"1.23.1 - 2024-10-07","text":""},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Support Python 3.13</li> </ul>"},{"location":"changelog/#1230-2024-07-14","title":"1.23.0 - 2024-07-14","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>BaseContext.alluka property for getting the   context's alluka client.</li> </ul>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>pagination.ResponseKwargs is now publicly exported to   allow 3rd party implementations of   AbstractPage.ctx_to_kwargs   and AbstractPage.to_kwargs to have properly   typed return types.</li> <li>pagination.ResponseKwargs's fields are now all marked   as not required.</li> </ul>"},{"location":"changelog/#1220-2024-07-11","title":"1.22.0 - 2024-07-11","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Support for component pagination based on global (\"static\") bot data.   More information on this can be found here.</li> </ul>"},{"location":"changelog/#deprecated","title":"Deprecated","text":"<ul> <li><code>yuyo.components.BaseContext</code> as this has been moved to   yuyo.interactions.BaseContext.</li> </ul>"},{"location":"changelog/#1211-2024-04-29","title":"1.21.1 - 2024-04-29","text":""},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>Bumped the minimum Alluka version to <code>v0.2.0</code>.</li> <li>The component, modal and reaction clients will now use the \"local\" Alluka client   returned by alluka.local.get if no client is passed and a local Alluka client is set.</li> </ul>"},{"location":"changelog/#1210-2024-04-21","title":"1.21.0 - 2024-04-21","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Component StreamExecutor for streaming over received   component contexts.</li> <li>Support for specifying specific component IDs for   WaitForExecutor.</li> </ul>"},{"location":"changelog/#1200-2024-03-29","title":"1.20.0 - 2024-03-29","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li><code>yuyo commands declare</code> command for declaring app commands based on a schema file.</li> <li><code>yuyo commands fetch</code> command for fetching the command schema file for an existing bot.</li> <li><code>yuyo commands rename</code> command for renaming the declared app commands.</li> </ul>"},{"location":"changelog/#1191-2023-12-28","title":"1.19.1 - 2023-12-28","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Support for Python 3.12.</li> </ul>"},{"location":"changelog/#1190-2023-08-30","title":"1.19.0 - 2023-08-30","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>ComponentClient.get_executor   method for getting the executor registered globally for a specific custom ID.</li> </ul>"},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>The ephemeral default is now ignored for message update create initial   response and defer calls. (This likely won't effect real world behaviour).</li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Explicitly passing <code>ephemeral=False</code> to   create_initial_response or   create_followup will now correctly   override the client-level ephemeral default.</li> <li>The component paginator will no-longer error out with a \"Initial response has   already been created\" error when the jump to last page button tries to push   the internal generator forwards only to find out it's depleted.</li> </ul>"},{"location":"changelog/#1180-2023-08-23","title":"1.18.0 - 2023-08-23","text":""},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li>yuyo.components.builder (a class descriptor),   ActionColumnExecutor.add_builder, and   ActionColumnExecutor.add_static_builder   functions and methods for adding raw component builders to a column without an   associated callback.</li> </ul>"},{"location":"changelog/#changed_5","title":"Changed","text":"<ul> <li>yuyo.pagination.Page is now exported top-level at <code>Yuyo.Page</code>.</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Properly track method names for callbacks registered using   as_interactive_button.   This allows the custom ID metadata to be overridden by passing   <code>id_metadata={\"function_name\": \"METADATA\"}</code> to   ActionColumnExecutor.__init__.</li> </ul>"},{"location":"changelog/#1170-2023-08-18","title":"1.17.0 - 2023-08-18","text":""},{"location":"changelog/#added_7","title":"Added","text":"<ul> <li>Wait for implementation for modals.</li> </ul>"},{"location":"changelog/#changed_6","title":"Changed","text":"<ul> <li>Page.__init__'s signature now more closely   Hikari's message create methods: with new <code>attachment</code> and <code>embed</code> keyword   arguments for passing singular values while also now allowing an embed or file   to be passed as <code>content</code>.</li> </ul>"},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>Timed out individual requests will no-longer lead to the chunk tracker crashing.</li> </ul>"},{"location":"changelog/#1160-2023-08-11","title":"1.16.0 - 2023-08-11","text":""},{"location":"changelog/#added_8","title":"Added","text":"<ul> <li>yuyo.InteractionError error type which can be used to end   modal and component interactions with a message.</li> </ul>"},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li>ComponentClient.from_tanjun and   ModalClient.from_tanjun both now correctly pass through   the relevant hikari bot components.</li> </ul>"},{"location":"changelog/#1150-2023-08-10","title":"1.15.0 - 2023-08-10","text":""},{"location":"changelog/#added_9","title":"Added","text":"<ul> <li>Support customising the <code>response_type</code> when deferring and creating the initial   response to a modal call.</li> <li><code>.cache</code>, <code>.events</code>, <code>.rest</code>, <code>.server</code>, <code>.shards</code> and <code>.voice</code> attributes to   yuyo.ComponentClient,   yuyo.ComponentContext,   yuyo.ModalClient, and   yuyo.ModalContext which represent parts of the linked   Hikari bot in a similar style to tanjun.</li> <li>The following utility attributes to yuyo.ComponentContext   and yuyo.ModalContext which mostly relay attributes from the inner   interaction: <code>.author</code>, <code>.channel_id</code>, <code>.created_at</code>, <code>.guild_id</code>, <code>.member</code>, <code>.shard</code>.</li> </ul>"},{"location":"changelog/#1142-2023-05-08","title":"1.14.2 - 2023-05-08","text":""},{"location":"changelog/#fixed_5","title":"Fixed","text":"<ul> <li>The fields for a ModalOptions are now correctly   tracked when added to a Modal instance and are   no-longer erroneously tracked as static fields for <code>type(modal)</code>.</li> </ul>"},{"location":"changelog/#1141-2023-05-03","title":"1.14.1 - 2023-05-03","text":""},{"location":"changelog/#changed_7","title":"Changed","text":"<ul> <li>ComponentClient.register_executor   now raises a <code>ValueError</code> if any of the custom IDs or the message ID is   already registered to better match <code>register_modal</code>.</li> <li>ComponentClient.deregister_executor   now raises a <code>KeyError</code> if the component isn't registered to better match the   other deregister methods.</li> </ul>"},{"location":"changelog/#removed_1","title":"Removed","text":"<ul> <li>Erroneous <code>prefix_match</code> parameter from yuyo.modals.with_text_input which   should've been removed in <code>v1.14.0</code></li> </ul>"},{"location":"changelog/#1140-2023-05-03","title":"1.14.0 - 2023-05-03","text":""},{"location":"changelog/#added_10","title":"Added","text":"<ul> <li><code>authors</code> option to   components.ActionColumnExecutor.__init__.</li> <li>Functions for generating Discord Oauth2 authorize links and bot invite links   to yuyo.links.</li> <li>ActionColumnExecutor.with_interactive_button.</li> <li>ActionColumnExecutor.with_static_interactive_button.</li> <li>ActionColumnExecutor.with_mentionable_menu.</li> <li>ActionColumnExecutor.with_static_mentionable_menu.</li> <li>ActionColumnExecutor.with_role_menu.</li> <li>ActionColumnExecutor.with_static_role_menu.</li> <li>ActionColumnExecutor.with_user_menu.</li> <li>ActionColumnExecutor.with_static_user_menu.</li> <li>ActionColumnExecutor.with_channel_menu.</li> <li>ActionColumnExecutor.with_text_menu.</li> <li>ActionColumnExecutor.with_static_text_menu.</li> <li>yuyo.components.column_template shorthand function for creating a column subclass.</li> </ul>"},{"location":"changelog/#changed_8","title":"Changed","text":"<ul> <li>Message component custom IDs are now defaulted to a constant ID that's generated   from the function's path (which includes the relevant module and class   qualnames) when added using the <code>as_</code> descriptors in yuyo.components.</li> <li>The <code>id_metadata</code> field in   components.ActionColumnExecutor.__init__   now also supports using a component callback's name in the class' namespace   as the key (specifically when it was added using one of the <code>as_</code>   descriptors).</li> <li>The auto-generated default UUID custom IDs now only consist of the UUID's hex   (without any <code>-</code>), bringing the length down from 36 chars to 32.</li> <li>The descriptors returned by the <code>as_</code> decorators in yuyo.components are   now hidden when accessed directly on classes. The decorated callback will now   be directly exposed as the class attribute instead.</li> </ul>"},{"location":"changelog/#fixed_6","title":"Fixed","text":"<ul> <li>ActionColumnExecutor and   Modal both now properly relay   <code>__init_subclass__</code> keyword arguments when being used in mixed inheritance.</li> </ul>"},{"location":"changelog/#removed_2","title":"Removed","text":"<ul> <li><code>yuyo.components.with_static_interactive_button</code></li> <li><code>yuyo.components.with_static_link_button</code></li> <li><code>yuyo.components.with_static_select_menu</code></li> <li><code>yuyo.components.with_static_channel_menu</code></li> <li><code>yuyo.components.with_static_text_menu</code></li> <li>The following deprecated functionality and aliases:<ul> <li><code>ActionRowExecutor</code> in favour of the new action column executor.</li> <li>Allowing callback to be passed as the first argument and type as the second argument for ActionColumnExecutor.add_select_menu, and ActionColumnExecutor.add_static_select_menu.</li> <li><code>timeout</code> keyword argument from ComponentExecutor.__init__, ActionColumnExecutor.__init__, and ComponentPaginator.__init__.</li> <li><code>prefix_match</code> keyword argument from Modal.add_static_text_input, Modal.add_text_input, modals.with_static_text_input, modals.with_text_input, and modals.text_input.</li> <li><code>ComponentContext.select_channels</code></li> <li><code>ComponentContext.select_roles</code></li> <li><code>ComponentContext.select_texts</code></li> <li><code>ComponentContext.select_users</code></li> <li><code>ComponentContext.select_members</code></li> <li><code>ComponentClient.set_constant_id</code></li> <li><code>ComponentClient.get_constant_id</code></li> <li><code>ComponentClient.remove_constant_id</code></li> <li><code>ComponentClient.with_constant_id</code></li> <li><code>ComponentClient.set_executor</code></li> <li><code>ComponentClient.get_executor</code></li> <li><code>ComponentClient.remove_executor</code></li> <li><code>AbstractComponentExecutor.has_expired</code></li> <li><code>AbstractComponentExecutor.timeout</code></li> <li><code>ComponentExecutor.has_expired</code></li> <li><code>ComponentExecutor.timeout</code></li> <li><code>ActionColumnExecutor.timeout</code></li> <li><code>ActionColumnExecutor.has_expired</code></li> <li><code>ActionColumnExecutor.add_button</code></li> <li><code>ActionColumnExecutor.add_interative_button</code></li> <li><code>ActionColumnExecutor.add_static_button</code></li> <li><code>ActionColumnExecutor.add_static_interative_button</code></li> <li><code>ActionColumnExecutor.with_static_button</code></li> <li><code>ActionColumnExecutor.with_static_interative_button</code></li> <li><code>ActionColumnExecutor.with_static_select_menu</code></li> <li><code>ActionColumnExecutor.add_channel_select</code></li> <li><code>ActionColumnExecutor.add_static_channel_select</code></li> <li><code>ActionColumnExecutor.with_static_channel_select</code></li> <li><code>ActionColumnExecutor.add_text_select</code></li> <li><code>ActionColumnExecutor.add_static_text_select</code></li> <li><code>ComponentPaginator.builder</code></li> <li><code>ComponentPaginator.add_row</code></li> <li><code>components.with_static_button</code></li> <li><code>components.with_static_interative_button</code></li> <li><code>components.with_static_channel_select</code></li> <li><code>InviteLink.fetch</code></li> <li><code>InviteLink.get</code></li> <li><code>MessageLink.fetch</code></li> <li><code>MessageLink.get</code></li> <li><code>TemplateLink.fetch</code></li> <li><code>WebhookLink.fetch</code></li> <li><code>modals.AbstractTimeout</code></li> <li><code>modals.BasicTimeout</code></li> <li><code>modals.NeverTimeout</code></li> <li><code>ModalClient.set_modal</code></li> <li><code>ModalClient.remove_modal</code></li> <li><code>timeouts.BasicTimeout</code></li> <li><code>yuyo.BasicTimeout</code></li> </ul> </li> </ul>"},{"location":"changelog/#1130a1-2023-04-25","title":"1.13.0a1 - 2023-04-25","text":""},{"location":"changelog/#added_11","title":"Added","text":"<ul> <li>components.Paginator alias of   components.ComponentPaginator.</li> <li>reactions.Handler alias of   reactions.ReactionHandler.</li> <li>reactions.Paginator alias of   reactions.ReactionPaginator.</li> </ul>"},{"location":"changelog/#changed_9","title":"Changed","text":"<ul> <li>ComponentPaginator now implements   ActionColumnExecutor rather than   <code>ActionRowExecutor</code>.   The main (breaking) consequence of this change is that you now need to pass   <code>pagintor.rows</code> to <code>components</code> rather than passing the paginator itself to   <code>component</code>.</li> <li>Moved out the paginator logic used by yuyo.components.ComponentPaginator   and yuyo.reactions.ReactionPaginator to the new   yuyo.pagination.Paginator class.</li> </ul>"},{"location":"changelog/#deprecated_1","title":"Deprecated","text":"<ul> <li><code>yuyo.components.ActionRowExecutor</code> in favour of the action column executor.</li> <li><code>ActionColumnExecutor.add_row</code>.</li> </ul>"},{"location":"changelog/#fixed_7","title":"Fixed","text":"<ul> <li>reactions.Client now correctly points towards   reactions.ReactionClient.</li> <li>Some edge cases where the paginators were sending the current page in response   to a reaction/interaction instead of giving a noop response or just not   responding.</li> </ul>"},{"location":"changelog/#removed_3","title":"Removed","text":"<ul> <li><code>timeout</code> argument from ComponentPaginator.__init__.</li> <li><code>\"WaitFor\"</code> from <code>yuyo.components.__all__</code>.</li> </ul>"},{"location":"changelog/#1120a1-2023-04-24","title":"1.12.0a1 - 2023-04-24","text":""},{"location":"changelog/#added_12","title":"Added","text":"<ul> <li><code>ephemeral_default</code> option to ActionColumnExecutor.__init__.</li> <li>Shorthand methods and functions for adding/declaring mentionable, role and user menus:<ul> <li>components.as_mentionable_menu</li> <li>components.as_role_menu</li> <li>components.as_user_menu</li> <li>ActionColumnExecutor.add_mentionable_menu</li> <li>ActionColumnExecutor.add_static_mentionable_menu</li> <li>ActionColumnExecutor.add_role_menu</li> <li>ActionColumnExecutor.add_static_role_menu</li> <li>ActionColumnExecutor.add_user_menu</li> <li>ActionColumnExecutor.add_static_user_menu</li> <li><code>ActionRowExecutor.add_mentionable_menu</code></li> <li><code>ActionRowExecutor.add_role_menu</code></li> <li><code>ActionRowExecutor.add_user_menu</code></li> </ul> </li> </ul>"},{"location":"changelog/#changed_10","title":"Changed","text":"<ul> <li>ActionColumnExecutor now allows overriding   inherited component class descriptors.</li> <li>The <code>add_static</code> methods on ActionColumnExecutor   now override any previously added sub-component with the same match ID rather than   append a duplicate entry.</li> </ul>"},{"location":"changelog/#fixed_8","title":"Fixed","text":"<ul> <li>ActionColumnExecutor now respects the order   component descriptors were defined in on the class.</li> </ul>"},{"location":"changelog/#1112a1-2023-04-10","title":"1.11.2a1 - 2023-04-10","text":""},{"location":"changelog/#added_13","title":"Added","text":"<ul> <li>Support for parsing message links to yuyo.links.</li> </ul>"},{"location":"changelog/#changed_11","title":"Changed","text":"<ul> <li>Added support for <code>ptb.</code> and <code>canary.</code> links to yuyo.links.</li> <li>Modals now default the per-field custom IDs (i.e. for text components) to the parameter's   name (attribute name for ModalOptions fields), if set.</li> <li>Renamed the link get and fetch methods:<ul> <li><code>InviteLink.fetch</code> to InviteLink.fetch_invite</li> <li><code>InviteLink.get</code> to InviteLink.get_invite</li> <li><code>MessageLink.fetch</code> to MessageLink.fetch_message</li> <li><code>MessageLink.get</code> to MessageLink.get_message</li> <li><code>TemplateLink.fetch</code> to TemplateLink.fetch_template</li> <li><code>WebhookLink.fetch</code> to WebhookLink.fetch_webhook</li> </ul> </li> </ul>"},{"location":"changelog/#fixed_9","title":"Fixed","text":"<ul> <li>ModalOptions attributes now correctly expose the values passed to   the modal rather than internal descriptors.</li> <li>ChunkTracker.set_auto_chunk_members   now correctly disables auto chunking when False is passed after it has been previously   enabled. This now also always changes the configuration for <code>chunk_presences</code>.</li> <li>Some typoed function names which were missing the \"c\" in \"interactive\".</li> <li>AsgiBot.start and AsgiBot.close   will now call the startup and shutdown callbacks respectively when <code>asgi_managed=False</code>.</li> </ul>"},{"location":"changelog/#1111a1-2023-04-05","title":"1.11.1a1 - 2023-04-05","text":""},{"location":"changelog/#changed_12","title":"Changed","text":"<ul> <li><code>callback</code> and <code>type</code> have been flipped (making <code>type</code> the first argument and <code>callback</code>    the second one) for the following functions:<ul> <li><code>ActionRowExecutor.add_select_menu</code></li> <li>ActionColumnExecutor.add_select_menu</li> <li>ActionColumnExecutor.add_static_select_menu</li> <li><code>with_static_select_menu</code></li> </ul> </li> <li>Renamed the component context select menu data properties:<ul> <li><code>ComponentContext.select_channels</code> to ComponentContext.selected_channels</li> <li><code>ComponentContext.select_roles</code> to ComponentContext.selected_roles</li> <li><code>ComponentContext.select_texts</code> to ComponentContext.selected_texts</li> <li><code>ComponentContext.select_users</code> to ComponentContext.selected_users</li> <li><code>ComponentContext.select_members</code> to ComponentContext.selected_members</li> </ul> </li> </ul>"},{"location":"changelog/#deprecated_2","title":"Deprecated","text":"<ul> <li>Passing <code>callback</code> as the first argument when adding a select menu to a component executor or column.</li> <li>The <code>with_{}</code> methods on yuyo.components.ActionColumnExecutor.</li> </ul>"},{"location":"changelog/#fixed_10","title":"Fixed","text":"<ul> <li>yuyo.modals.modal and yuyo.modals.as_modal both now properly support DI for the   modal's callback.</li> <li>yuyo.modals.as_modal and yuyo.modals.as_modal_template both now allow passing   <code>parse_signature</code> typing wise.</li> <li>ComponentClient.register_executor   now defaults to unlimited uses instead of 1 use.</li> </ul>"},{"location":"changelog/#1110a1-2023-04-02","title":"1.11.0a1 - 2023-04-02","text":""},{"location":"changelog/#added_14","title":"Added","text":"<ul> <li>A static timeout implementation.</li> <li>Support for custom ID prefix matching to the Message component executors.</li> <li>Message components have support for loading components from class attributes again.   Support for this has been implemented through yuyo.components.ActionColumnExecutor this time.</li> <li>yuyo.components.SingleExecutor and yuyo.components.as_single_executor   to allow registering a component executor with a single callback.</li> <li>New component handling system to the component client which allows component executors to be   used statelessly. This moves to using the classes in yuyo.timeouts to handle timeouts   (rather than the component executors) and makes binding to a specific message optional.   This consists of ComponentClient.register_executor   and ComponentClient.deregister_executor.</li> <li><code>yuyo.components.with_static_text_menu</code> decorator for declaring a static text select menu on   a ActionColumnExecutor subclass.</li> <li><code>options</code> parameter to <code>ActionColumnExecutor.add_static_text_select</code>,   <code>ActionColumnExecutor.add_text_select</code>, and <code>ActionRowExecutor.add_text_select</code> for passing   option builders.</li> <li><code>ComponentContext.id_match</code> and <code>ModalContext.id_metadata</code> convenient properties for getting   the matching and metadata parts of the component's custom ID.</li> <li><code>Modal.id_match</code>, <code>Modal.id_metadata</code> and ModalContext.component_ids   convenience properties for getting the matching and metadata parts of the Modal's top-level   custom ID and the sub-component custom IDs.</li> <li>ComponentExecutor.set_callback and   ComponentExecutor.with_callback now   both raise ValueError if <code>\":\"</code> is present in <code>custom_id</code>.</li> <li><code>id_metadata</code> option to   ActionColumnExecutor.__init__ and   Modal.__init__ to allow for setting the   ID metadata of components per-init.</li> </ul>"},{"location":"changelog/#changed_13","title":"Changed","text":"<ul> <li>Bumped the minimum Hikari version to <code>2.0.0.dev118</code>.   Some of the breaking component changes listed in Hikari's   change log   around the component builders effect Yuyo's component executors.</li> <li>Prefix matching behaviour is now always enabled for both modals and components.</li> <li>Message components now split by <code>\":\"</code> for prefix matching like the modals client.</li> <li>Marked most deprecated timeout class aliases using <code>typing.deprecated</code>.   (only <code>yuyo.modals.AbstractTimeout</code> was skipped).</li> <li>yuyo.components.WaitForExecutor now inherits from yuyo.components.WaitForExecutor   and should also be passed to <code>timeout=</code>.</li> <li>ActionColumnExecutor.rows now returns   hikari.api.MessageActionRowBuilder.</li> <li>Message components will now give a \"timed-out\" ephemeral initial response when   ExecutorClosed is raised without any response.</li> <li>The <code>authors</code> field is now optional (defaulting to public) for   WaitForExecutor.__init__,   ComponentPaginator.__init__, and   ReactionPaginator.__init__.</li> <li>Renamed <code>yuyo.timeouts.BasicTimeout</code> to yuyo.timeouts.SlidingTimeout.</li> <li>Renamed <code>ModalClient.set_modal</code> to Modal.register_modal.</li> <li>Renamed <code>ModalClient.remove_modal</code> to Modal.deregister_modal.</li> <li>Renamed <code>ComponentClient.get_executor</code> to ComponentClient.get_executor_for_message.</li> <li>Renamed <code>ComponentClient.remove_executor</code> to ComponentClient.deregister_message.</li> <li>Renamed <code>add_</code> and <code>with_</code> component methods to better match Hikari's new naming scheme:<ul> <li><code>ActionRowExecutor.add_button</code> to <code>.add_interactive_button</code></li> <li><code>ActionRowExecutor.add_channel_select</code> to <code>.add_channel_menu</code></li> <li><code>ActionRowExecutor.add_text_select</code> to <code>.add_text_menu</code></li> <li><code>ActionColumnExecutor.add_button</code> to <code>.add_interactive_button</code></li> <li><code>ActionColumnExecutor.add_channel_select</code> to <code>.add_channel_menu</code></li> <li><code>ActionColumnExecutor.add_text_select</code> to <code>.add_text_menu</code></li> <li><code>ActionColumnExecutor.add_static_button</code> to <code>.add_static_interactive_button</code></li> <li><code>ActionColumnExecutor.with_static_button</code> to <code>.with_static_interactive_button</code></li> <li><code>ActionColumnExecutor.add_static_channel_select</code> to <code>.add_static_channel_menu</code></li> <li><code>ActionColumnExecutor.with_static_channel_select</code> to <code>.with_static_channel_menu</code></li> <li><code>ActionColumnExecutor.add_static_text_select</code> to <code>.add_static_text_menu</code></li> <li><code>yuyo.components.with_static_button</code> to <code>.with_static_interactive_button</code></li> <li><code>yuyo.components.with_static_channel_select</code> to <code>.with_static_channel_menu</code></li> </ul> </li> </ul>"},{"location":"changelog/#deprecated_3","title":"Deprecated","text":"<ul> <li>The constant ID component handling system.   This has been replaced with passing yuyo.components.SingleExecutor to   ComponentClient.register_executor.</li> <li>Passing <code>timeout</code> to ComponentExecutor.__init__,   <code>ActionRowExecutor.__init__</code>,   ActionColumnExecutor.__init__, and   ComponentPaginator.__init__.   This has been replaced by passing <code>timeout</code> to   ComponentClient.register_executor   to allow for the stateless reuse of component executors.</li> <li><code>AbstractComponentExecutor.has_expired</code>.</li> <li><code>ActionRowExecutor.is_full</code>.</li> <li><code>ComponentClient.set_executor</code>, this has been replaced by   Component.register_executor.</li> <li>Passing <code>yuyo.components.ActionRowExecutor</code> to <code>ActionColumnExecutor.add_row</code>. This   now takes hikari.api.MessageActionRowBuilder.</li> <li>The <code>prefix_match</code> parameter as this is now always enabled.</li> </ul>"},{"location":"changelog/#removed_4","title":"Removed","text":"<ul> <li><code>yuyo.modals.NoDefault</code>.</li> </ul>"},{"location":"changelog/#1101a1-2023-03-25","title":"1.10.1a1 - 2023-03-25","text":""},{"location":"changelog/#added_15","title":"Added","text":"<ul> <li>Some convenience properties to ComponentContext for getting select   menu values:<ul> <li><code>.select_channels</code></li> <li><code>.select_roles</code></li> <li><code>.select_texts</code></li> <li><code>.select_users</code></li> <li><code>.select_members</code></li> </ul> </li> <li>The yuyo.components.Context and yuyo.modals.Context aliases.</li> <li>The yuyo.components.Client, yuyo.modals.Client, and yuyo.reactions.Client aliases.</li> </ul>"},{"location":"changelog/#changed_14","title":"Changed","text":"<ul> <li>A Modal text input's <code>default</code> will now also be used for <code>value</code> when <code>value</code> is left undefined and   <code>default</code> is a string of <code>&lt;=4000</code> characters.</li> <li>Increased the default timeout for modals to 2 minutes.</li> </ul>"},{"location":"changelog/#fixed_11","title":"Fixed","text":"<ul> <li>Text select menus will no-longer lead to an error being returned by Discord when <code>max_values</code> is   greater then the count of its choices.</li> </ul>"},{"location":"changelog/#1100a1-2023-03-20","title":"1.10.0a1 - 2023-03-20","text":""},{"location":"changelog/#added_16","title":"Added","text":"<ul> <li>Support for declaring modal options in the modal callback's signature.</li> </ul>"},{"location":"changelog/#changed_15","title":"Changed","text":"<ul> <li>Moved <code>yuyo.modals.AbstractTimeout</code>, <code>yuyo.modals.BasicTimeout</code> and <code>yuyo.modals.NeverTimeout</code>   to new yuyo.timeouts module.</li> </ul>"},{"location":"changelog/#deprecated_4","title":"Deprecated","text":"<ul> <li><code>yuyo.modals.AbstractTimeout</code>, <code>yuyo.modals.BasicTimeout</code> and <code>yuyo.modals.NeverTimeout</code> as deprecated aliases</li> </ul>"},{"location":"changelog/#fixed_12","title":"Fixed","text":"<ul> <li>Modals now correctly default to a timeout duration of 10 seconds rather than 10 days.</li> </ul>"},{"location":"changelog/#removed_5","title":"Removed","text":"<ul> <li>The deprecated <code>yuyo.components.MultiComponentExecutor</code> and <code>yuyo.components.ChildActionRowExecutor</code>   types.</li> <li><code>ActionRowExecutor.add_button</code> can no-longer be used to add link buttons.</li> <li>yuyo.modals.Modal subclasses will no-longer inherits fields.</li> </ul>"},{"location":"changelog/#191a1-2023-03-07","title":"1.9.1a1 - 2023-03-07","text":""},{"location":"changelog/#added_17","title":"Added","text":"<ul> <li>Re-exposed <code>yuyo.reactions.EventT</code> as yuyo.reactions.ReactionEventT.</li> </ul>"},{"location":"changelog/#changed_16","title":"Changed","text":"<ul> <li><code>token_type</code> now defaults to <code>\"Bot\"</code> when a string token is passed for   AsgiBot.__init__.</li> </ul>"},{"location":"changelog/#fixed_13","title":"Fixed","text":"<ul> <li>yuyo.modals.modal and yuyo.modals.as_modal no-longer lead to Alluka's type-hint introspection   raising an exception.</li> <li>Handling of defaulting empty modal text inputs.</li> <li>Add <code>type</code> property to <code>yuyo.components.ActionRowExecutor</code> and   <code>yuyo.components.ChildActionRowExecutor</code> to fix compatibility with <code>Hikari&gt;=2.0.0.dev117</code>.</li> </ul>"},{"location":"changelog/#190a1-2023-02-27","title":"1.9.0a1 - 2023-02-27","text":""},{"location":"changelog/#added_18","title":"Added","text":"<ul> <li><code>from_tanjun</code> convenience classmethods for initialising from a Tanjun client to   ComponentClient, ModalClient,   ReactionClient, and ServiceManager.</li> <li><code>alluka</code> keyword-argument to to <code>from_gateway_bot</code> and <code>from_rest_bot</code> methods on   ComponentClient, ModalClient, and   ReactionClient.</li> </ul>"},{"location":"changelog/#changed_17","title":"Changed","text":"<ul> <li><code>timeout</code> is now keyword-only for ChunkTracker.__init__.</li> <li>The Alluka bound clients (ComponentClient,   ModalClient, and ReactionClient)   now all register themselves as type dependencies when they're not passed a 3rd party client.</li> </ul>"},{"location":"changelog/#fixed_14","title":"Fixed","text":"<ul> <li>Prefix matched custom IDs are now correctly lower priority for modals.</li> <li>AsgiBot.remove_shutdown_callback and   AsgiBot.remove_startup_callback now raise a ValueError   if the callback isn't registered (as per the documented behaviour) instead of silently passing.</li> </ul>"},{"location":"changelog/#removed_6","title":"Removed","text":"<ul> <li>Unnecessary entries from module <code>__all__</code>s (i.e. type hints, abstract classes, base classes and   internal signal error classes).</li> <li>Type variables are no-longer publicly exposed other than a couple callback types.</li> </ul>"},{"location":"changelog/#180a1post1-2023-02-23","title":"1.8.0a1.post1 - 2023-02-23","text":""},{"location":"changelog/#fixed_15","title":"Fixed","text":"<ul> <li>The yuyo.components.ComponentPaginator will no-longer send a new message with \"MESSAGE_UPDATE\" as   the content when the last entry button is pressed for the first time instead of marking it as loading.</li> <li>The yuyo.components.ComponentPaginator will no-longer create a new message with \"MESSAGE_UPDATE\"   as the content instead of giving a noop update response.</li> </ul>"},{"location":"changelog/#180a1-2023-02-23","title":"1.8.0a1 - 2023-02-23","text":""},{"location":"changelog/#added_19","title":"Added","text":"<ul> <li><code>timeout</code> config to ChunkTracker.__init__.</li> <li><code>bot_managed</code> config to ComponentClient.from_rest_bot.</li> <li>ComponentContext.create_modal_response method.</li> <li>Support for modals in <code>yuyo.modals</code>.</li> <li>yuyo.components.ActionColumnExecutor which handles building and executing multiple message   action row components and also introduces a class template system for message components in a similar   fashion to modals.</li> </ul>"},{"location":"changelog/#changed_18","title":"Changed","text":"<ul> <li>The <code>response_type</code> argument is now keyword only and defaults to   ResponseType.MESSAGE_CREATE in   ComponentContext.create_initial_response.</li> <li>The <code>defer_type</code> argument is now keyword only and defaults to   ResponseType.DEFERRED_MESSAGE_CREATE   in ComponentContext.defer.</li> </ul>"},{"location":"changelog/#deprecated_5","title":"Deprecated","text":"<ul> <li><code>yuyo.components.MultiComponentExecutor</code> and <code>yuyo.components.ChildActionRowExecutor</code>.   yuyo.components.ActionColumnExecutor should be used instead.</li> <li>Using <code>ActionRowExecutor.add_button</code> to add specifically link buttons.   <code>ActionRowExecutor.add_link_button</code> should be used instead.</li> </ul>"},{"location":"changelog/#fixed_16","title":"Fixed","text":"<ul> <li>The <code>add_{}_button</code> methods on ComponentPaginator now ignore   <code>emoji</code> when <code>label</code> is passed to avoid erroring when users don't explicitly unset the   default for <code>emoji</code>.</li> </ul>"},{"location":"changelog/#removed_7","title":"Removed","text":"<ul> <li>The <code>AbstractReactionHandler.last_triggered</code> and <code>ReactionHandler.timeout</code> properties as   these were leaking impl detail.</li> </ul>"},{"location":"changelog/#170a1-2023-02-14","title":"1.7.0a1 - 2023-02-14","text":""},{"location":"changelog/#added_20","title":"Added","text":"<ul> <li>Support for the new select menu types to <code>yuyo.to_builder</code>.</li> <li><code>ActionRowExecutor.add_channel_select</code> for adding channel select menus to an action row.</li> <li><code>ActionRowExecutor.add_select_menu</code> for adding the other new select menu types to an action row.</li> <li>yuyo.pagination.Page type which can be used to represent a response page in the paginators.   This allows configuring attachments and multiple embeds for a page.</li> <li>Methods for manually setting the buttons for yuyo.components.ComponentPaginator and   yuyo.reactions.ReactionPaginator which allow manually overriding the config for each button   or reaction.</li> </ul>"},{"location":"changelog/#changed_19","title":"Changed","text":"<ul> <li><code>from_gateway_bot</code> classmethods can now also take cache-less <code>ShardAware</code> bots.</li> <li>Bumped minimum Hikari version to <code>2.0.0.dev116</code>.</li> <li>Renamed <code>ErrorManager.with_rule</code> to ErrorManager.add_rule   and made its arguments positional only.</li> <li>The <code>guild</code> argument for yuyo.chunk_tracker.ChunkTracker.request_guild_members is now   positional only.</li> <li><code>iterator</code> is now positional only in   ReactionPaginator.__init__ and   ComponentPaginator.__init__.</li> <li><code>lines</code> is now positional only in yuyo.pagination.async_paginate_string,   yuyo.pagination.sync_paginate_string and yuyo.pagination.paginate_string.</li> <li>Renamed <code>add_callback</code> to <code>set_callback</code> on <code>ComponentExecutor</code> and <code>ReactionHandler</code>.</li> <li><code>ActionRowExecutor.add_button</code> now takes all the button's options as arguments.   This also now returns the action row and adds the button to the row immediately (without   any calls to <code>add_to_parent</code>).</li> <li>Renamed the old <code>ActionRowExecutor.add_select_menu</code> to <code>ActionRowExecutor.add_text_select</code>   and added the other select menu's config as keyword-arguments.</li> <li>Renamed <code>add_handler</code> to ReactionClient.set_handler.</li> <li>ReactionClient.set_handler's arguments are now all   positional-only.</li> <li>ComponentPaginator.get_next_entry and   ReactionPaginator.get_next_entry now both   return yuyo.pagination.Page rather than a tuple.   This can be used to create a response easily by passing the result of   Page.to_kwargs to the create message or execute webhook REST method as <code>**kwargs</code>.</li> </ul>"},{"location":"changelog/#fixed_17","title":"Fixed","text":"<ul> <li><code>Context.create_initial_response</code> (and by extension <code>Context.respond</code> for the initial   response specifically) will no-longer try to pass the attachment, component or embed as   the actual message content when passed for the <code>content</code> argument for REST-based   interaction commands.</li> <li><code>BLACK_CROSS</code> can now be passed to   ComponentPaginator.__init__ and   ReactionPaginator.__init__   in the <code>triggers</code> array to enable the stop button.</li> <li>The configured executor is now used for handling attachments when creating the initial responses   with the ASGI bot.</li> <li>Check the headers before reading the body in the ASGI adapter and bot to avoid unnecessary hold up   on bad requests.</li> </ul>"},{"location":"changelog/#removed_8","title":"Removed","text":"<ul> <li><code>yuyo.InteractiveButtonBuilder</code>/<code>yuyo.components.InteractiveButtonBuilder</code> and   <code>yuyo.SelectMenuBuilder</code>/<code>yuyo.components.SelectMenuBuilder</code>. Hikari's default   implementations should be used instead.</li> <li>The deprecated <code>load_from_attributes</code> arguments and the relevant deprecated <code>as_reaction_callback</code>   and <code>as_component_callback</code> functions.</li> <li>The deprecated <code>WaitForComponent</code> alias of <code>WaitForExecutor</code>.</li> </ul>"},{"location":"changelog/#security","title":"Security","text":"<ul> <li>The yuyo.asgi.AsgiAdapter and yuyo.asgi.AsgiBot both now have a max body size limit to avoid   potential DoS and memory issues. This is configurable using <code>max_body_size</code> in the <code>__init__</code>s.</li> </ul>"},{"location":"changelog/#161a1-2023-01-17","title":"1.6.1a1 - 2023-01-17","text":""},{"location":"changelog/#changed_20","title":"Changed","text":"<ul> <li>Detect/allow invite links which aren't prefixed by <code>https://</code> or <code>https://www.</code> in   InviteLink.find,   InviteLink.find_iter, and   InviteLink.from_link to better match Discord's special invite   embedding logic.</li> <li>All link parsers now allow <code>http://</code> links.</li> <li>The startup and shutdown callbacks on yuyo.asgi.AsgiAdapter now take no arguments.   This change does not effect startup and shutdown callbacks on yuyo.asgi.AsgiBot.</li> </ul>"},{"location":"changelog/#removed_9","title":"Removed","text":"<ul> <li>The <code>process_lifespan_event</code> and <code>process_request</code> methods from yuyo.asgi.AsgiAdapter.</li> <li>yuyo.asgi.AsgiBot no-longer inherits from yuyo.asgi.AsgiAdapter directly but still   functions as one.</li> </ul>"},{"location":"changelog/#160a1-2023-01-12","title":"1.6.0a1 - 2023-01-12","text":""},{"location":"changelog/#added_21","title":"Added","text":"<ul> <li>Helper functions for converting some Hikrai modals to builder objects in yuyo.to_builder.   These support application commands and message components.</li> </ul>"},{"location":"changelog/#changed_21","title":"Changed","text":"<ul> <li>Bumped minimum Hikari version to <code>v2.0.0.dev114</code>.</li> </ul>"},{"location":"changelog/#150a1-2023-01-10","title":"1.5.0a1 - 2023-01-10","text":""},{"location":"changelog/#added_22","title":"Added","text":"<ul> <li>Add classes and functions for handling message, webhook, invite and template links.</li> </ul>"},{"location":"changelog/#changed_22","title":"Changed","text":"<ul> <li>Officially drop support for Python 3.8.</li> </ul>"},{"location":"changelog/#140a1post1-2022-11-20","title":"1.4.0a1.post1 - 2022-11-20","text":""},{"location":"changelog/#changed_23","title":"Changed","text":"<ul> <li>CacheStrategy.__init__ now   takes two arguments <code>(hikari.api.Cache, hikari.ShardAware)</code>.</li> </ul>"},{"location":"changelog/#fixed_18","title":"Fixed","text":"<ul> <li>yuyo.list_status.DiscordBotListService's logging when declaring per-shard stats.</li> <li>Declare bot stats per-shard instead of for the whole bot when list status is using the   standard cache or event strategies.</li> </ul>"},{"location":"changelog/#140a1-2022-11-20","title":"1.4.0a1 - 2022-11-20","text":""},{"location":"changelog/#added_23","title":"Added","text":"<ul> <li>A system for automatically declaring a bot's guild count on the bot lists   top.gg, bots.gg and discordbotlist.com. See yuyo.list_status for more   information.</li> <li><code>\"asgi\"</code> feature flag for ensuring this installs with the dependencies required to run   the Asgi REST bot adapter.</li> </ul>"},{"location":"changelog/#changed_24","title":"Changed","text":"<ul> <li>yuyo.backoff.Backoff now increments the internal counter regardless of whether   yuyo.backoff.Backoff.set_next_backoff has been called.</li> <li>yuyo.backoff.Backoff now iterates over the retry counter (int), starting at 0,   rather than just None.</li> <li>yuyo.backoff.Backoff.backoff now returns the current retry count as int or   None if it has reached max retries or the finished flag has been set.</li> <li>Allow None to be passed for <code>attachment</code> and <code>attachments</code> to edit response methods.</li> <li>Star imports are no-longer used on the top level (at yuyo) so only the attributes present   in <code>yuyo.__all__</code> can be accessed there now.</li> <li>yuyo.components.AbstractComponentExecutor, <code>yuyo.components.ChildActionRowExecutor</code>,   <code>InteractiveButtonBuilder</code>, <code>yuyo.components.as_child_executor</code>,   <code>yuyo.components.as_component_callback</code>, yuyo.reactions.AbstractReactionHandler, and   <code>yuyo.reactions.as_reaction_callback</code> are no longer included in <code>yuyo.__all__</code>/exported   top-level.</li> </ul>"},{"location":"changelog/#deprecated_6","title":"Deprecated","text":"<ul> <li><code>yuyo.components.as_child_executor</code>, <code>yuyo.components.as_component_callback</code>, and   <code>yuyo.components.as_reaction_callback</code> are no longer documented (included in their   relevant module's <code>__all__</code>) as these are considered deprecated and undocumented.</li> </ul>"},{"location":"changelog/#fixed_19","title":"Fixed","text":"<ul> <li>yuyo.backoff.Backoff.backoff now respects the max retires config and finished flag.   For this it will now return None without sleeping when either has been reached.</li> </ul>"},{"location":"changelog/#removed_10","title":"Removed","text":"<ul> <li><code>backoff</code> option from yuyo.backoff.Backoff.backoff to better match the aiter flow.</li> </ul>"},{"location":"changelog/#131a1-2022-11-07","title":"1.3.1a1 - 2022-11-07","text":""},{"location":"changelog/#added_24","title":"Added","text":"<ul> <li>A chunk request tracker implementation.</li> </ul>"},{"location":"changelog/#changed_25","title":"Changed","text":"<ul> <li>Bumped the minimum Hikari version to <code>2.0.0.dev112</code>.</li> <li>yuyo.asgi.AsgiAdapter's startup and shutdown callbacks now take 1 argument,   must return None and must be asynchronous to match the methods added to   hikari.RESTBotAware in   https://github.com/hikari-py/hikari/releases/tag/2.0.0.dev112.</li> </ul> <p>This argument will be of type yuyo.asgi.AsgiAdapter when these methods are   called of an asgi adapter and of type yuyo.asgi.AsgiBot when called on an   asgi bot instance.</p>"},{"location":"changelog/#removed_11","title":"Removed","text":"<ul> <li><code>replace_attachments</code> argument from the relevant context edit response methods.   For more information see https://github.com/hikari-py/hikari/releases/tag/2.0.0.dev112.</li> </ul>"},{"location":"changelog/#121a1-2022-11-04","title":"1.2.1a1 - 2022-11-04","text":""},{"location":"changelog/#added_25","title":"Added","text":"<ul> <li><code>ephemeral</code> keyword-argument to yuyo.components.ComponentContext's <code>create_initial_response</code>,   <code>create_follow_up</code> and <code>defer</code> methods as a shorthand for including <code>1 &lt;&lt; 6</code> in the passed flags.</li> <li><code>delete_after</code> option to yuyo.components.ComponentContext response methods.</li> <li><code>expires_at</code> property to yuyo.components.ComponentContext.</li> <li>Support for dependency injection through Alluka to the reaction and component clients.</li> </ul>"},{"location":"changelog/#changed_26","title":"Changed","text":"<ul> <li><code>ComponentExecutor.execute</code> now takes a context object instead of interaction and future objects.</li> <li>yuyo.pagination.async_paginate_string, yuyo.pagination.sync_paginate_string and   yuyo.pagination.paginate_string now return an (async) iterator of the str pages rather than   an iterator of <code>tuple[str, int]</code>. If you need page counts, use enumerate or   yuyo.pagination.aenumerate.</li> <li>(Async) iterables can now be passed to yuyo.pagination.async_paginate_string,   yuyo.pagination.sync_paginate_string and yuyo.pagination.paginate_string instead of just   iterators.</li> </ul>"},{"location":"changelog/#fixed_20","title":"Fixed","text":"<ul> <li>yuyo.interactions.BaseContext.respond trying to edit in the initial response instead   of create a follow up if a deferred initial response was deleted.</li> <li>Long running <code>delete_after</code> and component execution tasks will no-longer be cancelled by GC.</li> </ul>"},{"location":"changelog/#removed_12","title":"Removed","text":"<ul> <li>The project metadata dunder attributes from yuyo.   importlib.metadata should be used to get this metadata instead.</li> </ul>"},{"location":"changelog/#111a1-2022-08-28","title":"1.1.1a1 - 2022-08-28","text":""},{"location":"changelog/#added_26","title":"Added","text":"<ul> <li>Support for sending attachments in the initial response to the ASGI server implementation.</li> <li>Support for sending attachments on initial response to the <code>ComponentContext</code>.</li> </ul>"},{"location":"changelog/#changed_27","title":"Changed","text":"<ul> <li>Bumped the minimum hikari version to dev109.</li> <li>Async functions must be typed as returning <code>typing.Coroutine</code>/<code>collections.abc.Coroutine</code>   rather than <code>typing.Awaitable</code> now.</li> </ul>"},{"location":"changelog/#fixed_21","title":"Fixed","text":"<ul> <li>Several bug fixes on handling context response tracking have been copied over from Tanjun   to <code>ComponentContext</code>.</li> </ul>"},{"location":"changelog/#106a1-2022-05-24","title":"1.0.6a1 - 2022-05-24","text":""},{"location":"changelog/#changed_28","title":"Changed","text":"<ul> <li>Bumped the minimum hikari version to dev108.</li> </ul>"},{"location":"changelog/#fixed_22","title":"Fixed","text":"<ul> <li><code>WaitForExecutor</code> now has better semantics/behaviour around being called when it's inactive:<ul> <li>Timeouts are now handled better meaning that a wait for executor timeout will mark it to be de-registered.</li> <li>Execute calls to an executor that hasn't been waited for yet now return a not active message.</li> </ul> </li> </ul>"},{"location":"changelog/#105a1post1-2021-12-21","title":"1.0.5a1.post1 - 2021-12-21","text":""},{"location":"changelog/#changed_29","title":"Changed","text":"<ul> <li><code>AsgiBot</code> is now (by default) started and closed based on the ASGI lifespan events with   the <code>asgi_managed</code> keyword argument to <code>AsgiBot.__init__</code> allowing this to be disabled.</li> </ul>"},{"location":"changelog/#105a1-2021-12-21","title":"1.0.5a1 - 2021-12-21","text":""},{"location":"changelog/#added_27","title":"Added","text":"<ul> <li><code>AsgiBot</code> extension for <code>AsgiAdapter</code> which can be run by itself (manages a rest client).</li> </ul>"},{"location":"changelog/#changed_30","title":"Changed","text":"<ul> <li>Renamed <code>WaitForComponent</code> to <code>WaitForExecutor</code>.</li> </ul>"},{"location":"changelog/#104a1-2021-11-22","title":"1.0.4a1 - 2021-11-22","text":""},{"location":"changelog/#added_28","title":"Added","text":"<ul> <li><code>prefix_match</code> option to ComponentClient custom ids to make storing metadata in custom ids   possible.</li> </ul>"},{"location":"changelog/#fixed_23","title":"Fixed","text":"<ul> <li>custom id methods now raise ValueError on conflict rather than KeyError.</li> </ul>"},{"location":"changelog/#103a1-2021-10-27","title":"1.0.3a1 - 2021-10-27","text":""},{"location":"changelog/#added_29","title":"Added","text":"<ul> <li>An ASGI/3 adapter for Hikari's interaction server.</li> <li>Ability to register a callback for a constant custom_id in the component client.   This takes precedence over any registered component executors.</li> </ul>"},{"location":"changelog/#changed_31","title":"Changed","text":"<ul> <li>Renamed <code>components.WaitFor</code> to <code>WaitForComponent</code> and added it to <code>components.__all__</code> and   <code>yuyo.__all__</code>.</li> </ul>"},{"location":"changelog/#fixed_24","title":"Fixed","text":"<ul> <li><code>Context.defer</code> is now used in the ComponentPaginator instead of   <code>Context.create_initial_response</code> to defer the initial response since before deleting it   as <code>Context.create_initial_response</code> errors in the REST flow when a defer type is passed.</li> <li><code>Context.create_initial_response</code> is no longer typed as taking deferred types.</li> <li>Handling of authors in WaitForComponent.</li> <li>Added timeout handling to the future returned by WaitForComponent.wait_for.</li> </ul>"},{"location":"changelog/#102a1post1-2021-10-02","title":"[1.0.2a1.post1] - 2021-10-02","text":""},{"location":"changelog/#fixed_25","title":"Fixed","text":"<ul> <li>ComponentClient erroneously garbage collecting unexpired executors.</li> <li>ComponentPaginator and ReactionPaginator both starting on index 1 instead of 0.</li> </ul>"},{"location":"changelog/#102a1-2021-10-02","title":"1.0.2a1 - 2021-10-02","text":""},{"location":"changelog/#added_30","title":"Added","text":"<ul> <li>Option to have the ComponentClient be event managed when linked to an event manager.   This is True by default.</li> </ul>"},{"location":"changelog/#changed_32","title":"Changed","text":"<ul> <li>The client now gives a ephemeral timed out response when an unknown message is received.</li> </ul>"},{"location":"changelog/#fixed_26","title":"Fixed","text":"<ul> <li>ComponentClient's gc task not being started when its opened.</li> <li>Handling of access errors in the component client.</li> <li>MultiComponentExecutor slots.</li> </ul>"},{"location":"changelog/#101a1-2021-09-21","title":"1.0.1a1 - 2021-09-21","text":""},{"location":"changelog/#added_31","title":"Added","text":"<ul> <li>Higher level component execution client and a pagination specific implementation of its   executor.</li> </ul>"},{"location":"changelog/#changed_33","title":"Changed","text":"<ul> <li>Totally refactored reaction pagination client to make it more abstract and abstracted away from   pagination where the pagination is just a standard use case specific implementation of its   executor.</li> <li>Renamed module pagnation to pagination.</li> <li>Move the reaction handling logic over to \"reactions.py\"</li> <li>Renamed string_patinator functions to paginate_string</li> </ul>"},{"location":"changelog/#fixed_27","title":"Fixed","text":"<ul> <li>Iffy behaviour around \"locking\" the reaction executor which lead to some requests just being ignored.</li> </ul>"},{"location":"reference/","title":"yuyo","text":"<p>A collection of utility functions and classes designed to expand Hikari.</p>"},{"location":"reference/#yuyo.LocalizedPage","title":"LocalizedPage  <code>module-attribute</code>","text":"<pre><code>LocalizedPage = LocalisedPage\n</code></pre> <p>Alias of LocalisedPage.</p>"},{"location":"reference/#yuyo.ActionColumnExecutor","title":"ActionColumnExecutor","text":"<p>               Bases: <code>AbstractComponentExecutor</code></p> <p>Executor which handles columns of action rows.</p> <p>This can be used to declare and handle the components on a message a couple of ways.</p> <p>To send a column's components pass ActionColumnExecutor.rows as <code>components</code> when calling the create message method (e.g. <code>respond</code>/<code>create_message</code>).</p> <p>Examples:</p> <p>Sub-components can be added to an instance of the column executor using chainable methods on it:</p> <pre><code>async def callback_1(ctx: components.Context) -&gt; None:\n    await ctx.respond(\"meow\")\n\ncomponents = (\n    components.ActionColumnExecutor()\n    .add_interactive_button(hikari.ButtonStyle.PRIMARY, chainable, label=\"Button 1\")\n    .add_link_button(\"https://example.com\", label=\"Button 2\",)\n)\n</code></pre> <p>Alternatively, subclasses of ActionColumnExecutor can act as a template where \"static\" fields are included on all instances and subclasses of that class:</p> <p>Note</p> <p>Since decorators are executed from the bottom upwards fields added through decorator calls will follow the same order.</p> <pre><code>async def callback_1(ctx: components.Context) -&gt; None:\n    await ctx.respond(\"meow\")\n\nasync def callback_2(ctx: components.Context) -&gt; None:\n    await ctx.respond(\"meow\")\n\n@components.with_static_select_menu(callback_1, hikari.ComponentType.USER_SELECT_MENU, max_values=5)\nclass CustomColumn(components.ActionColumnExecutor):\n    __slots__ = (\"special_string\",)  # ActionColumnExecutor supports slotting.\n\n    # The init can be overridden to store extra data on the column object when subclassing.\n    def __init__(self, special_string: str, timeout: datetime.timedelta | None = None):\n        super().__init__(timeout=timeout)\n        self.special_string = special_string\n\n(\n    CustomColumn.add_static_text_menu(callback_2, min_values=0, max_values=3)\n    # The following calls are all adding options to the added\n    # text select menu.\n    .add_option(\"Option 1\", \"value 1\")\n    .add_option(\"Option 2\", \"value 2\")\n    .add_option(\"Option 3\", \"value 3\")\n)\n</code></pre> <p>There's also class descriptors which can be used to declare static components. The following descriptors work by decorating their component's callback:</p> <ul> <li>as_interactive_button</li> <li>as_channel_menu</li> <li>as_mentionable_menu</li> <li>as_role_menu</li> <li>as_text_menu</li> <li>as_user_menu</li> </ul> <p>link_button returns a descriptor without decorating any callback.</p> <pre><code>class CustomColumn(components.ActionColumnExecutor):\n    @components.as_interactive_button(ButtonStyle.PRIMARY, label=\"label\")\n    async def left_button(self, ctx: components.Context) -&gt; None:\n        ...\n\n    link_button = components.link_button(url=\"https://example.com\", label=\"Go to page\")\n\n    @components.as_interactive_button(ButtonStyle.SECONDARY, label=\"meow\")\n    async def right_button(self, ctx: components.Context) -&gt; None:\n        ...\n\n    @components.as_channel_menu(channel_types=[hikari.TextableChannel], custom_id=\"eep\")\n    async def text_select_menu(self, ctx: components.Context) -&gt; None:\n        ...\n</code></pre>"},{"location":"reference/#yuyo.ActionColumnExecutor._added_static_fields","title":"_added_static_fields  <code>class-attribute</code>","text":"<pre><code>_added_static_fields = {}\n</code></pre> <p>Dict of match IDs to the static fields added to this class through add method calls.</p> <p>This doesn't include inherited fields.</p>"},{"location":"reference/#yuyo.ActionColumnExecutor._static_fields","title":"_static_fields  <code>class-attribute</code>","text":"<pre><code>_static_fields = {}\n</code></pre> <p>Dict of match IDs to the static fields on this class.</p> <p>This includes inherited fields and fields added through method calls.</p>"},{"location":"reference/#yuyo.ActionColumnExecutor.rows","title":"rows  <code>property</code>","text":"<pre><code>rows\n</code></pre> <p>The rows in this column.</p>"},{"location":"reference/#yuyo.ActionColumnExecutor.__init__","title":"__init__","text":"<pre><code>__init__(*, authors=None, ephemeral_default=False, id_metadata=None)\n</code></pre> <p>Initialise an action column executor.</p> <p>Parameters:</p> <ul> <li> <code>authors</code>               (<code>Iterable[SnowflakeishOr[User]] | None</code>, default:                   <code>None</code> )           \u2013            <p>Users who are allowed to use the components this represents.</p> <p>If no users are provided then the components will be public (meaning that anybody can use it).</p> </li> <li> <code>ephemeral_default</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether or not the responses made on contexts spawned from this executor should default to ephemeral (meaning only the author can see them) unless <code>flags</code> is specified on the response method.</p> </li> <li> <code>id_metadata</code>               (<code>Mapping[str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Mapping of metadata to append to the custom IDs in this column.</p> <p>The keys in this can either be the match part of component custom IDs or the names of the component's callback when it was added using one of the <code>as_</code> class descriptors.</p> </li> </ul>"},{"location":"reference/#yuyo.ActionColumnExecutor.add_builder","title":"add_builder","text":"<pre><code>add_builder(builder)\n</code></pre> <p>Add a raw component builder to this action column.</p> <p>This is mostly for adding components where the custom ID is already registered as a separate constant executor.</p> <p>Parameters:</p> <ul> <li> <code>builder</code>               (<code>ComponentBuilder</code>)           \u2013            <p>The component builder to add to the column.</p> </li> </ul>"},{"location":"reference/#yuyo.ActionColumnExecutor.add_channel_menu","title":"add_channel_menu","text":"<pre><code>add_channel_menu(callback, /, *, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a channel select menu to this action column.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>channel_types</code>               (<code>None | Sequence[ChannelType | type[PartialChannel]]</code>, default:                   <code>None</code> )           \u2013            <p>Sequence of the types of channels this select menu should show as options.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The action column to enable chained calls.</p> </li> </ul>"},{"location":"reference/#yuyo.ActionColumnExecutor.add_interactive_button","title":"add_interactive_button","text":"<pre><code>add_interactive_button(style, callback, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add an interactive button to this action column.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>)           \u2013            <p>The button's style.</p> </li> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>The button's execution callback.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The button's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's emoji.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's label.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the button should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The action column to enable chained calls.</p> </li> </ul>"},{"location":"reference/#yuyo.ActionColumnExecutor.add_link_button","title":"add_link_button","text":"<pre><code>add_link_button(url, /, *, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add a link button to this action column.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>url</code>               (<code>str</code>)           \u2013            <p>The button's url.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's emoji.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's label.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the button should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The action column to enable chained calls.</p> </li> </ul>"},{"location":"reference/#yuyo.ActionColumnExecutor.add_mentionable_menu","title":"add_mentionable_menu","text":"<pre><code>add_mentionable_menu(callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a mentionable select menu to this action column.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The action column to enable chained calls.</p> </li> </ul>"},{"location":"reference/#yuyo.ActionColumnExecutor.add_role_menu","title":"add_role_menu","text":"<pre><code>add_role_menu(callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a role select menu to this action column.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The action column to enable chained calls.</p> </li> </ul>"},{"location":"reference/#yuyo.ActionColumnExecutor.add_select_menu","title":"add_select_menu","text":"<pre><code>add_select_menu(type_, callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a select menu to this action column.</p> <p>The following methods should be used instead:</p> <ul> <li>.add_channel_menu</li> <li>.add_mentionable_menu</li> <li>.add_role_menu</li> <li>.add_text_menu</li> <li>.add_user_menu</li> </ul>"},{"location":"reference/#yuyo.ActionColumnExecutor.add_static_builder","title":"add_static_builder  <code>classmethod</code>","text":"<pre><code>add_static_builder(builder)\n</code></pre> <p>Add a raw component builder to all subclasses and instances of this column.</p> <p>This is mostly for adding components where the custom ID is already registered as a separate constant executor.</p> <p>Parameters:</p> <ul> <li> <code>builder</code>               (<code>ComponentBuilder</code>)           \u2013            <p>The component builder to add to the column class.</p> </li> </ul>"},{"location":"reference/#yuyo.ActionColumnExecutor.add_static_channel_menu","title":"add_static_channel_menu  <code>classmethod</code>","text":"<pre><code>add_static_channel_menu(callback, /, *, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a channel select menu to all subclasses and instances of this action column class.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>channel_types</code>               (<code>None | Sequence[ChannelType | type[PartialChannel]]</code>, default:                   <code>None</code> )           \u2013            <p>Sequence of the types of channels this select menu should show as options.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[Self]</code>           \u2013            <p>The action column class to enable chained calls.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/#yuyo.ActionColumnExecutor.add_static_interactive_button","title":"add_static_interactive_button  <code>classmethod</code>","text":"<pre><code>add_static_interactive_button(style, callback, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add an interactive button to all subclasses and instances of this action column class.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>)           \u2013            <p>The button's style.</p> </li> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>The button's execution callback.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The button's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's emoji.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's label.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the button should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[Self]</code>           \u2013            <p>The action column class to enable chained calls.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/#yuyo.ActionColumnExecutor.add_static_link_button","title":"add_static_link_button  <code>classmethod</code>","text":"<pre><code>add_static_link_button(url, /, *, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add a link button to all subclasses and instances of this action column class.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>url</code>               (<code>str</code>)           \u2013            <p>The button's url.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's emoji.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's label.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the button should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[Self]</code>           \u2013            <p>The action column class to enable chained calls.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/#yuyo.ActionColumnExecutor.add_static_mentionable_menu","title":"add_static_mentionable_menu  <code>classmethod</code>","text":"<pre><code>add_static_mentionable_menu(callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a mentionable select menu to all subclasses and instances of this action column class.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[Self]</code>           \u2013            <p>The action column class to enable chained calls.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/#yuyo.ActionColumnExecutor.add_static_role_menu","title":"add_static_role_menu  <code>classmethod</code>","text":"<pre><code>add_static_role_menu(callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a role select menu to all subclasses and instances of this action column class.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[Self]</code>           \u2013            <p>The action column class to enable chained calls.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/#yuyo.ActionColumnExecutor.add_static_select_menu","title":"add_static_select_menu  <code>classmethod</code>","text":"<pre><code>add_static_select_menu(type_, callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a select menu to all subclasses and instances of this action column class.</p> <p>The following class methods should be used instead:</p> <ul> <li>.add_static_channel_menu</li> <li>.add_static_mentionable_menu</li> <li>.add_static_role_menu</li> <li>.add_static_text_menu</li> <li>.add_static_user_menu</li> </ul>"},{"location":"reference/#yuyo.ActionColumnExecutor.add_static_text_menu","title":"add_static_text_menu  <code>classmethod</code>","text":"<pre><code>add_static_text_menu(callback, /, *, custom_id=None, options=(), placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a text select menu to all subclasses and instances of this action column class.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>options</code>               (<code>Sequence[SelectOptionBuilder]</code>, default:                   <code>()</code> )           \u2013            <p>The text select's options.</p> <p>These can also be added by calling TextSelectMenuBuilder.add_option.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>TextSelectMenuBuilder</code>           \u2013            <p>Builder for the added text select menu.</p> <p>TextSelectMenuBuilder.add_option should be used to add options to this select menu.</p> <p>And the parent action column can be accessed by calling TextSelectMenuBuilder.parent.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/#yuyo.ActionColumnExecutor.add_static_user_menu","title":"add_static_user_menu  <code>classmethod</code>","text":"<pre><code>add_static_user_menu(callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a user select menu to all subclasses and instances of this action column class.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[Self]</code>           \u2013            <p>The action column class to enable chained calls.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/#yuyo.ActionColumnExecutor.add_text_menu","title":"add_text_menu","text":"<pre><code>add_text_menu(callback, /, *, custom_id=None, options=(), placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a text select menu to this action column.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>options</code>               (<code>Sequence[SelectOptionBuilder]</code>, default:                   <code>()</code> )           \u2013            <p>The text select's options.</p> <p>These can also be added by calling TextSelectMenuBuilder.add_option.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>TextSelectMenuBuilder</code>           \u2013            <p>Builder for the added text select menu.</p> <p>TextSelectMenuBuilder.add_option should be used to add options to this select menu.</p> <p>And the parent action column can be accessed by calling TextSelectMenuBuilder.parent.</p> </li> </ul>"},{"location":"reference/#yuyo.ActionColumnExecutor.add_user_menu","title":"add_user_menu","text":"<pre><code>add_user_menu(callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a user select menu to this action column.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The action column to enable chained calls.</p> </li> </ul>"},{"location":"reference/#yuyo.ActionColumnExecutor.with_channel_menu","title":"with_channel_menu","text":"<pre><code>with_channel_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_channel_menu(*, custom_id: str | None = None, channel_types: None | Sequence[ChannelType | type[PartialChannel]] = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_channel_menu(callback=None, /, *, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a channel select menu to this action column through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>channel_types</code>               (<code>None | Sequence[ChannelType | type[PartialChannel]]</code>, default:                   <code>None</code> )           \u2013            <p>Sequence of the types of channels this select menu should show as options.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul>"},{"location":"reference/#yuyo.ActionColumnExecutor.with_interactive_button","title":"with_interactive_button","text":"<pre><code>with_interactive_button(style, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add an interactive button to this action column through a decorator call.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>)           \u2013            <p>The button's style.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The button's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's emoji.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's label.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the button should be marked as disabled.</p> </li> </ul>"},{"location":"reference/#yuyo.ActionColumnExecutor.with_mentionable_menu","title":"with_mentionable_menu","text":"<pre><code>with_mentionable_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_mentionable_menu(*, custom_id: str | None = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_mentionable_menu(callback=None, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a mentionable select menu to this action column through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul>"},{"location":"reference/#yuyo.ActionColumnExecutor.with_role_menu","title":"with_role_menu","text":"<pre><code>with_role_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_role_menu(*, custom_id: str | None = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_role_menu(callback=None, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a role select menu to this action column through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul>"},{"location":"reference/#yuyo.ActionColumnExecutor.with_static_channel_menu","title":"with_static_channel_menu  <code>classmethod</code>","text":"<pre><code>with_static_channel_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_static_channel_menu(*, custom_id: str | None = None, channel_types: None | Sequence[ChannelType | type[PartialChannel]] = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_static_channel_menu(callback=None, /, *, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a channel select menu to this action column class through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>channel_types</code>               (<code>None | Sequence[ChannelType | type[PartialChannel]]</code>, default:                   <code>None</code> )           \u2013            <p>Sequence of the types of channels this select menu should show as options.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/#yuyo.ActionColumnExecutor.with_static_interactive_button","title":"with_static_interactive_button  <code>classmethod</code>","text":"<pre><code>with_static_interactive_button(style, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add a static interactive button to this action column class through a decorator call.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>)           \u2013            <p>The button's style.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The button's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's emoji.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's label.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the button should be marked as disabled.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/#yuyo.ActionColumnExecutor.with_static_mentionable_menu","title":"with_static_mentionable_menu  <code>classmethod</code>","text":"<pre><code>with_static_mentionable_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_static_mentionable_menu(*, custom_id: str | None = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_static_mentionable_menu(callback=None, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a static mentionable select menu to this action column class through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/#yuyo.ActionColumnExecutor.with_static_role_menu","title":"with_static_role_menu  <code>classmethod</code>","text":"<pre><code>with_static_role_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_static_role_menu(*, custom_id: str | None = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_static_role_menu(callback=None, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a static role select menu to this action column class through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/#yuyo.ActionColumnExecutor.with_static_text_menu","title":"with_static_text_menu  <code>classmethod</code>","text":"<pre><code>with_static_text_menu(callback: Callable[_P, _CoroT]) -&gt; _WrappedTextMenuBuilder[_P]\n</code></pre><pre><code>with_static_text_menu(*, custom_id: str | None = None, options: Sequence[SelectOptionBuilder] = (), placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[collections.Callable[_P, _CoroT]], _WrappedTextMenuBuilder[_P]]\n</code></pre> <pre><code>with_static_text_menu(callback=None, /, *, custom_id=None, options=(), placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a text select menu to this action column class through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>options</code>               (<code>Sequence[SelectOptionBuilder]</code>, default:                   <code>()</code> )           \u2013            <p>The text select's options.</p> <p>These can also be added using [yuyo.components.with_option].</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/#yuyo.ActionColumnExecutor.with_static_user_menu","title":"with_static_user_menu  <code>classmethod</code>","text":"<pre><code>with_static_user_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_static_user_menu(*, custom_id: str | None = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_static_user_menu(callback=None, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a static user select menu to this action column class through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/#yuyo.ActionColumnExecutor.with_text_menu","title":"with_text_menu","text":"<pre><code>with_text_menu(callback: Callable[_P, _CoroT]) -&gt; _WrappedTextMenuBuilder[_P]\n</code></pre><pre><code>with_text_menu(*, custom_id: str | None = None, options: Sequence[SelectOptionBuilder] = (), placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[collections.Callable[_P, _CoroT]], _WrappedTextMenuBuilder[_P]]\n</code></pre> <pre><code>with_text_menu(callback=None, /, *, custom_id=None, options=(), placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a text select menu to this action column through a decorator callback.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>options</code>               (<code>Sequence[SelectOptionBuilder]</code>, default:                   <code>()</code> )           \u2013            <p>The text select's options.</p> <p>These can also be added using components.with_option.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul>"},{"location":"reference/#yuyo.ActionColumnExecutor.with_user_menu","title":"with_user_menu","text":"<pre><code>with_user_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_user_menu(*, custom_id: str | None = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_user_menu(callback=None, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a user select menu to this action column through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul>"},{"location":"reference/#yuyo.AsgiAdapter","title":"AsgiAdapter","text":"<p>Asgi/3 adapter for Hikari's interaction server interface.</p> <p>For this to work, hikari has to be installed with the optional \"server\" feature (e.g <code>python -m pip install hikari[server]</code>).</p>"},{"location":"reference/#yuyo.AsgiAdapter.server","title":"server  <code>property</code>","text":"<pre><code>server\n</code></pre> <p>The interaction server this adapter is bound to.</p>"},{"location":"reference/#yuyo.AsgiAdapter.__call__","title":"__call__  <code>async</code>","text":"<pre><code>__call__(scope, receive, send)\n</code></pre> <p>Call the adapter.</p> <p>Note</p> <p>This method is called by the ASGI server.</p> <p>Parameters:</p> <ul> <li> <code>scope</code>               (<code>Scope</code>)           \u2013            <p>The scope of the request.</p> </li> <li> <code>receive</code>               (<code>ASGIReceiveCallable</code>)           \u2013            <p>The receive function to use.</p> </li> <li> <code>send</code>               (<code>ASGISendCallable</code>)           \u2013            <p>The send function to use.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NotImplementedError</code>             \u2013            <p>If this is called with a websocket scope.</p> </li> <li> <code>RuntimeError</code>             \u2013            <p>If an invalid scope event is passed.</p> </li> </ul>"},{"location":"reference/#yuyo.AsgiAdapter.__init__","title":"__init__","text":"<pre><code>__init__(server, /, *, executor=None, max_body_size=1024 ** 2)\n</code></pre> <p>Initialise the adapter.</p> <p>Parameters:</p> <ul> <li> <code>server</code>               (<code>InteractionServer</code>)           \u2013            <p>The interaction server to use.</p> </li> <li> <code>executor</code>               (<code>Executor | None</code>, default:                   <code>None</code> )           \u2013            <p>If non-None, then this executor is used instead of the concurrent.futures.ThreadPoolExecutor attached to the asyncio.AbstractEventLoop that the bot will run on. This executor is used primarily for file-IO.</p> <p>While mainly supporting the concurrent.futures.ThreadPoolExecutor implementation in the standard lib, Hikari's file handling systems should also work with concurrent.futures.ProcessPoolExecutor, which relies on all objects used in IPC to be <code>pickle</code>able. Many third-party libraries will not support this fully though, so your mileage may vary on using ProcessPoolExecutor implementations with this parameter.</p> </li> <li> <code>max_body_size</code>               (<code>int</code>, default:                   <code>1024 ** 2</code> )           \u2013            <p>The maximum body size this should allow received request bodies to be in bytes before failing the request with a 413 - Content Too Large.</p> </li> </ul>"},{"location":"reference/#yuyo.AsgiAdapter._process_lifespan_event","title":"_process_lifespan_event  <code>async</code>","text":"<pre><code>_process_lifespan_event(receive, send)\n</code></pre> <p>Process a lifespan ASGI event.</p> <p>Note</p> <p>This function is used internally by the adapter.</p> <p>Parameters:</p> <ul> <li> <code>receive</code>               (<code>ASGIReceiveCallable</code>)           \u2013            <p>The receive function to use.</p> </li> <li> <code>send</code>               (<code>ASGISendCallable</code>)           \u2013            <p>The send function to use.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If an invalid lifespan event is passed.</p> </li> </ul>"},{"location":"reference/#yuyo.AsgiAdapter._process_request","title":"_process_request  <code>async</code>","text":"<pre><code>_process_request(scope, receive, send)\n</code></pre> <p>Process an HTTP request.</p> <p>Note</p> <p>This function is used internally by the adapter.</p> <p>Parameters:</p> <ul> <li> <code>scope</code>               (<code>HTTPScope</code>)           \u2013            <p>The scope of the request.</p> </li> <li> <code>receive</code>               (<code>ASGIReceiveCallable</code>)           \u2013            <p>The receive function to use.</p> </li> <li> <code>send</code>               (<code>ASGISendCallable</code>)           \u2013            <p>The send function to use.</p> </li> </ul>"},{"location":"reference/#yuyo.AsgiAdapter.add_shutdown_callback","title":"add_shutdown_callback","text":"<pre><code>add_shutdown_callback(callback)\n</code></pre> <p>Add a callback to be called when the ASGI server shuts down.</p> <p>Warning</p> <p>These callbacks will block the ASGI server from shutting down until they complete and any raised errors will lead to a failed shutdown.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>Callable[[], Coroutine[Any, Any, None]]</code>)           \u2013            <p>The shutdown callback to add.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The adapter to enable chained calls.</p> </li> </ul>"},{"location":"reference/#yuyo.AsgiAdapter.add_startup_callback","title":"add_startup_callback","text":"<pre><code>add_startup_callback(callback)\n</code></pre> <p>Add a callback to be called when the ASGI server starts up.</p> <p>Warning</p> <p>These callbacks will block the ASGI server from starting until they complete and any raised errors will lead to a failed startup.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>Callable[[], Coroutine[Any, Any, None]]</code>)           \u2013            <p>The startup callback to add.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The adapter to enable chained calls.</p> </li> </ul>"},{"location":"reference/#yuyo.AsgiAdapter.remove_shutdown_callback","title":"remove_shutdown_callback","text":"<pre><code>remove_shutdown_callback(callback)\n</code></pre> <p>Remove a shutdown callback.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>Callable[[], Coroutine[Any, Any, None]]</code>)           \u2013            <p>The shutdown callback to remove.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The adapter to enable chained calls.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the callback was not registered.</p> </li> </ul>"},{"location":"reference/#yuyo.AsgiAdapter.remove_startup_callback","title":"remove_startup_callback","text":"<pre><code>remove_startup_callback(callback)\n</code></pre> <p>Remove a startup callback.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>Callable[[], Coroutine[Any, Any, None]]</code>)           \u2013            <p>The startup callback to remove.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The adapter to enable chained calls.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the callback was not registered.</p> </li> </ul>"},{"location":"reference/#yuyo.AsgiBot","title":"AsgiBot","text":"<p>               Bases: <code>RESTBotAware</code></p> <p>Bot implementation which acts as an ASGI adapter.</p> <p>This bot doesn't initiate a server internally but instead relies on being called as an ASGI app.</p> <p>For this to work, hikari has to be installed with the optional \"server\" feature (e.g <code>python -m pip install hikari[server]</code>).</p>"},{"location":"reference/#yuyo.AsgiBot.__call__","title":"__call__  <code>async</code>","text":"<pre><code>__call__(scope, receive, send)\n</code></pre> <p>Call the bot with an ASGI event.</p> <p>Note</p> <p>This method is called by the ASGI server and allows the bot to function like AsgiAdapter.</p> <p>Parameters:</p> <ul> <li> <code>scope</code>               (<code>Scope</code>)           \u2013            <p>The scope of the request.</p> </li> <li> <code>receive</code>               (<code>ASGIReceiveCallable</code>)           \u2013            <p>The receive function to use.</p> </li> <li> <code>send</code>               (<code>ASGISendCallable</code>)           \u2013            <p>The send function to use.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NotImplementedError</code>             \u2013            <p>If this is called with a websocket scope.</p> </li> <li> <code>RuntimeError</code>             \u2013            <p>If an invalid scope event is passed.</p> </li> </ul>"},{"location":"reference/#yuyo.AsgiBot.__init__","title":"__init__","text":"<pre><code>__init__(token: TokenStrategy, *, public_key: bytes | str | None = None, asgi_managed: bool = True, executor: Executor | None = None, http_settings: HTTPSettings | None = None, max_body_size: int = 1024 ** 2, max_rate_limit: float = 300.0, max_retries: int = 3, proxy_settings: ProxySettings | None = None, rest_url: str | None = None) -&gt; None\n</code></pre><pre><code>__init__(token: str, token_type: str | TokenType = hikari.TokenType.BOT, public_key: bytes | str | None = None, *, asgi_managed: bool = True, executor: Executor | None = None, http_settings: HTTPSettings | None = None, max_body_size: int = 1024 ** 2, max_rate_limit: float = 300.0, max_retries: int = 3, proxy_settings: ProxySettings | None = None, rest_url: str | None = None) -&gt; None\n</code></pre> <pre><code>__init__(token, token_type=None, public_key=None, *, asgi_managed=True, executor=None, http_settings=None, max_body_size=1024 ** 2, max_rate_limit=300.0, max_retries=3, proxy_settings=None, rest_url=None)\n</code></pre> <p>Initialise a new ASGI bot.</p> <p>Parameters:</p> <ul> <li> <code>token</code>               (<code>str | TokenStrategy</code>)           \u2013            <p>The bot or bearer token. If no token is to be used, this can be undefined.</p> </li> <li> <code>token_type</code>               (<code>TokenType | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The type of token in use. This should only be passed when <code>str</code> is passed for <code>token</code>, can be <code>\"Bot\"</code> or <code>\"Bearer\"</code> and will be defaulted to <code>\"Bot\"</code> in this situation.</p> <p>This should be left as None when either hikari.api.TokenStrategy or None is passed for <code>token</code>.</p> </li> <li> <code>asgi_managed</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether this bot's internal components should be automatically started and stopped based on the Asgi lifespan events.</p> </li> <li> <code>executor</code>               (<code>Executor | None</code>, default:                   <code>None</code> )           \u2013            <p>If non-None, then this executor is used instead of the concurrent.futures.ThreadPoolExecutor attached to the asyncio.AbstractEventLoop that the bot will run on. This executor is used primarily for file-IO.</p> <p>While mainly supporting the concurrent.futures.ThreadPoolExecutor implementation in the standard lib, Hikari's file handling systems should also work with concurrent.futures.ProcessPoolExecutor, which relies on all objects used in IPC to be <code>pickle</code>able. Many third-party libraries will not support this fully though, so your mileage may vary on using ProcessPoolExecutor implementations with this parameter.</p> </li> <li> <code>http_settings</code>               (<code>HTTPSettings | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional custom HTTP configuration settings to use. Allows you to customise functionality such as whether SSL-verification is enabled, what timeouts <code>aiohttp</code> should expect to use for requests, and behavior regarding HTTP-redirects.</p> </li> <li> <code>max_body_size</code>               (<code>int</code>, default:                   <code>1024 ** 2</code> )           \u2013            <p>The maximum body size this should allow received request bodies to be in bytes before failing the request with a 413 - Content Too Large.</p> </li> <li> <code>max_rate_limit</code>               (<code>float</code>, default:                   <code>300.0</code> )           \u2013            <p>The max number of seconds to backoff for when rate limited. Anything greater than this will instead raise an error.</p> <p>This defaults to five minutes to stop potentially indefinitely waiting on an endpoint, which is almost never what you want to do if giving a response to a user.</p> <p>You can set this to <code>float(\"inf\")</code> to disable this check entirely. Note that this only applies to the REST API component that communicates with Discord, and will not affect sharding or third party HTTP endpoints that may be in use.</p> </li> <li> <code>max_retries</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            <p>Maximum number of times a request will be retried if</p> <p>it fails with a <code>5xx</code> status. Defaults to 3 if set to None.</p> </li> <li> <code>proxy_settings</code>               (<code>ProxySettings | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom proxy settings to use with network-layer logic in your application to get through an HTTP-proxy.</p> </li> <li> <code>public_key</code>               (<code>bytes | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The public key to use to verify received interaction requests.</p> <p>This may be a hex encoded <code>str</code> or the raw <code>bytes</code>. If left as None then the client will try to work this value out based on <code>token</code>.</p> </li> <li> <code>rest_url</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Defaults to the Discord REST API URL if None. Can be overridden if you are attempting to point to an unofficial endpoint, or if you are attempting to mock/stub the Discord API for any reason.</p> <p>Generally you do not want to change this.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <ul> <li>If <code>token_type</code> is provided when a token strategy is passed for <code>token</code>.</li> <li>if <code>token_type</code> is left as None when a string is passed for <code>token</code>.</li> </ul> </li> </ul>"},{"location":"reference/#yuyo.AsgiBot.add_shutdown_callback","title":"add_shutdown_callback","text":"<pre><code>add_shutdown_callback(callback)\n</code></pre> <p>Add a callback to be called when the bot shuts down.</p> <p>Warning</p> <p>These callbacks will block the bot from shutting down until they complete and any raised errors will lead to a failed shutdown.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>Callable[[Self], Coroutine[Any, Any, None]]</code>)           \u2013            <p>The shutdown callback to add.</p> </li> </ul>"},{"location":"reference/#yuyo.AsgiBot.add_startup_callback","title":"add_startup_callback","text":"<pre><code>add_startup_callback(callback)\n</code></pre> <p>Add a callback to be called when the bot starts up.</p> <p>Warning</p> <p>These callbacks will block the bot from starting until they complete and any raised errors will lead to a failed startup.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>Callable[[Self], Coroutine[Any, Any, None]]</code>)           \u2013            <p>The startup callback to add.</p> </li> </ul>"},{"location":"reference/#yuyo.AsgiBot.close","title":"close  <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Close the bot's REST client.</p> <p>Warning</p> <p>Unless <code>asgi_managed=False</code> is passed to <code>AsgiBot.__init__</code>, the bot will be automatically closed based on the ASGI lifespan events and any other calls to this function will raise a RuntimeError.</p> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If the client isn't alive. If the client is ASGI managed.</p> </li> </ul>"},{"location":"reference/#yuyo.AsgiBot.remove_shutdown_callback","title":"remove_shutdown_callback","text":"<pre><code>remove_shutdown_callback(callback)\n</code></pre> <p>Remove a shutdown callback.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>Callable[[Self], Coroutine[Any, Any, None]]</code>)           \u2013            <p>The shutdown callback to remove.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the callback was not registered.</p> </li> </ul>"},{"location":"reference/#yuyo.AsgiBot.remove_startup_callback","title":"remove_startup_callback","text":"<pre><code>remove_startup_callback(callback)\n</code></pre> <p>Remove a startup callback.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>Callable[[Self], Coroutine[Any, Any, None]]</code>)           \u2013            <p>The startup callback to remove.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the callback was not registered.</p> </li> </ul>"},{"location":"reference/#yuyo.AsgiBot.run","title":"run","text":"<pre><code>run()\n</code></pre> <p>Start the bot's REST client and wait until the bot's closed.</p> <p>Warning</p> <p>Unless <code>asgi_managed=False</code> is passed to AsgiBot.__init__, the bot will be automatically started and closed based on the ASGI lifespan events and any other calls to this function will raise a RuntimeError.</p> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If the client is already alive. If the client is ASGI managed.</p> </li> </ul>"},{"location":"reference/#yuyo.AsgiBot.start","title":"start  <code>async</code>","text":"<pre><code>start()\n</code></pre> <p>Start the bot's REST client.</p> <p>Warning</p> <p>Unless <code>asgi_managed=False</code> is passed to AsgiBot.__init__, the bot will be automatically started based on the ASGI lifespan events and any other calls to this function will raise a RuntimeError.</p> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If the client is already alive. If the client is ASGI managed.</p> </li> </ul>"},{"location":"reference/#yuyo.Backoff","title":"Backoff","text":"<p>Used to exponentially backoff asynchronously.</p> <p>This class acts as an asynchronous iterator and can be iterated over to provide implicit backoff where for every iteration other than the first this will either back off for the time passed to Backoff.set_next_backoff if applicable or a time calculated exponentially.</p> <p>Each iteration yields the current retry count (starting at 0).</p> <p>Examples:</p> <p>An example of using this class as an asynchronous iterator may look like the following</p> <pre><code># While we can directly do `async for _ in Backoff()`, by assigning it to a\n# variable we allow ourself to provide a specific backoff time in some cases.\nbackoff = Backoff()\nasync for _ in backoff:\n    response = await client.fetch(f\"https://example.com/{resource_id}\")\n    if response.status_code == 403:  # Ratelimited\n        # If we have a specific backoff time then set it for the next iteration\n        backoff.set_next_backoff(response.headers.get(\"Retry-After\"))\n\n    elif response.status_code &gt;= 500:  # Internal server error\n        # Else let the iterator calculate an exponential backoff before the next loop.\n        pass\n\n    else:\n        response.raise_for_status()\n        resource = response.json()\n        # We need to break out of the iterator to make sure it doesn't backoff again.\n        # Alternatively `Backoff.finish()` can be called to break out of the loop.\n        break\n</code></pre> <p>Alternatively you may want to explicitly call Backoff.backoff. An alternative implementation of the previous example which uses Backoff.backoff may look like the following:</p> <pre><code>backoff = Backoff()\nresource = None\nwhile not resource:\n    response = await client.fetch(f\"https://example.com/{resource_id}\")\n    if response == 403  # Ratelimited\n        # If we have a specific backoff time then set it for the next iteration.\n        backoff.set_next_backoff(response.headers.get(\"Retry-After\"))\n        await backoff.backoff()  # We must explicitly backoff in this flow.\n\n    elif response &gt;= 500:  # Internal server error\n        # Else let the iterator calculate an exponential backoff and explicitly backoff.\n        await backoff.backoff()\n\n    else:\n        response.raise_for_status()\n        resource = response.json()\n</code></pre>"},{"location":"reference/#yuyo.Backoff.is_depleted","title":"is_depleted  <code>property</code>","text":"<pre><code>is_depleted\n</code></pre> <p>Whether \"max_retries\" has been reached.</p> <p>This can be used to workout whether the loop was explicitly broken out of using Backoff.finish/<code>break</code> or if it hit \"max_retries\".</p>"},{"location":"reference/#yuyo.Backoff.__init__","title":"__init__","text":"<pre><code>__init__(max_retries=None, *, base=2.0, maximum=64.0, jitter_multiplier=1.0, initial_increment=0)\n</code></pre> <p>Initialise a backoff instance.</p> <p>Parameters:</p> <ul> <li> <code>max_retries</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The maximum amount of times this should iterate for between resets.</p> <p>If left as None then this iterator will be unlimited. This must be greater than or equal to 1.</p> </li> <li> <code>base</code>               (<code>float</code>, default:                   <code>2.0</code> )           \u2013            <p>The base to use.</p> </li> <li> <code>maximum</code>               (<code>float</code>, default:                   <code>64.0</code> )           \u2013            <p>The max value the backoff can be in a single iteration. Anything above this will be capped to this base value plus random jitter.</p> </li> <li> <code>jitter_multiplier</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The multiplier for the random jitter.</p> <p>Set to <code>0</code> to disable jitter.</p> </li> <li> <code>initial_increment</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The initial increment to start at.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If an int that's too big to be represented as a float or a non-finite value is passed in place of a field that's annotated as float or if <code>max_retries</code> is less than <code>1</code>.</p> </li> </ul>"},{"location":"reference/#yuyo.Backoff.backoff","title":"backoff  <code>async</code>","text":"<pre><code>backoff()\n</code></pre> <p>Sleep for the provided backoff or for the next exponent.</p> <p>This provides an alternative to iterating over this class.</p> <p>Returns:</p> <ul> <li> <code>int | None</code>           \u2013            <p>Whether this has reached the end of its iteration.</p> <p>If this returns True then that call didn't sleep as this has been marked as finished or has reached the max retries.</p> </li> </ul>"},{"location":"reference/#yuyo.Backoff.finish","title":"finish","text":"<pre><code>finish()\n</code></pre> <p>Mark the iterator as finished to break out of the current loop.</p>"},{"location":"reference/#yuyo.Backoff.reset","title":"reset","text":"<pre><code>reset()\n</code></pre> <p>Reset the backoff to it's original state to reuse it.</p>"},{"location":"reference/#yuyo.Backoff.set_next_backoff","title":"set_next_backoff","text":"<pre><code>set_next_backoff(backoff_)\n</code></pre> <p>Specify a backoff time for the next iteration or Backoff.backoff call.</p> <p>If this is called then the exponent won't be increased for this iteration.</p> <p>Note</p> <p>Calling this multiple times in a single iteration will overwrite any previously set next backoff.</p> <p>Parameters:</p> <ul> <li> <code>backoff_</code>               (<code>float | int | None</code>)           \u2013            <p>The amount of time to backoff for in seconds.</p> <p>If this is None then any previously set next backoff will be unset.</p> </li> </ul>"},{"location":"reference/#yuyo.BotsGGService","title":"BotsGGService","text":"<p>https://discord.bots.gg status update service.</p>"},{"location":"reference/#yuyo.BotsGGService.__init__","title":"__init__","text":"<pre><code>__init__(token)\n</code></pre> <p>Initialise a bots.gg service.</p> <p>Parameters:</p> <ul> <li> <code>token</code>               (<code>str</code>)           \u2013            <p>Authorization token used to update the bot's status.</p> </li> </ul>"},{"location":"reference/#yuyo.ChunkRequestFinishedEvent","title":"ChunkRequestFinishedEvent","text":"<p>               Bases: <code>ShardEvent</code></p> <p>Event that's dispatched when a specific chunk request has finished.</p> <p>This will be fired for every chunk request which has a nonce.</p>"},{"location":"reference/#yuyo.ChunkRequestFinishedEvent.chunk_count","title":"chunk_count  <code>property</code>","text":"<pre><code>chunk_count\n</code></pre> <p>The amount of chunk events which should've been received for this request.</p>"},{"location":"reference/#yuyo.ChunkRequestFinishedEvent.first_received_at","title":"first_received_at  <code>property</code>","text":"<pre><code>first_received_at\n</code></pre> <p>When the first response was received.</p>"},{"location":"reference/#yuyo.ChunkRequestFinishedEvent.guild_id","title":"guild_id  <code>property</code>","text":"<pre><code>guild_id\n</code></pre> <p>Id of the guild this chunk request was for.</p>"},{"location":"reference/#yuyo.ChunkRequestFinishedEvent.last_received_at","title":"last_received_at  <code>property</code>","text":"<pre><code>last_received_at\n</code></pre> <p>When the last response was received.</p>"},{"location":"reference/#yuyo.ChunkRequestFinishedEvent.missed_chunks","title":"missed_chunks  <code>property</code>","text":"<pre><code>missed_chunks\n</code></pre> <p>Collection of the chunk responses which were missed (if any).</p>"},{"location":"reference/#yuyo.ChunkRequestFinishedEvent.not_found_ids","title":"not_found_ids  <code>property</code>","text":"<pre><code>not_found_ids\n</code></pre> <p>Collection of the User IDs which weren't found.</p> <p>This is only relevant when <code>users</code> was specified while requesting the members.</p>"},{"location":"reference/#yuyo.ChunkRequestFinishedEvent.__init__","title":"__init__","text":"<pre><code>__init__(app, shard, data)\n</code></pre> <p>Initialise a chunk request finished event.</p> <p>This should never be initialised directly.</p>"},{"location":"reference/#yuyo.ChunkTracker","title":"ChunkTracker","text":"<p>Chunk payload event tracker.</p> <p>This will dispatch ShardFinishedChunkingEvent, FinishedChunkingEvent and ChunkRequestFinishedEvent events.</p> <p>To configure this to automatically request member chunks to fill a member and/or presence cache on startup and guild join see ChunkTracker.set_auto_chunk_members.</p> <p>Note</p> <p>ChunkTracker.request_guild_members ensures a request will be tracked as this only tracks chunk requests with a set nonce.</p>"},{"location":"reference/#yuyo.ChunkTracker.__init__","title":"__init__","text":"<pre><code>__init__(event_manager, rest, shards, /, *, timeout=datetime.timedelta(seconds=5))\n</code></pre> <p>Initialise a chunk tracker.</p> <p>For a shorthand for initialising this from a hikari.GatewayBotAware see ChunkTracker.from_gateway_bot.</p> <p>Parameters:</p> <ul> <li> <code>event_manager</code>               (<code>EventManager</code>)           \u2013            <p>The event manager this chunk tracker should dispatch events over.</p> </li> <li> <code>rest</code>               (<code>RESTAware</code>)           \u2013            <p>The REST aware object this should use.</p> </li> <li> <code>shards</code>               (<code>ShardAware</code>)           \u2013            <p>The shard aware object this should use.</p> </li> <li> <code>timeout</code>               (<code>int | float | timedelta</code>, default:                   <code>timedelta(seconds=5)</code> )           \u2013            <p>How long this should wait between chunks until deciding the request has finished early/incomplete.</p> </li> </ul>"},{"location":"reference/#yuyo.ChunkTracker.from_gateway_bot","title":"from_gateway_bot  <code>classmethod</code>","text":"<pre><code>from_gateway_bot(bot, /, *, timeout=datetime.timedelta(seconds=5))\n</code></pre> <p>Initialise a chunk tracker from a gateway bot.</p> <p>Parameters:</p> <ul> <li> <code>bot</code>               (<code>ShardAware &amp; RESTAware &amp; EventManagerAware</code>)           \u2013            <p>The gateway bot this chunk tracker should use.</p> </li> <li> <code>timeout</code>               (<code>int | float | timedelta</code>, default:                   <code>timedelta(seconds=5)</code> )           \u2013            <p>How long this should wait between chunks until deciding the request has finished early/incomplete.</p> </li> </ul>"},{"location":"reference/#yuyo.ChunkTracker.request_guild_members","title":"request_guild_members  <code>async</code>","text":"<pre><code>request_guild_members(guild, /, *, include_presences=hikari.UNDEFINED, query='', limit=0, users=hikari.UNDEFINED)\n</code></pre> <p>Request guild members.</p> <p>Note</p> <p>To request the full list of members, leave <code>query</code> as <code>\"\"</code> (empty string) and <code>limit</code> as <code>0</code>.</p> <p>Parameters:</p> <ul> <li> <code>guild</code>               (<code>SnowflakeishOr[PartialGuild]</code>)           \u2013            <p>The guild to request chunk for.</p> </li> <li> <code>include_presences</code>               (<code>UndefinedOr[bool]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, whether to request presences.</p> </li> <li> <code>query</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>If not <code>\"\"</code>, request the members who's usernames starts with the string.</p> </li> <li> <code>limit</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Maximum number of members to send matching the query.</p> </li> <li> <code>users</code>               (<code>UndefinedOr[SnowflakeishSequence[User]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the users to request for.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>When trying to specify <code>users</code> with <code>query</code>/<code>limit</code>, if <code>limit</code> is not between 0 and 100, both inclusive or if <code>users</code> length is over 100.</p> </li> <li> <code>MissingIntentError</code>             \u2013            <p>When trying to request presences without the <code>GUILD_MEMBERS</code> or when trying to request the full list of members without <code>GUILD_PRESENCES</code>.</p> </li> </ul>"},{"location":"reference/#yuyo.ChunkTracker.set_auto_chunk_members","title":"set_auto_chunk_members","text":"<pre><code>set_auto_chunk_members(state, /, *, chunk_presences=True)\n</code></pre> <p>Configure whether this should request member chunks in response to GUILD_CREATE.</p> <p>This may be useful for filling 3rd party caches but may conflict with the <code>auto_chunk_members</code> config of hikari.impl.GatewayBot if it's enabled.</p> <p>Warning</p> <p>This will be ignored if Intents.GUILD_MEMBERS hasn't been declared.</p> <p>Parameters:</p> <ul> <li> <code>state</code>               (<code>bool</code>)           \u2013            <p>Whether this should request member chunks when GUILD_CREATE events are received.</p> </li> <li> <code>chunk_presences</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether this should also request member presences on these member chunks.</p> <p>This will be ignored if Intents.GUILD_PRESENCES hasn't been declared.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The chunk tracker object to enable call chaining.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentClient","title":"ComponentClient","text":"<p>Client used to handle component executors within a REST or gateway flow.</p>"},{"location":"reference/#yuyo.ComponentClient._executors","title":"_executors  <code>instance-attribute</code>","text":"<pre><code>_executors = {}\n</code></pre> <p>Dict of custom IDs to executors.</p>"},{"location":"reference/#yuyo.ComponentClient._message_executors","title":"_message_executors  <code>instance-attribute</code>","text":"<pre><code>_message_executors = {}\n</code></pre> <p>Dict of message IDs to executors.</p>"},{"location":"reference/#yuyo.ComponentClient.alluka","title":"alluka  <code>property</code>","text":"<pre><code>alluka\n</code></pre> <p>The Alluka client being used for callback dependency injection.</p>"},{"location":"reference/#yuyo.ComponentClient.cache","title":"cache  <code>property</code>","text":"<pre><code>cache\n</code></pre> <p>Hikari cache instance this client was initialised with.</p>"},{"location":"reference/#yuyo.ComponentClient.events","title":"events  <code>property</code>","text":"<pre><code>events\n</code></pre> <p>Object of the event manager this client was initialised with.</p>"},{"location":"reference/#yuyo.ComponentClient.rest","title":"rest  <code>property</code>","text":"<pre><code>rest\n</code></pre> <p>Object of the Hikari REST client this client was initialised with.</p>"},{"location":"reference/#yuyo.ComponentClient.server","title":"server  <code>property</code>","text":"<pre><code>server\n</code></pre> <p>Object of the Hikari interaction server provided for this client.</p>"},{"location":"reference/#yuyo.ComponentClient.shards","title":"shards  <code>property</code>","text":"<pre><code>shards\n</code></pre> <p>Object of the Hikari shard manager this client was initialised with.</p>"},{"location":"reference/#yuyo.ComponentClient.voice","title":"voice  <code>property</code>","text":"<pre><code>voice\n</code></pre> <p>Object of the Hikari voice component this client was initialised with.</p>"},{"location":"reference/#yuyo.ComponentClient.__init__","title":"__init__","text":"<pre><code>__init__(*, alluka=None, cache=None, event_manager=None, event_managed=None, rest=None, server=None, shards=None, voice=None)\n</code></pre> <p>Initialise a component client.</p> <p>This sets ComponentClient as a type dependency when <code>alluka</code> isn't passed.</p> <p>Note</p> <p>For an easier way to initialise the client from a bot see ComponentClient.from_gateway_bot, ComponentClient.from_rest_bot, and ComponentClient.from_tanjun.</p> <p>Parameters:</p> <ul> <li> <code>alluka</code>               (<code>Client | None</code>, default:                   <code>None</code> )           \u2013            <p>The Alluka client to use for callback dependency injection in this client.</p> <p>If not provided then this will initialise its own Alluka client.</p> </li> <li> <code>event_manager</code>               (<code>EventManager | None</code>, default:                   <code>None</code> )           \u2013            <p>The event manager this client should listen to dispatched component interactions from if applicable.</p> </li> <li> <code>event_managed</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether this client should be automatically opened and closed based on the lifetime events dispatched by <code>event_manager</code>.</p> <p>Defaults to True if an event manager is passed.</p> </li> <li> <code>server</code>               (<code>InteractionServer | None</code>, default:                   <code>None</code> )           \u2013            <p>The server this client should listen to component interactions from if applicable.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>event_managed</code> is passed as True when <code>event_manager</code> is None.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentClient.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Close the component client.</p>"},{"location":"reference/#yuyo.ComponentClient.deregister_executor","title":"deregister_executor","text":"<pre><code>deregister_executor(executor)\n</code></pre> <p>Remove a component executor by its custom IDs.</p> <p>Parameters:</p> <ul> <li> <code>executor</code>               (<code>AbstractComponentExecutor</code>)           \u2013            <p>The executor to remove.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The component client to allow chaining.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>If the executor isn't registered.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentClient.deregister_message","title":"deregister_message","text":"<pre><code>deregister_message(message)\n</code></pre> <p>Remove a component executor by its message.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>SnowflakeishOr[Message]</code>)           \u2013            <p>The message to remove the executor for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The component client to allow chaining.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>If the message is not registered.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentClient.from_gateway_bot","title":"from_gateway_bot  <code>classmethod</code>","text":"<pre><code>from_gateway_bot(bot, /, *, alluka=None, event_managed=True)\n</code></pre> <p>Build a component client from a Gateway Bot.</p> <p>This sets ComponentClient as a type dependency when <code>alluka</code> isn't passed.</p> <p>Parameters:</p> <ul> <li> <code>bot</code>               (<code>_GatewayBotProto</code>)           \u2013            <p>The Gateway bot this component client should be bound to.</p> </li> <li> <code>alluka</code>               (<code>Client | None</code>, default:                   <code>None</code> )           \u2013            <p>The Alluka client to use for callback dependency injection in this client.</p> <p>If not provided then this will initialise its own Alluka client.</p> </li> <li> <code>event_managed</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the component client should be automatically opened and closed based on the lifetime events dispatched by <code>bot</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ComponentClient</code>           \u2013            <p>The initialised component client.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentClient.from_rest_bot","title":"from_rest_bot  <code>classmethod</code>","text":"<pre><code>from_rest_bot(bot, /, *, alluka=None, bot_managed=False)\n</code></pre> <p>Build a component client from a REST Bot.</p> <p>This sets ComponentClient as a type dependency when <code>alluka</code> isn't passed.</p> <p>Parameters:</p> <ul> <li> <code>bot</code>               (<code>RESTBotAware</code>)           \u2013            <p>The REST bot this component client should be bound to.</p> </li> <li> <code>alluka</code>               (<code>Client | None</code>, default:                   <code>None</code> )           \u2013            <p>The Alluka client to use for callback dependency injection in this client.</p> <p>If not provided then this will initialise its own Alluka client.</p> </li> <li> <code>bot_managed</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the component client should be automatically opened and closed based on the Bot's startup and shutdown callbacks.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ComponentClient</code>           \u2013            <p>The initialised component client.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentClient.from_tanjun","title":"from_tanjun  <code>classmethod</code>","text":"<pre><code>from_tanjun(tanjun_client, /, *, tanjun_managed=True)\n</code></pre> <p>Build a component client from a Tanjun client.</p> <p>This will use the Tanjun client's alluka client and registers ComponentClient as a type dependency on Tanjun.</p> <p>Parameters:</p> <ul> <li> <code>tanjun_client</code>               (<code>Client</code>)           \u2013            <p>The Tanjun client this component client should be bound to.</p> </li> <li> <code>tanjun_managed</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the component client should be automatically opened and closed based on the Tanjun client's lifetime client callback.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ComponentClient</code>           \u2013            <p>The initialised component client.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentClient.get_executor","title":"get_executor","text":"<pre><code>get_executor(custom_id)\n</code></pre> <p>Get the component executor registered for a custom ID.</p> <p>Note</p> <p>For message scoped executors use get_executor_for_message. as they will not be returned here.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str</code>)           \u2013            <p>The custom ID to get the executor for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AbstractComponentExecutor | None</code>           \u2013            <p>The executor set for the custom ID or None if none is set.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentClient.get_executor_for_message","title":"get_executor_for_message","text":"<pre><code>get_executor_for_message(message)\n</code></pre> <p>Get the component executor registered for a message.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>SnowflakeishOr[Message]</code>)           \u2013            <p>The message to get the executor for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AbstractComponentExecutor | None</code>           \u2013            <p>The executor set for the message or None if none is set.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentClient.on_gateway_event","title":"on_gateway_event  <code>async</code>","text":"<pre><code>on_gateway_event(event)\n</code></pre> <p>Process an interaction create gateway event.</p> <p>Parameters:</p> <ul> <li> <code>event</code>               (<code>InteractionCreateEvent</code>)           \u2013            <p>The interaction create gateway event to process.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentClient.on_rest_request","title":"on_rest_request  <code>async</code>","text":"<pre><code>on_rest_request(interaction)\n</code></pre> <p>Process a component interaction REST request.</p> <p>Parameters:</p> <ul> <li> <code>interaction</code>               (<code>ComponentInteraction</code>)           \u2013            <p>The interaction to process.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ResponseT</code>           \u2013            <p>The REST response.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentClient.open","title":"open","text":"<pre><code>open()\n</code></pre> <p>Startup the component client.</p>"},{"location":"reference/#yuyo.ComponentClient.register_executor","title":"register_executor","text":"<pre><code>register_executor(executor, /, *, message=None, timeout=_internal.NO_DEFAULT)\n</code></pre> <p>Add an executor to this client.</p> <p>Parameters:</p> <ul> <li> <code>executor</code>               (<code>AbstractComponentExecutor</code>)           \u2013            <p>The executor to register.</p> </li> <li> <code>message</code>               (<code>SnowflakeishOr[Message] | None</code>, default:                   <code>None</code> )           \u2013            <p>The message to register this executor for.</p> <p>If this is left as None then this executor will be registered globally for its custom IDs.</p> </li> <li> <code>timeout</code>               (<code>AbstractTimeout | None | NoDefault</code>, default:                   <code>NO_DEFAULT</code> )           \u2013            <p>The executor's timeout.</p> <p>This defaults to a 30 second sliding timeout.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The component client to allow chaining.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>message</code> is already registered when it's passed.</p> <p>If any of the executor's custom IDs are already registered when <code>message</code> wasn't passed.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentContext","title":"ComponentContext","text":"<p>               Bases: <code>BaseContext[ComponentInteraction]</code></p> <p>The context used for message component triggers.</p>"},{"location":"reference/#yuyo.ComponentContext.alluka","title":"alluka  <code>property</code>","text":"<pre><code>alluka\n</code></pre> <p>The Alluka client being used for callback dependency injection.</p>"},{"location":"reference/#yuyo.ComponentContext.author","title":"author  <code>property</code>","text":"<pre><code>author\n</code></pre> <p>Author of this interaction.</p>"},{"location":"reference/#yuyo.ComponentContext.cache","title":"cache  <code>property</code>","text":"<pre><code>cache\n</code></pre> <p>Hikari cache instance this context's client was initialised with.</p>"},{"location":"reference/#yuyo.ComponentContext.channel_id","title":"channel_id  <code>property</code>","text":"<pre><code>channel_id\n</code></pre> <p>ID of the channel this interaction was triggered in.</p>"},{"location":"reference/#yuyo.ComponentContext.client","title":"client  <code>property</code>","text":"<pre><code>client\n</code></pre> <p>The component client this context is bound to.</p>"},{"location":"reference/#yuyo.ComponentContext.events","title":"events  <code>property</code>","text":"<pre><code>events\n</code></pre> <p>Object of the event manager this context's client was initialised with.</p>"},{"location":"reference/#yuyo.ComponentContext.expires_at","title":"expires_at  <code>property</code>","text":"<pre><code>expires_at\n</code></pre> <p>When this context expires.</p> <p>After this time is reached, the message/response methods on this context will always raise hikari.NotFoundError.</p>"},{"location":"reference/#yuyo.ComponentContext.has_been_deferred","title":"has_been_deferred  <code>property</code>","text":"<pre><code>has_been_deferred\n</code></pre> <p>Whether this context's initial response has been deferred.</p> <p>This will be true if BaseContext.defer has been called.</p>"},{"location":"reference/#yuyo.ComponentContext.has_responded","title":"has_responded  <code>property</code>","text":"<pre><code>has_responded\n</code></pre> <p>Whether an initial response has been made to this context yet.</p> <p>It's worth noting that a context must be either responded to or deferred within 3 seconds from it being received otherwise it'll be marked as failed.</p> <p>This will be true if either BaseContext.respond, BaseContext.create_initial_response or BaseContext.edit_initial_response (after a deferral) has been called.</p>"},{"location":"reference/#yuyo.ComponentContext.id_match","title":"id_match  <code>property</code>","text":"<pre><code>id_match\n</code></pre> <p>Section of the ID used to identify the relevant executor.</p>"},{"location":"reference/#yuyo.ComponentContext.id_metadata","title":"id_metadata  <code>property</code>","text":"<pre><code>id_metadata\n</code></pre> <p>Metadata from the interaction's custom ID.</p>"},{"location":"reference/#yuyo.ComponentContext.interaction","title":"interaction  <code>property</code>","text":"<pre><code>interaction\n</code></pre> <p>Object of the interaction this context is for.</p>"},{"location":"reference/#yuyo.ComponentContext.rest","title":"rest  <code>property</code>","text":"<pre><code>rest\n</code></pre> <p>Object of the Hikari REST client this context's client was initialised with.</p>"},{"location":"reference/#yuyo.ComponentContext.selected_channels","title":"selected_channels  <code>property</code>","text":"<pre><code>selected_channels\n</code></pre> <p>Sequence of the users passed for a channel select menu.</p>"},{"location":"reference/#yuyo.ComponentContext.selected_members","title":"selected_members  <code>property</code>","text":"<pre><code>selected_members\n</code></pre> <p>Sequence of the members passed for a user select menu.</p> <p>This will also include some of the values for a mentionable select menu.</p>"},{"location":"reference/#yuyo.ComponentContext.selected_roles","title":"selected_roles  <code>property</code>","text":"<pre><code>selected_roles\n</code></pre> <p>Sequence of the users passed for a role select menu.</p> <p>This will also include some of the values for a mentionable select menu.</p>"},{"location":"reference/#yuyo.ComponentContext.selected_texts","title":"selected_texts  <code>property</code>","text":"<pre><code>selected_texts\n</code></pre> <p>Sequence of the values passed for a text select menu.</p>"},{"location":"reference/#yuyo.ComponentContext.selected_users","title":"selected_users  <code>property</code>","text":"<pre><code>selected_users\n</code></pre> <p>Sequence of the users passed for a user select menu.</p> <p>This will also include some of the values for a mentionable select menu.</p> <p>ComponentContext.selected_members has the full member objects.</p>"},{"location":"reference/#yuyo.ComponentContext.server","title":"server  <code>property</code>","text":"<pre><code>server\n</code></pre> <p>Object of the Hikari interaction server provided for this context's client.</p>"},{"location":"reference/#yuyo.ComponentContext.shard","title":"shard  <code>property</code>","text":"<pre><code>shard\n</code></pre> <p>Shard that triggered the interaction.</p> <p>Note</p> <p>This will be None if BaseContext.shards is also None.</p>"},{"location":"reference/#yuyo.ComponentContext.shards","title":"shards  <code>property</code>","text":"<pre><code>shards\n</code></pre> <p>Object of the Hikari shard manager this context's client was initialised with.</p>"},{"location":"reference/#yuyo.ComponentContext.voice","title":"voice  <code>property</code>","text":"<pre><code>voice\n</code></pre> <p>Object of the Hikari voice component this context's client was initialised with.</p>"},{"location":"reference/#yuyo.ComponentContext.create_followup","title":"create_followup  <code>async</code>","text":"<pre><code>create_followup(content=hikari.UNDEFINED, *, delete_after=None, ephemeral=None, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, mentions_everyone=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED, tts=hikari.UNDEFINED, flags=hikari.UNDEFINED)\n</code></pre> <p>Create a followup response for this context.</p> <p>Warning</p> <p>Calling this on a context which hasn't had an initial response yet will lead to a hikari.NotFoundError being raised.</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>UndefinedOr[Any]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message content to send.</p> <p>If this is a hikari.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead be treated as an embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> </li> <li> <code>delete_after</code>               (<code>timedelta | float | int | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, the seconds after which the response message should be deleted.</p> <p>Interaction responses can only be deleted within 15 minutes of the interaction being received.</p> </li> <li> <code>ephemeral</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether the deferred response should be ephemeral. Passing True here is a shorthand for including <code>1 &lt;&lt; 64</code> in the passed flags.</p> </li> <li> <code>attachment</code>               (<code>UndefinedOr[Resourceish]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.</p> </li> <li> <code>attachments</code>               (<code>UndefinedOr[Sequence[Resourceish]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.</p> </li> <li> <code>component</code>               (<code>UndefinedOr[ComponentBuilder]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, builder object of the component to include in this message.</p> </li> <li> <code>components</code>               (<code>UndefinedOr[Sequence[ComponentBuilder]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, a sequence of the component builder objects to include in this message.</p> </li> <li> <code>embed</code>               (<code>UndefinedOr[Embed]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message embed.</p> </li> <li> <code>embeds</code>               (<code>UndefinedOr[Sequence[Embed]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message embeds.</p> </li> <li> <code>mentions_everyone</code>               (<code>UndefinedOr[bool]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, whether the message should parse @everyone/@here mentions.</p> </li> <li> <code>user_mentions</code>               (<code>SnowflakeishSequence[PartialUser] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialUser derivatives to enforce mentioning specific users.</p> </li> <li> <code>role_mentions</code>               (<code>SnowflakeishSequence[PartialRole] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialRole derivatives to enforce mentioning specific roles.</p> </li> <li> <code>tts</code>               (<code>UndefinedOr[bool]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, whether the message will be sent as a TTS message.</p> </li> <li> <code>flags</code>               (<code>UndefinedType | int | MessageFlag</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The flags to set for this response.</p> <p>As of writing this can only flag which can be provided is EPHEMERAL, other flags are just ignored.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Message</code>           \u2013            <p>The created message object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NotFoundError</code>             \u2013            <p>If the current interaction is not found or it hasn't had an initial response yet.</p> </li> <li> <code>BadRequestError</code>             \u2013            <p>This can be raised if the file is too large; if the embed exceeds the defined limits; if the message content is specified only and empty or greater than <code>2000</code> characters; if neither content, file or embeds are specified. If any invalid snowflake IDs are passed; a snowflake may be invalid due to it being outside of the range of a 64 bit integer.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If more than 100 unique objects/entities are passed for <code>role_mentions</code> or `user_mentions.</p> <p>If the interaction will have expired before <code>delete_after</code> is reached.</p> <p>If both <code>attachment</code> and <code>attachments</code> are passed or both <code>component</code> and <code>components</code> are passed or both <code>embed</code> and <code>embeds</code> are passed.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentContext.create_initial_response","title":"create_initial_response  <code>async</code>","text":"<pre><code>create_initial_response(content=hikari.UNDEFINED, *, response_type=hikari.ResponseType.MESSAGE_CREATE, delete_after=None, ephemeral=None, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, mentions_everyone=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED, flags=hikari.UNDEFINED, tts=hikari.UNDEFINED)\n</code></pre> <p>Create the initial response for this context.</p> <p>Warning</p> <p>Calling this on a context which already has an initial response will result in this raising a hikari.NotFoundError. This includes if the REST interaction server has already responded to the request and deferrals.</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>UndefinedOr[Any]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message content to respond with.</p> <p>If this is a hikari.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead be treated as an embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> </li> <li> <code>response_type</code>               (<code>MessageResponseTypesT</code>, default:                   <code>MESSAGE_CREATE</code> )           \u2013            <p>The type of message response to give.</p> </li> <li> <code>delete_after</code>               (<code>timedelta | float | int | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, the seconds after which the response message should be deleted.</p> <p>Interaction responses can only be deleted within 15 minutes of the interaction being received.</p> </li> <li> <code>ephemeral</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether the deferred response should be ephemeral.</p> <p>Passing True here is a shorthand for including <code>1 &lt;&lt; 64</code> in the passed flags.</p> </li> <li> <code>attachment</code>               (<code>UndefinedOr[Resourceish]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.</p> </li> <li> <code>attachments</code>               (<code>UndefinedOr[Sequence[Resourceish]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.</p> </li> <li> <code>component</code>               (<code>UndefinedOr[ComponentBuilder]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, builder object of the component to include in this message.</p> </li> <li> <code>components</code>               (<code>UndefinedOr[Sequence[ComponentBuilder]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, a sequence of the component builder objects to include in this message.</p> </li> <li> <code>embed</code>               (<code>UndefinedOr[Embed]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message embed.</p> </li> <li> <code>embeds</code>               (<code>UndefinedOr[Sequence[Embed]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message embeds.</p> </li> <li> <code>flags</code>               (<code>int | MessageFlag | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message flags this response should have.</p> <p>As of writing the only message flag which can be set here is MessageFlag.EPHEMERAL.</p> </li> <li> <code>tts</code>               (<code>UndefinedOr[bool]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, whether the message will be read out by a screen reader using Discord's TTS (text-to-speech) system.</p> </li> <li> <code>mentions_everyone</code>               (<code>UndefinedOr[bool]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, whether the message should parse @everyone/@here mentions.</p> </li> <li> <code>user_mentions</code>               (<code>SnowflakeishSequence[PartialUser] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialUser derivatives to enforce mentioning specific users.</p> </li> <li> <code>role_mentions</code>               (<code>SnowflakeishSequence[PartialRole] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialRole derivatives to enforce mentioning specific roles.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If more than 100 unique objects/entities are passed for <code>role_mentions</code> or <code>user_mentions</code>.</p> <p>If the interaction will have expired before <code>delete_after</code> is reached.</p> <p>If both <code>attachment</code> and <code>attachments</code> are passed or both <code>component</code> and <code>components</code> are passed or both <code>embed</code> and <code>embeds</code> are passed.</p> </li> <li> <code>BadRequestError</code>             \u2013            <p>This may be raised in several discrete situations, such as messages being empty with no embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; invalid image URLs in embeds.</p> </li> <li> <code>UnauthorizedError</code>             \u2013            <p>If you are unauthorized to make the request (invalid/missing token).</p> </li> <li> <code>NotFoundError</code>             \u2013            <p>If the interaction is not found or if the interaction's initial response has already been created.</p> </li> <li> <code>RateLimitTooLongError</code>             \u2013            <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> </li> <li> <code>InternalServerError</code>             \u2013            <p>If an internal error occurs on Discord while handling the request.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentContext.create_modal_response","title":"create_modal_response  <code>async</code>","text":"<pre><code>create_modal_response(title, custom_id, /, *, component=hikari.UNDEFINED, components=hikari.UNDEFINED)\n</code></pre> <p>Send a modal as the initial response for this context.</p> <p>Warning</p> <p>This must be called as the first response to a context before any deferring.</p> <p>Parameters:</p> <ul> <li> <code>title</code>               (<code>str</code>)           \u2013            <p>The title that will show up in the modal.</p> </li> <li> <code>custom_id</code>               (<code>str</code>)           \u2013            <p>Developer set custom ID used for identifying interactions with this modal.</p> <p>Yuyo's Component client will only match against <code>custom_id.split(\":\", 1)[0]</code>, allowing metadata to be put after <code>\":\"</code>.</p> </li> <li> <code>component</code>               (<code>UndefinedOr[ComponentBuilder]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A component builder to send in this modal.</p> </li> <li> <code>components</code>               (<code>UndefinedOr[Sequence[ComponentBuilder]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A sequence of component builders to send in this modal.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If both <code>component</code> and <code>components</code> are specified or if none are specified.</p> </li> <li> <code>BadRequestError</code>             \u2013            <p>When the requests' data is outside Discord's accept ranges/validation.</p> </li> <li> <code>UnauthorizedError</code>             \u2013            <p>If you are unauthorized to make the request (invalid/missing token).</p> </li> <li> <code>NotFoundError</code>             \u2013            <p>If the interaction is not found or if the interaction's initial response has already been created or deferred.</p> </li> <li> <code>RateLimitTooLongError</code>             \u2013            <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> </li> <li> <code>InternalServerError</code>             \u2013            <p>If an internal error occurs on Discord while handling the request.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentContext.defer","title":"defer  <code>async</code>","text":"<pre><code>defer(*, defer_type=hikari.ResponseType.DEFERRED_MESSAGE_CREATE, ephemeral=None, flags=hikari.UNDEFINED)\n</code></pre> <p>Defer the initial response for this context.</p> <p>Note</p> <p>The ephemeral state of the first response is decided by whether the deferral is ephemeral.</p> <p>Parameters:</p> <ul> <li> <code>defer_type</code>               (<code>DeferredResponseTypesT</code>, default:                   <code>DEFERRED_MESSAGE_CREATE</code> )           \u2013            <p>The type of deferral this should be.</p> <p>This may any of the following:</p> <ul> <li>ResponseType.DEFERRED_MESSAGE_CREATE     to indicate that the following up call to     BaseContext.edit_initial_response     or BaseContext.respond     should create a new message.</li> <li>ResponseType.DEFERRED_MESSAGE_UPDATE     to indicate that the following call to the aforementioned     methods should update the existing message.</li> </ul> </li> <li> <code>ephemeral</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether the deferred response should be ephemeral.</p> <p>Passing True here is a shorthand for including <code>1 &lt;&lt; 64</code> in the passed flags.</p> </li> <li> <code>flags</code>               (<code>UndefinedType | int | MessageFlag</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The flags to use for the initial response.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentContext.delete_initial_response","title":"delete_initial_response  <code>async</code>","text":"<pre><code>delete_initial_response()\n</code></pre> <p>Delete the initial response after invoking this context.</p> <p>Raises:</p> <ul> <li> <code>(LookupError, NotFoundError)</code>             \u2013            <p>The last context has no initial response.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentContext.delete_last_response","title":"delete_last_response  <code>async</code>","text":"<pre><code>delete_last_response()\n</code></pre> <p>Delete the last response after invoking this context.</p> <p>Raises:</p> <ul> <li> <code>(LookupError, NotFoundError)</code>             \u2013            <p>The last context has no responses.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentContext.edit_initial_response","title":"edit_initial_response  <code>async</code>","text":"<pre><code>edit_initial_response(content=hikari.UNDEFINED, *, delete_after=None, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, mentions_everyone=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED)\n</code></pre> <p>Edit the initial response for this context.</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>UndefinedOr[Any]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message content to edit the initial response with.</p> <p>If this is a hikari.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> </li> <li> <code>delete_after</code>               (<code>timedelta | float | int | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, the seconds after which the response message should be deleted.</p> <p>Interaction responses can only be deleted within 15 minutes of the interaction being received.</p> </li> <li> <code>attachment</code>               (<code>UndefinedNoneOr[Resourceish]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A singular attachment to edit the initial response with.</p> </li> <li> <code>attachments</code>               (<code>UndefinedNoneOr[Sequence[Resourceish]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A sequence of attachments to edit the initial response with.</p> </li> <li> <code>component</code>               (<code>UndefinedNoneOr[ComponentBuilder]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, builder object of the component to set for this message. This component will replace any previously set components and passing None will remove all components.</p> </li> <li> <code>components</code>               (<code>UndefinedNoneOr[Sequence[ComponentBuilder]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing None or an empty sequence will remove all components.</p> </li> <li> <code>embed</code>               (<code>UndefinedNoneOr[Embed]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>An embed to replace the initial response with.</p> </li> <li> <code>embeds</code>               (<code>UndefinedNoneOr[Sequence[Embed]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A sequence of embeds to replace the initial response with.</p> </li> <li> <code>mentions_everyone</code>               (<code>UndefinedOr[bool]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, whether the message should parse @everyone/@here mentions.</p> </li> <li> <code>user_mentions</code>               (<code>SnowflakeishSequence[PartialUser] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialUser derivatives to enforce mentioning specific users.</p> </li> <li> <code>role_mentions</code>               (<code>SnowflakeishSequence[PartialRole] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialRole derivatives to enforce mentioning specific roles.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Message</code>           \u2013            <p>The message that has been edited.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If more than 100 unique objects/entities are passed for <code>role_mentions</code> or <code>user_mentions</code>.</p> <p>If <code>delete_after</code> would be more than 15 minutes after the interaction was received.</p> <p>If both <code>attachment</code> and <code>attachments</code> are passed or both <code>component</code> and <code>components</code> are passed or both <code>embed</code> and <code>embeds</code> are passed.</p> </li> <li> <code>BadRequestError</code>             \u2013            <p>This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components.</p> </li> <li> <code>UnauthorizedError</code>             \u2013            <p>If you are unauthorized to make the request (invalid/missing token).</p> </li> <li> <code>ForbiddenError</code>             \u2013            <p>If you are missing the <code>SEND_MESSAGES</code> in the channel or the person you are trying to message has the DM's disabled.</p> </li> <li> <code>NotFoundError</code>             \u2013            <p>If the channel is not found.</p> </li> <li> <code>RateLimitTooLongError</code>             \u2013            <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> </li> <li> <code>InternalServerError</code>             \u2013            <p>If an internal error occurs on Discord while handling the request.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentContext.edit_last_response","title":"edit_last_response  <code>async</code>","text":"<pre><code>edit_last_response(content=hikari.UNDEFINED, *, delete_after=None, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, mentions_everyone=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED)\n</code></pre> <p>Edit the last response for this context.</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>UndefinedOr[Any]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the content to edit the last response with.</p> <p>If this is a hikari.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> </li> <li> <code>delete_after</code>               (<code>timedelta | float | int | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, the seconds after which the response message should be deleted.</p> <p>Interaction responses can only be deleted within 15 minutes of the interaction being received.</p> </li> <li> <code>attachment</code>               (<code>UndefinedNoneOr[Resourceish]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A singular attachment to edit the last response with.</p> </li> <li> <code>attachments</code>               (<code>UndefinedNoneOr[Sequence[Resourceish]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A sequence of attachments to edit the last response with.</p> </li> <li> <code>component</code>               (<code>UndefinedNoneOr[ComponentBuilder]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, builder object of the component to set for this message. This component will replace any previously set components and passing None will remove all components.</p> </li> <li> <code>components</code>               (<code>UndefinedNoneOr[Sequence[ComponentBuilder]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing None or an empty sequence will remove all components.</p> </li> <li> <code>embed</code>               (<code>UndefinedNoneOr[Embed]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>An embed to replace the last response with.</p> </li> <li> <code>embeds</code>               (<code>UndefinedNoneOr[Sequence[Embed]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A sequence of embeds to replace the last response with.</p> </li> <li> <code>mentions_everyone</code>               (<code>UndefinedOr[bool]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, whether the message should parse @everyone/@here mentions.</p> </li> <li> <code>user_mentions</code>               (<code>SnowflakeishSequence[PartialUser] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialUser derivatives to enforce mentioning specific users.</p> </li> <li> <code>role_mentions</code>               (<code>SnowflakeishSequence[PartialRole] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialRole derivatives to enforce mentioning specific roles.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Message</code>           \u2013            <p>The message that has been edited.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If more than 100 unique objects/entities are passed for <code>role_mentions</code> or <code>user_mentions</code>.</p> <p>If <code>delete_after</code> would be more than 15 minutes after the slash interaction was received.</p> <p>If both <code>attachment</code> and <code>attachments</code> are passed or both <code>component</code> and <code>components</code> are passed or both <code>embed</code> and <code>embeds</code> are passed.</p> </li> <li> <code>BadRequestError</code>             \u2013            <p>This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components.</p> </li> <li> <code>UnauthorizedError</code>             \u2013            <p>If you are unauthorized to make the request (invalid/missing token).</p> </li> <li> <code>ForbiddenError</code>             \u2013            <p>If you are missing the <code>SEND_MESSAGES</code> in the channel or the person you are trying to message has the DM's disabled.</p> </li> <li> <code>NotFoundError</code>             \u2013            <p>If the channel is not found.</p> </li> <li> <code>RateLimitTooLongError</code>             \u2013            <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> </li> <li> <code>InternalServerError</code>             \u2013            <p>If an internal error occurs on Discord while handling the request.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentContext.fetch_initial_response","title":"fetch_initial_response  <code>async</code>","text":"<pre><code>fetch_initial_response()\n</code></pre> <p>Fetch the initial response for this context.</p> <p>Returns:</p> <ul> <li> <code>Message</code>           \u2013            <p>The initial response's message object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>(LookupError, NotFoundError)</code>             \u2013            <p>The response was not found.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentContext.fetch_last_response","title":"fetch_last_response  <code>async</code>","text":"<pre><code>fetch_last_response()\n</code></pre> <p>Fetch the last response for this context.</p> <p>Returns:</p> <ul> <li> <code>Message</code>           \u2013            <p>The most response response's message object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>(LookupError, NotFoundError)</code>             \u2013            <p>The response was not found.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentContext.respond","title":"respond  <code>async</code>","text":"<pre><code>respond(content: UndefinedOr[Any] = hikari.UNDEFINED, *, ensure_result: Literal[True], delete_after: timedelta | float | int | None = None, attachment: UndefinedOr[Resourceish] = hikari.UNDEFINED, attachments: UndefinedOr[Sequence[Resourceish]] = hikari.UNDEFINED, component: UndefinedOr[ComponentBuilder] = hikari.UNDEFINED, components: UndefinedOr[Sequence[ComponentBuilder]] = hikari.UNDEFINED, embed: UndefinedOr[Embed] = hikari.UNDEFINED, embeds: UndefinedOr[Sequence[Embed]] = hikari.UNDEFINED, mentions_everyone: UndefinedOr[bool] = hikari.UNDEFINED, user_mentions: SnowflakeishSequence[PartialUser] | bool | UndefinedType = hikari.UNDEFINED, role_mentions: SnowflakeishSequence[PartialRole] | bool | UndefinedType = hikari.UNDEFINED) -&gt; hikari.Message\n</code></pre><pre><code>respond(content: UndefinedOr[Any] = hikari.UNDEFINED, *, ensure_result: bool = False, delete_after: timedelta | float | int | None = None, attachment: UndefinedOr[Resourceish] = hikari.UNDEFINED, attachments: UndefinedOr[Sequence[Resourceish]] = hikari.UNDEFINED, component: UndefinedOr[ComponentBuilder] = hikari.UNDEFINED, components: UndefinedOr[Sequence[ComponentBuilder]] = hikari.UNDEFINED, embed: UndefinedOr[Embed] = hikari.UNDEFINED, embeds: UndefinedOr[Sequence[Embed]] = hikari.UNDEFINED, mentions_everyone: UndefinedOr[bool] = hikari.UNDEFINED, user_mentions: SnowflakeishSequence[PartialUser] | bool | UndefinedType = hikari.UNDEFINED, role_mentions: SnowflakeishSequence[PartialRole] | bool | UndefinedType = hikari.UNDEFINED) -&gt; hikari.Message | None\n</code></pre> <pre><code>respond(content=hikari.UNDEFINED, *, ensure_result=False, delete_after=None, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, mentions_everyone=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED)\n</code></pre> <p>Respond to this context.</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>UndefinedOr[Any]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message content to respond with.</p> <p>If this is a hikari.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead be treated as an embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> </li> <li> <code>ensure_result</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Ensure that this call will always return a message object.</p> <p>If True then this will always return hikari.Message, otherwise this will return <code>hikari.Message | None</code>.</p> <p>It's worth noting that this may lead to an extre request being made under certain scenarios.</p> </li> <li> <code>delete_after</code>               (<code>timedelta | float | int | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, the seconds after which the response message should be deleted.</p> <p>Interaction responses can only be deleted within 15 minutes of the interaction being received.</p> </li> <li> <code>attachment</code>               (<code>UndefinedOr[Resourceish]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.</p> </li> <li> <code>attachments</code>               (<code>UndefinedOr[Sequence[Resourceish]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.</p> </li> <li> <code>component</code>               (<code>UndefinedOr[ComponentBuilder]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, builder object of the component to include in this response.</p> </li> <li> <code>components</code>               (<code>UndefinedOr[Sequence[ComponentBuilder]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, a sequence of the component builder objects to include in this response.</p> </li> <li> <code>embed</code>               (<code>UndefinedOr[Embed]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>An embed to respond with.</p> </li> <li> <code>embeds</code>               (<code>UndefinedOr[Sequence[Embed]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A sequence of embeds to respond with.</p> </li> <li> <code>mentions_everyone</code>               (<code>UndefinedOr[bool]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, whether the message should parse @everyone/@here mentions.</p> </li> <li> <code>user_mentions</code>               (<code>SnowflakeishSequence[PartialUser] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialUser derivatives to enforce mentioning specific users.</p> </li> <li> <code>role_mentions</code>               (<code>SnowflakeishSequence[PartialRole] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialRole derivatives to enforce mentioning specific roles.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Message | None</code>           \u2013            <p>The message that has been created if it was immedieatly available or <code>ensure_result</code> was set to True, else None.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If more than 100 unique objects/entities are passed for <code>role_mentions</code> or <code>user_mentions</code>.</p> <p>If <code>delete_after</code> would be more than 15 minutes after the interaction was received.</p> <p>If both <code>attachment</code> and <code>attachments</code> are passed or both <code>component</code> and <code>components</code> are passed or both <code>embed</code> and <code>embeds</code> are passed.</p> </li> <li> <code>BadRequestError</code>             \u2013            <p>This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components.</p> </li> <li> <code>UnauthorizedError</code>             \u2013            <p>If you are unauthorized to make the request (invalid/missing token).</p> </li> <li> <code>ForbiddenError</code>             \u2013            <p>If you are missing the <code>SEND_MESSAGES</code> in the channel or the person you are trying to message has the DM's disabled.</p> </li> <li> <code>NotFoundError</code>             \u2013            <p>If the channel is not found.</p> </li> <li> <code>RateLimitTooLongError</code>             \u2013            <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> </li> <li> <code>InternalServerError</code>             \u2013            <p>If an internal error occurs on Discord while handling the request.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentContext.set_ephemeral_default","title":"set_ephemeral_default","text":"<pre><code>set_ephemeral_default(state)\n</code></pre> <p>Set the ephemeral default state for this context.</p> <p>Parameters:</p> <ul> <li> <code>state</code>               (<code>bool</code>)           \u2013            <p>The new ephemeral default state.</p> <p>If this is True then all calls to the response creating methods on this context will default to being ephemeral.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentExecutor","title":"ComponentExecutor","text":"<p>               Bases: <code>AbstractComponentExecutor</code></p> <p>implementation of a component executor with per-custom ID callbacks.</p>"},{"location":"reference/#yuyo.ComponentExecutor.callbacks","title":"callbacks  <code>property</code>","text":"<pre><code>callbacks\n</code></pre> <p>Mapping of custom IDs to their set callbacks.</p>"},{"location":"reference/#yuyo.ComponentExecutor.__init__","title":"__init__","text":"<pre><code>__init__(*, ephemeral_default=False)\n</code></pre> <p>Initialise a component executor.</p> <p>Parameters:</p> <ul> <li> <code>ephemeral_default</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this executor's responses should default to being ephemeral.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentExecutor.set_callback","title":"set_callback","text":"<pre><code>set_callback(custom_id, callback)\n</code></pre> <p>Set the callback for a custom ID.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str</code>)           \u2013            <p>The custom ID to set the callback for.</p> <p>This will be matched against <code>interaction.custom_id.split(\":\", 1)[0]</code>, allowing metadata to be stored after a <code>\":\"</code>.</p> </li> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>The callback to set.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>\":\"</code> is in the custom ID.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentExecutor.with_callback","title":"with_callback","text":"<pre><code>with_callback(custom_id)\n</code></pre> <p>Set the callback for a custom ID through a decorator callback.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str</code>)           \u2013            <p>The custom ID to set the callback for.</p> <p>This will be matched against <code>interaction.custom_id.split(\":\", 1)[0]</code>, allowing metadata to be stored after a <code>\":\"</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable[[CallbackSig], CallbackSig]</code>           \u2013            <p>Decorator callback used to set a custom ID's callback.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>\":\"</code> is in the custom ID.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentPaginator","title":"ComponentPaginator","text":"<p>               Bases: <code>ActionColumnExecutor</code></p> <p>Standard implementation of an action row executor used for pagination.</p> <p>This is a convenience class that allows you to easily implement a paginator.</p> <p>Note</p> <p>This doesn't use action column's \"static\" components so any static components added to base-classes of this will appear before the pagination components.</p>"},{"location":"reference/#yuyo.ComponentPaginator._added_static_fields","title":"_added_static_fields  <code>class-attribute</code>","text":"<pre><code>_added_static_fields = {}\n</code></pre> <p>Dict of match IDs to the static fields added to this class through add method calls.</p> <p>This doesn't include inherited fields.</p>"},{"location":"reference/#yuyo.ComponentPaginator._static_fields","title":"_static_fields  <code>class-attribute</code>","text":"<pre><code>_static_fields = {}\n</code></pre> <p>Dict of match IDs to the static fields on this class.</p> <p>This includes inherited fields and fields added through method calls.</p>"},{"location":"reference/#yuyo.ComponentPaginator.rows","title":"rows  <code>property</code>","text":"<pre><code>rows\n</code></pre> <p>The rows in this column.</p>"},{"location":"reference/#yuyo.ComponentPaginator.__init__","title":"__init__","text":"<pre><code>__init__(iterator, /, *, authors=None, ephemeral_default=False, triggers=(pagination.LEFT_TRIANGLE, pagination.STOP_SQUARE, pagination.RIGHT_TRIANGLE))\n</code></pre> <p>Initialise a component paginator.</p> <p>Parameters:</p> <ul> <li> <code>iterator</code>               (<code>Iterator[EntryT] | AsyncIterator[EntryT]</code>)           \u2013            <p>The iterator to paginate.</p> <p>This should be an iterator of yuyo.pagination.AbstractPages.</p> </li> <li> <code>authors</code>               (<code>Iterable[SnowflakeishOr[User]] | None</code>, default:                   <code>None</code> )           \u2013            <p>Users who are allowed to use the components this represents.</p> <p>If no users are provided then the components will be public (meaning that anybody can use it).</p> </li> <li> <code>ephemeral_default</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether or not the responses made on contexts spawned from this paginator should default to ephemeral (meaning only the author can see them) unless <code>flags</code> is specified on the response method.</p> </li> <li> <code>triggers</code>               (<code>Collection[str]</code>, default:                   <code>(LEFT_TRIANGLE, STOP_SQUARE, RIGHT_TRIANGLE)</code> )           \u2013            <p>Collection of the unicode emojis that should trigger this paginator.</p> <p>As of current the only usable emojis are yuyo.pagination.LEFT_TRIANGLE, yuyo.pagination.RIGHT_TRIANGLE, yuyo.pagination.STOP_SQUARE, yuyo.pagination.LEFT_DOUBLE_TRIANGLE and yuyo.pagination.LEFT_TRIANGLE.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentPaginator.add_builder","title":"add_builder","text":"<pre><code>add_builder(builder)\n</code></pre> <p>Add a raw component builder to this action column.</p> <p>This is mostly for adding components where the custom ID is already registered as a separate constant executor.</p> <p>Parameters:</p> <ul> <li> <code>builder</code>               (<code>ComponentBuilder</code>)           \u2013            <p>The component builder to add to the column.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentPaginator.add_channel_menu","title":"add_channel_menu","text":"<pre><code>add_channel_menu(callback, /, *, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a channel select menu to this action column.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>channel_types</code>               (<code>None | Sequence[ChannelType | type[PartialChannel]]</code>, default:                   <code>None</code> )           \u2013            <p>Sequence of the types of channels this select menu should show as options.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The action column to enable chained calls.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentPaginator.add_first_button","title":"add_first_button","text":"<pre><code>add_first_button(*, style=hikari.ButtonStyle.SECONDARY, custom_id=None, emoji=pagination.LEFT_DOUBLE_TRIANGLE, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add the jump to first entry button to this paginator.</p> <p>You should pass <code>triggers=[]</code> to ComponentPaginator.__init__ before calling this.</p> <p>Note</p> <p>These buttons will appear in the order these methods were called in.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>, default:                   <code>SECONDARY</code> )           \u2013            <p>The button's style.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom ID to use for identifying button presses.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>LEFT_DOUBLE_TRIANGLE</code> )           \u2013            <p>Emoji to display on this button.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Label to display on this button.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to make this button as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>To enable chained calls.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentPaginator.add_interactive_button","title":"add_interactive_button","text":"<pre><code>add_interactive_button(style, callback, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add an interactive button to this action column.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>)           \u2013            <p>The button's style.</p> </li> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>The button's execution callback.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The button's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's emoji.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's label.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the button should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The action column to enable chained calls.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentPaginator.add_last_button","title":"add_last_button","text":"<pre><code>add_last_button(*, style=hikari.ButtonStyle.SECONDARY, custom_id=None, emoji=pagination.RIGHT_DOUBLE_TRIANGLE, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add the jump to last entry button to this paginator.</p> <p>You should pass <code>triggers=[]</code> to ComponentPaginator.__init__ before calling this.</p> <p>Note</p> <p>These buttons will appear in the order these methods were called in.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>, default:                   <code>SECONDARY</code> )           \u2013            <p>The button's style.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom ID to use for identifying button presses.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>RIGHT_DOUBLE_TRIANGLE</code> )           \u2013            <p>Emoji to display on this button.</p> <p>Either this or <code>label</code> must be provided, but not both.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Label to display on this button.</p> <p>Either this or <code>emoji</code> must be provided, but not both.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to make this button as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>To enable chained calls.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentPaginator.add_link_button","title":"add_link_button","text":"<pre><code>add_link_button(url, /, *, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add a link button to this action column.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>url</code>               (<code>str</code>)           \u2013            <p>The button's url.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's emoji.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's label.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the button should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The action column to enable chained calls.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentPaginator.add_mentionable_menu","title":"add_mentionable_menu","text":"<pre><code>add_mentionable_menu(callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a mentionable select menu to this action column.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The action column to enable chained calls.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentPaginator.add_next_button","title":"add_next_button","text":"<pre><code>add_next_button(*, style=hikari.ButtonStyle.SECONDARY, custom_id=None, emoji=pagination.RIGHT_TRIANGLE, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add the next entry button to this paginator.</p> <p>You should pass <code>triggers=[]</code> to ComponentPaginator.__init__ before calling this.</p> <p>Note</p> <p>These buttons will appear in the order these methods were called in.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>, default:                   <code>SECONDARY</code> )           \u2013            <p>The button's style.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom ID to use for identifying button presses.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>RIGHT_TRIANGLE</code> )           \u2013            <p>Emoji to display on this button.</p> <p>Either this or <code>label</code> must be provided, but not both.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Label to display on this button.</p> <p>Either this or <code>emoji</code> must be provided, but not both.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to make this button as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>To enable chained calls.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentPaginator.add_previous_button","title":"add_previous_button","text":"<pre><code>add_previous_button(*, style=hikari.ButtonStyle.SECONDARY, custom_id=None, emoji=pagination.LEFT_TRIANGLE, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add the previous entry button to this paginator.</p> <p>You should pass <code>triggers=[]</code> to ComponentPaginator.__init__ before calling this.</p> <p>Note</p> <p>These buttons will appear in the order these methods were called in.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>, default:                   <code>SECONDARY</code> )           \u2013            <p>The button's style.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom ID to use for identifying button presses.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>LEFT_TRIANGLE</code> )           \u2013            <p>Emoji to display on this button.</p> <p>Either this or <code>label</code> must be provided, but not both.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Label to display on this button.</p> <p>Either this or <code>emoji</code> must be provided, but not both.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to make this button as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>To enable chained calls.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentPaginator.add_role_menu","title":"add_role_menu","text":"<pre><code>add_role_menu(callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a role select menu to this action column.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The action column to enable chained calls.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentPaginator.add_select_menu","title":"add_select_menu","text":"<pre><code>add_select_menu(type_, callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a select menu to this action column.</p> <p>The following methods should be used instead:</p> <ul> <li>.add_channel_menu</li> <li>.add_mentionable_menu</li> <li>.add_role_menu</li> <li>.add_text_menu</li> <li>.add_user_menu</li> </ul>"},{"location":"reference/#yuyo.ComponentPaginator.add_static_builder","title":"add_static_builder  <code>classmethod</code>","text":"<pre><code>add_static_builder(builder)\n</code></pre> <p>Add a raw component builder to all subclasses and instances of this column.</p> <p>This is mostly for adding components where the custom ID is already registered as a separate constant executor.</p> <p>Parameters:</p> <ul> <li> <code>builder</code>               (<code>ComponentBuilder</code>)           \u2013            <p>The component builder to add to the column class.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentPaginator.add_static_channel_menu","title":"add_static_channel_menu  <code>classmethod</code>","text":"<pre><code>add_static_channel_menu(callback, /, *, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a channel select menu to all subclasses and instances of this action column class.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>channel_types</code>               (<code>None | Sequence[ChannelType | type[PartialChannel]]</code>, default:                   <code>None</code> )           \u2013            <p>Sequence of the types of channels this select menu should show as options.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[Self]</code>           \u2013            <p>The action column class to enable chained calls.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentPaginator.add_static_interactive_button","title":"add_static_interactive_button  <code>classmethod</code>","text":"<pre><code>add_static_interactive_button(style, callback, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add an interactive button to all subclasses and instances of this action column class.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>)           \u2013            <p>The button's style.</p> </li> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>The button's execution callback.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The button's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's emoji.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's label.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the button should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[Self]</code>           \u2013            <p>The action column class to enable chained calls.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentPaginator.add_static_link_button","title":"add_static_link_button  <code>classmethod</code>","text":"<pre><code>add_static_link_button(url, /, *, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add a link button to all subclasses and instances of this action column class.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>url</code>               (<code>str</code>)           \u2013            <p>The button's url.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's emoji.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's label.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the button should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[Self]</code>           \u2013            <p>The action column class to enable chained calls.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentPaginator.add_static_mentionable_menu","title":"add_static_mentionable_menu  <code>classmethod</code>","text":"<pre><code>add_static_mentionable_menu(callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a mentionable select menu to all subclasses and instances of this action column class.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[Self]</code>           \u2013            <p>The action column class to enable chained calls.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentPaginator.add_static_role_menu","title":"add_static_role_menu  <code>classmethod</code>","text":"<pre><code>add_static_role_menu(callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a role select menu to all subclasses and instances of this action column class.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[Self]</code>           \u2013            <p>The action column class to enable chained calls.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentPaginator.add_static_select_menu","title":"add_static_select_menu  <code>classmethod</code>","text":"<pre><code>add_static_select_menu(type_, callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a select menu to all subclasses and instances of this action column class.</p> <p>The following class methods should be used instead:</p> <ul> <li>.add_static_channel_menu</li> <li>.add_static_mentionable_menu</li> <li>.add_static_role_menu</li> <li>.add_static_text_menu</li> <li>.add_static_user_menu</li> </ul>"},{"location":"reference/#yuyo.ComponentPaginator.add_static_text_menu","title":"add_static_text_menu  <code>classmethod</code>","text":"<pre><code>add_static_text_menu(callback, /, *, custom_id=None, options=(), placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a text select menu to all subclasses and instances of this action column class.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>options</code>               (<code>Sequence[SelectOptionBuilder]</code>, default:                   <code>()</code> )           \u2013            <p>The text select's options.</p> <p>These can also be added by calling TextSelectMenuBuilder.add_option.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>TextSelectMenuBuilder</code>           \u2013            <p>Builder for the added text select menu.</p> <p>TextSelectMenuBuilder.add_option should be used to add options to this select menu.</p> <p>And the parent action column can be accessed by calling TextSelectMenuBuilder.parent.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentPaginator.add_static_user_menu","title":"add_static_user_menu  <code>classmethod</code>","text":"<pre><code>add_static_user_menu(callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a user select menu to all subclasses and instances of this action column class.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[Self]</code>           \u2013            <p>The action column class to enable chained calls.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentPaginator.add_stop_button","title":"add_stop_button","text":"<pre><code>add_stop_button(*, style=hikari.ButtonStyle.DANGER, custom_id=None, emoji=pagination.BLACK_CROSS, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add the stop button to this paginator.</p> <p>You should pass <code>triggers=[]</code> to ComponentPaginator.__init__ before calling this.</p> <p>Note</p> <p>These buttons will appear in the order these methods were called in.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>, default:                   <code>DANGER</code> )           \u2013            <p>The button's style.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom ID to use for identifying button presses.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>BLACK_CROSS</code> )           \u2013            <p>Emoji to display on this button.</p> <p>Either this or <code>label</code> must be provided, but not both.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Label to display on this button.</p> <p>Either this or <code>emoji</code> must be provided, but not both.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to make this button as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>To enable chained calls.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentPaginator.add_text_menu","title":"add_text_menu","text":"<pre><code>add_text_menu(callback, /, *, custom_id=None, options=(), placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a text select menu to this action column.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>options</code>               (<code>Sequence[SelectOptionBuilder]</code>, default:                   <code>()</code> )           \u2013            <p>The text select's options.</p> <p>These can also be added by calling TextSelectMenuBuilder.add_option.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>TextSelectMenuBuilder</code>           \u2013            <p>Builder for the added text select menu.</p> <p>TextSelectMenuBuilder.add_option should be used to add options to this select menu.</p> <p>And the parent action column can be accessed by calling TextSelectMenuBuilder.parent.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentPaginator.add_user_menu","title":"add_user_menu","text":"<pre><code>add_user_menu(callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a user select menu to this action column.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The action column to enable chained calls.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentPaginator.get_next_entry","title":"get_next_entry  <code>async</code>","text":"<pre><code>get_next_entry()\n</code></pre> <p>Get the next entry in this paginator.</p> <p>This is generally helpful for making the message which the paginator will be based off and will still internally store the entry and increment the position of the paginator.</p> <p>Examples:</p> <pre><code>paginator = yuyo.ComponentPaginator(pages, authors=[ctx.author.id])\nfirst_response = await paginator.get_next_entry()\nassert first_response\nmessage = await ctx.respond(components=paginator.rows, **first_response.to_kwargs(), ensure_result=True)\ncomponent_client.register_executor(paginator, message=message)\n</code></pre> <p>Returns:</p> <ul> <li> <code>AbstractPage | None</code>           \u2013            <p>The next entry in this paginator, or None if there are no more entries.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentPaginator.with_channel_menu","title":"with_channel_menu","text":"<pre><code>with_channel_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_channel_menu(*, custom_id: str | None = None, channel_types: None | Sequence[ChannelType | type[PartialChannel]] = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_channel_menu(callback=None, /, *, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a channel select menu to this action column through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>channel_types</code>               (<code>None | Sequence[ChannelType | type[PartialChannel]]</code>, default:                   <code>None</code> )           \u2013            <p>Sequence of the types of channels this select menu should show as options.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentPaginator.with_interactive_button","title":"with_interactive_button","text":"<pre><code>with_interactive_button(style, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add an interactive button to this action column through a decorator call.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>)           \u2013            <p>The button's style.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The button's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's emoji.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's label.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the button should be marked as disabled.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentPaginator.with_mentionable_menu","title":"with_mentionable_menu","text":"<pre><code>with_mentionable_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_mentionable_menu(*, custom_id: str | None = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_mentionable_menu(callback=None, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a mentionable select menu to this action column through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentPaginator.with_role_menu","title":"with_role_menu","text":"<pre><code>with_role_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_role_menu(*, custom_id: str | None = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_role_menu(callback=None, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a role select menu to this action column through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentPaginator.with_static_channel_menu","title":"with_static_channel_menu  <code>classmethod</code>","text":"<pre><code>with_static_channel_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_static_channel_menu(*, custom_id: str | None = None, channel_types: None | Sequence[ChannelType | type[PartialChannel]] = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_static_channel_menu(callback=None, /, *, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a channel select menu to this action column class through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>channel_types</code>               (<code>None | Sequence[ChannelType | type[PartialChannel]]</code>, default:                   <code>None</code> )           \u2013            <p>Sequence of the types of channels this select menu should show as options.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentPaginator.with_static_interactive_button","title":"with_static_interactive_button  <code>classmethod</code>","text":"<pre><code>with_static_interactive_button(style, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add a static interactive button to this action column class through a decorator call.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>)           \u2013            <p>The button's style.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The button's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's emoji.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's label.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the button should be marked as disabled.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentPaginator.with_static_mentionable_menu","title":"with_static_mentionable_menu  <code>classmethod</code>","text":"<pre><code>with_static_mentionable_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_static_mentionable_menu(*, custom_id: str | None = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_static_mentionable_menu(callback=None, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a static mentionable select menu to this action column class through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentPaginator.with_static_role_menu","title":"with_static_role_menu  <code>classmethod</code>","text":"<pre><code>with_static_role_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_static_role_menu(*, custom_id: str | None = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_static_role_menu(callback=None, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a static role select menu to this action column class through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentPaginator.with_static_text_menu","title":"with_static_text_menu  <code>classmethod</code>","text":"<pre><code>with_static_text_menu(callback: Callable[_P, _CoroT]) -&gt; _WrappedTextMenuBuilder[_P]\n</code></pre><pre><code>with_static_text_menu(*, custom_id: str | None = None, options: Sequence[SelectOptionBuilder] = (), placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[collections.Callable[_P, _CoroT]], _WrappedTextMenuBuilder[_P]]\n</code></pre> <pre><code>with_static_text_menu(callback=None, /, *, custom_id=None, options=(), placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a text select menu to this action column class through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>options</code>               (<code>Sequence[SelectOptionBuilder]</code>, default:                   <code>()</code> )           \u2013            <p>The text select's options.</p> <p>These can also be added using [yuyo.components.with_option].</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentPaginator.with_static_user_menu","title":"with_static_user_menu  <code>classmethod</code>","text":"<pre><code>with_static_user_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_static_user_menu(*, custom_id: str | None = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_static_user_menu(callback=None, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a static user select menu to this action column class through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentPaginator.with_text_menu","title":"with_text_menu","text":"<pre><code>with_text_menu(callback: Callable[_P, _CoroT]) -&gt; _WrappedTextMenuBuilder[_P]\n</code></pre><pre><code>with_text_menu(*, custom_id: str | None = None, options: Sequence[SelectOptionBuilder] = (), placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[collections.Callable[_P, _CoroT]], _WrappedTextMenuBuilder[_P]]\n</code></pre> <pre><code>with_text_menu(callback=None, /, *, custom_id=None, options=(), placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a text select menu to this action column through a decorator callback.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>options</code>               (<code>Sequence[SelectOptionBuilder]</code>, default:                   <code>()</code> )           \u2013            <p>The text select's options.</p> <p>These can also be added using components.with_option.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul>"},{"location":"reference/#yuyo.ComponentPaginator.with_user_menu","title":"with_user_menu","text":"<pre><code>with_user_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_user_menu(*, custom_id: str | None = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_user_menu(callback=None, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a user select menu to this action column through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul>"},{"location":"reference/#yuyo.DiscordBotListService","title":"DiscordBotListService","text":"<p>https://discordbotlist.com status update service.</p>"},{"location":"reference/#yuyo.DiscordBotListService.__init__","title":"__init__","text":"<pre><code>__init__(token)\n</code></pre> <p>Initialise a discordbotlist.com service.</p> <p>Parameters:</p> <ul> <li> <code>token</code>               (<code>str</code>)           \u2013            <p>Authorization token used to update the bot's status.</p> </li> </ul>"},{"location":"reference/#yuyo.ErrorManager","title":"ErrorManager","text":"<p>A context manager provided to allow for more concise error handling with Backoff.</p> <p>Examples:</p> <p>The following is an example of using ErrorManager alongside Backoff in-order to handle the exceptions which may be raised while trying to reply to a message.</p> <pre><code>retry = Backoff()\n# Rules can either be passed to `ErrorManager`'s initiate as variable arguments\n# or one at a time to `ErrorManager.with_rule` through possibly chained-calls.\nerror_handler = (\n    # For the 1st rule we catch two errors which would indicate the bot\n    # no-longer has access to the target channel and break out of the\n    # retry loop using `Backoff.retry`.\n    ErrorManager(((NotFoundError, ForbiddenError), lambda _: retry.finish()))\n        # For the 2nd rule we catch rate limited errors and set their\n        # `retry` value as the next backoff time before suppressing the\n        # error to allow this to retry the request.\n        .with_rule((RateLimitedError,), lambda exc: retry.set_next_backoff(exc.retry_after))\n        # For the 3rd rule we suppress the internal server error to allow\n        # backoff to reach the next retry and exponentially backoff as we\n        # don't have any specific retry time for this error.\n        .with_rule((InternalServerError,), lambda _: False)\n)\nasync for _ in retry:\n    # We entre this context manager each iteration to catch errors before\n    # they cause us to break out of the `Backoff` loop.\n    with error_handler:\n        await post(f\"https://example.com/{resource_id}\", json={\"content\": \"General Kenobi\"})\n        # We need to break out of `retry` if this request succeeds.\n        break\n</code></pre>"},{"location":"reference/#yuyo.ErrorManager.__init__","title":"__init__","text":"<pre><code>__init__(*rules)\n</code></pre> <p>Initialise an error manager instance.</p> <p>Parameters:</p> <ul> <li> <code>*rules</code>               (<code>tuple[Iterable[type[BaseException]], Callable[[Any], bool | None]]</code>, default:                   <code>()</code> )           \u2013            <p>Rules to initiate this error context manager with.</p> <p>These are each a 2-length tuple where the <code>tuple[0]</code> is an iterable of types of the exceptions this rule should apply to and <code>tuple[1]</code> is the rule's callback function.</p> <p>The callback function will be called with the raised exception when it matches one of the passed exceptions for the relevant rule and may raise, return True to indicate that the current error should be raised outside of the context manager or False/None to suppress the current error.</p> </li> </ul>"},{"location":"reference/#yuyo.ErrorManager.add_rule","title":"add_rule","text":"<pre><code>add_rule(exceptions, result)\n</code></pre> <p>Add a rule to this exception context manager.</p> <p>Parameters:</p> <ul> <li> <code>exceptions</code>               (<code>Iterable[type[BaseException]]</code>)           \u2013            <p>An iterable of types of the exceptions this rule should apply to.</p> </li> <li> <code>result</code>               (<code>Callable[[Any], bool | None]</code>)           \u2013            <p>The function called with the raised exception when it matches one of the passed <code>exceptions</code>. This may raise, return True to indicate that the current error should be raised outside of the context manager or False/None to suppress the current error.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>This returns the handler a rule was being added to in-order to allow for chained calls.</p> </li> </ul>"},{"location":"reference/#yuyo.ErrorManager.clear_rules","title":"clear_rules","text":"<pre><code>clear_rules()\n</code></pre> <p>Clear the rules registered with this handler.</p>"},{"location":"reference/#yuyo.FinishedChunkingEvent","title":"FinishedChunkingEvent","text":"<p>               Bases: <code>Event</code></p> <p>Event that's dispatched when the startup chunking has finished for the bot.</p> <p>This indicates that the member and presence caches should be complete globally.</p> <p>This will only be fired once after bot startups.</p>"},{"location":"reference/#yuyo.FinishedChunkingEvent.__init__","title":"__init__","text":"<pre><code>__init__(app)\n</code></pre> <p>Initialise a chunking finished event.</p> <p>This should never be initialised directly.</p>"},{"location":"reference/#yuyo.InteractionError","title":"InteractionError","text":"<p>               Bases: <code>Exception</code></p> <p>Error which is sent as a response to a modal or component call.</p>"},{"location":"reference/#yuyo.InteractionError.__init__","title":"__init__","text":"<pre><code>__init__(content=hikari.UNDEFINED, *, delete_after=None, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, mentions_everyone=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED)\n</code></pre> <p>Initialise an interaction error.</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>UndefinedOr[Any]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message content to respond with.</p> <p>If this is a hikari.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead be treated as an embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> </li> <li> <code>delete_after</code>               (<code>timedelta | float | int | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, the seconds after which the response message should be deleted.</p> <p>Interaction responses can only be deleted within 15 minutes of the interaction being received.</p> </li> <li> <code>attachment</code>               (<code>UndefinedOr[Resourceish]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A singular attachment to respond with.</p> </li> <li> <code>attachments</code>               (<code>UndefinedOr[Sequence[Resourceish]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A sequence of attachments to respond with.</p> </li> <li> <code>component</code>               (<code>UndefinedOr[ComponentBuilder]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, builder object of the component to include in this response.</p> </li> <li> <code>components</code>               (<code>UndefinedOr[Sequence[ComponentBuilder]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, a sequence of the component builder objects to include in this response.</p> </li> <li> <code>embed</code>               (<code>UndefinedOr[Embed]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>An embed to respond with.</p> </li> <li> <code>embeds</code>               (<code>UndefinedOr[Sequence[Embed]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A sequence of embeds to respond with.</p> </li> <li> <code>mentions_everyone</code>               (<code>UndefinedOr[bool]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, whether the message should parse @everyone/@here mentions.</p> </li> <li> <code>user_mentions</code>               (<code>SnowflakeishSequence[PartialUser] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialUser derivatives to enforce mentioning specific users.</p> </li> <li> <code>role_mentions</code>               (<code>SnowflakeishSequence[PartialRole] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialRole derivatives to enforce mentioning specific roles.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>Raised for any of the following reasons:</p> <ul> <li>When both <code>attachment</code> and <code>attachments</code> are provided.</li> <li>When both <code>component</code> and <code>components</code> are passed.</li> <li>When both <code>embed</code> and <code>embeds</code> are passed.</li> <li>If more than 100 entries are passed for <code>role_mentions</code>.</li> <li>If more than 100 entries are passed for <code>user_mentions</code>.</li> </ul> </li> </ul>"},{"location":"reference/#yuyo.InteractionError.send","title":"send  <code>async</code>","text":"<pre><code>send(ctx: BaseContext[ComponentInteraction] | BaseContext[ModalInteraction], /, *, ensure_result: Literal[True]) -&gt; hikari.Message\n</code></pre><pre><code>send(ctx: BaseContext[ComponentInteraction] | BaseContext[ModalInteraction], /, *, ensure_result: bool = False) -&gt; hikari.Message | None\n</code></pre> <pre><code>send(ctx, /, *, ensure_result=False)\n</code></pre> <p>Send this error as an interaction response.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>BaseContext[ComponentInteraction] | BaseContext[ModalInteraction]</code>)           \u2013            <p>The interaction context to respond to.</p> </li> <li> <code>ensure_result</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Ensure that this call will always return a message object.</p> <p>If True then this will always return hikari.Message, otherwise this will return <code>hikari.Message | None</code>.</p> <p>It's worth noting that this may lead to an extra request being made under certain scenarios.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>delete_after</code> would be more than 15 minutes after the interaction was received.</p> </li> <li> <code>BadRequestError</code>             \u2013            <p>This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components.</p> </li> <li> <code>UnauthorizedError</code>             \u2013            <p>If you are unauthorized to make the request (invalid/missing token).</p> </li> <li> <code>ForbiddenError</code>             \u2013            <p>If you are missing the <code>SEND_MESSAGES</code> in the channel or the person you are trying to message has the DM's disabled.</p> </li> <li> <code>NotFoundError</code>             \u2013            <p>If the channel is not found.</p> </li> <li> <code>RateLimitTooLongError</code>             \u2013            <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> </li> <li> <code>InternalServerError</code>             \u2013            <p>If an internal error occurs on Discord while handling the request.</p> </li> </ul>"},{"location":"reference/#yuyo.LocalisedPage","title":"LocalisedPage","text":"<p>               Bases: <code>AbstractPage</code></p> <p>Implementation of a paginated response which returns locale specific pages..</p>"},{"location":"reference/#yuyo.ModalClient","title":"ModalClient","text":"<p>Client used to handle modals within a REST or gateway flow.</p>"},{"location":"reference/#yuyo.ModalClient.alluka","title":"alluka  <code>property</code>","text":"<pre><code>alluka\n</code></pre> <p>The Alluka client being used for callback dependency injection.</p>"},{"location":"reference/#yuyo.ModalClient.cache","title":"cache  <code>property</code>","text":"<pre><code>cache\n</code></pre> <p>Hikari cache instance this client was initialised with.</p>"},{"location":"reference/#yuyo.ModalClient.events","title":"events  <code>property</code>","text":"<pre><code>events\n</code></pre> <p>Object of the event manager this client was initialised with.</p>"},{"location":"reference/#yuyo.ModalClient.rest","title":"rest  <code>property</code>","text":"<pre><code>rest\n</code></pre> <p>Object of the Hikari REST client this client was initialised with.</p>"},{"location":"reference/#yuyo.ModalClient.server","title":"server  <code>property</code>","text":"<pre><code>server\n</code></pre> <p>Object of the Hikari interaction server provided for this client.</p>"},{"location":"reference/#yuyo.ModalClient.shards","title":"shards  <code>property</code>","text":"<pre><code>shards\n</code></pre> <p>Object of the Hikari shard manager this client was initialised with.</p>"},{"location":"reference/#yuyo.ModalClient.voice","title":"voice  <code>property</code>","text":"<pre><code>voice\n</code></pre> <p>Object of the Hikari voice component this client was initialised with.</p>"},{"location":"reference/#yuyo.ModalClient.__init__","title":"__init__","text":"<pre><code>__init__(*, alluka=None, cache=None, event_manager=None, event_managed=None, rest=None, server=None, shards=None, voice=None)\n</code></pre> <p>Initialise a modal client.</p> <p>This registers ModalClient as a type dependency when <code>alluka</code> isn't passed.</p> <p>Note</p> <p>For an easier way to initialise the client from a bot see ModalClient.from_gateway_bot, ModalClient.from_rest_bot, and ModalClient.from_tanjun.</p> <p>Parameters:</p> <ul> <li> <code>alluka</code>               (<code>Client | None</code>, default:                   <code>None</code> )           \u2013            <p>The Alluka client to use for callback dependency injection in this client.</p> <p>If not provided then this will initialise its own Alluka client.</p> </li> <li> <code>event_manager</code>               (<code>EventManager | None</code>, default:                   <code>None</code> )           \u2013            <p>The event manager this client should listen to dispatched modal interactions from if applicable.</p> </li> <li> <code>event_managed</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether this client should be automatically opened and closed based on the lifetime events dispatched by <code>event_manager</code>.</p> <p>Defaults to True if an event manager is passed.</p> </li> <li> <code>server</code>               (<code>InteractionServer | None</code>, default:                   <code>None</code> )           \u2013            <p>The server this client should listen to modal interactions from if applicable.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>event_managed</code> is passed as True when <code>event_manager</code> is None.</p> </li> </ul>"},{"location":"reference/#yuyo.ModalClient.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Close the modal client.</p>"},{"location":"reference/#yuyo.ModalClient.deregister_modal","title":"deregister_modal","text":"<pre><code>deregister_modal(custom_id)\n</code></pre> <p>Remove the modal set for a custom ID.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str</code>)           \u2013            <p>The custom_id to unset the modal for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The modal client to allow chaining.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>If the custom_id is not registered.</p> </li> </ul>"},{"location":"reference/#yuyo.ModalClient.from_gateway_bot","title":"from_gateway_bot  <code>classmethod</code>","text":"<pre><code>from_gateway_bot(bot, /, *, alluka=None, event_managed=True)\n</code></pre> <p>Build a modal client from a Gateway Bot.</p> <p>This registers ModalClient as a type dependency when <code>alluka</code> isn't passed.</p> <p>Parameters:</p> <ul> <li> <code>bot</code>               (<code>_GatewayBotProto</code>)           \u2013            <p>The Gateway bot this modal client should be bound to.</p> </li> <li> <code>alluka</code>               (<code>Client | None</code>, default:                   <code>None</code> )           \u2013            <p>The Alluka client to use for callback dependency injection in this client.</p> <p>If not provided then this will initialise its own Alluka client.</p> </li> <li> <code>event_managed</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the modal client should be automatically opened and closed based on the lifetime events dispatched by <code>bot</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ModalClient</code>           \u2013            <p>The initialised modal client.</p> </li> </ul>"},{"location":"reference/#yuyo.ModalClient.from_rest_bot","title":"from_rest_bot  <code>classmethod</code>","text":"<pre><code>from_rest_bot(bot, /, *, alluka=None, bot_managed=False)\n</code></pre> <p>Build a modal client from a REST Bot.</p> <p>This registers ModalClient as a type dependency when <code>alluka</code> isn't passed.</p> <p>Parameters:</p> <ul> <li> <code>bot</code>               (<code>RESTBotAware</code>)           \u2013            <p>The REST bot this modal client should be bound to.</p> </li> <li> <code>alluka</code>               (<code>Client | None</code>, default:                   <code>None</code> )           \u2013            <p>The Alluka client to use for callback dependency injection in this client.</p> <p>If not provided then this will initialise its own Alluka client.</p> </li> <li> <code>bot_managed</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the modal client should be automatically opened and closed based on the Bot's startup and shutdown callbacks.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ModalClient</code>           \u2013            <p>The initialised modal client.</p> </li> </ul>"},{"location":"reference/#yuyo.ModalClient.from_tanjun","title":"from_tanjun  <code>classmethod</code>","text":"<pre><code>from_tanjun(tanjun_client, /, *, tanjun_managed=True)\n</code></pre> <p>Build a modal client from a Tanjun client.</p> <p>This will use the Tanjun client's alluka client and registers ModalClient as a type dependency on Tanjun.</p> <p>Parameters:</p> <ul> <li> <code>tanjun_client</code>               (<code>Client</code>)           \u2013            <p>The Tanjun client this modal client should be bound to.</p> </li> <li> <code>tanjun_managed</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the modal client should be automatically opened and closed based on the Tanjun client's lifetime client callback.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ModalClient</code>           \u2013            <p>The initialised modal client.</p> </li> </ul>"},{"location":"reference/#yuyo.ModalClient.get_modal","title":"get_modal","text":"<pre><code>get_modal(custom_id)\n</code></pre> <p>Get the modal set for a custom ID.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str</code>)           \u2013            <p>The custom_id to get the modal for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AbstractModal | None</code>           \u2013            <p>The callback for the custom_id, or None if it doesn't exist.</p> </li> </ul>"},{"location":"reference/#yuyo.ModalClient.on_gateway_event","title":"on_gateway_event  <code>async</code>","text":"<pre><code>on_gateway_event(event)\n</code></pre> <p>Process an interaction create gateway event.</p> <p>Parameters:</p> <ul> <li> <code>event</code>               (<code>InteractionCreateEvent</code>)           \u2013            <p>The interaction create gateway event to process.</p> </li> </ul>"},{"location":"reference/#yuyo.ModalClient.on_rest_request","title":"on_rest_request  <code>async</code>","text":"<pre><code>on_rest_request(interaction)\n</code></pre> <p>Process a modal interaction REST request.</p> <p>Parameters:</p> <ul> <li> <code>interaction</code>               (<code>ModalInteraction</code>)           \u2013            <p>The interaction to process.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>InteractionMessageBuilder | InteractionDeferredBuilder</code>           \u2013            <p>The REST response.</p> </li> </ul>"},{"location":"reference/#yuyo.ModalClient.open","title":"open","text":"<pre><code>open()\n</code></pre> <p>Startup the modal client.</p>"},{"location":"reference/#yuyo.ModalClient.register_modal","title":"register_modal","text":"<pre><code>register_modal(custom_id, modal, /, *, timeout=_internal.NO_DEFAULT)\n</code></pre> <p>Register a modal for a custom ID.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str</code>)           \u2013            <p>The custom_id to register the modal for.</p> <p>This will be matched against <code>interaction.custom_id.split(\":\", 1)[0]</code>, allowing metadata to be stored after a <code>\":\"</code>.</p> </li> <li> <code>modal</code>               (<code>AbstractModal</code>)           \u2013            <p>The modal to register.</p> </li> <li> <code>timeout</code>               (<code>AbstractTimeout | None | NoDefault</code>, default:                   <code>NO_DEFAULT</code> )           \u2013            <p>Timeout strategy for this modal.</p> <p>Passing None here will set NeverTimeout.</p> <p>This defaults to single use with a 2 minute timeout.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The modal client to allow chaining.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>custom_id</code> is already registered.</p> <p>If <code>\":\"</code> is in the custom ID.</p> </li> </ul>"},{"location":"reference/#yuyo.ModalContext","title":"ModalContext","text":"<p>               Bases: <code>BaseContext[ModalInteraction]</code></p> <p>The context used for modal triggers.</p>"},{"location":"reference/#yuyo.ModalContext.alluka","title":"alluka  <code>property</code>","text":"<pre><code>alluka\n</code></pre> <p>The Alluka client being used for callback dependency injection.</p>"},{"location":"reference/#yuyo.ModalContext.author","title":"author  <code>property</code>","text":"<pre><code>author\n</code></pre> <p>Author of this interaction.</p>"},{"location":"reference/#yuyo.ModalContext.cache","title":"cache  <code>property</code>","text":"<pre><code>cache\n</code></pre> <p>Hikari cache instance this context's client was initialised with.</p>"},{"location":"reference/#yuyo.ModalContext.channel_id","title":"channel_id  <code>property</code>","text":"<pre><code>channel_id\n</code></pre> <p>ID of the channel this interaction was triggered in.</p>"},{"location":"reference/#yuyo.ModalContext.client","title":"client  <code>property</code>","text":"<pre><code>client\n</code></pre> <p>The modal this context is bound to.</p>"},{"location":"reference/#yuyo.ModalContext.component_ids","title":"component_ids  <code>property</code>","text":"<pre><code>component_ids\n</code></pre> <p>Mapping of match ID parts to metadata ID parts for the modal's components.</p>"},{"location":"reference/#yuyo.ModalContext.events","title":"events  <code>property</code>","text":"<pre><code>events\n</code></pre> <p>Object of the event manager this context's client was initialised with.</p>"},{"location":"reference/#yuyo.ModalContext.expires_at","title":"expires_at  <code>property</code>","text":"<pre><code>expires_at\n</code></pre> <p>When this context expires.</p> <p>After this time is reached, the message/response methods on this context will always raise hikari.NotFoundError.</p>"},{"location":"reference/#yuyo.ModalContext.has_been_deferred","title":"has_been_deferred  <code>property</code>","text":"<pre><code>has_been_deferred\n</code></pre> <p>Whether this context's initial response has been deferred.</p> <p>This will be true if BaseContext.defer has been called.</p>"},{"location":"reference/#yuyo.ModalContext.has_responded","title":"has_responded  <code>property</code>","text":"<pre><code>has_responded\n</code></pre> <p>Whether an initial response has been made to this context yet.</p> <p>It's worth noting that a context must be either responded to or deferred within 3 seconds from it being received otherwise it'll be marked as failed.</p> <p>This will be true if either BaseContext.respond, BaseContext.create_initial_response or BaseContext.edit_initial_response (after a deferral) has been called.</p>"},{"location":"reference/#yuyo.ModalContext.id_match","title":"id_match  <code>property</code>","text":"<pre><code>id_match\n</code></pre> <p>Section of the ID used to identify the relevant executor.</p>"},{"location":"reference/#yuyo.ModalContext.id_metadata","title":"id_metadata  <code>property</code>","text":"<pre><code>id_metadata\n</code></pre> <p>Metadata from the interaction's custom ID.</p>"},{"location":"reference/#yuyo.ModalContext.interaction","title":"interaction  <code>property</code>","text":"<pre><code>interaction\n</code></pre> <p>Object of the interaction this context is for.</p>"},{"location":"reference/#yuyo.ModalContext.rest","title":"rest  <code>property</code>","text":"<pre><code>rest\n</code></pre> <p>Object of the Hikari REST client this context's client was initialised with.</p>"},{"location":"reference/#yuyo.ModalContext.server","title":"server  <code>property</code>","text":"<pre><code>server\n</code></pre> <p>Object of the Hikari interaction server provided for this context's client.</p>"},{"location":"reference/#yuyo.ModalContext.shard","title":"shard  <code>property</code>","text":"<pre><code>shard\n</code></pre> <p>Shard that triggered the interaction.</p> <p>Note</p> <p>This will be None if BaseContext.shards is also None.</p>"},{"location":"reference/#yuyo.ModalContext.shards","title":"shards  <code>property</code>","text":"<pre><code>shards\n</code></pre> <p>Object of the Hikari shard manager this context's client was initialised with.</p>"},{"location":"reference/#yuyo.ModalContext.voice","title":"voice  <code>property</code>","text":"<pre><code>voice\n</code></pre> <p>Object of the Hikari voice component this context's client was initialised with.</p>"},{"location":"reference/#yuyo.ModalContext.create_followup","title":"create_followup  <code>async</code>","text":"<pre><code>create_followup(content=hikari.UNDEFINED, *, delete_after=None, ephemeral=None, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, mentions_everyone=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED, tts=hikari.UNDEFINED, flags=hikari.UNDEFINED)\n</code></pre> <p>Create a followup response for this context.</p> <p>Warning</p> <p>Calling this on a context which hasn't had an initial response yet will lead to a hikari.NotFoundError being raised.</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>UndefinedOr[Any]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message content to send.</p> <p>If this is a hikari.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead be treated as an embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> </li> <li> <code>delete_after</code>               (<code>timedelta | float | int | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, the seconds after which the response message should be deleted.</p> <p>Interaction responses can only be deleted within 15 minutes of the interaction being received.</p> </li> <li> <code>ephemeral</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether the deferred response should be ephemeral. Passing True here is a shorthand for including <code>1 &lt;&lt; 64</code> in the passed flags.</p> </li> <li> <code>attachment</code>               (<code>UndefinedOr[Resourceish]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.</p> </li> <li> <code>attachments</code>               (<code>UndefinedOr[Sequence[Resourceish]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.</p> </li> <li> <code>component</code>               (<code>UndefinedOr[ComponentBuilder]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, builder object of the component to include in this message.</p> </li> <li> <code>components</code>               (<code>UndefinedOr[Sequence[ComponentBuilder]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, a sequence of the component builder objects to include in this message.</p> </li> <li> <code>embed</code>               (<code>UndefinedOr[Embed]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message embed.</p> </li> <li> <code>embeds</code>               (<code>UndefinedOr[Sequence[Embed]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message embeds.</p> </li> <li> <code>mentions_everyone</code>               (<code>UndefinedOr[bool]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, whether the message should parse @everyone/@here mentions.</p> </li> <li> <code>user_mentions</code>               (<code>SnowflakeishSequence[PartialUser] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialUser derivatives to enforce mentioning specific users.</p> </li> <li> <code>role_mentions</code>               (<code>SnowflakeishSequence[PartialRole] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialRole derivatives to enforce mentioning specific roles.</p> </li> <li> <code>tts</code>               (<code>UndefinedOr[bool]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, whether the message will be sent as a TTS message.</p> </li> <li> <code>flags</code>               (<code>UndefinedType | int | MessageFlag</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The flags to set for this response.</p> <p>As of writing this can only flag which can be provided is EPHEMERAL, other flags are just ignored.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Message</code>           \u2013            <p>The created message object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NotFoundError</code>             \u2013            <p>If the current interaction is not found or it hasn't had an initial response yet.</p> </li> <li> <code>BadRequestError</code>             \u2013            <p>This can be raised if the file is too large; if the embed exceeds the defined limits; if the message content is specified only and empty or greater than <code>2000</code> characters; if neither content, file or embeds are specified. If any invalid snowflake IDs are passed; a snowflake may be invalid due to it being outside of the range of a 64 bit integer.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If more than 100 unique objects/entities are passed for <code>role_mentions</code> or `user_mentions.</p> <p>If the interaction will have expired before <code>delete_after</code> is reached.</p> <p>If both <code>attachment</code> and <code>attachments</code> are passed or both <code>component</code> and <code>components</code> are passed or both <code>embed</code> and <code>embeds</code> are passed.</p> </li> </ul>"},{"location":"reference/#yuyo.ModalContext.create_initial_response","title":"create_initial_response  <code>async</code>","text":"<pre><code>create_initial_response(content=hikari.UNDEFINED, *, response_type=hikari.ResponseType.MESSAGE_CREATE, delete_after=None, ephemeral=None, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, mentions_everyone=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED, flags=hikari.UNDEFINED, tts=hikari.UNDEFINED)\n</code></pre> <p>Create the initial response for this context.</p> <p>Warning</p> <p>Calling this on a context which already has an initial response will result in this raising a hikari.NotFoundError. This includes if the REST interaction server has already responded to the request and deferrals.</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>UndefinedOr[Any]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message content to respond with.</p> <p>If this is a hikari.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead be treated as an embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> </li> <li> <code>response_type</code>               (<code>MessageResponseTypesT</code>, default:                   <code>MESSAGE_CREATE</code> )           \u2013            <p>The type of message response to give.</p> </li> <li> <code>delete_after</code>               (<code>timedelta | float | int | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, the seconds after which the response message should be deleted.</p> <p>Interaction responses can only be deleted within 15 minutes of the interaction being received.</p> </li> <li> <code>ephemeral</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether the deferred response should be ephemeral.</p> <p>Passing True here is a shorthand for including <code>1 &lt;&lt; 64</code> in the passed flags.</p> </li> <li> <code>attachment</code>               (<code>UndefinedOr[Resourceish]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.</p> </li> <li> <code>attachments</code>               (<code>UndefinedOr[Sequence[Resourceish]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.</p> </li> <li> <code>component</code>               (<code>UndefinedOr[ComponentBuilder]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, builder object of the component to include in this message.</p> </li> <li> <code>components</code>               (<code>UndefinedOr[Sequence[ComponentBuilder]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, a sequence of the component builder objects to include in this message.</p> </li> <li> <code>embed</code>               (<code>UndefinedOr[Embed]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message embed.</p> </li> <li> <code>embeds</code>               (<code>UndefinedOr[Sequence[Embed]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message embeds.</p> </li> <li> <code>flags</code>               (<code>int | MessageFlag | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message flags this response should have.</p> <p>As of writing the only message flag which can be set here is MessageFlag.EPHEMERAL.</p> </li> <li> <code>tts</code>               (<code>UndefinedOr[bool]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, whether the message will be read out by a screen reader using Discord's TTS (text-to-speech) system.</p> </li> <li> <code>mentions_everyone</code>               (<code>UndefinedOr[bool]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, whether the message should parse @everyone/@here mentions.</p> </li> <li> <code>user_mentions</code>               (<code>SnowflakeishSequence[PartialUser] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialUser derivatives to enforce mentioning specific users.</p> </li> <li> <code>role_mentions</code>               (<code>SnowflakeishSequence[PartialRole] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialRole derivatives to enforce mentioning specific roles.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If more than 100 unique objects/entities are passed for <code>role_mentions</code> or <code>user_mentions</code>.</p> <p>If the interaction will have expired before <code>delete_after</code> is reached.</p> <p>If both <code>attachment</code> and <code>attachments</code> are passed or both <code>component</code> and <code>components</code> are passed or both <code>embed</code> and <code>embeds</code> are passed.</p> </li> <li> <code>BadRequestError</code>             \u2013            <p>This may be raised in several discrete situations, such as messages being empty with no embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; invalid image URLs in embeds.</p> </li> <li> <code>UnauthorizedError</code>             \u2013            <p>If you are unauthorized to make the request (invalid/missing token).</p> </li> <li> <code>NotFoundError</code>             \u2013            <p>If the interaction is not found or if the interaction's initial response has already been created.</p> </li> <li> <code>RateLimitTooLongError</code>             \u2013            <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> </li> <li> <code>InternalServerError</code>             \u2013            <p>If an internal error occurs on Discord while handling the request.</p> </li> </ul>"},{"location":"reference/#yuyo.ModalContext.defer","title":"defer  <code>async</code>","text":"<pre><code>defer(*, defer_type=hikari.ResponseType.DEFERRED_MESSAGE_CREATE, ephemeral=None, flags=hikari.UNDEFINED)\n</code></pre> <p>Defer the initial response for this context.</p> <p>Note</p> <p>The ephemeral state of the first response is decided by whether the deferral is ephemeral.</p> <p>Parameters:</p> <ul> <li> <code>defer_type</code>               (<code>DeferredResponseTypesT</code>, default:                   <code>DEFERRED_MESSAGE_CREATE</code> )           \u2013            <p>The type of deferral this should be.</p> <p>This may any of the following:</p> <ul> <li>ResponseType.DEFERRED_MESSAGE_CREATE     to indicate that the following up call to     BaseContext.edit_initial_response     or BaseContext.respond     should create a new message.</li> <li>ResponseType.DEFERRED_MESSAGE_UPDATE     to indicate that the following call to the aforementioned     methods should update the existing message.</li> </ul> </li> <li> <code>ephemeral</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether the deferred response should be ephemeral.</p> <p>Passing True here is a shorthand for including <code>1 &lt;&lt; 64</code> in the passed flags.</p> </li> <li> <code>flags</code>               (<code>UndefinedType | int | MessageFlag</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The flags to use for the initial response.</p> </li> </ul>"},{"location":"reference/#yuyo.ModalContext.delete_initial_response","title":"delete_initial_response  <code>async</code>","text":"<pre><code>delete_initial_response()\n</code></pre> <p>Delete the initial response after invoking this context.</p> <p>Raises:</p> <ul> <li> <code>(LookupError, NotFoundError)</code>             \u2013            <p>The last context has no initial response.</p> </li> </ul>"},{"location":"reference/#yuyo.ModalContext.delete_last_response","title":"delete_last_response  <code>async</code>","text":"<pre><code>delete_last_response()\n</code></pre> <p>Delete the last response after invoking this context.</p> <p>Raises:</p> <ul> <li> <code>(LookupError, NotFoundError)</code>             \u2013            <p>The last context has no responses.</p> </li> </ul>"},{"location":"reference/#yuyo.ModalContext.edit_initial_response","title":"edit_initial_response  <code>async</code>","text":"<pre><code>edit_initial_response(content=hikari.UNDEFINED, *, delete_after=None, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, mentions_everyone=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED)\n</code></pre> <p>Edit the initial response for this context.</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>UndefinedOr[Any]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message content to edit the initial response with.</p> <p>If this is a hikari.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> </li> <li> <code>delete_after</code>               (<code>timedelta | float | int | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, the seconds after which the response message should be deleted.</p> <p>Interaction responses can only be deleted within 15 minutes of the interaction being received.</p> </li> <li> <code>attachment</code>               (<code>UndefinedNoneOr[Resourceish]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A singular attachment to edit the initial response with.</p> </li> <li> <code>attachments</code>               (<code>UndefinedNoneOr[Sequence[Resourceish]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A sequence of attachments to edit the initial response with.</p> </li> <li> <code>component</code>               (<code>UndefinedNoneOr[ComponentBuilder]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, builder object of the component to set for this message. This component will replace any previously set components and passing None will remove all components.</p> </li> <li> <code>components</code>               (<code>UndefinedNoneOr[Sequence[ComponentBuilder]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing None or an empty sequence will remove all components.</p> </li> <li> <code>embed</code>               (<code>UndefinedNoneOr[Embed]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>An embed to replace the initial response with.</p> </li> <li> <code>embeds</code>               (<code>UndefinedNoneOr[Sequence[Embed]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A sequence of embeds to replace the initial response with.</p> </li> <li> <code>mentions_everyone</code>               (<code>UndefinedOr[bool]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, whether the message should parse @everyone/@here mentions.</p> </li> <li> <code>user_mentions</code>               (<code>SnowflakeishSequence[PartialUser] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialUser derivatives to enforce mentioning specific users.</p> </li> <li> <code>role_mentions</code>               (<code>SnowflakeishSequence[PartialRole] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialRole derivatives to enforce mentioning specific roles.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Message</code>           \u2013            <p>The message that has been edited.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If more than 100 unique objects/entities are passed for <code>role_mentions</code> or <code>user_mentions</code>.</p> <p>If <code>delete_after</code> would be more than 15 minutes after the interaction was received.</p> <p>If both <code>attachment</code> and <code>attachments</code> are passed or both <code>component</code> and <code>components</code> are passed or both <code>embed</code> and <code>embeds</code> are passed.</p> </li> <li> <code>BadRequestError</code>             \u2013            <p>This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components.</p> </li> <li> <code>UnauthorizedError</code>             \u2013            <p>If you are unauthorized to make the request (invalid/missing token).</p> </li> <li> <code>ForbiddenError</code>             \u2013            <p>If you are missing the <code>SEND_MESSAGES</code> in the channel or the person you are trying to message has the DM's disabled.</p> </li> <li> <code>NotFoundError</code>             \u2013            <p>If the channel is not found.</p> </li> <li> <code>RateLimitTooLongError</code>             \u2013            <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> </li> <li> <code>InternalServerError</code>             \u2013            <p>If an internal error occurs on Discord while handling the request.</p> </li> </ul>"},{"location":"reference/#yuyo.ModalContext.edit_last_response","title":"edit_last_response  <code>async</code>","text":"<pre><code>edit_last_response(content=hikari.UNDEFINED, *, delete_after=None, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, mentions_everyone=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED)\n</code></pre> <p>Edit the last response for this context.</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>UndefinedOr[Any]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the content to edit the last response with.</p> <p>If this is a hikari.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> </li> <li> <code>delete_after</code>               (<code>timedelta | float | int | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, the seconds after which the response message should be deleted.</p> <p>Interaction responses can only be deleted within 15 minutes of the interaction being received.</p> </li> <li> <code>attachment</code>               (<code>UndefinedNoneOr[Resourceish]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A singular attachment to edit the last response with.</p> </li> <li> <code>attachments</code>               (<code>UndefinedNoneOr[Sequence[Resourceish]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A sequence of attachments to edit the last response with.</p> </li> <li> <code>component</code>               (<code>UndefinedNoneOr[ComponentBuilder]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, builder object of the component to set for this message. This component will replace any previously set components and passing None will remove all components.</p> </li> <li> <code>components</code>               (<code>UndefinedNoneOr[Sequence[ComponentBuilder]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing None or an empty sequence will remove all components.</p> </li> <li> <code>embed</code>               (<code>UndefinedNoneOr[Embed]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>An embed to replace the last response with.</p> </li> <li> <code>embeds</code>               (<code>UndefinedNoneOr[Sequence[Embed]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A sequence of embeds to replace the last response with.</p> </li> <li> <code>mentions_everyone</code>               (<code>UndefinedOr[bool]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, whether the message should parse @everyone/@here mentions.</p> </li> <li> <code>user_mentions</code>               (<code>SnowflakeishSequence[PartialUser] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialUser derivatives to enforce mentioning specific users.</p> </li> <li> <code>role_mentions</code>               (<code>SnowflakeishSequence[PartialRole] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialRole derivatives to enforce mentioning specific roles.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Message</code>           \u2013            <p>The message that has been edited.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If more than 100 unique objects/entities are passed for <code>role_mentions</code> or <code>user_mentions</code>.</p> <p>If <code>delete_after</code> would be more than 15 minutes after the slash interaction was received.</p> <p>If both <code>attachment</code> and <code>attachments</code> are passed or both <code>component</code> and <code>components</code> are passed or both <code>embed</code> and <code>embeds</code> are passed.</p> </li> <li> <code>BadRequestError</code>             \u2013            <p>This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components.</p> </li> <li> <code>UnauthorizedError</code>             \u2013            <p>If you are unauthorized to make the request (invalid/missing token).</p> </li> <li> <code>ForbiddenError</code>             \u2013            <p>If you are missing the <code>SEND_MESSAGES</code> in the channel or the person you are trying to message has the DM's disabled.</p> </li> <li> <code>NotFoundError</code>             \u2013            <p>If the channel is not found.</p> </li> <li> <code>RateLimitTooLongError</code>             \u2013            <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> </li> <li> <code>InternalServerError</code>             \u2013            <p>If an internal error occurs on Discord while handling the request.</p> </li> </ul>"},{"location":"reference/#yuyo.ModalContext.fetch_initial_response","title":"fetch_initial_response  <code>async</code>","text":"<pre><code>fetch_initial_response()\n</code></pre> <p>Fetch the initial response for this context.</p> <p>Returns:</p> <ul> <li> <code>Message</code>           \u2013            <p>The initial response's message object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>(LookupError, NotFoundError)</code>             \u2013            <p>The response was not found.</p> </li> </ul>"},{"location":"reference/#yuyo.ModalContext.fetch_last_response","title":"fetch_last_response  <code>async</code>","text":"<pre><code>fetch_last_response()\n</code></pre> <p>Fetch the last response for this context.</p> <p>Returns:</p> <ul> <li> <code>Message</code>           \u2013            <p>The most response response's message object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>(LookupError, NotFoundError)</code>             \u2013            <p>The response was not found.</p> </li> </ul>"},{"location":"reference/#yuyo.ModalContext.respond","title":"respond  <code>async</code>","text":"<pre><code>respond(content: UndefinedOr[Any] = hikari.UNDEFINED, *, ensure_result: Literal[True], delete_after: timedelta | float | int | None = None, attachment: UndefinedOr[Resourceish] = hikari.UNDEFINED, attachments: UndefinedOr[Sequence[Resourceish]] = hikari.UNDEFINED, component: UndefinedOr[ComponentBuilder] = hikari.UNDEFINED, components: UndefinedOr[Sequence[ComponentBuilder]] = hikari.UNDEFINED, embed: UndefinedOr[Embed] = hikari.UNDEFINED, embeds: UndefinedOr[Sequence[Embed]] = hikari.UNDEFINED, mentions_everyone: UndefinedOr[bool] = hikari.UNDEFINED, user_mentions: SnowflakeishSequence[PartialUser] | bool | UndefinedType = hikari.UNDEFINED, role_mentions: SnowflakeishSequence[PartialRole] | bool | UndefinedType = hikari.UNDEFINED) -&gt; hikari.Message\n</code></pre><pre><code>respond(content: UndefinedOr[Any] = hikari.UNDEFINED, *, ensure_result: bool = False, delete_after: timedelta | float | int | None = None, attachment: UndefinedOr[Resourceish] = hikari.UNDEFINED, attachments: UndefinedOr[Sequence[Resourceish]] = hikari.UNDEFINED, component: UndefinedOr[ComponentBuilder] = hikari.UNDEFINED, components: UndefinedOr[Sequence[ComponentBuilder]] = hikari.UNDEFINED, embed: UndefinedOr[Embed] = hikari.UNDEFINED, embeds: UndefinedOr[Sequence[Embed]] = hikari.UNDEFINED, mentions_everyone: UndefinedOr[bool] = hikari.UNDEFINED, user_mentions: SnowflakeishSequence[PartialUser] | bool | UndefinedType = hikari.UNDEFINED, role_mentions: SnowflakeishSequence[PartialRole] | bool | UndefinedType = hikari.UNDEFINED) -&gt; hikari.Message | None\n</code></pre> <pre><code>respond(content=hikari.UNDEFINED, *, ensure_result=False, delete_after=None, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, mentions_everyone=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED)\n</code></pre> <p>Respond to this context.</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>UndefinedOr[Any]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message content to respond with.</p> <p>If this is a hikari.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead be treated as an embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> </li> <li> <code>ensure_result</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Ensure that this call will always return a message object.</p> <p>If True then this will always return hikari.Message, otherwise this will return <code>hikari.Message | None</code>.</p> <p>It's worth noting that this may lead to an extre request being made under certain scenarios.</p> </li> <li> <code>delete_after</code>               (<code>timedelta | float | int | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, the seconds after which the response message should be deleted.</p> <p>Interaction responses can only be deleted within 15 minutes of the interaction being received.</p> </li> <li> <code>attachment</code>               (<code>UndefinedOr[Resourceish]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.</p> </li> <li> <code>attachments</code>               (<code>UndefinedOr[Sequence[Resourceish]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.</p> </li> <li> <code>component</code>               (<code>UndefinedOr[ComponentBuilder]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, builder object of the component to include in this response.</p> </li> <li> <code>components</code>               (<code>UndefinedOr[Sequence[ComponentBuilder]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, a sequence of the component builder objects to include in this response.</p> </li> <li> <code>embed</code>               (<code>UndefinedOr[Embed]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>An embed to respond with.</p> </li> <li> <code>embeds</code>               (<code>UndefinedOr[Sequence[Embed]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A sequence of embeds to respond with.</p> </li> <li> <code>mentions_everyone</code>               (<code>UndefinedOr[bool]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, whether the message should parse @everyone/@here mentions.</p> </li> <li> <code>user_mentions</code>               (<code>SnowflakeishSequence[PartialUser] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialUser derivatives to enforce mentioning specific users.</p> </li> <li> <code>role_mentions</code>               (<code>SnowflakeishSequence[PartialRole] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialRole derivatives to enforce mentioning specific roles.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Message | None</code>           \u2013            <p>The message that has been created if it was immedieatly available or <code>ensure_result</code> was set to True, else None.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If more than 100 unique objects/entities are passed for <code>role_mentions</code> or <code>user_mentions</code>.</p> <p>If <code>delete_after</code> would be more than 15 minutes after the interaction was received.</p> <p>If both <code>attachment</code> and <code>attachments</code> are passed or both <code>component</code> and <code>components</code> are passed or both <code>embed</code> and <code>embeds</code> are passed.</p> </li> <li> <code>BadRequestError</code>             \u2013            <p>This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components.</p> </li> <li> <code>UnauthorizedError</code>             \u2013            <p>If you are unauthorized to make the request (invalid/missing token).</p> </li> <li> <code>ForbiddenError</code>             \u2013            <p>If you are missing the <code>SEND_MESSAGES</code> in the channel or the person you are trying to message has the DM's disabled.</p> </li> <li> <code>NotFoundError</code>             \u2013            <p>If the channel is not found.</p> </li> <li> <code>RateLimitTooLongError</code>             \u2013            <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> </li> <li> <code>InternalServerError</code>             \u2013            <p>If an internal error occurs on Discord while handling the request.</p> </li> </ul>"},{"location":"reference/#yuyo.ModalContext.set_ephemeral_default","title":"set_ephemeral_default","text":"<pre><code>set_ephemeral_default(state)\n</code></pre> <p>Set the ephemeral default state for this context.</p> <p>Parameters:</p> <ul> <li> <code>state</code>               (<code>bool</code>)           \u2013            <p>The new ephemeral default state.</p> <p>If this is True then all calls to the response creating methods on this context will default to being ephemeral.</p> </li> </ul>"},{"location":"reference/#yuyo.Page","title":"Page","text":"<p>               Bases: <code>AbstractPage</code></p> <p>Represents a pagianted response.</p>"},{"location":"reference/#yuyo.Page.__init__","title":"__init__","text":"<pre><code>__init__(content: str | UndefinedType = hikari.UNDEFINED, *, attachment: UndefinedOr[Resourceish] = hikari.UNDEFINED, attachments: UndefinedOr[Sequence[Resourceish]] = hikari.UNDEFINED, embed: UndefinedOr[Embed] = hikari.UNDEFINED, embeds: UndefinedOr[Sequence[Embed]] = hikari.UNDEFINED) -&gt; None\n</code></pre><pre><code>__init__(content: Resourceish, *, embed: UndefinedOr[Embed] = hikari.UNDEFINED, embeds: UndefinedOr[Sequence[Embed]] = hikari.UNDEFINED) -&gt; None\n</code></pre><pre><code>__init__(content: Embed, *, attachment: UndefinedOr[Resourceish] = hikari.UNDEFINED, attachments: UndefinedOr[Sequence[Resourceish]] = hikari.UNDEFINED) -&gt; None\n</code></pre> <pre><code>__init__(content=hikari.UNDEFINED, *, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED)\n</code></pre> <p>Initialise a response page.</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>str | Embed | Resourceish | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The message content to send.</p> <p>If this is a hikari.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead be treated as an embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> </li> <li> <code>attachment</code>               (<code>UndefinedOr[Resourceish]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A singular attachment to send.</p> </li> <li> <code>attachments</code>               (<code>UndefinedOr[Sequence[Resourceish]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Up to 10 attachments to include in the response.</p> </li> <li> <code>embed</code>               (<code>UndefinedOr[Embed]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A singular embed to send.</p> </li> <li> <code>embeds</code>               (<code>UndefinedOr[Sequence[Embed]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Up to 10 embeds to include in the response.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>Raised for any of the following reasons:</p> <ul> <li>When both <code>attachment</code> and <code>attachments</code> are provided.</li> <li>When both <code>embed</code> and <code>embeds</code> are passed.</li> </ul> </li> </ul>"},{"location":"reference/#yuyo.Page.ctx_to_kwargs","title":"ctx_to_kwargs","text":"<pre><code>ctx_to_kwargs(_)\n</code></pre> <p>Form create message <code>**kwargs</code> for this page based on a component or modal context.</p> <p>Returns:</p> <ul> <li> <code>ResponseKwargs</code>           \u2013            <p>The create message kwargs for this page.</p> </li> </ul>"},{"location":"reference/#yuyo.Page.from_entry","title":"from_entry  <code>classmethod</code>","text":"<pre><code>from_entry(entry)\n</code></pre> <p>Create a Page from a EntryT.</p> <p>Parameters:</p> <ul> <li> <code>entry</code>               (<code>EntryT</code>)           \u2013            <p>The EntryT to make a page from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AbstractPage</code>           \u2013            <p>The created page.</p> </li> </ul>"},{"location":"reference/#yuyo.Page.to_kwargs","title":"to_kwargs","text":"<pre><code>to_kwargs()\n</code></pre> <p>Form create message <code>**kwargs</code> for this page.</p> <p>Returns:</p> <ul> <li> <code>ResponseKwargs</code>           \u2013            <p>The create message kwargs for this page.</p> </li> </ul>"},{"location":"reference/#yuyo.ReactionClient","title":"ReactionClient","text":"<p>A class which handles the events for multiple registered reaction handlers.</p>"},{"location":"reference/#yuyo.ReactionClient.alluka","title":"alluka  <code>property</code>","text":"<pre><code>alluka\n</code></pre> <p>The Alluka client being used for callback dependency injection.</p>"},{"location":"reference/#yuyo.ReactionClient.is_closed","title":"is_closed  <code>property</code>","text":"<pre><code>is_closed\n</code></pre> <p>Whether this client is closed.</p>"},{"location":"reference/#yuyo.ReactionClient.__init__","title":"__init__","text":"<pre><code>__init__(*, rest, event_manager, alluka=None, event_managed=True)\n</code></pre> <p>Initialise a reaction client.</p> <p>This registers ReactionClient as a type dependency when <code>alluka</code> isn't passed.</p> <p>Note</p> <p>For an easier way to initialise the client from a bot see ReactionClient.from_gateway_bot, and ReactionClient.from_tanjun.</p> <p>Parameters:</p> <ul> <li> <code>rest</code>               (<code>RESTClient</code>)           \u2013            <p>The REST client to register this reaction client with.</p> </li> <li> <code>event_manager</code>               (<code>EventManager</code>)           \u2013            <p>The event manager client to register this reaction client with.</p> </li> <li> <code>alluka</code>               (<code>Client | None</code>, default:                   <code>None</code> )           \u2013            <p>The Alluka client to use for callback dependency injection in this client.</p> <p>If not provided then this will initialise its own Alluka client.</p> </li> <li> <code>event_managed</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the reaction client should be automatically opened and closed based on the lifetime events dispatched by <code>event_managed</code>.</p> </li> </ul>"},{"location":"reference/#yuyo.ReactionClient.close","title":"close  <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Close this client by unregistering any registered tasks and event listeners.</p>"},{"location":"reference/#yuyo.ReactionClient.from_gateway_bot","title":"from_gateway_bot  <code>classmethod</code>","text":"<pre><code>from_gateway_bot(bot, /, *, alluka=None, event_managed=True)\n</code></pre> <p>Build a <code>ReactionClient</code> from a gateway bot.</p> <p>This registers ReactionClient as a type dependency when <code>alluka</code> isn't passed.</p> <p>Parameters:</p> <ul> <li> <code>bot</code>               (<code>EventManagerAware &amp; RESTAware</code>)           \u2013            <p>The bot to build a reaction client for.</p> </li> <li> <code>alluka</code>               (<code>Client | None</code>, default:                   <code>None</code> )           \u2013            <p>The Alluka client to use for callback dependency injection in this client.</p> <p>If not provided then this will initialise its own Alluka client.</p> </li> <li> <code>event_managed</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the reaction client should be automatically opened and closed based on the lifetime events dispatched by <code>bot</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ReactionClient</code>           \u2013            <p>The reaction client for the bot.</p> </li> </ul>"},{"location":"reference/#yuyo.ReactionClient.from_tanjun","title":"from_tanjun  <code>classmethod</code>","text":"<pre><code>from_tanjun(tanjun_client, /, *, tanjun_managed=True)\n</code></pre> <p>Build a <code>ReactionClient</code> from a gateway bot.</p> <p>This will use the Tanjun client's alluka client and registers ReactionClient as a type dependency on Tanjun.</p> <p>Parameters:</p> <ul> <li> <code>tanjun_client</code>               (<code>Client</code>)           \u2013            <p>The tanjun client to build a reaction client for.</p> </li> <li> <code>tanjun_managed</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the reaction client should be automatically opened and closed based on the Tanjun client's lifetime client callback.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ReactionClient</code>           \u2013            <p>The reaction client for the bot.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>tanjun_client.events</code> is None.</p> </li> </ul>"},{"location":"reference/#yuyo.ReactionClient.get_handler","title":"get_handler","text":"<pre><code>get_handler(message)\n</code></pre> <p>Get a reference to a handler registered in this reaction client.</p> <p>Note</p> <p>This does not call AbstractReactionHandler.close.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>SnowflakeishOr[Message]</code>)           \u2013            <p>The message ID to remove a handler for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AbstractReactionHandler | None</code>           \u2013            <p>The object of the registered handler if found else None.</p> </li> </ul>"},{"location":"reference/#yuyo.ReactionClient.open","title":"open  <code>async</code>","text":"<pre><code>open()\n</code></pre> <p>Start this client by registering the required tasks and event listeners for it to function.</p>"},{"location":"reference/#yuyo.ReactionClient.remove_handler","title":"remove_handler","text":"<pre><code>remove_handler(message)\n</code></pre> <p>Remove a handler from this reaction client.</p> <p>Note</p> <p>This does not call AbstractReactionHandler.close.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>SnowflakeishOr[Message]</code>)           \u2013            <p>The message ID to remove a handler for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AbstractReactionHandler | None</code>           \u2013            <p>The object of the registered handler if found else None.</p> </li> </ul>"},{"location":"reference/#yuyo.ReactionClient.set_handler","title":"set_handler","text":"<pre><code>set_handler(message, handler)\n</code></pre> <p>Add a reaction handler to this reaction client.</p> <p>Note</p> <p>This does not call AbstractReactionHandler.open.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>SnowflakeishOr[Message]</code>)           \u2013            <p>The message ID to add register a reaction handler with.</p> </li> <li> <code>handler</code>               (<code>AbstractReactionHandler</code>)           \u2013            <p>The object of the opened handler to register in this reaction client.</p> </li> </ul>"},{"location":"reference/#yuyo.ReactionHandler","title":"ReactionHandler","text":"<p>               Bases: <code>AbstractReactionHandler</code></p> <p>Standard basic implementation of a reaction handler.</p>"},{"location":"reference/#yuyo.ReactionHandler.authors","title":"authors  <code>property</code>","text":"<pre><code>authors\n</code></pre> <p>Set of the authors/owner of a enabled handler.</p> <p>Note</p> <p>If this is empty then the handler is considered public and any user will be able to trigger it.</p>"},{"location":"reference/#yuyo.ReactionHandler.__init__","title":"__init__","text":"<pre><code>__init__(*, authors=(), timeout=datetime.timedelta(seconds=30))\n</code></pre> <p>Initialise a reaction handler.</p> <p>Parameters:</p> <ul> <li> <code>authors</code>               (<code>Iterable[SnowflakeishOr[User]]</code>, default:                   <code>()</code> )           \u2013            <p>An iterable of IDs of the users who can call this handler.</p> <p>If no users are provided then the reactions will be public (meaning that anybody can use it).</p> </li> <li> <code>timeout</code>               (<code>timedelta | None</code>, default:                   <code>timedelta(seconds=30)</code> )           \u2013            <p>How long it should take for this handler to timeout.</p> </li> </ul>"},{"location":"reference/#yuyo.ReactionHandler.remove_callback","title":"remove_callback","text":"<pre><code>remove_callback(emoji_identifier)\n</code></pre> <p>Remove a callback from this reaction handler.</p> <p>Parameters:</p> <ul> <li> <code>emoji_identifier</code>               (<code>str | SnowflakeishOr[CustomEmoji]</code>)           \u2013            <p>Identifier of the emoji the callback to remove is for.</p> <p>This should be a snowfake if this is for a custom emoji or a string if this is for a unicode emoji.</p> </li> </ul>"},{"location":"reference/#yuyo.ReactionHandler.set_callback","title":"set_callback","text":"<pre><code>set_callback(emoji_identifier, callback)\n</code></pre> <p>Add a callback to this reaction handler.</p> <p>Parameters:</p> <ul> <li> <code>emoji_identifier</code>               (<code>str | SnowflakeishOr[CustomEmoji]</code>)           \u2013            <p>Identifier of the emoji this callback is for.</p> <p>This should be a snowfake if this is for a custom emoji or a string if this is for a unicode emoji.</p> </li> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>The callback to add.</p> <p>This should be a function that accepts a single parameter, which is the event that triggered this reaction.</p> </li> </ul>"},{"location":"reference/#yuyo.ReactionHandler.with_callback","title":"with_callback","text":"<pre><code>with_callback(emoji_identifier)\n</code></pre> <p>Add a callback to this reaction handler through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>emoji_identifier</code>               (<code>str | SnowflakeishOr[CustomEmoji]</code>)           \u2013            <p>Identifier of the emoji this callback is for.</p> <p>This should be a snowfake if this is for a custom emoji or a string if this is for a unicode emoji.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callback[[CallbackSig], CallbackSig]</code>           \u2013            <p>A decorator to add a callback to this reaction handler.</p> </li> </ul>"},{"location":"reference/#yuyo.ReactionPaginator","title":"ReactionPaginator","text":"<p>               Bases: <code>ReactionHandler</code></p> <p>Standard implementation of a reaction handler for pagination.</p>"},{"location":"reference/#yuyo.ReactionPaginator.authors","title":"authors  <code>property</code>","text":"<pre><code>authors\n</code></pre> <p>Set of the authors/owner of a enabled handler.</p> <p>Note</p> <p>If this is empty then the handler is considered public and any user will be able to trigger it.</p>"},{"location":"reference/#yuyo.ReactionPaginator.__init__","title":"__init__","text":"<pre><code>__init__(iterator, /, *, authors=(), triggers=(pagination.LEFT_TRIANGLE, pagination.STOP_SQUARE, pagination.RIGHT_TRIANGLE), timeout=datetime.timedelta(seconds=30))\n</code></pre> <p>Initialise a reaction paginator.</p> <p>Parameters:</p> <ul> <li> <code>iterator</code>               (<code>Iterator[EntryT] | AsyncIterator[EntryT]</code>)           \u2013            <p>Either an asynchronous or synchronous iterator of the entries this should paginate through.</p> <p>This should be an iterator of yuyo.pagination.AbstractPages.</p> </li> <li> <code>authors</code>               (<code>Iterable[SnowflakeishOr[User]]</code>, default:                   <code>()</code> )           \u2013            <p>An iterable of IDs of the users who can call this paginator.</p> <p>If no users are provided then the reactions will be public (meaning that anybody can use it).</p> </li> <li> <code>timeout</code>               (<code>timedelta | None</code>, default:                   <code>timedelta(seconds=30)</code> )           \u2013            <p>How long it should take for this paginator to timeout.</p> </li> </ul>"},{"location":"reference/#yuyo.ReactionPaginator.add_author","title":"add_author","text":"<pre><code>add_author(user)\n</code></pre> <p>Add a author/owner to this handler.</p> <p>Parameters:</p> <ul> <li> <code>user</code>               (<code>SnowflakeishOr[User]</code>)           \u2013            <p>The user to add as an owner for this handler.</p> </li> </ul>"},{"location":"reference/#yuyo.ReactionPaginator.add_first_button","title":"add_first_button","text":"<pre><code>add_first_button(*, emoji=pagination.LEFT_DOUBLE_TRIANGLE, add_reaction=True)\n</code></pre> <p>Add the jump to first entry reaction button to this paginator.</p> <p>You should pass <code>triggers=[]</code> to ReactionPaginator.__init__ before calling this.</p> <p>Note</p> <p>These reactions will appear in the order these methods were called in.</p> <p>Parameters:</p> <ul> <li> <code>emoji</code>               (<code>CustomEmoji | str</code>, default:                   <code>LEFT_DOUBLE_TRIANGLE</code> )           \u2013            <p>The emoji to react with for this button.</p> </li> <li> <code>add_reaction</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the bot should add this reaction to the message when ReactionPaginator.open is called with <code>add_reactions=True</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>To enable chained calls.</p> </li> </ul>"},{"location":"reference/#yuyo.ReactionPaginator.add_last_button","title":"add_last_button","text":"<pre><code>add_last_button(*, emoji=pagination.RIGHT_DOUBLE_TRIANGLE, add_reaction=True)\n</code></pre> <p>Add the jump to last entry reaction button to this paginator.</p> <p>You should pass <code>triggers=[]</code> to ReactionPaginator.__init__ before calling this.</p> <p>Note</p> <p>These reactions will appear in the order these methods were called in.</p> <p>Parameters:</p> <ul> <li> <code>emoji</code>               (<code>CustomEmoji | str</code>, default:                   <code>RIGHT_DOUBLE_TRIANGLE</code> )           \u2013            <p>The emoji to react with for this button.</p> </li> <li> <code>add_reaction</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the bot should add this reaction to the message when ReactionPaginator.open is called with <code>add_reactions=True</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>To enable chained calls.</p> </li> </ul>"},{"location":"reference/#yuyo.ReactionPaginator.add_next_button","title":"add_next_button","text":"<pre><code>add_next_button(*, emoji=pagination.RIGHT_TRIANGLE, add_reaction=True)\n</code></pre> <p>Add the next entry reaction button to this paginator.</p> <p>You should pass <code>triggers=[]</code> to ReactionPaginator.__init__ before calling this.</p> <p>Note</p> <p>These reactions will appear in the order these methods were called in.</p> <p>Parameters:</p> <ul> <li> <code>emoji</code>               (<code>CustomEmoji | str</code>, default:                   <code>RIGHT_TRIANGLE</code> )           \u2013            <p>The emoji to react with for this button.</p> </li> <li> <code>add_reaction</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the bot should add this reaction to the message when ReactionPaginator.open is called with <code>add_reactions=True</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>To enable chained calls.</p> </li> </ul>"},{"location":"reference/#yuyo.ReactionPaginator.add_previous_button","title":"add_previous_button","text":"<pre><code>add_previous_button(*, emoji=pagination.LEFT_TRIANGLE, add_reaction=True)\n</code></pre> <p>Add the previous entry reaction button to this paginator.</p> <p>You should pass <code>triggers=[]</code> to ReactionPaginator.__init__ before calling this.</p> <p>Note</p> <p>These reactions will appear in the order these methods were called in.</p> <p>Parameters:</p> <ul> <li> <code>emoji</code>               (<code>CustomEmoji | str</code>, default:                   <code>LEFT_TRIANGLE</code> )           \u2013            <p>The emoji to react with for this button.</p> </li> <li> <code>add_reaction</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the bot should add this reaction to the message when ReactionPaginator.open is called with <code>add_reactions=True</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>To enable chained calls.</p> </li> </ul>"},{"location":"reference/#yuyo.ReactionPaginator.add_stop_button","title":"add_stop_button","text":"<pre><code>add_stop_button(*, emoji=pagination.STOP_SQUARE, add_reaction=True)\n</code></pre> <p>Add the stop reaction button to this paginator.</p> <p>You should pass <code>triggers=[]</code> to ReactionPaginator.__init__ before calling this.</p> <p>Note</p> <p>These reactions will appear in the order these methods were called in.</p> <p>Parameters:</p> <ul> <li> <code>emoji</code>               (<code>CustomEmoji | str</code>, default:                   <code>STOP_SQUARE</code> )           \u2013            <p>The emoji to react with for this button.</p> </li> <li> <code>add_reaction</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the bot should add this reaction to the message when ReactionPaginator.open is called with <code>add_reactions=True</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>To enable chained calls.</p> </li> </ul>"},{"location":"reference/#yuyo.ReactionPaginator.close","title":"close  <code>async</code>","text":"<pre><code>close(*, remove_reactions=False)\n</code></pre> <p>Close this handler and deregister any previously registered message.</p> <p>Parameters:</p> <ul> <li> <code>remove_reactions</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this should remove the reactions that were being used to paginate through this from the previously registered message.</p> </li> </ul>"},{"location":"reference/#yuyo.ReactionPaginator.create_message","title":"create_message  <code>async</code>","text":"<pre><code>create_message(rest, channel_id, /, *, add_reactions=True)\n</code></pre> <p>Start this handler and link it to a bot message.</p> <p>Note</p> <p>Calling this multiple times will replace the previously registered message.</p> <p>Parameters:</p> <ul> <li> <code>rest</code>               (<code>RESTClient</code>)           \u2013            <p>Rest client to use to make the response.</p> </li> <li> <code>channel_id</code>               (<code>SnowflakeishOr[TextableChannel]</code>)           \u2013            <p>ID of the channel to respond in.</p> </li> <li> <code>add_reactions</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether this should add the paginator's reactions to the message after responding.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Message</code>           \u2013            <p>Object of the message this handler now targets. If <code>message</code> was not supplied then this will be the object of a newly created message, otherwise this will be what was supplied as <code>message</code>.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the provided iterator didn't yield any content for the first message.</p> </li> </ul>"},{"location":"reference/#yuyo.ReactionPaginator.get_next_entry","title":"get_next_entry  <code>async</code>","text":"<pre><code>get_next_entry()\n</code></pre> <p>Get the next entry in this paginator.</p> <p>Returns:</p> <ul> <li> <code>AbstractPage | None</code>           \u2013            <p>The next entry in this paginator, or None if there are no more entries.</p> </li> </ul>"},{"location":"reference/#yuyo.ReactionPaginator.open","title":"open  <code>async</code>","text":"<pre><code>open(message, /, *, add_reactions=True)\n</code></pre> <p>Start the reaction paginator and start accepting reactions..</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>Message</code>)           \u2013            <p>The message this paginator should target.</p> </li> <li> <code>add_reactions</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether this should add the paginator's reactions to the message.</p> </li> </ul>"},{"location":"reference/#yuyo.ReactionPaginator.remove_author","title":"remove_author","text":"<pre><code>remove_author(user)\n</code></pre> <p>Remove a author/owner from this handler.</p> <p>Note</p> <p>If the provided user isn't already a registered owner of this paginator then this should pass silently without raising.</p> <p>Parameters:</p> <ul> <li> <code>user</code>               (<code>SnowflakeishOr[User]</code>)           \u2013            <p>The user to remove from this handler's owners.</p> </li> </ul>"},{"location":"reference/#yuyo.ReactionPaginator.remove_callback","title":"remove_callback","text":"<pre><code>remove_callback(emoji_identifier)\n</code></pre> <p>Remove a callback from this reaction handler.</p> <p>Parameters:</p> <ul> <li> <code>emoji_identifier</code>               (<code>str | SnowflakeishOr[CustomEmoji]</code>)           \u2013            <p>Identifier of the emoji the callback to remove is for.</p> <p>This should be a snowfake if this is for a custom emoji or a string if this is for a unicode emoji.</p> </li> </ul>"},{"location":"reference/#yuyo.ReactionPaginator.set_callback","title":"set_callback","text":"<pre><code>set_callback(emoji_identifier, callback)\n</code></pre> <p>Add a callback to this reaction handler.</p> <p>Parameters:</p> <ul> <li> <code>emoji_identifier</code>               (<code>str | SnowflakeishOr[CustomEmoji]</code>)           \u2013            <p>Identifier of the emoji this callback is for.</p> <p>This should be a snowfake if this is for a custom emoji or a string if this is for a unicode emoji.</p> </li> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>The callback to add.</p> <p>This should be a function that accepts a single parameter, which is the event that triggered this reaction.</p> </li> </ul>"},{"location":"reference/#yuyo.ReactionPaginator.with_callback","title":"with_callback","text":"<pre><code>with_callback(emoji_identifier)\n</code></pre> <p>Add a callback to this reaction handler through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>emoji_identifier</code>               (<code>str | SnowflakeishOr[CustomEmoji]</code>)           \u2013            <p>Identifier of the emoji this callback is for.</p> <p>This should be a snowfake if this is for a custom emoji or a string if this is for a unicode emoji.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callback[[CallbackSig], CallbackSig]</code>           \u2013            <p>A decorator to add a callback to this reaction handler.</p> </li> </ul>"},{"location":"reference/#yuyo.ServiceManager","title":"ServiceManager","text":"<p>               Bases: <code>AbstractManager</code></p> <p>Standard service manager.</p>"},{"location":"reference/#yuyo.ServiceManager.is_alive","title":"is_alive  <code>property</code>","text":"<pre><code>is_alive\n</code></pre> <p>Wwhether this manager is active.</p>"},{"location":"reference/#yuyo.ServiceManager.__init__","title":"__init__","text":"<pre><code>__init__(rest, /, *, cache=None, event_manager=None, shards=None, event_managed=None, strategy=None, user_agent=None)\n</code></pre> <p>Initialise a service manager.</p> <p>Note</p> <p>For an easier way to initialise the manager from a bot see ServiceManager.from_gateway_bot, and ServiceManager.from_tanjun.</p> <p>Parameters:</p> <ul> <li> <code>rest</code>               (<code>RESTClient</code>)           \u2013            <p>The RESTAware Hikari client to bind this manager to.</p> </li> <li> <code>cache</code>               (<code>Cache | None</code>, default:                   <code>None</code> )           \u2013            <p>The cache aware Hikari client this manager should use.</p> </li> <li> <code>event_manager</code>               (<code>EventManager | None</code>, default:                   <code>None</code> )           \u2013            <p>The event manager aware Hikari client this manager should use.</p> </li> <li> <code>shards</code>               (<code>ShardAware | None</code>, default:                   <code>None</code> )           \u2013            <p>The shard aware Hikari client this manager should use.</p> </li> <li> <code>event_managed</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether this client should be automatically opened and closed based on <code>event_manager</code>'s lifetime events.</p> <p>Defaults to True when <code>event_manager</code> is passed.</p> </li> <li> <code>strategy</code>               (<code>AbstractCountStrategy | None</code>, default:                   <code>None</code> )           \u2013            <p>The counter strategy this manager should expose to services.</p> <p>If this is left as None then the manager will try to pick a suitable standard strategy based on the provided Hikari clients.</p> </li> <li> <code>user_agent</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Override the standard user agent used during requests to bot list services.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the manager failed to find a suitable standard strategy to use when <code>strategy</code> was left as None.</p> <p>If <code>event_managed</code> is passed as True when <code>event_manager</code> is None.</p> </li> </ul>"},{"location":"reference/#yuyo.ServiceManager.add_service","title":"add_service","text":"<pre><code>add_service(service, /, *, repeat=datetime.timedelta(hours=1))\n</code></pre> <p>Add a service to this manager.</p> <p>Parameters:</p> <ul> <li> <code>service</code>               (<code>ServiceSig</code>)           \u2013            <p>Asynchronous callback used to update this service.</p> </li> <li> <code>repeat</code>               (<code>timedelta | int | float</code>, default:                   <code>timedelta(hours=1)</code> )           \u2013            <p>How often this service should be updated in seconds.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>Object of this service manager.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If repeat is less than 1 second.</p> </li> <li> <code>RuntimeError</code>             \u2013            <p>If the client is already running.</p> </li> </ul>"},{"location":"reference/#yuyo.ServiceManager.close","title":"close  <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Close this manager.</p>"},{"location":"reference/#yuyo.ServiceManager.from_gateway_bot","title":"from_gateway_bot  <code>classmethod</code>","text":"<pre><code>from_gateway_bot(bot, /, *, event_managed=True, strategy=None, user_agent=None)\n</code></pre> <p>Build a service manager from a gateway bot.</p> <p>Parameters:</p> <ul> <li> <code>bot</code>               (<code>ShardAware &amp; RESTAware &amp; EventManagerAware</code>)           \u2013            <p>The gateway bot to build a service manager from.</p> </li> <li> <code>event_managed</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether this client should be automatically opened and closed based on <code>bot</code>'s lifetime events.</p> </li> <li> <code>strategy</code>               (<code>AbstractCountStrategy | None</code>, default:                   <code>None</code> )           \u2013            <p>The counter strategy this manager should expose to services.</p> <p>If this is left as None then the manager will try to pick a suitable standard strategy based on the provided Hikari clients.</p> </li> <li> <code>user_agent</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Override the standard user agent used during requests to bot list services.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ServiceManager</code>           \u2013            <p>The build service manager.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the manager failed to find a suitable standard strategy to use when <code>strategy</code> was left as None.</p> </li> </ul>"},{"location":"reference/#yuyo.ServiceManager.from_tanjun","title":"from_tanjun  <code>classmethod</code>","text":"<pre><code>from_tanjun(tanjun_client, /, *, tanjun_managed=True, strategy=None, user_agent=None)\n</code></pre> <p>Build a service manager from a Tanjun client.</p> <p>This will use the Tanjun client's alluka client and registers ServiceManager and AbstractManager as type dependencies on Tanjun.</p> <p>Parameters:</p> <ul> <li> <code>tanjun_client</code>               (<code>Client</code>)           \u2013            <p>The Tanjun client to build a service manager from.</p> </li> <li> <code>tanjun_managed</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether this client should be automatically opened and closed based on the Tanjun client's lifetime client callback.</p> </li> <li> <code>strategy</code>               (<code>AbstractCountStrategy | None</code>, default:                   <code>None</code> )           \u2013            <p>The counter strategy this manager should expose to services.</p> <p>If this is left as None then the manager will try to pick a suitable standard strategy based on the provided Hikari clients.</p> </li> <li> <code>user_agent</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Override the standard user agent used during requests to bot list services.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ServiceManager</code>           \u2013            <p>The build service manager.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the manager failed to find a suitable standard strategy to use when <code>strategy</code> was left as None.</p> </li> </ul>"},{"location":"reference/#yuyo.ServiceManager.open","title":"open  <code>async</code>","text":"<pre><code>open()\n</code></pre> <p>Start this manager.</p> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If this manager is already running.</p> </li> </ul>"},{"location":"reference/#yuyo.ServiceManager.remove_service","title":"remove_service","text":"<pre><code>remove_service(service)\n</code></pre> <p>Remove the first found entry of the registered service.</p> <p>Parameters:</p> <ul> <li> <code>service</code>               (<code>ServiceSig</code>)           \u2013            <p>Service callback to unregister.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If called while the manager is active.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If the service callback isn't found.</p> </li> </ul>"},{"location":"reference/#yuyo.ServiceManager.with_service","title":"with_service","text":"<pre><code>with_service(*, repeat=datetime.timedelta(hours=1))\n</code></pre> <p>Add a service to this manager by decorating a function.</p> <p>Parameters:</p> <ul> <li> <code>repeat</code>               (<code>timedelta | int | float</code>, default:                   <code>timedelta(hours=1)</code> )           \u2013            <p>How often this service should be updated in seconds.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable[[ServiceSig], ServiceSig]</code>           \u2013            <p>Decorator callback used to add a service.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If repeat is less than 1 second.</p> </li> <li> <code>RuntimeError</code>             \u2013            <p>If the client is already running.</p> </li> </ul>"},{"location":"reference/#yuyo.ShardFinishedChunkingEvent","title":"ShardFinishedChunkingEvent","text":"<p>               Bases: <code>ShardEvent</code></p> <p>Event that's dispatched when the startup chunking has finished for a shard.</p> <p>This indicates that the member and presence caches should be complete for guilds covered by this shard.</p> <p>This will be fired after every shard identify which triggers chunking (including re-identifies).</p>"},{"location":"reference/#yuyo.ShardFinishedChunkingEvent.incomplete_guild_ids","title":"incomplete_guild_ids  <code>property</code>","text":"<pre><code>incomplete_guild_ids\n</code></pre> <p>Sequence of the IDs of guilds some chunk responses were missed for.</p>"},{"location":"reference/#yuyo.ShardFinishedChunkingEvent.missed_guild_ids","title":"missed_guild_ids  <code>property</code>","text":"<pre><code>missed_guild_ids\n</code></pre> <p>Sequence of the IDs of guilds no chunk responses were received for.</p>"},{"location":"reference/#yuyo.ShardFinishedChunkingEvent.__init__","title":"__init__","text":"<pre><code>__init__(app, shard, /, *, incomplete_guild_ids=(), missed_guild_ids=())\n</code></pre> <p>Initialise a shard chunking finished event.</p> <p>This should never be initialised directly.</p>"},{"location":"reference/#yuyo.SlidingTimeout","title":"SlidingTimeout","text":"<p>               Bases: <code>AbstractTimeout</code></p> <p>Timeout strategy which resets every use.</p> <p>This implementation times out if <code>timeout</code> passes since the last call or when <code>max_uses</code> is reached.</p>"},{"location":"reference/#yuyo.SlidingTimeout.__init__","title":"__init__","text":"<pre><code>__init__(timeout, /, *, max_uses=1)\n</code></pre> <p>Initialise a sliding timeout.</p> <p>Parameters:</p> <ul> <li> <code>timeout</code>               (<code>timedelta | int | float</code>)           \u2013            <p>How long this should wait between calls before timing-out.</p> </li> <li> <code>max_uses</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of uses this allows.</p> <p>Setting this to <code>-1</code> marks it as unlimited.</p> </li> </ul>"},{"location":"reference/#yuyo.StaticComponentPaginator","title":"StaticComponentPaginator","text":"<p>               Bases: <code>ActionColumnExecutor</code></p> <p>Implementation of components for paginating static data.</p> <p>This enables paginated responses to be persisted between bot restarts.</p>"},{"location":"reference/#yuyo.StaticComponentPaginator._added_static_fields","title":"_added_static_fields  <code>class-attribute</code>","text":"<pre><code>_added_static_fields = {}\n</code></pre> <p>Dict of match IDs to the static fields added to this class through add method calls.</p> <p>This doesn't include inherited fields.</p>"},{"location":"reference/#yuyo.StaticComponentPaginator._static_fields","title":"_static_fields  <code>class-attribute</code>","text":"<pre><code>_static_fields = {}\n</code></pre> <p>Dict of match IDs to the static fields on this class.</p> <p>This includes inherited fields and fields added through method calls.</p>"},{"location":"reference/#yuyo.StaticComponentPaginator.rows","title":"rows  <code>property</code>","text":"<pre><code>rows\n</code></pre> <p>The rows in this column.</p>"},{"location":"reference/#yuyo.StaticComponentPaginator.__init__","title":"__init__","text":"<pre><code>__init__(paginator_id, page_number, /, *, content_hash=None, ephemeral_default=False, include_buttons=True, id_metadata=None)\n</code></pre> <p>Initialise a static component paginator.</p> <p>Parameters:</p> <ul> <li> <code>paginator_id</code>               (<code>str</code>)           \u2013            <p>ID of the paginator this targets.</p> <p>This is ignored when this is used to execute interactions.</p> </li> <li> <code>page_number</code>               (<code>int</code>)           \u2013            <p>Index of the current page this paginator is on.</p> <p>This is ignored when this is used to execute interactions.</p> </li> <li> <code>content_hash</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Hash used to validate that the received interaction's components are still in-sync with the static data stored in this paginator.</p> </li> <li> <code>ephemeral_default</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this executor's responses should default to being ephemeral.</p> </li> <li> <code>include_buttons</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to include the default buttons.</p> </li> <li> <code>id_metadata</code>               (<code>Mapping[str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Mapping of metadata to append to the custom IDs in this column.</p> <p>This does not effect the standard buttons.</p> </li> </ul>"},{"location":"reference/#yuyo.StaticComponentPaginator.add_builder","title":"add_builder","text":"<pre><code>add_builder(builder)\n</code></pre> <p>Add a raw component builder to this action column.</p> <p>This is mostly for adding components where the custom ID is already registered as a separate constant executor.</p> <p>Parameters:</p> <ul> <li> <code>builder</code>               (<code>ComponentBuilder</code>)           \u2013            <p>The component builder to add to the column.</p> </li> </ul>"},{"location":"reference/#yuyo.StaticComponentPaginator.add_channel_menu","title":"add_channel_menu","text":"<pre><code>add_channel_menu(callback, /, *, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a channel select menu to this action column.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>channel_types</code>               (<code>None | Sequence[ChannelType | type[PartialChannel]]</code>, default:                   <code>None</code> )           \u2013            <p>Sequence of the types of channels this select menu should show as options.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The action column to enable chained calls.</p> </li> </ul>"},{"location":"reference/#yuyo.StaticComponentPaginator.add_first_button","title":"add_first_button","text":"<pre><code>add_first_button(*, style=hikari.ButtonStyle.SECONDARY, custom_id=_StaticPaginatorId.FIRST, emoji=pagination.LEFT_DOUBLE_TRIANGLE, id_metadata=None, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add the jump to first entry button to this paginator.</p> <p>You should pass <code>include_buttons=False</code> to StaticComponentPaginator.__init__ before calling this.</p> <p>Note</p> <p>These buttons will appear in the order these methods were called in.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>, default:                   <code>SECONDARY</code> )           \u2013            <p>The button's style.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>LEFT_DOUBLE_TRIANGLE</code> )           \u2013            <p>Emoji to display on this button.</p> </li> <li> <code>id_metadata</code>               (<code>Mapping[str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Mapping of keys to the values of extra metadata to include in this button's custom ID.</p> <p>This will be encoded as a url query string.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Label to display on this button.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to make this button as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>To enable chained calls.</p> </li> </ul>"},{"location":"reference/#yuyo.StaticComponentPaginator.add_interactive_button","title":"add_interactive_button","text":"<pre><code>add_interactive_button(style, callback, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add an interactive button to this action column.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>)           \u2013            <p>The button's style.</p> </li> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>The button's execution callback.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The button's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's emoji.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's label.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the button should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The action column to enable chained calls.</p> </li> </ul>"},{"location":"reference/#yuyo.StaticComponentPaginator.add_last_button","title":"add_last_button","text":"<pre><code>add_last_button(*, style=hikari.ButtonStyle.SECONDARY, custom_id=_StaticPaginatorId.LAST, emoji=pagination.RIGHT_DOUBLE_TRIANGLE, id_metadata=None, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add the jump to last entry button to this paginator.</p> <p>You should pass <code>include_buttons=False</code> to StaticComponentPaginator.__init__ before calling this.</p> <p>Note</p> <p>These buttons will appear in the order these methods were called in.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>, default:                   <code>SECONDARY</code> )           \u2013            <p>The button's style.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>RIGHT_DOUBLE_TRIANGLE</code> )           \u2013            <p>Emoji to display on this button.</p> <p>Either this or <code>label</code> must be provided, but not both.</p> </li> <li> <code>id_metadata</code>               (<code>Mapping[str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Mapping of keys to the values of extra metadata to include in this button's custom ID.</p> <p>This will be encoded as a url query string.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Label to display on this button.</p> <p>Either this or <code>emoji</code> must be provided, but not both.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to make this button as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>To enable chained calls.</p> </li> </ul>"},{"location":"reference/#yuyo.StaticComponentPaginator.add_link_button","title":"add_link_button","text":"<pre><code>add_link_button(url, /, *, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add a link button to this action column.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>url</code>               (<code>str</code>)           \u2013            <p>The button's url.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's emoji.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's label.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the button should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The action column to enable chained calls.</p> </li> </ul>"},{"location":"reference/#yuyo.StaticComponentPaginator.add_mentionable_menu","title":"add_mentionable_menu","text":"<pre><code>add_mentionable_menu(callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a mentionable select menu to this action column.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The action column to enable chained calls.</p> </li> </ul>"},{"location":"reference/#yuyo.StaticComponentPaginator.add_next_button","title":"add_next_button","text":"<pre><code>add_next_button(*, style=hikari.ButtonStyle.SECONDARY, custom_id=_StaticPaginatorId.NEXT, emoji=pagination.RIGHT_TRIANGLE, id_metadata=None, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add the next entry button to this paginator.</p> <p>You should pass <code>include_buttons=False</code> to StaticComponentPaginator.__init__ before calling this.</p> <p>Note</p> <p>These buttons will appear in the order these methods were called in.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>, default:                   <code>SECONDARY</code> )           \u2013            <p>The button's style.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>RIGHT_TRIANGLE</code> )           \u2013            <p>Emoji to display on this button.</p> <p>Either this or <code>label</code> must be provided, but not both.</p> </li> <li> <code>id_metadata</code>               (<code>Mapping[str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Mapping of keys to the values of extra metadata to include in this button's custom ID.</p> <p>This will be encoded as a url query string.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Label to display on this button.</p> <p>Either this or <code>emoji</code> must be provided, but not both.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to make this button as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>To enable chained calls.</p> </li> </ul>"},{"location":"reference/#yuyo.StaticComponentPaginator.add_previous_button","title":"add_previous_button","text":"<pre><code>add_previous_button(*, style=hikari.ButtonStyle.SECONDARY, custom_id=_StaticPaginatorId.PREVIOUS, emoji=pagination.LEFT_TRIANGLE, id_metadata=None, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add the previous entry button to this paginator.</p> <p>You should pass <code>include_buttons=False</code> to StaticComponentPaginator.__init__ before calling this.</p> <p>Note</p> <p>These buttons will appear in the order these methods were called in.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>, default:                   <code>SECONDARY</code> )           \u2013            <p>The button's style.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>LEFT_TRIANGLE</code> )           \u2013            <p>Emoji to display on this button.</p> <p>Either this or <code>label</code> must be provided, but not both.</p> </li> <li> <code>id_metadata</code>               (<code>Mapping[str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Mapping of keys to the values of extra metadata to include in this button's custom ID.</p> <p>This will be encoded as a url query string.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Label to display on this button.</p> <p>Either this or <code>emoji</code> must be provided, but not both.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to make this button as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>To enable chained calls.</p> </li> </ul>"},{"location":"reference/#yuyo.StaticComponentPaginator.add_role_menu","title":"add_role_menu","text":"<pre><code>add_role_menu(callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a role select menu to this action column.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The action column to enable chained calls.</p> </li> </ul>"},{"location":"reference/#yuyo.StaticComponentPaginator.add_select_button","title":"add_select_button","text":"<pre><code>add_select_button(*, style=hikari.ButtonStyle.DANGER, custom_id=_StaticPaginatorId.SELECT, emoji=pagination.SELECT_PAGE_SYMBOL, id_metadata=None, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add the select page button to this paginator.</p> <p>You should pass <code>include_buttons=False</code> to StaticComponentPaginator.__init__ before calling this.</p> <p>Note</p> <p>These buttons will appear in the order these methods were called in.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>, default:                   <code>DANGER</code> )           \u2013            <p>The button's style.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>SELECT_PAGE_SYMBOL</code> )           \u2013            <p>Emoji to display on this button.</p> <p>Either this or <code>label</code> must be provided, but not both.</p> </li> <li> <code>id_metadata</code>               (<code>Mapping[str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Mapping of keys to the values of extra metadata to include in this button's custom ID.</p> <p>This will be encoded as a url query string.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Label to display on this button.</p> <p>Either this or <code>emoji</code> must be provided, but not both.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to make this button as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>To enable chained calls.</p> </li> </ul>"},{"location":"reference/#yuyo.StaticComponentPaginator.add_select_menu","title":"add_select_menu","text":"<pre><code>add_select_menu(type_, callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a select menu to this action column.</p> <p>The following methods should be used instead:</p> <ul> <li>.add_channel_menu</li> <li>.add_mentionable_menu</li> <li>.add_role_menu</li> <li>.add_text_menu</li> <li>.add_user_menu</li> </ul>"},{"location":"reference/#yuyo.StaticComponentPaginator.add_static_builder","title":"add_static_builder  <code>classmethod</code>","text":"<pre><code>add_static_builder(builder)\n</code></pre> <p>Add a raw component builder to all subclasses and instances of this column.</p> <p>This is mostly for adding components where the custom ID is already registered as a separate constant executor.</p> <p>Parameters:</p> <ul> <li> <code>builder</code>               (<code>ComponentBuilder</code>)           \u2013            <p>The component builder to add to the column class.</p> </li> </ul>"},{"location":"reference/#yuyo.StaticComponentPaginator.add_static_channel_menu","title":"add_static_channel_menu  <code>classmethod</code>","text":"<pre><code>add_static_channel_menu(callback, /, *, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a channel select menu to all subclasses and instances of this action column class.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>channel_types</code>               (<code>None | Sequence[ChannelType | type[PartialChannel]]</code>, default:                   <code>None</code> )           \u2013            <p>Sequence of the types of channels this select menu should show as options.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[Self]</code>           \u2013            <p>The action column class to enable chained calls.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/#yuyo.StaticComponentPaginator.add_static_interactive_button","title":"add_static_interactive_button  <code>classmethod</code>","text":"<pre><code>add_static_interactive_button(style, callback, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add an interactive button to all subclasses and instances of this action column class.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>)           \u2013            <p>The button's style.</p> </li> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>The button's execution callback.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The button's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's emoji.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's label.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the button should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[Self]</code>           \u2013            <p>The action column class to enable chained calls.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/#yuyo.StaticComponentPaginator.add_static_link_button","title":"add_static_link_button  <code>classmethod</code>","text":"<pre><code>add_static_link_button(url, /, *, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add a link button to all subclasses and instances of this action column class.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>url</code>               (<code>str</code>)           \u2013            <p>The button's url.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's emoji.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's label.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the button should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[Self]</code>           \u2013            <p>The action column class to enable chained calls.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/#yuyo.StaticComponentPaginator.add_static_mentionable_menu","title":"add_static_mentionable_menu  <code>classmethod</code>","text":"<pre><code>add_static_mentionable_menu(callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a mentionable select menu to all subclasses and instances of this action column class.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[Self]</code>           \u2013            <p>The action column class to enable chained calls.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/#yuyo.StaticComponentPaginator.add_static_role_menu","title":"add_static_role_menu  <code>classmethod</code>","text":"<pre><code>add_static_role_menu(callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a role select menu to all subclasses and instances of this action column class.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[Self]</code>           \u2013            <p>The action column class to enable chained calls.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/#yuyo.StaticComponentPaginator.add_static_select_menu","title":"add_static_select_menu  <code>classmethod</code>","text":"<pre><code>add_static_select_menu(type_, callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a select menu to all subclasses and instances of this action column class.</p> <p>The following class methods should be used instead:</p> <ul> <li>.add_static_channel_menu</li> <li>.add_static_mentionable_menu</li> <li>.add_static_role_menu</li> <li>.add_static_text_menu</li> <li>.add_static_user_menu</li> </ul>"},{"location":"reference/#yuyo.StaticComponentPaginator.add_static_text_menu","title":"add_static_text_menu  <code>classmethod</code>","text":"<pre><code>add_static_text_menu(callback, /, *, custom_id=None, options=(), placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a text select menu to all subclasses and instances of this action column class.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>options</code>               (<code>Sequence[SelectOptionBuilder]</code>, default:                   <code>()</code> )           \u2013            <p>The text select's options.</p> <p>These can also be added by calling TextSelectMenuBuilder.add_option.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>TextSelectMenuBuilder</code>           \u2013            <p>Builder for the added text select menu.</p> <p>TextSelectMenuBuilder.add_option should be used to add options to this select menu.</p> <p>And the parent action column can be accessed by calling TextSelectMenuBuilder.parent.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/#yuyo.StaticComponentPaginator.add_static_user_menu","title":"add_static_user_menu  <code>classmethod</code>","text":"<pre><code>add_static_user_menu(callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a user select menu to all subclasses and instances of this action column class.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[Self]</code>           \u2013            <p>The action column class to enable chained calls.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/#yuyo.StaticComponentPaginator.add_text_menu","title":"add_text_menu","text":"<pre><code>add_text_menu(callback, /, *, custom_id=None, options=(), placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a text select menu to this action column.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>options</code>               (<code>Sequence[SelectOptionBuilder]</code>, default:                   <code>()</code> )           \u2013            <p>The text select's options.</p> <p>These can also be added by calling TextSelectMenuBuilder.add_option.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>TextSelectMenuBuilder</code>           \u2013            <p>Builder for the added text select menu.</p> <p>TextSelectMenuBuilder.add_option should be used to add options to this select menu.</p> <p>And the parent action column can be accessed by calling TextSelectMenuBuilder.parent.</p> </li> </ul>"},{"location":"reference/#yuyo.StaticComponentPaginator.add_user_menu","title":"add_user_menu","text":"<pre><code>add_user_menu(callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a user select menu to this action column.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The action column to enable chained calls.</p> </li> </ul>"},{"location":"reference/#yuyo.StaticComponentPaginator.with_channel_menu","title":"with_channel_menu","text":"<pre><code>with_channel_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_channel_menu(*, custom_id: str | None = None, channel_types: None | Sequence[ChannelType | type[PartialChannel]] = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_channel_menu(callback=None, /, *, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a channel select menu to this action column through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>channel_types</code>               (<code>None | Sequence[ChannelType | type[PartialChannel]]</code>, default:                   <code>None</code> )           \u2013            <p>Sequence of the types of channels this select menu should show as options.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul>"},{"location":"reference/#yuyo.StaticComponentPaginator.with_interactive_button","title":"with_interactive_button","text":"<pre><code>with_interactive_button(style, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add an interactive button to this action column through a decorator call.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>)           \u2013            <p>The button's style.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The button's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's emoji.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's label.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the button should be marked as disabled.</p> </li> </ul>"},{"location":"reference/#yuyo.StaticComponentPaginator.with_mentionable_menu","title":"with_mentionable_menu","text":"<pre><code>with_mentionable_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_mentionable_menu(*, custom_id: str | None = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_mentionable_menu(callback=None, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a mentionable select menu to this action column through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul>"},{"location":"reference/#yuyo.StaticComponentPaginator.with_role_menu","title":"with_role_menu","text":"<pre><code>with_role_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_role_menu(*, custom_id: str | None = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_role_menu(callback=None, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a role select menu to this action column through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul>"},{"location":"reference/#yuyo.StaticComponentPaginator.with_static_channel_menu","title":"with_static_channel_menu  <code>classmethod</code>","text":"<pre><code>with_static_channel_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_static_channel_menu(*, custom_id: str | None = None, channel_types: None | Sequence[ChannelType | type[PartialChannel]] = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_static_channel_menu(callback=None, /, *, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a channel select menu to this action column class through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>channel_types</code>               (<code>None | Sequence[ChannelType | type[PartialChannel]]</code>, default:                   <code>None</code> )           \u2013            <p>Sequence of the types of channels this select menu should show as options.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/#yuyo.StaticComponentPaginator.with_static_interactive_button","title":"with_static_interactive_button  <code>classmethod</code>","text":"<pre><code>with_static_interactive_button(style, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add a static interactive button to this action column class through a decorator call.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>)           \u2013            <p>The button's style.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The button's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's emoji.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's label.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the button should be marked as disabled.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/#yuyo.StaticComponentPaginator.with_static_mentionable_menu","title":"with_static_mentionable_menu  <code>classmethod</code>","text":"<pre><code>with_static_mentionable_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_static_mentionable_menu(*, custom_id: str | None = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_static_mentionable_menu(callback=None, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a static mentionable select menu to this action column class through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/#yuyo.StaticComponentPaginator.with_static_role_menu","title":"with_static_role_menu  <code>classmethod</code>","text":"<pre><code>with_static_role_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_static_role_menu(*, custom_id: str | None = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_static_role_menu(callback=None, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a static role select menu to this action column class through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/#yuyo.StaticComponentPaginator.with_static_text_menu","title":"with_static_text_menu  <code>classmethod</code>","text":"<pre><code>with_static_text_menu(callback: Callable[_P, _CoroT]) -&gt; _WrappedTextMenuBuilder[_P]\n</code></pre><pre><code>with_static_text_menu(*, custom_id: str | None = None, options: Sequence[SelectOptionBuilder] = (), placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[collections.Callable[_P, _CoroT]], _WrappedTextMenuBuilder[_P]]\n</code></pre> <pre><code>with_static_text_menu(callback=None, /, *, custom_id=None, options=(), placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a text select menu to this action column class through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>options</code>               (<code>Sequence[SelectOptionBuilder]</code>, default:                   <code>()</code> )           \u2013            <p>The text select's options.</p> <p>These can also be added using [yuyo.components.with_option].</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/#yuyo.StaticComponentPaginator.with_static_user_menu","title":"with_static_user_menu  <code>classmethod</code>","text":"<pre><code>with_static_user_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_static_user_menu(*, custom_id: str | None = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_static_user_menu(callback=None, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a static user select menu to this action column class through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/#yuyo.StaticComponentPaginator.with_text_menu","title":"with_text_menu","text":"<pre><code>with_text_menu(callback: Callable[_P, _CoroT]) -&gt; _WrappedTextMenuBuilder[_P]\n</code></pre><pre><code>with_text_menu(*, custom_id: str | None = None, options: Sequence[SelectOptionBuilder] = (), placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[collections.Callable[_P, _CoroT]], _WrappedTextMenuBuilder[_P]]\n</code></pre> <pre><code>with_text_menu(callback=None, /, *, custom_id=None, options=(), placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a text select menu to this action column through a decorator callback.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>options</code>               (<code>Sequence[SelectOptionBuilder]</code>, default:                   <code>()</code> )           \u2013            <p>The text select's options.</p> <p>These can also be added using components.with_option.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul>"},{"location":"reference/#yuyo.StaticComponentPaginator.with_user_menu","title":"with_user_menu","text":"<pre><code>with_user_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_user_menu(*, custom_id: str | None = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_user_menu(callback=None, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a user select menu to this action column through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul>"},{"location":"reference/#yuyo.StaticPaginatorIndex","title":"StaticPaginatorIndex","text":"<p>Index of all the static paginators within a bot.</p>"},{"location":"reference/#yuyo.StaticPaginatorIndex.not_found_response","title":"not_found_response  <code>property</code>","text":"<pre><code>not_found_response\n</code></pre> <p>Response that's sent by the default implementation when a paginator ID isn't found.</p>"},{"location":"reference/#yuyo.StaticPaginatorIndex.out_of_date_response","title":"out_of_date_response  <code>property</code>","text":"<pre><code>out_of_date_response\n</code></pre> <p>Response that's sent by the default implementation when content hashes don't match.</p>"},{"location":"reference/#yuyo.StaticPaginatorIndex.__init__","title":"__init__","text":"<pre><code>__init__(*, make_components=lambda paginator_id, page_number, content_hash: StaticComponentPaginator(paginator_id, page_number, content_hash=content_hash), make_modal=static_paginator_model, modal_title='Select page', not_found_response=None, out_of_date_response=None)\n</code></pre> <p>Initialise a static paginator index.</p> <p>Parameters:</p> <ul> <li> <code>make_components</code>               (<code>Callable[[str, int, str | None], ActionColumnExecutor]</code>, default:                   <code>lambda paginator_id, page_number, content_hash: StaticComponentPaginator(paginator_id, page_number, content_hash=content_hash)</code> )           \u2013            <p>Callback that's used to make the default pagination message components.</p> </li> <li> <code>make_modal</code>               (<code>Callable[[], Modal]</code>, default:                   <code>static_paginator_model</code> )           \u2013            <p>Callback that's used to make a modal that handles the select page button.</p> </li> <li> <code>modal_title</code>               (<code>MaybeLocalsiedType[str]</code>, default:                   <code>'Select page'</code> )           \u2013            <p>Title of the modal that's sent when the select page button is pressed.</p> </li> <li> <code>not_found_response</code>               (<code>AbstractPage | None</code>, default:                   <code>None</code> )           \u2013            <p>The response to send when a paginator ID isn't found.</p> </li> <li> <code>out_of_date_response</code>               (<code>AbstractPage | None</code>, default:                   <code>None</code> )           \u2013            <p>The response to send when the content hashes don't match.</p> </li> </ul>"},{"location":"reference/#yuyo.StaticPaginatorIndex.add_to_clients","title":"add_to_clients","text":"<pre><code>add_to_clients(component_client, modal_client)\n</code></pre> <p>Add this index to the component and modal clients to enable operation.</p> <p>Parameters:</p> <ul> <li> <code>component_client</code>               (<code>ComponentClient</code>)           \u2013            <p>The component client to add this to.</p> </li> <li> <code>modal_client</code>               (<code>ModalClient</code>)           \u2013            <p>The modal client to add this to.</p> </li> </ul>"},{"location":"reference/#yuyo.StaticPaginatorIndex.callback","title":"callback  <code>async</code>","text":"<pre><code>callback(ctx, page_number)\n</code></pre> <p>Execute a static paginator interaction.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>BaseContext[ComponentInteraction] | BaseContext[ModalInteraction]</code>)           \u2013            <p>The context of the component or modal interaction being executed.</p> </li> <li> <code>page_number</code>               (<code>int</code>)           \u2013            <p>The paginator instance's current page.</p> </li> </ul>"},{"location":"reference/#yuyo.StaticPaginatorIndex.create_select_modal","title":"create_select_modal  <code>async</code>","text":"<pre><code>create_select_modal(ctx)\n</code></pre> <p>Create the standard modal used to handle the select page button.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>ComponentContext</code>)           \u2013            <p>The component context this modal is being made for.</p> </li> </ul>"},{"location":"reference/#yuyo.StaticPaginatorIndex.get_paginator","title":"get_paginator","text":"<pre><code>get_paginator(paginator_id)\n</code></pre> <p>Get a paginator.</p> <p>Parameters:</p> <ul> <li> <code>paginator_id</code>               (<code>str</code>)           \u2013            <p>ID of the paginator to get.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>StaticPaginatorData</code>           \u2013            <p>The found static paginator.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>If no paginator was found.</p> </li> </ul>"},{"location":"reference/#yuyo.StaticPaginatorIndex.remove_paginator","title":"remove_paginator","text":"<pre><code>remove_paginator(paginator_id)\n</code></pre> <p>Remove a static paginator.</p> <p>Parameters:</p> <ul> <li> <code>paginator_id</code>               (<code>str</code>)           \u2013            <p>ID of the paginator to remove.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>If no paginator was found.</p> </li> </ul>"},{"location":"reference/#yuyo.StaticPaginatorIndex.set_paginator","title":"set_paginator","text":"<pre><code>set_paginator(paginator_id, pages, /, *, content_hash=None)\n</code></pre> <p>Set the static paginator for a custom ID.</p> <p>Parameters:</p> <ul> <li> <code>paginator_id</code>               (<code>str</code>)           \u2013            <p>ID that's used to identify this paginator.</p> </li> <li> <code>pages</code>               (<code>Sequence[AbstractPage]</code>)           \u2013            <p>Sequence of the paginator's built pages.</p> </li> <li> <code>content_hash</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Content hash that's used to optionally ensure instances of the of the paginator's components are compatible with the bot's stored data.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>paginator_id</code> is already set.</p> </li> </ul>"},{"location":"reference/#yuyo.StaticTimeout","title":"StaticTimeout","text":"<p>               Bases: <code>AbstractTimeout</code></p> <p>Timeout at a specific time.</p> <p>This implementation times out when <code>timeout_at</code> is reached or when <code>max_uses</code> is reached.</p>"},{"location":"reference/#yuyo.StaticTimeout.__init__","title":"__init__","text":"<pre><code>__init__(timeout_at, /, *, max_uses=1)\n</code></pre> <p>Initialise a static timeout.</p> <p>Parameters:</p> <ul> <li> <code>timeout_at</code>               (<code>datetime</code>)           \u2013            <p>When this should time out.</p> </li> <li> <code>max_uses</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of uses this allows.</p> <p>Setting this to <code>-1</code> marks it as unlimited.</p> </li> </ul>"},{"location":"reference/#yuyo.StreamExecutor","title":"StreamExecutor","text":"<p>               Bases: <code>AbstractComponentExecutor</code>, <code>AbstractTimeout</code></p> <p>Stream over the received component interactions.</p> <p>This should also be passed for <code>timeout=</code> and will reject contexts until it's opened.</p> <p>Examples:</p> <pre><code>message = await ctx.respond(\"hi, pick an option\", components=[...])\nstream = yuyo.components.Stream(authors=[ctx.author.id], timeout=datetime.timedelta(seconds=30))\ncomponent_client.register_executor(stream, message=message, timeout=stream)\n\nwith stream:\n    async for result in stream:\n        await result.respond(\"...\")\n</code></pre>"},{"location":"reference/#yuyo.StreamExecutor.__init__","title":"__init__","text":"<pre><code>__init__(*, authors, custom_ids=(), ephemeral_default=False, max_backlog=5, timeout)\n</code></pre> <p>Initialise a stream executor.</p> <p>Parameters:</p> <ul> <li> <code>authors</code>               (<code>Iterable[SnowflakeishOr[User]] | None</code>)           \u2013            <p>Users who are allowed to use the components this represents.</p> <p>If None is passed here then the paginator will be public (meaning that anybody can use it).</p> </li> <li> <code>custom_ids</code>               (<code>Collection[str]</code>, default:                   <code>()</code> )           \u2013            <p>Collection of the custom IDs this executor should be triggered by when registered globally.</p> </li> <li> <code>ephemeral_default</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether or not the responses made on contexts spawned from this paginator should default to ephemeral (meaning only the author can see them) unless <code>flags</code> is specified on the response method.</p> </li> <li> <code>max_backlog</code>               (<code>int</code>, default:                   <code>5</code> )           \u2013            <p>The maximum amount of interaction contexts this should store in its backlog.</p> <p>Any extra interactions will be rejected while the backlog is full.</p> </li> <li> <code>timeout</code>               (<code>float | int | timedelta | None</code>)           \u2013            <p>How long this should wait between iterations for a matching interaction to be recveived before ending the iteration.</p> <p>This alone does not close the stream.</p> </li> </ul>"},{"location":"reference/#yuyo.TopGGService","title":"TopGGService","text":"<p>https://top.gg status update service.</p>"},{"location":"reference/#yuyo.TopGGService.__init__","title":"__init__","text":"<pre><code>__init__(token)\n</code></pre> <p>Initialise a top.gg service.</p> <p>Parameters:</p> <ul> <li> <code>token</code>               (<code>str</code>)           \u2013            <p>Authorization token used to update the bot's status.</p> </li> </ul>"},{"location":"reference/#yuyo.WaitForExecutor","title":"WaitForExecutor","text":"<p>               Bases: <code>AbstractComponentExecutor</code>, <code>AbstractTimeout</code></p> <p>Component executor used to wait for a single component interaction.</p> <p>This should also be passed for <code>timeout=</code>.</p> <p>Examples:</p> <pre><code>message = await ctx.respond(\"hi, pick an option\", components=[...], ensure_result=True)\n\nexecutor = yuyo.components.WaitFor(authors=[ctx.author.id], timeout=datetime.timedelta(seconds=30))\ncomponent_client.register_executor(executor, message=message, timeout=executor)\n\ntry:\n    result = await executor.wait_for()\nexcept asyncio.TimeoutError:\n    await ctx.respond(\"timed out\")\nelse:\n    await result.respond(\"...\")\n</code></pre>"},{"location":"reference/#yuyo.WaitForExecutor.__init__","title":"__init__","text":"<pre><code>__init__(*, authors=None, custom_ids=(), ephemeral_default=False, timeout)\n</code></pre> <p>Initialise a wait for executor.</p> <p>Parameters:</p> <ul> <li> <code>authors</code>               (<code>Iterable[SnowflakeishOr[User]] | None</code>, default:                   <code>None</code> )           \u2013            <p>Users who are allowed to use the components this represents.</p> <p>If no users are provided then the components will be public (meaning that anybody can use it).</p> </li> <li> <code>custom_ids</code>               (<code>Collection[str]</code>, default:                   <code>()</code> )           \u2013            <p>Collection of the custom IDs this executor should be triggered by when registered globally.</p> </li> <li> <code>ephemeral_default</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether or not the responses made on contexts spawned from this paginator should default to ephemeral (meaning only the author can see them) unless <code>flags</code> is specified on the response method.</p> </li> <li> <code>timeout</code>               (<code>timedelta | None</code>)           \u2013            <p>How long this should wait for a matching component interaction until it times-out.</p> </li> </ul>"},{"location":"reference/#yuyo.WaitForExecutor.wait_for","title":"wait_for  <code>async</code>","text":"<pre><code>wait_for()\n</code></pre> <p>Wait for the next matching interaction.</p> <p>Returns:</p> <ul> <li> <code>Context</code>           \u2013            <p>The next matching interaction.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If the executor is already being waited for.</p> </li> <li> <code>TimeoutError</code>             \u2013            <p>If the timeout is reached.</p> </li> </ul>"},{"location":"reference/#yuyo.aenumerate","title":"aenumerate  <code>async</code>","text":"<pre><code>aenumerate(iterable)\n</code></pre> <p>Async equivalent of enumerate.</p> <p>Parameters:</p> <ul> <li> <code>iterable</code>               (<code>AsyncIterable[_T]</code>)           \u2013            <p>The async iterable to enumerate.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AsyncIterator[tuple[int, _T]]</code>           \u2013            <p>The enumerated async iterator.</p> </li> </ul>"},{"location":"reference/#yuyo.async_paginate_string","title":"async_paginate_string  <code>async</code>","text":"<pre><code>async_paginate_string(lines, /, *, char_limit=2000, line_limit=25, wrapper=None)\n</code></pre> <p>Lazily paginate an iterator of lines.</p> <p>Parameters:</p> <ul> <li> <code>lines</code>               (<code>AsyncIterable[str]</code>)           \u2013            <p>The asynchronous iterator of lines to paginate.</p> </li> <li> <code>char_limit</code>               (<code>int</code>, default:                   <code>2000</code> )           \u2013            <p>The limit for how many characters should be included per yielded page.</p> </li> <li> <code>line_limit</code>               (<code>int</code>, default:                   <code>25</code> )           \u2013            <p>The limit for how many lines should be included per yielded page.</p> </li> <li> <code>wrapper</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A wrapper for each yielded page. This should leave \"{}\" in it to be replaced by the page's content.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AsyncIterator[str]</code>           \u2013            <p>An async iterator of each page's content.</p> </li> </ul>"},{"location":"reference/#yuyo.paginate_string","title":"paginate_string","text":"<pre><code>paginate_string(lines: AsyncIterator[str], /, *, char_limit: int = 2000, line_limit: int = 25, wrapper: str | None = None) -&gt; collections.AsyncIterator[str]\n</code></pre><pre><code>paginate_string(lines: Iterator[str], /, *, char_limit: int = 2000, line_limit: int = 25, wrapper: str | None = None) -&gt; collections.Iterator[str]\n</code></pre> <pre><code>paginate_string(lines, /, *, char_limit=2000, line_limit=25, wrapper=None)\n</code></pre> <p>Lazily paginate an iterator of lines.</p> <p>Parameters:</p> <ul> <li> <code>lines</code>               (<code>Iterator[str] | AsyncIterator[str]</code>)           \u2013            <p>The iterator of lines to paginate. This iterator may be asynchronous or synchronous.</p> </li> <li> <code>char_limit</code>               (<code>int</code>, default:                   <code>2000</code> )           \u2013            <p>The limit for how many characters should be included per yielded page.</p> </li> <li> <code>line_limit</code>               (<code>int</code>, default:                   <code>25</code> )           \u2013            <p>The limit for how many lines should be included per yielded page.</p> </li> <li> <code>wrapper</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A wrapper for each yielded page. This should leave \"{}\" in it to be replaced by the page's content.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AsyncIterator[str] | Iterator[str]</code>           \u2013            <p>An iterator of each page's content.</p> </li> </ul>"},{"location":"reference/#yuyo.sync_paginate_string","title":"sync_paginate_string","text":"<pre><code>sync_paginate_string(lines, /, *, char_limit=2000, line_limit=25, wrapper=None)\n</code></pre> <p>Lazily paginate an iterator of lines.</p> <p>Parameters:</p> <ul> <li> <code>lines</code>               (<code>Iterable[str]</code>)           \u2013            <p>The iterator of lines to paginate.</p> </li> <li> <code>char_limit</code>               (<code>int</code>, default:                   <code>2000</code> )           \u2013            <p>The limit for how many characters should be included per yielded page.</p> </li> <li> <code>line_limit</code>               (<code>int</code>, default:                   <code>25</code> )           \u2013            <p>The limit for how many lines should be included per yielded page.</p> </li> <li> <code>wrapper</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A wrapper for each yielded page. This should leave \"{}\" in it to be replaced by the page's content.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[str]</code>           \u2013            <p>An iterator of each page's content.</p> </li> </ul>"},{"location":"reference/asgi/","title":"yuyo.asgi","text":"<p>ASGI/3 adapter for Hikari's interaction server.</p>"},{"location":"reference/asgi/#yuyo.asgi.AsgiAdapter","title":"AsgiAdapter","text":"<p>Asgi/3 adapter for Hikari's interaction server interface.</p> <p>For this to work, hikari has to be installed with the optional \"server\" feature (e.g <code>python -m pip install hikari[server]</code>).</p>"},{"location":"reference/asgi/#yuyo.asgi.AsgiAdapter.server","title":"server  <code>property</code>","text":"<pre><code>server\n</code></pre> <p>The interaction server this adapter is bound to.</p>"},{"location":"reference/asgi/#yuyo.asgi.AsgiAdapter.__call__","title":"__call__  <code>async</code>","text":"<pre><code>__call__(scope, receive, send)\n</code></pre> <p>Call the adapter.</p> <p>Note</p> <p>This method is called by the ASGI server.</p> <p>Parameters:</p> <ul> <li> <code>scope</code>               (<code>Scope</code>)           \u2013            <p>The scope of the request.</p> </li> <li> <code>receive</code>               (<code>ASGIReceiveCallable</code>)           \u2013            <p>The receive function to use.</p> </li> <li> <code>send</code>               (<code>ASGISendCallable</code>)           \u2013            <p>The send function to use.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NotImplementedError</code>             \u2013            <p>If this is called with a websocket scope.</p> </li> <li> <code>RuntimeError</code>             \u2013            <p>If an invalid scope event is passed.</p> </li> </ul>"},{"location":"reference/asgi/#yuyo.asgi.AsgiAdapter.__init__","title":"__init__","text":"<pre><code>__init__(server, /, *, executor=None, max_body_size=1024 ** 2)\n</code></pre> <p>Initialise the adapter.</p> <p>Parameters:</p> <ul> <li> <code>server</code>               (<code>InteractionServer</code>)           \u2013            <p>The interaction server to use.</p> </li> <li> <code>executor</code>               (<code>Executor | None</code>, default:                   <code>None</code> )           \u2013            <p>If non-None, then this executor is used instead of the concurrent.futures.ThreadPoolExecutor attached to the asyncio.AbstractEventLoop that the bot will run on. This executor is used primarily for file-IO.</p> <p>While mainly supporting the concurrent.futures.ThreadPoolExecutor implementation in the standard lib, Hikari's file handling systems should also work with concurrent.futures.ProcessPoolExecutor, which relies on all objects used in IPC to be <code>pickle</code>able. Many third-party libraries will not support this fully though, so your mileage may vary on using ProcessPoolExecutor implementations with this parameter.</p> </li> <li> <code>max_body_size</code>               (<code>int</code>, default:                   <code>1024 ** 2</code> )           \u2013            <p>The maximum body size this should allow received request bodies to be in bytes before failing the request with a 413 - Content Too Large.</p> </li> </ul>"},{"location":"reference/asgi/#yuyo.asgi.AsgiAdapter._process_lifespan_event","title":"_process_lifespan_event  <code>async</code>","text":"<pre><code>_process_lifespan_event(receive, send)\n</code></pre> <p>Process a lifespan ASGI event.</p> <p>Note</p> <p>This function is used internally by the adapter.</p> <p>Parameters:</p> <ul> <li> <code>receive</code>               (<code>ASGIReceiveCallable</code>)           \u2013            <p>The receive function to use.</p> </li> <li> <code>send</code>               (<code>ASGISendCallable</code>)           \u2013            <p>The send function to use.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If an invalid lifespan event is passed.</p> </li> </ul>"},{"location":"reference/asgi/#yuyo.asgi.AsgiAdapter._process_request","title":"_process_request  <code>async</code>","text":"<pre><code>_process_request(scope, receive, send)\n</code></pre> <p>Process an HTTP request.</p> <p>Note</p> <p>This function is used internally by the adapter.</p> <p>Parameters:</p> <ul> <li> <code>scope</code>               (<code>HTTPScope</code>)           \u2013            <p>The scope of the request.</p> </li> <li> <code>receive</code>               (<code>ASGIReceiveCallable</code>)           \u2013            <p>The receive function to use.</p> </li> <li> <code>send</code>               (<code>ASGISendCallable</code>)           \u2013            <p>The send function to use.</p> </li> </ul>"},{"location":"reference/asgi/#yuyo.asgi.AsgiAdapter.add_shutdown_callback","title":"add_shutdown_callback","text":"<pre><code>add_shutdown_callback(callback)\n</code></pre> <p>Add a callback to be called when the ASGI server shuts down.</p> <p>Warning</p> <p>These callbacks will block the ASGI server from shutting down until they complete and any raised errors will lead to a failed shutdown.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>Callable[[], Coroutine[Any, Any, None]]</code>)           \u2013            <p>The shutdown callback to add.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The adapter to enable chained calls.</p> </li> </ul>"},{"location":"reference/asgi/#yuyo.asgi.AsgiAdapter.add_startup_callback","title":"add_startup_callback","text":"<pre><code>add_startup_callback(callback)\n</code></pre> <p>Add a callback to be called when the ASGI server starts up.</p> <p>Warning</p> <p>These callbacks will block the ASGI server from starting until they complete and any raised errors will lead to a failed startup.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>Callable[[], Coroutine[Any, Any, None]]</code>)           \u2013            <p>The startup callback to add.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The adapter to enable chained calls.</p> </li> </ul>"},{"location":"reference/asgi/#yuyo.asgi.AsgiAdapter.remove_shutdown_callback","title":"remove_shutdown_callback","text":"<pre><code>remove_shutdown_callback(callback)\n</code></pre> <p>Remove a shutdown callback.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>Callable[[], Coroutine[Any, Any, None]]</code>)           \u2013            <p>The shutdown callback to remove.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The adapter to enable chained calls.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the callback was not registered.</p> </li> </ul>"},{"location":"reference/asgi/#yuyo.asgi.AsgiAdapter.remove_startup_callback","title":"remove_startup_callback","text":"<pre><code>remove_startup_callback(callback)\n</code></pre> <p>Remove a startup callback.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>Callable[[], Coroutine[Any, Any, None]]</code>)           \u2013            <p>The startup callback to remove.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The adapter to enable chained calls.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the callback was not registered.</p> </li> </ul>"},{"location":"reference/asgi/#yuyo.asgi.AsgiBot","title":"AsgiBot","text":"<p>               Bases: <code>RESTBotAware</code></p> <p>Bot implementation which acts as an ASGI adapter.</p> <p>This bot doesn't initiate a server internally but instead relies on being called as an ASGI app.</p> <p>For this to work, hikari has to be installed with the optional \"server\" feature (e.g <code>python -m pip install hikari[server]</code>).</p>"},{"location":"reference/asgi/#yuyo.asgi.AsgiBot.__call__","title":"__call__  <code>async</code>","text":"<pre><code>__call__(scope, receive, send)\n</code></pre> <p>Call the bot with an ASGI event.</p> <p>Note</p> <p>This method is called by the ASGI server and allows the bot to function like AsgiAdapter.</p> <p>Parameters:</p> <ul> <li> <code>scope</code>               (<code>Scope</code>)           \u2013            <p>The scope of the request.</p> </li> <li> <code>receive</code>               (<code>ASGIReceiveCallable</code>)           \u2013            <p>The receive function to use.</p> </li> <li> <code>send</code>               (<code>ASGISendCallable</code>)           \u2013            <p>The send function to use.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NotImplementedError</code>             \u2013            <p>If this is called with a websocket scope.</p> </li> <li> <code>RuntimeError</code>             \u2013            <p>If an invalid scope event is passed.</p> </li> </ul>"},{"location":"reference/asgi/#yuyo.asgi.AsgiBot.__init__","title":"__init__","text":"<pre><code>__init__(token: TokenStrategy, *, public_key: bytes | str | None = None, asgi_managed: bool = True, executor: Executor | None = None, http_settings: HTTPSettings | None = None, max_body_size: int = 1024 ** 2, max_rate_limit: float = 300.0, max_retries: int = 3, proxy_settings: ProxySettings | None = None, rest_url: str | None = None) -&gt; None\n</code></pre><pre><code>__init__(token: str, token_type: str | TokenType = hikari.TokenType.BOT, public_key: bytes | str | None = None, *, asgi_managed: bool = True, executor: Executor | None = None, http_settings: HTTPSettings | None = None, max_body_size: int = 1024 ** 2, max_rate_limit: float = 300.0, max_retries: int = 3, proxy_settings: ProxySettings | None = None, rest_url: str | None = None) -&gt; None\n</code></pre> <pre><code>__init__(token, token_type=None, public_key=None, *, asgi_managed=True, executor=None, http_settings=None, max_body_size=1024 ** 2, max_rate_limit=300.0, max_retries=3, proxy_settings=None, rest_url=None)\n</code></pre> <p>Initialise a new ASGI bot.</p> <p>Parameters:</p> <ul> <li> <code>token</code>               (<code>str | TokenStrategy</code>)           \u2013            <p>The bot or bearer token. If no token is to be used, this can be undefined.</p> </li> <li> <code>token_type</code>               (<code>TokenType | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The type of token in use. This should only be passed when <code>str</code> is passed for <code>token</code>, can be <code>\"Bot\"</code> or <code>\"Bearer\"</code> and will be defaulted to <code>\"Bot\"</code> in this situation.</p> <p>This should be left as None when either hikari.api.TokenStrategy or None is passed for <code>token</code>.</p> </li> <li> <code>asgi_managed</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether this bot's internal components should be automatically started and stopped based on the Asgi lifespan events.</p> </li> <li> <code>executor</code>               (<code>Executor | None</code>, default:                   <code>None</code> )           \u2013            <p>If non-None, then this executor is used instead of the concurrent.futures.ThreadPoolExecutor attached to the asyncio.AbstractEventLoop that the bot will run on. This executor is used primarily for file-IO.</p> <p>While mainly supporting the concurrent.futures.ThreadPoolExecutor implementation in the standard lib, Hikari's file handling systems should also work with concurrent.futures.ProcessPoolExecutor, which relies on all objects used in IPC to be <code>pickle</code>able. Many third-party libraries will not support this fully though, so your mileage may vary on using ProcessPoolExecutor implementations with this parameter.</p> </li> <li> <code>http_settings</code>               (<code>HTTPSettings | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional custom HTTP configuration settings to use. Allows you to customise functionality such as whether SSL-verification is enabled, what timeouts <code>aiohttp</code> should expect to use for requests, and behavior regarding HTTP-redirects.</p> </li> <li> <code>max_body_size</code>               (<code>int</code>, default:                   <code>1024 ** 2</code> )           \u2013            <p>The maximum body size this should allow received request bodies to be in bytes before failing the request with a 413 - Content Too Large.</p> </li> <li> <code>max_rate_limit</code>               (<code>float</code>, default:                   <code>300.0</code> )           \u2013            <p>The max number of seconds to backoff for when rate limited. Anything greater than this will instead raise an error.</p> <p>This defaults to five minutes to stop potentially indefinitely waiting on an endpoint, which is almost never what you want to do if giving a response to a user.</p> <p>You can set this to <code>float(\"inf\")</code> to disable this check entirely. Note that this only applies to the REST API component that communicates with Discord, and will not affect sharding or third party HTTP endpoints that may be in use.</p> </li> <li> <code>max_retries</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            <p>Maximum number of times a request will be retried if</p> <p>it fails with a <code>5xx</code> status. Defaults to 3 if set to None.</p> </li> <li> <code>proxy_settings</code>               (<code>ProxySettings | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom proxy settings to use with network-layer logic in your application to get through an HTTP-proxy.</p> </li> <li> <code>public_key</code>               (<code>bytes | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The public key to use to verify received interaction requests.</p> <p>This may be a hex encoded <code>str</code> or the raw <code>bytes</code>. If left as None then the client will try to work this value out based on <code>token</code>.</p> </li> <li> <code>rest_url</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Defaults to the Discord REST API URL if None. Can be overridden if you are attempting to point to an unofficial endpoint, or if you are attempting to mock/stub the Discord API for any reason.</p> <p>Generally you do not want to change this.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <ul> <li>If <code>token_type</code> is provided when a token strategy is passed for <code>token</code>.</li> <li>if <code>token_type</code> is left as None when a string is passed for <code>token</code>.</li> </ul> </li> </ul>"},{"location":"reference/asgi/#yuyo.asgi.AsgiBot.add_shutdown_callback","title":"add_shutdown_callback","text":"<pre><code>add_shutdown_callback(callback)\n</code></pre> <p>Add a callback to be called when the bot shuts down.</p> <p>Warning</p> <p>These callbacks will block the bot from shutting down until they complete and any raised errors will lead to a failed shutdown.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>Callable[[Self], Coroutine[Any, Any, None]]</code>)           \u2013            <p>The shutdown callback to add.</p> </li> </ul>"},{"location":"reference/asgi/#yuyo.asgi.AsgiBot.add_startup_callback","title":"add_startup_callback","text":"<pre><code>add_startup_callback(callback)\n</code></pre> <p>Add a callback to be called when the bot starts up.</p> <p>Warning</p> <p>These callbacks will block the bot from starting until they complete and any raised errors will lead to a failed startup.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>Callable[[Self], Coroutine[Any, Any, None]]</code>)           \u2013            <p>The startup callback to add.</p> </li> </ul>"},{"location":"reference/asgi/#yuyo.asgi.AsgiBot.close","title":"close  <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Close the bot's REST client.</p> <p>Warning</p> <p>Unless <code>asgi_managed=False</code> is passed to <code>AsgiBot.__init__</code>, the bot will be automatically closed based on the ASGI lifespan events and any other calls to this function will raise a RuntimeError.</p> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If the client isn't alive. If the client is ASGI managed.</p> </li> </ul>"},{"location":"reference/asgi/#yuyo.asgi.AsgiBot.remove_shutdown_callback","title":"remove_shutdown_callback","text":"<pre><code>remove_shutdown_callback(callback)\n</code></pre> <p>Remove a shutdown callback.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>Callable[[Self], Coroutine[Any, Any, None]]</code>)           \u2013            <p>The shutdown callback to remove.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the callback was not registered.</p> </li> </ul>"},{"location":"reference/asgi/#yuyo.asgi.AsgiBot.remove_startup_callback","title":"remove_startup_callback","text":"<pre><code>remove_startup_callback(callback)\n</code></pre> <p>Remove a startup callback.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>Callable[[Self], Coroutine[Any, Any, None]]</code>)           \u2013            <p>The startup callback to remove.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the callback was not registered.</p> </li> </ul>"},{"location":"reference/asgi/#yuyo.asgi.AsgiBot.run","title":"run","text":"<pre><code>run()\n</code></pre> <p>Start the bot's REST client and wait until the bot's closed.</p> <p>Warning</p> <p>Unless <code>asgi_managed=False</code> is passed to AsgiBot.__init__, the bot will be automatically started and closed based on the ASGI lifespan events and any other calls to this function will raise a RuntimeError.</p> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If the client is already alive. If the client is ASGI managed.</p> </li> </ul>"},{"location":"reference/asgi/#yuyo.asgi.AsgiBot.start","title":"start  <code>async</code>","text":"<pre><code>start()\n</code></pre> <p>Start the bot's REST client.</p> <p>Warning</p> <p>Unless <code>asgi_managed=False</code> is passed to AsgiBot.__init__, the bot will be automatically started based on the ASGI lifespan events and any other calls to this function will raise a RuntimeError.</p> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If the client is already alive. If the client is ASGI managed.</p> </li> </ul>"},{"location":"reference/backoff/","title":"yuyo.backoff","text":"<p>Utility used for handling automatic back-off.</p> <p>This can be used to cover cases such as hitting rate-limits and failed requests.</p>"},{"location":"reference/backoff/#yuyo.backoff.Backoff","title":"Backoff","text":"<p>Used to exponentially backoff asynchronously.</p> <p>This class acts as an asynchronous iterator and can be iterated over to provide implicit backoff where for every iteration other than the first this will either back off for the time passed to Backoff.set_next_backoff if applicable or a time calculated exponentially.</p> <p>Each iteration yields the current retry count (starting at 0).</p> <p>Examples:</p> <p>An example of using this class as an asynchronous iterator may look like the following</p> <pre><code># While we can directly do `async for _ in Backoff()`, by assigning it to a\n# variable we allow ourself to provide a specific backoff time in some cases.\nbackoff = Backoff()\nasync for _ in backoff:\n    response = await client.fetch(f\"https://example.com/{resource_id}\")\n    if response.status_code == 403:  # Ratelimited\n        # If we have a specific backoff time then set it for the next iteration\n        backoff.set_next_backoff(response.headers.get(\"Retry-After\"))\n\n    elif response.status_code &gt;= 500:  # Internal server error\n        # Else let the iterator calculate an exponential backoff before the next loop.\n        pass\n\n    else:\n        response.raise_for_status()\n        resource = response.json()\n        # We need to break out of the iterator to make sure it doesn't backoff again.\n        # Alternatively `Backoff.finish()` can be called to break out of the loop.\n        break\n</code></pre> <p>Alternatively you may want to explicitly call Backoff.backoff. An alternative implementation of the previous example which uses Backoff.backoff may look like the following:</p> <pre><code>backoff = Backoff()\nresource = None\nwhile not resource:\n    response = await client.fetch(f\"https://example.com/{resource_id}\")\n    if response == 403  # Ratelimited\n        # If we have a specific backoff time then set it for the next iteration.\n        backoff.set_next_backoff(response.headers.get(\"Retry-After\"))\n        await backoff.backoff()  # We must explicitly backoff in this flow.\n\n    elif response &gt;= 500:  # Internal server error\n        # Else let the iterator calculate an exponential backoff and explicitly backoff.\n        await backoff.backoff()\n\n    else:\n        response.raise_for_status()\n        resource = response.json()\n</code></pre>"},{"location":"reference/backoff/#yuyo.backoff.Backoff.is_depleted","title":"is_depleted  <code>property</code>","text":"<pre><code>is_depleted\n</code></pre> <p>Whether \"max_retries\" has been reached.</p> <p>This can be used to workout whether the loop was explicitly broken out of using Backoff.finish/<code>break</code> or if it hit \"max_retries\".</p>"},{"location":"reference/backoff/#yuyo.backoff.Backoff.__init__","title":"__init__","text":"<pre><code>__init__(max_retries=None, *, base=2.0, maximum=64.0, jitter_multiplier=1.0, initial_increment=0)\n</code></pre> <p>Initialise a backoff instance.</p> <p>Parameters:</p> <ul> <li> <code>max_retries</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The maximum amount of times this should iterate for between resets.</p> <p>If left as None then this iterator will be unlimited. This must be greater than or equal to 1.</p> </li> <li> <code>base</code>               (<code>float</code>, default:                   <code>2.0</code> )           \u2013            <p>The base to use.</p> </li> <li> <code>maximum</code>               (<code>float</code>, default:                   <code>64.0</code> )           \u2013            <p>The max value the backoff can be in a single iteration. Anything above this will be capped to this base value plus random jitter.</p> </li> <li> <code>jitter_multiplier</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The multiplier for the random jitter.</p> <p>Set to <code>0</code> to disable jitter.</p> </li> <li> <code>initial_increment</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The initial increment to start at.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If an int that's too big to be represented as a float or a non-finite value is passed in place of a field that's annotated as float or if <code>max_retries</code> is less than <code>1</code>.</p> </li> </ul>"},{"location":"reference/backoff/#yuyo.backoff.Backoff.backoff","title":"backoff  <code>async</code>","text":"<pre><code>backoff()\n</code></pre> <p>Sleep for the provided backoff or for the next exponent.</p> <p>This provides an alternative to iterating over this class.</p> <p>Returns:</p> <ul> <li> <code>int | None</code>           \u2013            <p>Whether this has reached the end of its iteration.</p> <p>If this returns True then that call didn't sleep as this has been marked as finished or has reached the max retries.</p> </li> </ul>"},{"location":"reference/backoff/#yuyo.backoff.Backoff.finish","title":"finish","text":"<pre><code>finish()\n</code></pre> <p>Mark the iterator as finished to break out of the current loop.</p>"},{"location":"reference/backoff/#yuyo.backoff.Backoff.reset","title":"reset","text":"<pre><code>reset()\n</code></pre> <p>Reset the backoff to it's original state to reuse it.</p>"},{"location":"reference/backoff/#yuyo.backoff.Backoff.set_next_backoff","title":"set_next_backoff","text":"<pre><code>set_next_backoff(backoff_)\n</code></pre> <p>Specify a backoff time for the next iteration or Backoff.backoff call.</p> <p>If this is called then the exponent won't be increased for this iteration.</p> <p>Note</p> <p>Calling this multiple times in a single iteration will overwrite any previously set next backoff.</p> <p>Parameters:</p> <ul> <li> <code>backoff_</code>               (<code>float | int | None</code>)           \u2013            <p>The amount of time to backoff for in seconds.</p> <p>If this is None then any previously set next backoff will be unset.</p> </li> </ul>"},{"location":"reference/backoff/#yuyo.backoff.ErrorManager","title":"ErrorManager","text":"<p>A context manager provided to allow for more concise error handling with Backoff.</p> <p>Examples:</p> <p>The following is an example of using ErrorManager alongside Backoff in-order to handle the exceptions which may be raised while trying to reply to a message.</p> <pre><code>retry = Backoff()\n# Rules can either be passed to `ErrorManager`'s initiate as variable arguments\n# or one at a time to `ErrorManager.with_rule` through possibly chained-calls.\nerror_handler = (\n    # For the 1st rule we catch two errors which would indicate the bot\n    # no-longer has access to the target channel and break out of the\n    # retry loop using `Backoff.retry`.\n    ErrorManager(((NotFoundError, ForbiddenError), lambda _: retry.finish()))\n        # For the 2nd rule we catch rate limited errors and set their\n        # `retry` value as the next backoff time before suppressing the\n        # error to allow this to retry the request.\n        .with_rule((RateLimitedError,), lambda exc: retry.set_next_backoff(exc.retry_after))\n        # For the 3rd rule we suppress the internal server error to allow\n        # backoff to reach the next retry and exponentially backoff as we\n        # don't have any specific retry time for this error.\n        .with_rule((InternalServerError,), lambda _: False)\n)\nasync for _ in retry:\n    # We entre this context manager each iteration to catch errors before\n    # they cause us to break out of the `Backoff` loop.\n    with error_handler:\n        await post(f\"https://example.com/{resource_id}\", json={\"content\": \"General Kenobi\"})\n        # We need to break out of `retry` if this request succeeds.\n        break\n</code></pre>"},{"location":"reference/backoff/#yuyo.backoff.ErrorManager.__init__","title":"__init__","text":"<pre><code>__init__(*rules)\n</code></pre> <p>Initialise an error manager instance.</p> <p>Parameters:</p> <ul> <li> <code>*rules</code>               (<code>tuple[Iterable[type[BaseException]], Callable[[Any], bool | None]]</code>, default:                   <code>()</code> )           \u2013            <p>Rules to initiate this error context manager with.</p> <p>These are each a 2-length tuple where the <code>tuple[0]</code> is an iterable of types of the exceptions this rule should apply to and <code>tuple[1]</code> is the rule's callback function.</p> <p>The callback function will be called with the raised exception when it matches one of the passed exceptions for the relevant rule and may raise, return True to indicate that the current error should be raised outside of the context manager or False/None to suppress the current error.</p> </li> </ul>"},{"location":"reference/backoff/#yuyo.backoff.ErrorManager.add_rule","title":"add_rule","text":"<pre><code>add_rule(exceptions, result)\n</code></pre> <p>Add a rule to this exception context manager.</p> <p>Parameters:</p> <ul> <li> <code>exceptions</code>               (<code>Iterable[type[BaseException]]</code>)           \u2013            <p>An iterable of types of the exceptions this rule should apply to.</p> </li> <li> <code>result</code>               (<code>Callable[[Any], bool | None]</code>)           \u2013            <p>The function called with the raised exception when it matches one of the passed <code>exceptions</code>. This may raise, return True to indicate that the current error should be raised outside of the context manager or False/None to suppress the current error.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>This returns the handler a rule was being added to in-order to allow for chained calls.</p> </li> </ul>"},{"location":"reference/backoff/#yuyo.backoff.ErrorManager.clear_rules","title":"clear_rules","text":"<pre><code>clear_rules()\n</code></pre> <p>Clear the rules registered with this handler.</p>"},{"location":"reference/chunk_tracker/","title":"yuyo.chunk_tracker","text":"<p>Utility class for tracking request guild member responses.</p>"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ChunkRequestFinishedEvent","title":"ChunkRequestFinishedEvent","text":"<p>               Bases: <code>ShardEvent</code></p> <p>Event that's dispatched when a specific chunk request has finished.</p> <p>This will be fired for every chunk request which has a nonce.</p>"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ChunkRequestFinishedEvent.chunk_count","title":"chunk_count  <code>property</code>","text":"<pre><code>chunk_count\n</code></pre> <p>The amount of chunk events which should've been received for this request.</p>"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ChunkRequestFinishedEvent.first_received_at","title":"first_received_at  <code>property</code>","text":"<pre><code>first_received_at\n</code></pre> <p>When the first response was received.</p>"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ChunkRequestFinishedEvent.guild_id","title":"guild_id  <code>property</code>","text":"<pre><code>guild_id\n</code></pre> <p>Id of the guild this chunk request was for.</p>"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ChunkRequestFinishedEvent.last_received_at","title":"last_received_at  <code>property</code>","text":"<pre><code>last_received_at\n</code></pre> <p>When the last response was received.</p>"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ChunkRequestFinishedEvent.missed_chunks","title":"missed_chunks  <code>property</code>","text":"<pre><code>missed_chunks\n</code></pre> <p>Collection of the chunk responses which were missed (if any).</p>"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ChunkRequestFinishedEvent.not_found_ids","title":"not_found_ids  <code>property</code>","text":"<pre><code>not_found_ids\n</code></pre> <p>Collection of the User IDs which weren't found.</p> <p>This is only relevant when <code>users</code> was specified while requesting the members.</p>"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ChunkRequestFinishedEvent.__init__","title":"__init__","text":"<pre><code>__init__(app, shard, data)\n</code></pre> <p>Initialise a chunk request finished event.</p> <p>This should never be initialised directly.</p>"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ChunkTracker","title":"ChunkTracker","text":"<p>Chunk payload event tracker.</p> <p>This will dispatch ShardFinishedChunkingEvent, FinishedChunkingEvent and ChunkRequestFinishedEvent events.</p> <p>To configure this to automatically request member chunks to fill a member and/or presence cache on startup and guild join see ChunkTracker.set_auto_chunk_members.</p> <p>Note</p> <p>ChunkTracker.request_guild_members ensures a request will be tracked as this only tracks chunk requests with a set nonce.</p>"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ChunkTracker.__init__","title":"__init__","text":"<pre><code>__init__(event_manager, rest, shards, /, *, timeout=datetime.timedelta(seconds=5))\n</code></pre> <p>Initialise a chunk tracker.</p> <p>For a shorthand for initialising this from a hikari.GatewayBotAware see ChunkTracker.from_gateway_bot.</p> <p>Parameters:</p> <ul> <li> <code>event_manager</code>               (<code>EventManager</code>)           \u2013            <p>The event manager this chunk tracker should dispatch events over.</p> </li> <li> <code>rest</code>               (<code>RESTAware</code>)           \u2013            <p>The REST aware object this should use.</p> </li> <li> <code>shards</code>               (<code>ShardAware</code>)           \u2013            <p>The shard aware object this should use.</p> </li> <li> <code>timeout</code>               (<code>int | float | timedelta</code>, default:                   <code>timedelta(seconds=5)</code> )           \u2013            <p>How long this should wait between chunks until deciding the request has finished early/incomplete.</p> </li> </ul>"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ChunkTracker.from_gateway_bot","title":"from_gateway_bot  <code>classmethod</code>","text":"<pre><code>from_gateway_bot(bot, /, *, timeout=datetime.timedelta(seconds=5))\n</code></pre> <p>Initialise a chunk tracker from a gateway bot.</p> <p>Parameters:</p> <ul> <li> <code>bot</code>               (<code>ShardAware &amp; RESTAware &amp; EventManagerAware</code>)           \u2013            <p>The gateway bot this chunk tracker should use.</p> </li> <li> <code>timeout</code>               (<code>int | float | timedelta</code>, default:                   <code>timedelta(seconds=5)</code> )           \u2013            <p>How long this should wait between chunks until deciding the request has finished early/incomplete.</p> </li> </ul>"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ChunkTracker.request_guild_members","title":"request_guild_members  <code>async</code>","text":"<pre><code>request_guild_members(guild, /, *, include_presences=hikari.UNDEFINED, query='', limit=0, users=hikari.UNDEFINED)\n</code></pre> <p>Request guild members.</p> <p>Note</p> <p>To request the full list of members, leave <code>query</code> as <code>\"\"</code> (empty string) and <code>limit</code> as <code>0</code>.</p> <p>Parameters:</p> <ul> <li> <code>guild</code>               (<code>SnowflakeishOr[PartialGuild]</code>)           \u2013            <p>The guild to request chunk for.</p> </li> <li> <code>include_presences</code>               (<code>UndefinedOr[bool]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, whether to request presences.</p> </li> <li> <code>query</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>If not <code>\"\"</code>, request the members who's usernames starts with the string.</p> </li> <li> <code>limit</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Maximum number of members to send matching the query.</p> </li> <li> <code>users</code>               (<code>UndefinedOr[SnowflakeishSequence[User]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the users to request for.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>When trying to specify <code>users</code> with <code>query</code>/<code>limit</code>, if <code>limit</code> is not between 0 and 100, both inclusive or if <code>users</code> length is over 100.</p> </li> <li> <code>MissingIntentError</code>             \u2013            <p>When trying to request presences without the <code>GUILD_MEMBERS</code> or when trying to request the full list of members without <code>GUILD_PRESENCES</code>.</p> </li> </ul>"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ChunkTracker.set_auto_chunk_members","title":"set_auto_chunk_members","text":"<pre><code>set_auto_chunk_members(state, /, *, chunk_presences=True)\n</code></pre> <p>Configure whether this should request member chunks in response to GUILD_CREATE.</p> <p>This may be useful for filling 3rd party caches but may conflict with the <code>auto_chunk_members</code> config of hikari.impl.GatewayBot if it's enabled.</p> <p>Warning</p> <p>This will be ignored if Intents.GUILD_MEMBERS hasn't been declared.</p> <p>Parameters:</p> <ul> <li> <code>state</code>               (<code>bool</code>)           \u2013            <p>Whether this should request member chunks when GUILD_CREATE events are received.</p> </li> <li> <code>chunk_presences</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether this should also request member presences on these member chunks.</p> <p>This will be ignored if Intents.GUILD_PRESENCES hasn't been declared.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The chunk tracker object to enable call chaining.</p> </li> </ul>"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.FinishedChunkingEvent","title":"FinishedChunkingEvent","text":"<p>               Bases: <code>Event</code></p> <p>Event that's dispatched when the startup chunking has finished for the bot.</p> <p>This indicates that the member and presence caches should be complete globally.</p> <p>This will only be fired once after bot startups.</p>"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.FinishedChunkingEvent.__init__","title":"__init__","text":"<pre><code>__init__(app)\n</code></pre> <p>Initialise a chunking finished event.</p> <p>This should never be initialised directly.</p>"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ShardFinishedChunkingEvent","title":"ShardFinishedChunkingEvent","text":"<p>               Bases: <code>ShardEvent</code></p> <p>Event that's dispatched when the startup chunking has finished for a shard.</p> <p>This indicates that the member and presence caches should be complete for guilds covered by this shard.</p> <p>This will be fired after every shard identify which triggers chunking (including re-identifies).</p>"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ShardFinishedChunkingEvent.incomplete_guild_ids","title":"incomplete_guild_ids  <code>property</code>","text":"<pre><code>incomplete_guild_ids\n</code></pre> <p>Sequence of the IDs of guilds some chunk responses were missed for.</p>"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ShardFinishedChunkingEvent.missed_guild_ids","title":"missed_guild_ids  <code>property</code>","text":"<pre><code>missed_guild_ids\n</code></pre> <p>Sequence of the IDs of guilds no chunk responses were received for.</p>"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ShardFinishedChunkingEvent.__init__","title":"__init__","text":"<pre><code>__init__(app, shard, /, *, incomplete_guild_ids=(), missed_guild_ids=())\n</code></pre> <p>Initialise a shard chunking finished event.</p> <p>This should never be initialised directly.</p>"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker._log_task_exc","title":"_log_task_exc","text":"<pre><code>_log_task_exc(message)\n</code></pre> <p>Log the exception when a task raises instead of leaving it up to the gods.</p>"},{"location":"reference/components/","title":"yuyo.components","text":"<p>Higher level client for callback based component execution.</p>"},{"location":"reference/components/#yuyo.components.BaseContext","title":"BaseContext  <code>module-attribute</code>","text":"<pre><code>BaseContext = BaseContext\n</code></pre> <p>Deprecated alias of yuyo.interactions.BaseContext</p>"},{"location":"reference/components/#yuyo.components.CallbackSig","title":"CallbackSig  <code>module-attribute</code>","text":"<pre><code>CallbackSig = Callable[..., Coroutine[Any, Any, None]]\n</code></pre> <p>Type hint of a component callback.</p>"},{"location":"reference/components/#yuyo.components.Client","title":"Client  <code>module-attribute</code>","text":"<pre><code>Client = ComponentClient\n</code></pre> <p>Alias of ComponentClient.</p>"},{"location":"reference/components/#yuyo.components.Context","title":"Context  <code>module-attribute</code>","text":"<pre><code>Context = ComponentContext\n</code></pre> <p>Alias of ComponentContext.</p>"},{"location":"reference/components/#yuyo.components.Paginator","title":"Paginator  <code>module-attribute</code>","text":"<pre><code>Paginator = ComponentPaginator\n</code></pre> <p>Alias of ComponentPaginator.</p>"},{"location":"reference/components/#yuyo.components.StaticPaginator","title":"StaticPaginator  <code>module-attribute</code>","text":"<pre><code>StaticPaginator = StaticComponentPaginator\n</code></pre> <p>Alias of StaticComponentPaginator.</p>"},{"location":"reference/components/#yuyo.components.Stream","title":"Stream  <code>module-attribute</code>","text":"<pre><code>Stream = StreamExecutor\n</code></pre> <p>Alias of StreamExecutor.</p>"},{"location":"reference/components/#yuyo.components.WaitFor","title":"WaitFor  <code>module-attribute</code>","text":"<pre><code>WaitFor = WaitForExecutor\n</code></pre> <p>Alias of WaitForExecutor.</p>"},{"location":"reference/components/#yuyo.components._CHANNEL_TYPES","title":"_CHANNEL_TYPES  <code>module-attribute</code>","text":"<pre><code>_CHANNEL_TYPES = {GuildTextChannel: {GUILD_TEXT}, DMChannel: {DM}, GuildVoiceChannel: {GUILD_VOICE}, GroupDMChannel: {GROUP_DM}, GuildCategory: {GUILD_CATEGORY}, GuildNewsChannel: {GUILD_NEWS}, GuildStageChannel: {GUILD_STAGE}, GuildNewsThread: {GUILD_NEWS_THREAD}, GuildPublicThread: {GUILD_PUBLIC_THREAD}, GuildPrivateThread: {GUILD_PRIVATE_THREAD}, GuildForumChannel: {GUILD_FORUM}}\n</code></pre> <p>Mapping of hikari channel classes to the raw channel types which are compatible for it.</p>"},{"location":"reference/components/#yuyo.components._ComponentResponseT","title":"_ComponentResponseT  <code>module-attribute</code>","text":"<pre><code>_ComponentResponseT = InteractionMessageBuilder | InteractionDeferredBuilder | InteractionModalBuilder\n</code></pre> <p>Type hint of the builder response types allows for component interactions.</p>"},{"location":"reference/components/#yuyo.components.AbstractComponentExecutor","title":"AbstractComponentExecutor","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract interface of an object which handles the execution of a message component.</p>"},{"location":"reference/components/#yuyo.components.AbstractComponentExecutor.custom_ids","title":"custom_ids  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>custom_ids\n</code></pre> <p>Collection of the custom IDs this executor is listening for.</p>"},{"location":"reference/components/#yuyo.components.AbstractComponentExecutor.execute","title":"execute  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>execute(ctx)\n</code></pre> <p>Execute this component.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The context to execute this with.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ExecutorClosed</code>             \u2013            <p>If the executor is closed.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor","title":"ActionColumnExecutor","text":"<p>               Bases: <code>AbstractComponentExecutor</code></p> <p>Executor which handles columns of action rows.</p> <p>This can be used to declare and handle the components on a message a couple of ways.</p> <p>To send a column's components pass ActionColumnExecutor.rows as <code>components</code> when calling the create message method (e.g. <code>respond</code>/<code>create_message</code>).</p> <p>Examples:</p> <p>Sub-components can be added to an instance of the column executor using chainable methods on it:</p> <pre><code>async def callback_1(ctx: components.Context) -&gt; None:\n    await ctx.respond(\"meow\")\n\ncomponents = (\n    components.ActionColumnExecutor()\n    .add_interactive_button(hikari.ButtonStyle.PRIMARY, chainable, label=\"Button 1\")\n    .add_link_button(\"https://example.com\", label=\"Button 2\",)\n)\n</code></pre> <p>Alternatively, subclasses of ActionColumnExecutor can act as a template where \"static\" fields are included on all instances and subclasses of that class:</p> <p>Note</p> <p>Since decorators are executed from the bottom upwards fields added through decorator calls will follow the same order.</p> <pre><code>async def callback_1(ctx: components.Context) -&gt; None:\n    await ctx.respond(\"meow\")\n\nasync def callback_2(ctx: components.Context) -&gt; None:\n    await ctx.respond(\"meow\")\n\n@components.with_static_select_menu(callback_1, hikari.ComponentType.USER_SELECT_MENU, max_values=5)\nclass CustomColumn(components.ActionColumnExecutor):\n    __slots__ = (\"special_string\",)  # ActionColumnExecutor supports slotting.\n\n    # The init can be overridden to store extra data on the column object when subclassing.\n    def __init__(self, special_string: str, timeout: datetime.timedelta | None = None):\n        super().__init__(timeout=timeout)\n        self.special_string = special_string\n\n(\n    CustomColumn.add_static_text_menu(callback_2, min_values=0, max_values=3)\n    # The following calls are all adding options to the added\n    # text select menu.\n    .add_option(\"Option 1\", \"value 1\")\n    .add_option(\"Option 2\", \"value 2\")\n    .add_option(\"Option 3\", \"value 3\")\n)\n</code></pre> <p>There's also class descriptors which can be used to declare static components. The following descriptors work by decorating their component's callback:</p> <ul> <li>as_interactive_button</li> <li>as_channel_menu</li> <li>as_mentionable_menu</li> <li>as_role_menu</li> <li>as_text_menu</li> <li>as_user_menu</li> </ul> <p>link_button returns a descriptor without decorating any callback.</p> <pre><code>class CustomColumn(components.ActionColumnExecutor):\n    @components.as_interactive_button(ButtonStyle.PRIMARY, label=\"label\")\n    async def left_button(self, ctx: components.Context) -&gt; None:\n        ...\n\n    link_button = components.link_button(url=\"https://example.com\", label=\"Go to page\")\n\n    @components.as_interactive_button(ButtonStyle.SECONDARY, label=\"meow\")\n    async def right_button(self, ctx: components.Context) -&gt; None:\n        ...\n\n    @components.as_channel_menu(channel_types=[hikari.TextableChannel], custom_id=\"eep\")\n    async def text_select_menu(self, ctx: components.Context) -&gt; None:\n        ...\n</code></pre>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor._added_static_fields","title":"_added_static_fields  <code>class-attribute</code>","text":"<pre><code>_added_static_fields = {}\n</code></pre> <p>Dict of match IDs to the static fields added to this class through add method calls.</p> <p>This doesn't include inherited fields.</p>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor._static_fields","title":"_static_fields  <code>class-attribute</code>","text":"<pre><code>_static_fields = {}\n</code></pre> <p>Dict of match IDs to the static fields on this class.</p> <p>This includes inherited fields and fields added through method calls.</p>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.rows","title":"rows  <code>property</code>","text":"<pre><code>rows\n</code></pre> <p>The rows in this column.</p>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.__init__","title":"__init__","text":"<pre><code>__init__(*, authors=None, ephemeral_default=False, id_metadata=None)\n</code></pre> <p>Initialise an action column executor.</p> <p>Parameters:</p> <ul> <li> <code>authors</code>               (<code>Iterable[SnowflakeishOr[User]] | None</code>, default:                   <code>None</code> )           \u2013            <p>Users who are allowed to use the components this represents.</p> <p>If no users are provided then the components will be public (meaning that anybody can use it).</p> </li> <li> <code>ephemeral_default</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether or not the responses made on contexts spawned from this executor should default to ephemeral (meaning only the author can see them) unless <code>flags</code> is specified on the response method.</p> </li> <li> <code>id_metadata</code>               (<code>Mapping[str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Mapping of metadata to append to the custom IDs in this column.</p> <p>The keys in this can either be the match part of component custom IDs or the names of the component's callback when it was added using one of the <code>as_</code> class descriptors.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.add_builder","title":"add_builder","text":"<pre><code>add_builder(builder)\n</code></pre> <p>Add a raw component builder to this action column.</p> <p>This is mostly for adding components where the custom ID is already registered as a separate constant executor.</p> <p>Parameters:</p> <ul> <li> <code>builder</code>               (<code>ComponentBuilder</code>)           \u2013            <p>The component builder to add to the column.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.add_channel_menu","title":"add_channel_menu","text":"<pre><code>add_channel_menu(callback, /, *, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a channel select menu to this action column.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>channel_types</code>               (<code>None | Sequence[ChannelType | type[PartialChannel]]</code>, default:                   <code>None</code> )           \u2013            <p>Sequence of the types of channels this select menu should show as options.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The action column to enable chained calls.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.add_interactive_button","title":"add_interactive_button","text":"<pre><code>add_interactive_button(style, callback, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add an interactive button to this action column.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>)           \u2013            <p>The button's style.</p> </li> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>The button's execution callback.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The button's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's emoji.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's label.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the button should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The action column to enable chained calls.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.add_link_button","title":"add_link_button","text":"<pre><code>add_link_button(url, /, *, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add a link button to this action column.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>url</code>               (<code>str</code>)           \u2013            <p>The button's url.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's emoji.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's label.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the button should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The action column to enable chained calls.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.add_mentionable_menu","title":"add_mentionable_menu","text":"<pre><code>add_mentionable_menu(callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a mentionable select menu to this action column.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The action column to enable chained calls.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.add_role_menu","title":"add_role_menu","text":"<pre><code>add_role_menu(callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a role select menu to this action column.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The action column to enable chained calls.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.add_select_menu","title":"add_select_menu","text":"<pre><code>add_select_menu(type_, callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a select menu to this action column.</p> <p>The following methods should be used instead:</p> <ul> <li>.add_channel_menu</li> <li>.add_mentionable_menu</li> <li>.add_role_menu</li> <li>.add_text_menu</li> <li>.add_user_menu</li> </ul>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.add_static_builder","title":"add_static_builder  <code>classmethod</code>","text":"<pre><code>add_static_builder(builder)\n</code></pre> <p>Add a raw component builder to all subclasses and instances of this column.</p> <p>This is mostly for adding components where the custom ID is already registered as a separate constant executor.</p> <p>Parameters:</p> <ul> <li> <code>builder</code>               (<code>ComponentBuilder</code>)           \u2013            <p>The component builder to add to the column class.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.add_static_channel_menu","title":"add_static_channel_menu  <code>classmethod</code>","text":"<pre><code>add_static_channel_menu(callback, /, *, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a channel select menu to all subclasses and instances of this action column class.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>channel_types</code>               (<code>None | Sequence[ChannelType | type[PartialChannel]]</code>, default:                   <code>None</code> )           \u2013            <p>Sequence of the types of channels this select menu should show as options.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[Self]</code>           \u2013            <p>The action column class to enable chained calls.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.add_static_interactive_button","title":"add_static_interactive_button  <code>classmethod</code>","text":"<pre><code>add_static_interactive_button(style, callback, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add an interactive button to all subclasses and instances of this action column class.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>)           \u2013            <p>The button's style.</p> </li> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>The button's execution callback.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The button's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's emoji.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's label.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the button should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[Self]</code>           \u2013            <p>The action column class to enable chained calls.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.add_static_link_button","title":"add_static_link_button  <code>classmethod</code>","text":"<pre><code>add_static_link_button(url, /, *, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add a link button to all subclasses and instances of this action column class.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>url</code>               (<code>str</code>)           \u2013            <p>The button's url.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's emoji.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's label.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the button should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[Self]</code>           \u2013            <p>The action column class to enable chained calls.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.add_static_mentionable_menu","title":"add_static_mentionable_menu  <code>classmethod</code>","text":"<pre><code>add_static_mentionable_menu(callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a mentionable select menu to all subclasses and instances of this action column class.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[Self]</code>           \u2013            <p>The action column class to enable chained calls.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.add_static_role_menu","title":"add_static_role_menu  <code>classmethod</code>","text":"<pre><code>add_static_role_menu(callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a role select menu to all subclasses and instances of this action column class.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[Self]</code>           \u2013            <p>The action column class to enable chained calls.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.add_static_select_menu","title":"add_static_select_menu  <code>classmethod</code>","text":"<pre><code>add_static_select_menu(type_, callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a select menu to all subclasses and instances of this action column class.</p> <p>The following class methods should be used instead:</p> <ul> <li>.add_static_channel_menu</li> <li>.add_static_mentionable_menu</li> <li>.add_static_role_menu</li> <li>.add_static_text_menu</li> <li>.add_static_user_menu</li> </ul>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.add_static_text_menu","title":"add_static_text_menu  <code>classmethod</code>","text":"<pre><code>add_static_text_menu(callback, /, *, custom_id=None, options=(), placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a text select menu to all subclasses and instances of this action column class.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>options</code>               (<code>Sequence[SelectOptionBuilder]</code>, default:                   <code>()</code> )           \u2013            <p>The text select's options.</p> <p>These can also be added by calling TextSelectMenuBuilder.add_option.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>TextSelectMenuBuilder</code>           \u2013            <p>Builder for the added text select menu.</p> <p>TextSelectMenuBuilder.add_option should be used to add options to this select menu.</p> <p>And the parent action column can be accessed by calling TextSelectMenuBuilder.parent.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.add_static_user_menu","title":"add_static_user_menu  <code>classmethod</code>","text":"<pre><code>add_static_user_menu(callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a user select menu to all subclasses and instances of this action column class.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[Self]</code>           \u2013            <p>The action column class to enable chained calls.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.add_text_menu","title":"add_text_menu","text":"<pre><code>add_text_menu(callback, /, *, custom_id=None, options=(), placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a text select menu to this action column.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>options</code>               (<code>Sequence[SelectOptionBuilder]</code>, default:                   <code>()</code> )           \u2013            <p>The text select's options.</p> <p>These can also be added by calling TextSelectMenuBuilder.add_option.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>TextSelectMenuBuilder</code>           \u2013            <p>Builder for the added text select menu.</p> <p>TextSelectMenuBuilder.add_option should be used to add options to this select menu.</p> <p>And the parent action column can be accessed by calling TextSelectMenuBuilder.parent.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.add_user_menu","title":"add_user_menu","text":"<pre><code>add_user_menu(callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a user select menu to this action column.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The action column to enable chained calls.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.with_channel_menu","title":"with_channel_menu","text":"<pre><code>with_channel_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_channel_menu(*, custom_id: str | None = None, channel_types: None | Sequence[ChannelType | type[PartialChannel]] = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_channel_menu(callback=None, /, *, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a channel select menu to this action column through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>channel_types</code>               (<code>None | Sequence[ChannelType | type[PartialChannel]]</code>, default:                   <code>None</code> )           \u2013            <p>Sequence of the types of channels this select menu should show as options.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.with_interactive_button","title":"with_interactive_button","text":"<pre><code>with_interactive_button(style, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add an interactive button to this action column through a decorator call.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>)           \u2013            <p>The button's style.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The button's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's emoji.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's label.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the button should be marked as disabled.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.with_mentionable_menu","title":"with_mentionable_menu","text":"<pre><code>with_mentionable_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_mentionable_menu(*, custom_id: str | None = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_mentionable_menu(callback=None, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a mentionable select menu to this action column through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.with_role_menu","title":"with_role_menu","text":"<pre><code>with_role_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_role_menu(*, custom_id: str | None = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_role_menu(callback=None, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a role select menu to this action column through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.with_static_channel_menu","title":"with_static_channel_menu  <code>classmethod</code>","text":"<pre><code>with_static_channel_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_static_channel_menu(*, custom_id: str | None = None, channel_types: None | Sequence[ChannelType | type[PartialChannel]] = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_static_channel_menu(callback=None, /, *, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a channel select menu to this action column class through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>channel_types</code>               (<code>None | Sequence[ChannelType | type[PartialChannel]]</code>, default:                   <code>None</code> )           \u2013            <p>Sequence of the types of channels this select menu should show as options.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.with_static_interactive_button","title":"with_static_interactive_button  <code>classmethod</code>","text":"<pre><code>with_static_interactive_button(style, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add a static interactive button to this action column class through a decorator call.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>)           \u2013            <p>The button's style.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The button's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's emoji.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's label.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the button should be marked as disabled.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.with_static_mentionable_menu","title":"with_static_mentionable_menu  <code>classmethod</code>","text":"<pre><code>with_static_mentionable_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_static_mentionable_menu(*, custom_id: str | None = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_static_mentionable_menu(callback=None, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a static mentionable select menu to this action column class through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.with_static_role_menu","title":"with_static_role_menu  <code>classmethod</code>","text":"<pre><code>with_static_role_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_static_role_menu(*, custom_id: str | None = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_static_role_menu(callback=None, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a static role select menu to this action column class through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.with_static_text_menu","title":"with_static_text_menu  <code>classmethod</code>","text":"<pre><code>with_static_text_menu(callback: Callable[_P, _CoroT]) -&gt; _WrappedTextMenuBuilder[_P]\n</code></pre><pre><code>with_static_text_menu(*, custom_id: str | None = None, options: Sequence[SelectOptionBuilder] = (), placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[collections.Callable[_P, _CoroT]], _WrappedTextMenuBuilder[_P]]\n</code></pre> <pre><code>with_static_text_menu(callback=None, /, *, custom_id=None, options=(), placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a text select menu to this action column class through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>options</code>               (<code>Sequence[SelectOptionBuilder]</code>, default:                   <code>()</code> )           \u2013            <p>The text select's options.</p> <p>These can also be added using [yuyo.components.with_option].</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.with_static_user_menu","title":"with_static_user_menu  <code>classmethod</code>","text":"<pre><code>with_static_user_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_static_user_menu(*, custom_id: str | None = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_static_user_menu(callback=None, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a static user select menu to this action column class through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.with_text_menu","title":"with_text_menu","text":"<pre><code>with_text_menu(callback: Callable[_P, _CoroT]) -&gt; _WrappedTextMenuBuilder[_P]\n</code></pre><pre><code>with_text_menu(*, custom_id: str | None = None, options: Sequence[SelectOptionBuilder] = (), placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[collections.Callable[_P, _CoroT]], _WrappedTextMenuBuilder[_P]]\n</code></pre> <pre><code>with_text_menu(callback=None, /, *, custom_id=None, options=(), placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a text select menu to this action column through a decorator callback.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>options</code>               (<code>Sequence[SelectOptionBuilder]</code>, default:                   <code>()</code> )           \u2013            <p>The text select's options.</p> <p>These can also be added using components.with_option.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ActionColumnExecutor.with_user_menu","title":"with_user_menu","text":"<pre><code>with_user_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_user_menu(*, custom_id: str | None = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_user_menu(callback=None, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a user select menu to this action column through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentClient","title":"ComponentClient","text":"<p>Client used to handle component executors within a REST or gateway flow.</p>"},{"location":"reference/components/#yuyo.components.ComponentClient._executors","title":"_executors  <code>instance-attribute</code>","text":"<pre><code>_executors = {}\n</code></pre> <p>Dict of custom IDs to executors.</p>"},{"location":"reference/components/#yuyo.components.ComponentClient._message_executors","title":"_message_executors  <code>instance-attribute</code>","text":"<pre><code>_message_executors = {}\n</code></pre> <p>Dict of message IDs to executors.</p>"},{"location":"reference/components/#yuyo.components.ComponentClient.alluka","title":"alluka  <code>property</code>","text":"<pre><code>alluka\n</code></pre> <p>The Alluka client being used for callback dependency injection.</p>"},{"location":"reference/components/#yuyo.components.ComponentClient.cache","title":"cache  <code>property</code>","text":"<pre><code>cache\n</code></pre> <p>Hikari cache instance this client was initialised with.</p>"},{"location":"reference/components/#yuyo.components.ComponentClient.events","title":"events  <code>property</code>","text":"<pre><code>events\n</code></pre> <p>Object of the event manager this client was initialised with.</p>"},{"location":"reference/components/#yuyo.components.ComponentClient.rest","title":"rest  <code>property</code>","text":"<pre><code>rest\n</code></pre> <p>Object of the Hikari REST client this client was initialised with.</p>"},{"location":"reference/components/#yuyo.components.ComponentClient.server","title":"server  <code>property</code>","text":"<pre><code>server\n</code></pre> <p>Object of the Hikari interaction server provided for this client.</p>"},{"location":"reference/components/#yuyo.components.ComponentClient.shards","title":"shards  <code>property</code>","text":"<pre><code>shards\n</code></pre> <p>Object of the Hikari shard manager this client was initialised with.</p>"},{"location":"reference/components/#yuyo.components.ComponentClient.voice","title":"voice  <code>property</code>","text":"<pre><code>voice\n</code></pre> <p>Object of the Hikari voice component this client was initialised with.</p>"},{"location":"reference/components/#yuyo.components.ComponentClient.__init__","title":"__init__","text":"<pre><code>__init__(*, alluka=None, cache=None, event_manager=None, event_managed=None, rest=None, server=None, shards=None, voice=None)\n</code></pre> <p>Initialise a component client.</p> <p>This sets ComponentClient as a type dependency when <code>alluka</code> isn't passed.</p> <p>Note</p> <p>For an easier way to initialise the client from a bot see ComponentClient.from_gateway_bot, ComponentClient.from_rest_bot, and ComponentClient.from_tanjun.</p> <p>Parameters:</p> <ul> <li> <code>alluka</code>               (<code>Client | None</code>, default:                   <code>None</code> )           \u2013            <p>The Alluka client to use for callback dependency injection in this client.</p> <p>If not provided then this will initialise its own Alluka client.</p> </li> <li> <code>event_manager</code>               (<code>EventManager | None</code>, default:                   <code>None</code> )           \u2013            <p>The event manager this client should listen to dispatched component interactions from if applicable.</p> </li> <li> <code>event_managed</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether this client should be automatically opened and closed based on the lifetime events dispatched by <code>event_manager</code>.</p> <p>Defaults to True if an event manager is passed.</p> </li> <li> <code>server</code>               (<code>InteractionServer | None</code>, default:                   <code>None</code> )           \u2013            <p>The server this client should listen to component interactions from if applicable.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>event_managed</code> is passed as True when <code>event_manager</code> is None.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentClient.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Close the component client.</p>"},{"location":"reference/components/#yuyo.components.ComponentClient.deregister_executor","title":"deregister_executor","text":"<pre><code>deregister_executor(executor)\n</code></pre> <p>Remove a component executor by its custom IDs.</p> <p>Parameters:</p> <ul> <li> <code>executor</code>               (<code>AbstractComponentExecutor</code>)           \u2013            <p>The executor to remove.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The component client to allow chaining.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>If the executor isn't registered.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentClient.deregister_message","title":"deregister_message","text":"<pre><code>deregister_message(message)\n</code></pre> <p>Remove a component executor by its message.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>SnowflakeishOr[Message]</code>)           \u2013            <p>The message to remove the executor for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The component client to allow chaining.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>If the message is not registered.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentClient.from_gateway_bot","title":"from_gateway_bot  <code>classmethod</code>","text":"<pre><code>from_gateway_bot(bot, /, *, alluka=None, event_managed=True)\n</code></pre> <p>Build a component client from a Gateway Bot.</p> <p>This sets ComponentClient as a type dependency when <code>alluka</code> isn't passed.</p> <p>Parameters:</p> <ul> <li> <code>bot</code>               (<code>_GatewayBotProto</code>)           \u2013            <p>The Gateway bot this component client should be bound to.</p> </li> <li> <code>alluka</code>               (<code>Client | None</code>, default:                   <code>None</code> )           \u2013            <p>The Alluka client to use for callback dependency injection in this client.</p> <p>If not provided then this will initialise its own Alluka client.</p> </li> <li> <code>event_managed</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the component client should be automatically opened and closed based on the lifetime events dispatched by <code>bot</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ComponentClient</code>           \u2013            <p>The initialised component client.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentClient.from_rest_bot","title":"from_rest_bot  <code>classmethod</code>","text":"<pre><code>from_rest_bot(bot, /, *, alluka=None, bot_managed=False)\n</code></pre> <p>Build a component client from a REST Bot.</p> <p>This sets ComponentClient as a type dependency when <code>alluka</code> isn't passed.</p> <p>Parameters:</p> <ul> <li> <code>bot</code>               (<code>RESTBotAware</code>)           \u2013            <p>The REST bot this component client should be bound to.</p> </li> <li> <code>alluka</code>               (<code>Client | None</code>, default:                   <code>None</code> )           \u2013            <p>The Alluka client to use for callback dependency injection in this client.</p> <p>If not provided then this will initialise its own Alluka client.</p> </li> <li> <code>bot_managed</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the component client should be automatically opened and closed based on the Bot's startup and shutdown callbacks.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ComponentClient</code>           \u2013            <p>The initialised component client.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentClient.from_tanjun","title":"from_tanjun  <code>classmethod</code>","text":"<pre><code>from_tanjun(tanjun_client, /, *, tanjun_managed=True)\n</code></pre> <p>Build a component client from a Tanjun client.</p> <p>This will use the Tanjun client's alluka client and registers ComponentClient as a type dependency on Tanjun.</p> <p>Parameters:</p> <ul> <li> <code>tanjun_client</code>               (<code>Client</code>)           \u2013            <p>The Tanjun client this component client should be bound to.</p> </li> <li> <code>tanjun_managed</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the component client should be automatically opened and closed based on the Tanjun client's lifetime client callback.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ComponentClient</code>           \u2013            <p>The initialised component client.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentClient.get_executor","title":"get_executor","text":"<pre><code>get_executor(custom_id)\n</code></pre> <p>Get the component executor registered for a custom ID.</p> <p>Note</p> <p>For message scoped executors use get_executor_for_message. as they will not be returned here.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str</code>)           \u2013            <p>The custom ID to get the executor for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AbstractComponentExecutor | None</code>           \u2013            <p>The executor set for the custom ID or None if none is set.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentClient.get_executor_for_message","title":"get_executor_for_message","text":"<pre><code>get_executor_for_message(message)\n</code></pre> <p>Get the component executor registered for a message.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>SnowflakeishOr[Message]</code>)           \u2013            <p>The message to get the executor for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AbstractComponentExecutor | None</code>           \u2013            <p>The executor set for the message or None if none is set.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentClient.on_gateway_event","title":"on_gateway_event  <code>async</code>","text":"<pre><code>on_gateway_event(event)\n</code></pre> <p>Process an interaction create gateway event.</p> <p>Parameters:</p> <ul> <li> <code>event</code>               (<code>InteractionCreateEvent</code>)           \u2013            <p>The interaction create gateway event to process.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentClient.on_rest_request","title":"on_rest_request  <code>async</code>","text":"<pre><code>on_rest_request(interaction)\n</code></pre> <p>Process a component interaction REST request.</p> <p>Parameters:</p> <ul> <li> <code>interaction</code>               (<code>ComponentInteraction</code>)           \u2013            <p>The interaction to process.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ResponseT</code>           \u2013            <p>The REST response.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentClient.open","title":"open","text":"<pre><code>open()\n</code></pre> <p>Startup the component client.</p>"},{"location":"reference/components/#yuyo.components.ComponentClient.register_executor","title":"register_executor","text":"<pre><code>register_executor(executor, /, *, message=None, timeout=_internal.NO_DEFAULT)\n</code></pre> <p>Add an executor to this client.</p> <p>Parameters:</p> <ul> <li> <code>executor</code>               (<code>AbstractComponentExecutor</code>)           \u2013            <p>The executor to register.</p> </li> <li> <code>message</code>               (<code>SnowflakeishOr[Message] | None</code>, default:                   <code>None</code> )           \u2013            <p>The message to register this executor for.</p> <p>If this is left as None then this executor will be registered globally for its custom IDs.</p> </li> <li> <code>timeout</code>               (<code>AbstractTimeout | None | NoDefault</code>, default:                   <code>NO_DEFAULT</code> )           \u2013            <p>The executor's timeout.</p> <p>This defaults to a 30 second sliding timeout.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The component client to allow chaining.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>message</code> is already registered when it's passed.</p> <p>If any of the executor's custom IDs are already registered when <code>message</code> wasn't passed.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentContext","title":"ComponentContext","text":"<p>               Bases: <code>BaseContext[ComponentInteraction]</code></p> <p>The context used for message component triggers.</p>"},{"location":"reference/components/#yuyo.components.ComponentContext.alluka","title":"alluka  <code>property</code>","text":"<pre><code>alluka\n</code></pre> <p>The Alluka client being used for callback dependency injection.</p>"},{"location":"reference/components/#yuyo.components.ComponentContext.author","title":"author  <code>property</code>","text":"<pre><code>author\n</code></pre> <p>Author of this interaction.</p>"},{"location":"reference/components/#yuyo.components.ComponentContext.cache","title":"cache  <code>property</code>","text":"<pre><code>cache\n</code></pre> <p>Hikari cache instance this context's client was initialised with.</p>"},{"location":"reference/components/#yuyo.components.ComponentContext.channel_id","title":"channel_id  <code>property</code>","text":"<pre><code>channel_id\n</code></pre> <p>ID of the channel this interaction was triggered in.</p>"},{"location":"reference/components/#yuyo.components.ComponentContext.client","title":"client  <code>property</code>","text":"<pre><code>client\n</code></pre> <p>The component client this context is bound to.</p>"},{"location":"reference/components/#yuyo.components.ComponentContext.events","title":"events  <code>property</code>","text":"<pre><code>events\n</code></pre> <p>Object of the event manager this context's client was initialised with.</p>"},{"location":"reference/components/#yuyo.components.ComponentContext.expires_at","title":"expires_at  <code>property</code>","text":"<pre><code>expires_at\n</code></pre> <p>When this context expires.</p> <p>After this time is reached, the message/response methods on this context will always raise hikari.NotFoundError.</p>"},{"location":"reference/components/#yuyo.components.ComponentContext.has_been_deferred","title":"has_been_deferred  <code>property</code>","text":"<pre><code>has_been_deferred\n</code></pre> <p>Whether this context's initial response has been deferred.</p> <p>This will be true if BaseContext.defer has been called.</p>"},{"location":"reference/components/#yuyo.components.ComponentContext.has_responded","title":"has_responded  <code>property</code>","text":"<pre><code>has_responded\n</code></pre> <p>Whether an initial response has been made to this context yet.</p> <p>It's worth noting that a context must be either responded to or deferred within 3 seconds from it being received otherwise it'll be marked as failed.</p> <p>This will be true if either BaseContext.respond, BaseContext.create_initial_response or BaseContext.edit_initial_response (after a deferral) has been called.</p>"},{"location":"reference/components/#yuyo.components.ComponentContext.id_match","title":"id_match  <code>property</code>","text":"<pre><code>id_match\n</code></pre> <p>Section of the ID used to identify the relevant executor.</p>"},{"location":"reference/components/#yuyo.components.ComponentContext.id_metadata","title":"id_metadata  <code>property</code>","text":"<pre><code>id_metadata\n</code></pre> <p>Metadata from the interaction's custom ID.</p>"},{"location":"reference/components/#yuyo.components.ComponentContext.interaction","title":"interaction  <code>property</code>","text":"<pre><code>interaction\n</code></pre> <p>Object of the interaction this context is for.</p>"},{"location":"reference/components/#yuyo.components.ComponentContext.rest","title":"rest  <code>property</code>","text":"<pre><code>rest\n</code></pre> <p>Object of the Hikari REST client this context's client was initialised with.</p>"},{"location":"reference/components/#yuyo.components.ComponentContext.selected_channels","title":"selected_channels  <code>property</code>","text":"<pre><code>selected_channels\n</code></pre> <p>Sequence of the users passed for a channel select menu.</p>"},{"location":"reference/components/#yuyo.components.ComponentContext.selected_members","title":"selected_members  <code>property</code>","text":"<pre><code>selected_members\n</code></pre> <p>Sequence of the members passed for a user select menu.</p> <p>This will also include some of the values for a mentionable select menu.</p>"},{"location":"reference/components/#yuyo.components.ComponentContext.selected_roles","title":"selected_roles  <code>property</code>","text":"<pre><code>selected_roles\n</code></pre> <p>Sequence of the users passed for a role select menu.</p> <p>This will also include some of the values for a mentionable select menu.</p>"},{"location":"reference/components/#yuyo.components.ComponentContext.selected_texts","title":"selected_texts  <code>property</code>","text":"<pre><code>selected_texts\n</code></pre> <p>Sequence of the values passed for a text select menu.</p>"},{"location":"reference/components/#yuyo.components.ComponentContext.selected_users","title":"selected_users  <code>property</code>","text":"<pre><code>selected_users\n</code></pre> <p>Sequence of the users passed for a user select menu.</p> <p>This will also include some of the values for a mentionable select menu.</p> <p>ComponentContext.selected_members has the full member objects.</p>"},{"location":"reference/components/#yuyo.components.ComponentContext.server","title":"server  <code>property</code>","text":"<pre><code>server\n</code></pre> <p>Object of the Hikari interaction server provided for this context's client.</p>"},{"location":"reference/components/#yuyo.components.ComponentContext.shard","title":"shard  <code>property</code>","text":"<pre><code>shard\n</code></pre> <p>Shard that triggered the interaction.</p> <p>Note</p> <p>This will be None if BaseContext.shards is also None.</p>"},{"location":"reference/components/#yuyo.components.ComponentContext.shards","title":"shards  <code>property</code>","text":"<pre><code>shards\n</code></pre> <p>Object of the Hikari shard manager this context's client was initialised with.</p>"},{"location":"reference/components/#yuyo.components.ComponentContext.voice","title":"voice  <code>property</code>","text":"<pre><code>voice\n</code></pre> <p>Object of the Hikari voice component this context's client was initialised with.</p>"},{"location":"reference/components/#yuyo.components.ComponentContext.create_followup","title":"create_followup  <code>async</code>","text":"<pre><code>create_followup(content=hikari.UNDEFINED, *, delete_after=None, ephemeral=None, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, mentions_everyone=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED, tts=hikari.UNDEFINED, flags=hikari.UNDEFINED)\n</code></pre> <p>Create a followup response for this context.</p> <p>Warning</p> <p>Calling this on a context which hasn't had an initial response yet will lead to a hikari.NotFoundError being raised.</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>UndefinedOr[Any]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message content to send.</p> <p>If this is a hikari.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead be treated as an embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> </li> <li> <code>delete_after</code>               (<code>timedelta | float | int | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, the seconds after which the response message should be deleted.</p> <p>Interaction responses can only be deleted within 15 minutes of the interaction being received.</p> </li> <li> <code>ephemeral</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether the deferred response should be ephemeral. Passing True here is a shorthand for including <code>1 &lt;&lt; 64</code> in the passed flags.</p> </li> <li> <code>attachment</code>               (<code>UndefinedOr[Resourceish]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.</p> </li> <li> <code>attachments</code>               (<code>UndefinedOr[Sequence[Resourceish]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.</p> </li> <li> <code>component</code>               (<code>UndefinedOr[ComponentBuilder]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, builder object of the component to include in this message.</p> </li> <li> <code>components</code>               (<code>UndefinedOr[Sequence[ComponentBuilder]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, a sequence of the component builder objects to include in this message.</p> </li> <li> <code>embed</code>               (<code>UndefinedOr[Embed]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message embed.</p> </li> <li> <code>embeds</code>               (<code>UndefinedOr[Sequence[Embed]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message embeds.</p> </li> <li> <code>mentions_everyone</code>               (<code>UndefinedOr[bool]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, whether the message should parse @everyone/@here mentions.</p> </li> <li> <code>user_mentions</code>               (<code>SnowflakeishSequence[PartialUser] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialUser derivatives to enforce mentioning specific users.</p> </li> <li> <code>role_mentions</code>               (<code>SnowflakeishSequence[PartialRole] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialRole derivatives to enforce mentioning specific roles.</p> </li> <li> <code>tts</code>               (<code>UndefinedOr[bool]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, whether the message will be sent as a TTS message.</p> </li> <li> <code>flags</code>               (<code>UndefinedType | int | MessageFlag</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The flags to set for this response.</p> <p>As of writing this can only flag which can be provided is EPHEMERAL, other flags are just ignored.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Message</code>           \u2013            <p>The created message object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NotFoundError</code>             \u2013            <p>If the current interaction is not found or it hasn't had an initial response yet.</p> </li> <li> <code>BadRequestError</code>             \u2013            <p>This can be raised if the file is too large; if the embed exceeds the defined limits; if the message content is specified only and empty or greater than <code>2000</code> characters; if neither content, file or embeds are specified. If any invalid snowflake IDs are passed; a snowflake may be invalid due to it being outside of the range of a 64 bit integer.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If more than 100 unique objects/entities are passed for <code>role_mentions</code> or `user_mentions.</p> <p>If the interaction will have expired before <code>delete_after</code> is reached.</p> <p>If both <code>attachment</code> and <code>attachments</code> are passed or both <code>component</code> and <code>components</code> are passed or both <code>embed</code> and <code>embeds</code> are passed.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentContext.create_initial_response","title":"create_initial_response  <code>async</code>","text":"<pre><code>create_initial_response(content=hikari.UNDEFINED, *, response_type=hikari.ResponseType.MESSAGE_CREATE, delete_after=None, ephemeral=None, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, mentions_everyone=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED, flags=hikari.UNDEFINED, tts=hikari.UNDEFINED)\n</code></pre> <p>Create the initial response for this context.</p> <p>Warning</p> <p>Calling this on a context which already has an initial response will result in this raising a hikari.NotFoundError. This includes if the REST interaction server has already responded to the request and deferrals.</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>UndefinedOr[Any]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message content to respond with.</p> <p>If this is a hikari.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead be treated as an embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> </li> <li> <code>response_type</code>               (<code>MessageResponseTypesT</code>, default:                   <code>MESSAGE_CREATE</code> )           \u2013            <p>The type of message response to give.</p> </li> <li> <code>delete_after</code>               (<code>timedelta | float | int | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, the seconds after which the response message should be deleted.</p> <p>Interaction responses can only be deleted within 15 minutes of the interaction being received.</p> </li> <li> <code>ephemeral</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether the deferred response should be ephemeral.</p> <p>Passing True here is a shorthand for including <code>1 &lt;&lt; 64</code> in the passed flags.</p> </li> <li> <code>attachment</code>               (<code>UndefinedOr[Resourceish]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.</p> </li> <li> <code>attachments</code>               (<code>UndefinedOr[Sequence[Resourceish]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.</p> </li> <li> <code>component</code>               (<code>UndefinedOr[ComponentBuilder]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, builder object of the component to include in this message.</p> </li> <li> <code>components</code>               (<code>UndefinedOr[Sequence[ComponentBuilder]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, a sequence of the component builder objects to include in this message.</p> </li> <li> <code>embed</code>               (<code>UndefinedOr[Embed]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message embed.</p> </li> <li> <code>embeds</code>               (<code>UndefinedOr[Sequence[Embed]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message embeds.</p> </li> <li> <code>flags</code>               (<code>int | MessageFlag | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message flags this response should have.</p> <p>As of writing the only message flag which can be set here is MessageFlag.EPHEMERAL.</p> </li> <li> <code>tts</code>               (<code>UndefinedOr[bool]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, whether the message will be read out by a screen reader using Discord's TTS (text-to-speech) system.</p> </li> <li> <code>mentions_everyone</code>               (<code>UndefinedOr[bool]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, whether the message should parse @everyone/@here mentions.</p> </li> <li> <code>user_mentions</code>               (<code>SnowflakeishSequence[PartialUser] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialUser derivatives to enforce mentioning specific users.</p> </li> <li> <code>role_mentions</code>               (<code>SnowflakeishSequence[PartialRole] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialRole derivatives to enforce mentioning specific roles.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If more than 100 unique objects/entities are passed for <code>role_mentions</code> or <code>user_mentions</code>.</p> <p>If the interaction will have expired before <code>delete_after</code> is reached.</p> <p>If both <code>attachment</code> and <code>attachments</code> are passed or both <code>component</code> and <code>components</code> are passed or both <code>embed</code> and <code>embeds</code> are passed.</p> </li> <li> <code>BadRequestError</code>             \u2013            <p>This may be raised in several discrete situations, such as messages being empty with no embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; invalid image URLs in embeds.</p> </li> <li> <code>UnauthorizedError</code>             \u2013            <p>If you are unauthorized to make the request (invalid/missing token).</p> </li> <li> <code>NotFoundError</code>             \u2013            <p>If the interaction is not found or if the interaction's initial response has already been created.</p> </li> <li> <code>RateLimitTooLongError</code>             \u2013            <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> </li> <li> <code>InternalServerError</code>             \u2013            <p>If an internal error occurs on Discord while handling the request.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentContext.create_modal_response","title":"create_modal_response  <code>async</code>","text":"<pre><code>create_modal_response(title, custom_id, /, *, component=hikari.UNDEFINED, components=hikari.UNDEFINED)\n</code></pre> <p>Send a modal as the initial response for this context.</p> <p>Warning</p> <p>This must be called as the first response to a context before any deferring.</p> <p>Parameters:</p> <ul> <li> <code>title</code>               (<code>str</code>)           \u2013            <p>The title that will show up in the modal.</p> </li> <li> <code>custom_id</code>               (<code>str</code>)           \u2013            <p>Developer set custom ID used for identifying interactions with this modal.</p> <p>Yuyo's Component client will only match against <code>custom_id.split(\":\", 1)[0]</code>, allowing metadata to be put after <code>\":\"</code>.</p> </li> <li> <code>component</code>               (<code>UndefinedOr[ComponentBuilder]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A component builder to send in this modal.</p> </li> <li> <code>components</code>               (<code>UndefinedOr[Sequence[ComponentBuilder]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A sequence of component builders to send in this modal.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If both <code>component</code> and <code>components</code> are specified or if none are specified.</p> </li> <li> <code>BadRequestError</code>             \u2013            <p>When the requests' data is outside Discord's accept ranges/validation.</p> </li> <li> <code>UnauthorizedError</code>             \u2013            <p>If you are unauthorized to make the request (invalid/missing token).</p> </li> <li> <code>NotFoundError</code>             \u2013            <p>If the interaction is not found or if the interaction's initial response has already been created or deferred.</p> </li> <li> <code>RateLimitTooLongError</code>             \u2013            <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> </li> <li> <code>InternalServerError</code>             \u2013            <p>If an internal error occurs on Discord while handling the request.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentContext.defer","title":"defer  <code>async</code>","text":"<pre><code>defer(*, defer_type=hikari.ResponseType.DEFERRED_MESSAGE_CREATE, ephemeral=None, flags=hikari.UNDEFINED)\n</code></pre> <p>Defer the initial response for this context.</p> <p>Note</p> <p>The ephemeral state of the first response is decided by whether the deferral is ephemeral.</p> <p>Parameters:</p> <ul> <li> <code>defer_type</code>               (<code>DeferredResponseTypesT</code>, default:                   <code>DEFERRED_MESSAGE_CREATE</code> )           \u2013            <p>The type of deferral this should be.</p> <p>This may any of the following:</p> <ul> <li>ResponseType.DEFERRED_MESSAGE_CREATE     to indicate that the following up call to     BaseContext.edit_initial_response     or BaseContext.respond     should create a new message.</li> <li>ResponseType.DEFERRED_MESSAGE_UPDATE     to indicate that the following call to the aforementioned     methods should update the existing message.</li> </ul> </li> <li> <code>ephemeral</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether the deferred response should be ephemeral.</p> <p>Passing True here is a shorthand for including <code>1 &lt;&lt; 64</code> in the passed flags.</p> </li> <li> <code>flags</code>               (<code>UndefinedType | int | MessageFlag</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The flags to use for the initial response.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentContext.delete_initial_response","title":"delete_initial_response  <code>async</code>","text":"<pre><code>delete_initial_response()\n</code></pre> <p>Delete the initial response after invoking this context.</p> <p>Raises:</p> <ul> <li> <code>(LookupError, NotFoundError)</code>             \u2013            <p>The last context has no initial response.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentContext.delete_last_response","title":"delete_last_response  <code>async</code>","text":"<pre><code>delete_last_response()\n</code></pre> <p>Delete the last response after invoking this context.</p> <p>Raises:</p> <ul> <li> <code>(LookupError, NotFoundError)</code>             \u2013            <p>The last context has no responses.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentContext.edit_initial_response","title":"edit_initial_response  <code>async</code>","text":"<pre><code>edit_initial_response(content=hikari.UNDEFINED, *, delete_after=None, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, mentions_everyone=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED)\n</code></pre> <p>Edit the initial response for this context.</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>UndefinedOr[Any]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message content to edit the initial response with.</p> <p>If this is a hikari.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> </li> <li> <code>delete_after</code>               (<code>timedelta | float | int | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, the seconds after which the response message should be deleted.</p> <p>Interaction responses can only be deleted within 15 minutes of the interaction being received.</p> </li> <li> <code>attachment</code>               (<code>UndefinedNoneOr[Resourceish]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A singular attachment to edit the initial response with.</p> </li> <li> <code>attachments</code>               (<code>UndefinedNoneOr[Sequence[Resourceish]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A sequence of attachments to edit the initial response with.</p> </li> <li> <code>component</code>               (<code>UndefinedNoneOr[ComponentBuilder]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, builder object of the component to set for this message. This component will replace any previously set components and passing None will remove all components.</p> </li> <li> <code>components</code>               (<code>UndefinedNoneOr[Sequence[ComponentBuilder]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing None or an empty sequence will remove all components.</p> </li> <li> <code>embed</code>               (<code>UndefinedNoneOr[Embed]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>An embed to replace the initial response with.</p> </li> <li> <code>embeds</code>               (<code>UndefinedNoneOr[Sequence[Embed]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A sequence of embeds to replace the initial response with.</p> </li> <li> <code>mentions_everyone</code>               (<code>UndefinedOr[bool]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, whether the message should parse @everyone/@here mentions.</p> </li> <li> <code>user_mentions</code>               (<code>SnowflakeishSequence[PartialUser] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialUser derivatives to enforce mentioning specific users.</p> </li> <li> <code>role_mentions</code>               (<code>SnowflakeishSequence[PartialRole] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialRole derivatives to enforce mentioning specific roles.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Message</code>           \u2013            <p>The message that has been edited.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If more than 100 unique objects/entities are passed for <code>role_mentions</code> or <code>user_mentions</code>.</p> <p>If <code>delete_after</code> would be more than 15 minutes after the interaction was received.</p> <p>If both <code>attachment</code> and <code>attachments</code> are passed or both <code>component</code> and <code>components</code> are passed or both <code>embed</code> and <code>embeds</code> are passed.</p> </li> <li> <code>BadRequestError</code>             \u2013            <p>This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components.</p> </li> <li> <code>UnauthorizedError</code>             \u2013            <p>If you are unauthorized to make the request (invalid/missing token).</p> </li> <li> <code>ForbiddenError</code>             \u2013            <p>If you are missing the <code>SEND_MESSAGES</code> in the channel or the person you are trying to message has the DM's disabled.</p> </li> <li> <code>NotFoundError</code>             \u2013            <p>If the channel is not found.</p> </li> <li> <code>RateLimitTooLongError</code>             \u2013            <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> </li> <li> <code>InternalServerError</code>             \u2013            <p>If an internal error occurs on Discord while handling the request.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentContext.edit_last_response","title":"edit_last_response  <code>async</code>","text":"<pre><code>edit_last_response(content=hikari.UNDEFINED, *, delete_after=None, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, mentions_everyone=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED)\n</code></pre> <p>Edit the last response for this context.</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>UndefinedOr[Any]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the content to edit the last response with.</p> <p>If this is a hikari.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> </li> <li> <code>delete_after</code>               (<code>timedelta | float | int | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, the seconds after which the response message should be deleted.</p> <p>Interaction responses can only be deleted within 15 minutes of the interaction being received.</p> </li> <li> <code>attachment</code>               (<code>UndefinedNoneOr[Resourceish]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A singular attachment to edit the last response with.</p> </li> <li> <code>attachments</code>               (<code>UndefinedNoneOr[Sequence[Resourceish]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A sequence of attachments to edit the last response with.</p> </li> <li> <code>component</code>               (<code>UndefinedNoneOr[ComponentBuilder]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, builder object of the component to set for this message. This component will replace any previously set components and passing None will remove all components.</p> </li> <li> <code>components</code>               (<code>UndefinedNoneOr[Sequence[ComponentBuilder]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing None or an empty sequence will remove all components.</p> </li> <li> <code>embed</code>               (<code>UndefinedNoneOr[Embed]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>An embed to replace the last response with.</p> </li> <li> <code>embeds</code>               (<code>UndefinedNoneOr[Sequence[Embed]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A sequence of embeds to replace the last response with.</p> </li> <li> <code>mentions_everyone</code>               (<code>UndefinedOr[bool]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, whether the message should parse @everyone/@here mentions.</p> </li> <li> <code>user_mentions</code>               (<code>SnowflakeishSequence[PartialUser] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialUser derivatives to enforce mentioning specific users.</p> </li> <li> <code>role_mentions</code>               (<code>SnowflakeishSequence[PartialRole] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialRole derivatives to enforce mentioning specific roles.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Message</code>           \u2013            <p>The message that has been edited.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If more than 100 unique objects/entities are passed for <code>role_mentions</code> or <code>user_mentions</code>.</p> <p>If <code>delete_after</code> would be more than 15 minutes after the slash interaction was received.</p> <p>If both <code>attachment</code> and <code>attachments</code> are passed or both <code>component</code> and <code>components</code> are passed or both <code>embed</code> and <code>embeds</code> are passed.</p> </li> <li> <code>BadRequestError</code>             \u2013            <p>This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components.</p> </li> <li> <code>UnauthorizedError</code>             \u2013            <p>If you are unauthorized to make the request (invalid/missing token).</p> </li> <li> <code>ForbiddenError</code>             \u2013            <p>If you are missing the <code>SEND_MESSAGES</code> in the channel or the person you are trying to message has the DM's disabled.</p> </li> <li> <code>NotFoundError</code>             \u2013            <p>If the channel is not found.</p> </li> <li> <code>RateLimitTooLongError</code>             \u2013            <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> </li> <li> <code>InternalServerError</code>             \u2013            <p>If an internal error occurs on Discord while handling the request.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentContext.fetch_initial_response","title":"fetch_initial_response  <code>async</code>","text":"<pre><code>fetch_initial_response()\n</code></pre> <p>Fetch the initial response for this context.</p> <p>Returns:</p> <ul> <li> <code>Message</code>           \u2013            <p>The initial response's message object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>(LookupError, NotFoundError)</code>             \u2013            <p>The response was not found.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentContext.fetch_last_response","title":"fetch_last_response  <code>async</code>","text":"<pre><code>fetch_last_response()\n</code></pre> <p>Fetch the last response for this context.</p> <p>Returns:</p> <ul> <li> <code>Message</code>           \u2013            <p>The most response response's message object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>(LookupError, NotFoundError)</code>             \u2013            <p>The response was not found.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentContext.respond","title":"respond  <code>async</code>","text":"<pre><code>respond(content: UndefinedOr[Any] = hikari.UNDEFINED, *, ensure_result: Literal[True], delete_after: timedelta | float | int | None = None, attachment: UndefinedOr[Resourceish] = hikari.UNDEFINED, attachments: UndefinedOr[Sequence[Resourceish]] = hikari.UNDEFINED, component: UndefinedOr[ComponentBuilder] = hikari.UNDEFINED, components: UndefinedOr[Sequence[ComponentBuilder]] = hikari.UNDEFINED, embed: UndefinedOr[Embed] = hikari.UNDEFINED, embeds: UndefinedOr[Sequence[Embed]] = hikari.UNDEFINED, mentions_everyone: UndefinedOr[bool] = hikari.UNDEFINED, user_mentions: SnowflakeishSequence[PartialUser] | bool | UndefinedType = hikari.UNDEFINED, role_mentions: SnowflakeishSequence[PartialRole] | bool | UndefinedType = hikari.UNDEFINED) -&gt; hikari.Message\n</code></pre><pre><code>respond(content: UndefinedOr[Any] = hikari.UNDEFINED, *, ensure_result: bool = False, delete_after: timedelta | float | int | None = None, attachment: UndefinedOr[Resourceish] = hikari.UNDEFINED, attachments: UndefinedOr[Sequence[Resourceish]] = hikari.UNDEFINED, component: UndefinedOr[ComponentBuilder] = hikari.UNDEFINED, components: UndefinedOr[Sequence[ComponentBuilder]] = hikari.UNDEFINED, embed: UndefinedOr[Embed] = hikari.UNDEFINED, embeds: UndefinedOr[Sequence[Embed]] = hikari.UNDEFINED, mentions_everyone: UndefinedOr[bool] = hikari.UNDEFINED, user_mentions: SnowflakeishSequence[PartialUser] | bool | UndefinedType = hikari.UNDEFINED, role_mentions: SnowflakeishSequence[PartialRole] | bool | UndefinedType = hikari.UNDEFINED) -&gt; hikari.Message | None\n</code></pre> <pre><code>respond(content=hikari.UNDEFINED, *, ensure_result=False, delete_after=None, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, mentions_everyone=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED)\n</code></pre> <p>Respond to this context.</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>UndefinedOr[Any]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message content to respond with.</p> <p>If this is a hikari.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead be treated as an embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> </li> <li> <code>ensure_result</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Ensure that this call will always return a message object.</p> <p>If True then this will always return hikari.Message, otherwise this will return <code>hikari.Message | None</code>.</p> <p>It's worth noting that this may lead to an extre request being made under certain scenarios.</p> </li> <li> <code>delete_after</code>               (<code>timedelta | float | int | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, the seconds after which the response message should be deleted.</p> <p>Interaction responses can only be deleted within 15 minutes of the interaction being received.</p> </li> <li> <code>attachment</code>               (<code>UndefinedOr[Resourceish]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.</p> </li> <li> <code>attachments</code>               (<code>UndefinedOr[Sequence[Resourceish]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.</p> </li> <li> <code>component</code>               (<code>UndefinedOr[ComponentBuilder]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, builder object of the component to include in this response.</p> </li> <li> <code>components</code>               (<code>UndefinedOr[Sequence[ComponentBuilder]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, a sequence of the component builder objects to include in this response.</p> </li> <li> <code>embed</code>               (<code>UndefinedOr[Embed]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>An embed to respond with.</p> </li> <li> <code>embeds</code>               (<code>UndefinedOr[Sequence[Embed]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A sequence of embeds to respond with.</p> </li> <li> <code>mentions_everyone</code>               (<code>UndefinedOr[bool]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, whether the message should parse @everyone/@here mentions.</p> </li> <li> <code>user_mentions</code>               (<code>SnowflakeishSequence[PartialUser] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialUser derivatives to enforce mentioning specific users.</p> </li> <li> <code>role_mentions</code>               (<code>SnowflakeishSequence[PartialRole] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialRole derivatives to enforce mentioning specific roles.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Message | None</code>           \u2013            <p>The message that has been created if it was immedieatly available or <code>ensure_result</code> was set to True, else None.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If more than 100 unique objects/entities are passed for <code>role_mentions</code> or <code>user_mentions</code>.</p> <p>If <code>delete_after</code> would be more than 15 minutes after the interaction was received.</p> <p>If both <code>attachment</code> and <code>attachments</code> are passed or both <code>component</code> and <code>components</code> are passed or both <code>embed</code> and <code>embeds</code> are passed.</p> </li> <li> <code>BadRequestError</code>             \u2013            <p>This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components.</p> </li> <li> <code>UnauthorizedError</code>             \u2013            <p>If you are unauthorized to make the request (invalid/missing token).</p> </li> <li> <code>ForbiddenError</code>             \u2013            <p>If you are missing the <code>SEND_MESSAGES</code> in the channel or the person you are trying to message has the DM's disabled.</p> </li> <li> <code>NotFoundError</code>             \u2013            <p>If the channel is not found.</p> </li> <li> <code>RateLimitTooLongError</code>             \u2013            <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> </li> <li> <code>InternalServerError</code>             \u2013            <p>If an internal error occurs on Discord while handling the request.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentContext.set_ephemeral_default","title":"set_ephemeral_default","text":"<pre><code>set_ephemeral_default(state)\n</code></pre> <p>Set the ephemeral default state for this context.</p> <p>Parameters:</p> <ul> <li> <code>state</code>               (<code>bool</code>)           \u2013            <p>The new ephemeral default state.</p> <p>If this is True then all calls to the response creating methods on this context will default to being ephemeral.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentExecutor","title":"ComponentExecutor","text":"<p>               Bases: <code>AbstractComponentExecutor</code></p> <p>implementation of a component executor with per-custom ID callbacks.</p>"},{"location":"reference/components/#yuyo.components.ComponentExecutor.callbacks","title":"callbacks  <code>property</code>","text":"<pre><code>callbacks\n</code></pre> <p>Mapping of custom IDs to their set callbacks.</p>"},{"location":"reference/components/#yuyo.components.ComponentExecutor.__init__","title":"__init__","text":"<pre><code>__init__(*, ephemeral_default=False)\n</code></pre> <p>Initialise a component executor.</p> <p>Parameters:</p> <ul> <li> <code>ephemeral_default</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this executor's responses should default to being ephemeral.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentExecutor.set_callback","title":"set_callback","text":"<pre><code>set_callback(custom_id, callback)\n</code></pre> <p>Set the callback for a custom ID.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str</code>)           \u2013            <p>The custom ID to set the callback for.</p> <p>This will be matched against <code>interaction.custom_id.split(\":\", 1)[0]</code>, allowing metadata to be stored after a <code>\":\"</code>.</p> </li> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>The callback to set.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>\":\"</code> is in the custom ID.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentExecutor.with_callback","title":"with_callback","text":"<pre><code>with_callback(custom_id)\n</code></pre> <p>Set the callback for a custom ID through a decorator callback.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str</code>)           \u2013            <p>The custom ID to set the callback for.</p> <p>This will be matched against <code>interaction.custom_id.split(\":\", 1)[0]</code>, allowing metadata to be stored after a <code>\":\"</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable[[CallbackSig], CallbackSig]</code>           \u2013            <p>Decorator callback used to set a custom ID's callback.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>\":\"</code> is in the custom ID.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentPaginator","title":"ComponentPaginator","text":"<p>               Bases: <code>ActionColumnExecutor</code></p> <p>Standard implementation of an action row executor used for pagination.</p> <p>This is a convenience class that allows you to easily implement a paginator.</p> <p>Note</p> <p>This doesn't use action column's \"static\" components so any static components added to base-classes of this will appear before the pagination components.</p>"},{"location":"reference/components/#yuyo.components.ComponentPaginator._added_static_fields","title":"_added_static_fields  <code>class-attribute</code>","text":"<pre><code>_added_static_fields = {}\n</code></pre> <p>Dict of match IDs to the static fields added to this class through add method calls.</p> <p>This doesn't include inherited fields.</p>"},{"location":"reference/components/#yuyo.components.ComponentPaginator._static_fields","title":"_static_fields  <code>class-attribute</code>","text":"<pre><code>_static_fields = {}\n</code></pre> <p>Dict of match IDs to the static fields on this class.</p> <p>This includes inherited fields and fields added through method calls.</p>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.rows","title":"rows  <code>property</code>","text":"<pre><code>rows\n</code></pre> <p>The rows in this column.</p>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.__init__","title":"__init__","text":"<pre><code>__init__(iterator, /, *, authors=None, ephemeral_default=False, triggers=(pagination.LEFT_TRIANGLE, pagination.STOP_SQUARE, pagination.RIGHT_TRIANGLE))\n</code></pre> <p>Initialise a component paginator.</p> <p>Parameters:</p> <ul> <li> <code>iterator</code>               (<code>Iterator[EntryT] | AsyncIterator[EntryT]</code>)           \u2013            <p>The iterator to paginate.</p> <p>This should be an iterator of yuyo.pagination.AbstractPages.</p> </li> <li> <code>authors</code>               (<code>Iterable[SnowflakeishOr[User]] | None</code>, default:                   <code>None</code> )           \u2013            <p>Users who are allowed to use the components this represents.</p> <p>If no users are provided then the components will be public (meaning that anybody can use it).</p> </li> <li> <code>ephemeral_default</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether or not the responses made on contexts spawned from this paginator should default to ephemeral (meaning only the author can see them) unless <code>flags</code> is specified on the response method.</p> </li> <li> <code>triggers</code>               (<code>Collection[str]</code>, default:                   <code>(LEFT_TRIANGLE, STOP_SQUARE, RIGHT_TRIANGLE)</code> )           \u2013            <p>Collection of the unicode emojis that should trigger this paginator.</p> <p>As of current the only usable emojis are yuyo.pagination.LEFT_TRIANGLE, yuyo.pagination.RIGHT_TRIANGLE, yuyo.pagination.STOP_SQUARE, yuyo.pagination.LEFT_DOUBLE_TRIANGLE and yuyo.pagination.LEFT_TRIANGLE.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.add_builder","title":"add_builder","text":"<pre><code>add_builder(builder)\n</code></pre> <p>Add a raw component builder to this action column.</p> <p>This is mostly for adding components where the custom ID is already registered as a separate constant executor.</p> <p>Parameters:</p> <ul> <li> <code>builder</code>               (<code>ComponentBuilder</code>)           \u2013            <p>The component builder to add to the column.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.add_channel_menu","title":"add_channel_menu","text":"<pre><code>add_channel_menu(callback, /, *, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a channel select menu to this action column.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>channel_types</code>               (<code>None | Sequence[ChannelType | type[PartialChannel]]</code>, default:                   <code>None</code> )           \u2013            <p>Sequence of the types of channels this select menu should show as options.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The action column to enable chained calls.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.add_first_button","title":"add_first_button","text":"<pre><code>add_first_button(*, style=hikari.ButtonStyle.SECONDARY, custom_id=None, emoji=pagination.LEFT_DOUBLE_TRIANGLE, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add the jump to first entry button to this paginator.</p> <p>You should pass <code>triggers=[]</code> to ComponentPaginator.__init__ before calling this.</p> <p>Note</p> <p>These buttons will appear in the order these methods were called in.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>, default:                   <code>SECONDARY</code> )           \u2013            <p>The button's style.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom ID to use for identifying button presses.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>LEFT_DOUBLE_TRIANGLE</code> )           \u2013            <p>Emoji to display on this button.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Label to display on this button.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to make this button as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>To enable chained calls.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.add_interactive_button","title":"add_interactive_button","text":"<pre><code>add_interactive_button(style, callback, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add an interactive button to this action column.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>)           \u2013            <p>The button's style.</p> </li> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>The button's execution callback.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The button's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's emoji.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's label.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the button should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The action column to enable chained calls.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.add_last_button","title":"add_last_button","text":"<pre><code>add_last_button(*, style=hikari.ButtonStyle.SECONDARY, custom_id=None, emoji=pagination.RIGHT_DOUBLE_TRIANGLE, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add the jump to last entry button to this paginator.</p> <p>You should pass <code>triggers=[]</code> to ComponentPaginator.__init__ before calling this.</p> <p>Note</p> <p>These buttons will appear in the order these methods were called in.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>, default:                   <code>SECONDARY</code> )           \u2013            <p>The button's style.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom ID to use for identifying button presses.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>RIGHT_DOUBLE_TRIANGLE</code> )           \u2013            <p>Emoji to display on this button.</p> <p>Either this or <code>label</code> must be provided, but not both.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Label to display on this button.</p> <p>Either this or <code>emoji</code> must be provided, but not both.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to make this button as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>To enable chained calls.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.add_link_button","title":"add_link_button","text":"<pre><code>add_link_button(url, /, *, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add a link button to this action column.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>url</code>               (<code>str</code>)           \u2013            <p>The button's url.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's emoji.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's label.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the button should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The action column to enable chained calls.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.add_mentionable_menu","title":"add_mentionable_menu","text":"<pre><code>add_mentionable_menu(callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a mentionable select menu to this action column.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The action column to enable chained calls.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.add_next_button","title":"add_next_button","text":"<pre><code>add_next_button(*, style=hikari.ButtonStyle.SECONDARY, custom_id=None, emoji=pagination.RIGHT_TRIANGLE, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add the next entry button to this paginator.</p> <p>You should pass <code>triggers=[]</code> to ComponentPaginator.__init__ before calling this.</p> <p>Note</p> <p>These buttons will appear in the order these methods were called in.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>, default:                   <code>SECONDARY</code> )           \u2013            <p>The button's style.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom ID to use for identifying button presses.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>RIGHT_TRIANGLE</code> )           \u2013            <p>Emoji to display on this button.</p> <p>Either this or <code>label</code> must be provided, but not both.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Label to display on this button.</p> <p>Either this or <code>emoji</code> must be provided, but not both.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to make this button as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>To enable chained calls.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.add_previous_button","title":"add_previous_button","text":"<pre><code>add_previous_button(*, style=hikari.ButtonStyle.SECONDARY, custom_id=None, emoji=pagination.LEFT_TRIANGLE, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add the previous entry button to this paginator.</p> <p>You should pass <code>triggers=[]</code> to ComponentPaginator.__init__ before calling this.</p> <p>Note</p> <p>These buttons will appear in the order these methods were called in.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>, default:                   <code>SECONDARY</code> )           \u2013            <p>The button's style.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom ID to use for identifying button presses.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>LEFT_TRIANGLE</code> )           \u2013            <p>Emoji to display on this button.</p> <p>Either this or <code>label</code> must be provided, but not both.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Label to display on this button.</p> <p>Either this or <code>emoji</code> must be provided, but not both.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to make this button as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>To enable chained calls.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.add_role_menu","title":"add_role_menu","text":"<pre><code>add_role_menu(callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a role select menu to this action column.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The action column to enable chained calls.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.add_select_menu","title":"add_select_menu","text":"<pre><code>add_select_menu(type_, callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a select menu to this action column.</p> <p>The following methods should be used instead:</p> <ul> <li>.add_channel_menu</li> <li>.add_mentionable_menu</li> <li>.add_role_menu</li> <li>.add_text_menu</li> <li>.add_user_menu</li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.add_static_builder","title":"add_static_builder  <code>classmethod</code>","text":"<pre><code>add_static_builder(builder)\n</code></pre> <p>Add a raw component builder to all subclasses and instances of this column.</p> <p>This is mostly for adding components where the custom ID is already registered as a separate constant executor.</p> <p>Parameters:</p> <ul> <li> <code>builder</code>               (<code>ComponentBuilder</code>)           \u2013            <p>The component builder to add to the column class.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.add_static_channel_menu","title":"add_static_channel_menu  <code>classmethod</code>","text":"<pre><code>add_static_channel_menu(callback, /, *, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a channel select menu to all subclasses and instances of this action column class.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>channel_types</code>               (<code>None | Sequence[ChannelType | type[PartialChannel]]</code>, default:                   <code>None</code> )           \u2013            <p>Sequence of the types of channels this select menu should show as options.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[Self]</code>           \u2013            <p>The action column class to enable chained calls.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.add_static_interactive_button","title":"add_static_interactive_button  <code>classmethod</code>","text":"<pre><code>add_static_interactive_button(style, callback, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add an interactive button to all subclasses and instances of this action column class.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>)           \u2013            <p>The button's style.</p> </li> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>The button's execution callback.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The button's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's emoji.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's label.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the button should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[Self]</code>           \u2013            <p>The action column class to enable chained calls.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.add_static_link_button","title":"add_static_link_button  <code>classmethod</code>","text":"<pre><code>add_static_link_button(url, /, *, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add a link button to all subclasses and instances of this action column class.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>url</code>               (<code>str</code>)           \u2013            <p>The button's url.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's emoji.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's label.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the button should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[Self]</code>           \u2013            <p>The action column class to enable chained calls.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.add_static_mentionable_menu","title":"add_static_mentionable_menu  <code>classmethod</code>","text":"<pre><code>add_static_mentionable_menu(callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a mentionable select menu to all subclasses and instances of this action column class.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[Self]</code>           \u2013            <p>The action column class to enable chained calls.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.add_static_role_menu","title":"add_static_role_menu  <code>classmethod</code>","text":"<pre><code>add_static_role_menu(callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a role select menu to all subclasses and instances of this action column class.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[Self]</code>           \u2013            <p>The action column class to enable chained calls.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.add_static_select_menu","title":"add_static_select_menu  <code>classmethod</code>","text":"<pre><code>add_static_select_menu(type_, callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a select menu to all subclasses and instances of this action column class.</p> <p>The following class methods should be used instead:</p> <ul> <li>.add_static_channel_menu</li> <li>.add_static_mentionable_menu</li> <li>.add_static_role_menu</li> <li>.add_static_text_menu</li> <li>.add_static_user_menu</li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.add_static_text_menu","title":"add_static_text_menu  <code>classmethod</code>","text":"<pre><code>add_static_text_menu(callback, /, *, custom_id=None, options=(), placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a text select menu to all subclasses and instances of this action column class.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>options</code>               (<code>Sequence[SelectOptionBuilder]</code>, default:                   <code>()</code> )           \u2013            <p>The text select's options.</p> <p>These can also be added by calling TextSelectMenuBuilder.add_option.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>TextSelectMenuBuilder</code>           \u2013            <p>Builder for the added text select menu.</p> <p>TextSelectMenuBuilder.add_option should be used to add options to this select menu.</p> <p>And the parent action column can be accessed by calling TextSelectMenuBuilder.parent.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.add_static_user_menu","title":"add_static_user_menu  <code>classmethod</code>","text":"<pre><code>add_static_user_menu(callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a user select menu to all subclasses and instances of this action column class.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[Self]</code>           \u2013            <p>The action column class to enable chained calls.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.add_stop_button","title":"add_stop_button","text":"<pre><code>add_stop_button(*, style=hikari.ButtonStyle.DANGER, custom_id=None, emoji=pagination.BLACK_CROSS, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add the stop button to this paginator.</p> <p>You should pass <code>triggers=[]</code> to ComponentPaginator.__init__ before calling this.</p> <p>Note</p> <p>These buttons will appear in the order these methods were called in.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>, default:                   <code>DANGER</code> )           \u2013            <p>The button's style.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom ID to use for identifying button presses.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>BLACK_CROSS</code> )           \u2013            <p>Emoji to display on this button.</p> <p>Either this or <code>label</code> must be provided, but not both.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Label to display on this button.</p> <p>Either this or <code>emoji</code> must be provided, but not both.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to make this button as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>To enable chained calls.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.add_text_menu","title":"add_text_menu","text":"<pre><code>add_text_menu(callback, /, *, custom_id=None, options=(), placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a text select menu to this action column.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>options</code>               (<code>Sequence[SelectOptionBuilder]</code>, default:                   <code>()</code> )           \u2013            <p>The text select's options.</p> <p>These can also be added by calling TextSelectMenuBuilder.add_option.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>TextSelectMenuBuilder</code>           \u2013            <p>Builder for the added text select menu.</p> <p>TextSelectMenuBuilder.add_option should be used to add options to this select menu.</p> <p>And the parent action column can be accessed by calling TextSelectMenuBuilder.parent.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.add_user_menu","title":"add_user_menu","text":"<pre><code>add_user_menu(callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a user select menu to this action column.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The action column to enable chained calls.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.get_next_entry","title":"get_next_entry  <code>async</code>","text":"<pre><code>get_next_entry()\n</code></pre> <p>Get the next entry in this paginator.</p> <p>This is generally helpful for making the message which the paginator will be based off and will still internally store the entry and increment the position of the paginator.</p> <p>Examples:</p> <pre><code>paginator = yuyo.ComponentPaginator(pages, authors=[ctx.author.id])\nfirst_response = await paginator.get_next_entry()\nassert first_response\nmessage = await ctx.respond(components=paginator.rows, **first_response.to_kwargs(), ensure_result=True)\ncomponent_client.register_executor(paginator, message=message)\n</code></pre> <p>Returns:</p> <ul> <li> <code>AbstractPage | None</code>           \u2013            <p>The next entry in this paginator, or None if there are no more entries.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.with_channel_menu","title":"with_channel_menu","text":"<pre><code>with_channel_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_channel_menu(*, custom_id: str | None = None, channel_types: None | Sequence[ChannelType | type[PartialChannel]] = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_channel_menu(callback=None, /, *, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a channel select menu to this action column through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>channel_types</code>               (<code>None | Sequence[ChannelType | type[PartialChannel]]</code>, default:                   <code>None</code> )           \u2013            <p>Sequence of the types of channels this select menu should show as options.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.with_interactive_button","title":"with_interactive_button","text":"<pre><code>with_interactive_button(style, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add an interactive button to this action column through a decorator call.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>)           \u2013            <p>The button's style.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The button's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's emoji.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's label.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the button should be marked as disabled.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.with_mentionable_menu","title":"with_mentionable_menu","text":"<pre><code>with_mentionable_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_mentionable_menu(*, custom_id: str | None = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_mentionable_menu(callback=None, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a mentionable select menu to this action column through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.with_role_menu","title":"with_role_menu","text":"<pre><code>with_role_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_role_menu(*, custom_id: str | None = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_role_menu(callback=None, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a role select menu to this action column through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.with_static_channel_menu","title":"with_static_channel_menu  <code>classmethod</code>","text":"<pre><code>with_static_channel_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_static_channel_menu(*, custom_id: str | None = None, channel_types: None | Sequence[ChannelType | type[PartialChannel]] = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_static_channel_menu(callback=None, /, *, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a channel select menu to this action column class through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>channel_types</code>               (<code>None | Sequence[ChannelType | type[PartialChannel]]</code>, default:                   <code>None</code> )           \u2013            <p>Sequence of the types of channels this select menu should show as options.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.with_static_interactive_button","title":"with_static_interactive_button  <code>classmethod</code>","text":"<pre><code>with_static_interactive_button(style, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add a static interactive button to this action column class through a decorator call.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>)           \u2013            <p>The button's style.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The button's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's emoji.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's label.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the button should be marked as disabled.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.with_static_mentionable_menu","title":"with_static_mentionable_menu  <code>classmethod</code>","text":"<pre><code>with_static_mentionable_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_static_mentionable_menu(*, custom_id: str | None = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_static_mentionable_menu(callback=None, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a static mentionable select menu to this action column class through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.with_static_role_menu","title":"with_static_role_menu  <code>classmethod</code>","text":"<pre><code>with_static_role_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_static_role_menu(*, custom_id: str | None = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_static_role_menu(callback=None, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a static role select menu to this action column class through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.with_static_text_menu","title":"with_static_text_menu  <code>classmethod</code>","text":"<pre><code>with_static_text_menu(callback: Callable[_P, _CoroT]) -&gt; _WrappedTextMenuBuilder[_P]\n</code></pre><pre><code>with_static_text_menu(*, custom_id: str | None = None, options: Sequence[SelectOptionBuilder] = (), placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[collections.Callable[_P, _CoroT]], _WrappedTextMenuBuilder[_P]]\n</code></pre> <pre><code>with_static_text_menu(callback=None, /, *, custom_id=None, options=(), placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a text select menu to this action column class through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>options</code>               (<code>Sequence[SelectOptionBuilder]</code>, default:                   <code>()</code> )           \u2013            <p>The text select's options.</p> <p>These can also be added using [yuyo.components.with_option].</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.with_static_user_menu","title":"with_static_user_menu  <code>classmethod</code>","text":"<pre><code>with_static_user_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_static_user_menu(*, custom_id: str | None = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_static_user_menu(callback=None, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a static user select menu to this action column class through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.with_text_menu","title":"with_text_menu","text":"<pre><code>with_text_menu(callback: Callable[_P, _CoroT]) -&gt; _WrappedTextMenuBuilder[_P]\n</code></pre><pre><code>with_text_menu(*, custom_id: str | None = None, options: Sequence[SelectOptionBuilder] = (), placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[collections.Callable[_P, _CoroT]], _WrappedTextMenuBuilder[_P]]\n</code></pre> <pre><code>with_text_menu(callback=None, /, *, custom_id=None, options=(), placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a text select menu to this action column through a decorator callback.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>options</code>               (<code>Sequence[SelectOptionBuilder]</code>, default:                   <code>()</code> )           \u2013            <p>The text select's options.</p> <p>These can also be added using components.with_option.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ComponentPaginator.with_user_menu","title":"with_user_menu","text":"<pre><code>with_user_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_user_menu(*, custom_id: str | None = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_user_menu(callback=None, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a user select menu to this action column through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.ExecutorClosed","title":"ExecutorClosed","text":"<p>               Bases: <code>Exception</code></p> <p>Error used to indicate that an executor is now closed during execution.</p>"},{"location":"reference/components/#yuyo.components.ExecutorClosed.__init__","title":"__init__","text":"<pre><code>__init__(*, already_closed=True)\n</code></pre> <p>Initialise an executor closed error.</p> <p>Parameters:</p> <ul> <li> <code>already_closed</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether this error is a result of the executor having been in a closed state when it was called.</p> <p>If so then this will lead to a \"timed-out\" message being sent as the initial response.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.SingleExecutor","title":"SingleExecutor","text":"<p>               Bases: <code>AbstractComponentExecutor</code></p> <p>Component executor with a single callback.</p>"},{"location":"reference/components/#yuyo.components.SingleExecutor.__init__","title":"__init__","text":"<pre><code>__init__(custom_id, callback, /, *, ephemeral_default=False)\n</code></pre> <p>Initialise an executor with a single callback.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str</code>)           \u2013            <p>The custom ID this executor is triggered for.</p> <p>This will be matched against <code>interaction.custom_id.split(\":\", 1)[0]</code>, allowing metadata to be stored after a <code>\":\"</code>.</p> </li> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>The executor's  callback.</p> </li> <li> <code>ephemeral_default</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this executor's responses should default to being ephemeral.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>\":\"</code> is in the custom ID.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticComponentPaginator","title":"StaticComponentPaginator","text":"<p>               Bases: <code>ActionColumnExecutor</code></p> <p>Implementation of components for paginating static data.</p> <p>This enables paginated responses to be persisted between bot restarts.</p>"},{"location":"reference/components/#yuyo.components.StaticComponentPaginator._added_static_fields","title":"_added_static_fields  <code>class-attribute</code>","text":"<pre><code>_added_static_fields = {}\n</code></pre> <p>Dict of match IDs to the static fields added to this class through add method calls.</p> <p>This doesn't include inherited fields.</p>"},{"location":"reference/components/#yuyo.components.StaticComponentPaginator._static_fields","title":"_static_fields  <code>class-attribute</code>","text":"<pre><code>_static_fields = {}\n</code></pre> <p>Dict of match IDs to the static fields on this class.</p> <p>This includes inherited fields and fields added through method calls.</p>"},{"location":"reference/components/#yuyo.components.StaticComponentPaginator.rows","title":"rows  <code>property</code>","text":"<pre><code>rows\n</code></pre> <p>The rows in this column.</p>"},{"location":"reference/components/#yuyo.components.StaticComponentPaginator.__init__","title":"__init__","text":"<pre><code>__init__(paginator_id, page_number, /, *, content_hash=None, ephemeral_default=False, include_buttons=True, id_metadata=None)\n</code></pre> <p>Initialise a static component paginator.</p> <p>Parameters:</p> <ul> <li> <code>paginator_id</code>               (<code>str</code>)           \u2013            <p>ID of the paginator this targets.</p> <p>This is ignored when this is used to execute interactions.</p> </li> <li> <code>page_number</code>               (<code>int</code>)           \u2013            <p>Index of the current page this paginator is on.</p> <p>This is ignored when this is used to execute interactions.</p> </li> <li> <code>content_hash</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Hash used to validate that the received interaction's components are still in-sync with the static data stored in this paginator.</p> </li> <li> <code>ephemeral_default</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this executor's responses should default to being ephemeral.</p> </li> <li> <code>include_buttons</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to include the default buttons.</p> </li> <li> <code>id_metadata</code>               (<code>Mapping[str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Mapping of metadata to append to the custom IDs in this column.</p> <p>This does not effect the standard buttons.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticComponentPaginator.add_builder","title":"add_builder","text":"<pre><code>add_builder(builder)\n</code></pre> <p>Add a raw component builder to this action column.</p> <p>This is mostly for adding components where the custom ID is already registered as a separate constant executor.</p> <p>Parameters:</p> <ul> <li> <code>builder</code>               (<code>ComponentBuilder</code>)           \u2013            <p>The component builder to add to the column.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticComponentPaginator.add_channel_menu","title":"add_channel_menu","text":"<pre><code>add_channel_menu(callback, /, *, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a channel select menu to this action column.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>channel_types</code>               (<code>None | Sequence[ChannelType | type[PartialChannel]]</code>, default:                   <code>None</code> )           \u2013            <p>Sequence of the types of channels this select menu should show as options.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The action column to enable chained calls.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticComponentPaginator.add_first_button","title":"add_first_button","text":"<pre><code>add_first_button(*, style=hikari.ButtonStyle.SECONDARY, custom_id=_StaticPaginatorId.FIRST, emoji=pagination.LEFT_DOUBLE_TRIANGLE, id_metadata=None, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add the jump to first entry button to this paginator.</p> <p>You should pass <code>include_buttons=False</code> to StaticComponentPaginator.__init__ before calling this.</p> <p>Note</p> <p>These buttons will appear in the order these methods were called in.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>, default:                   <code>SECONDARY</code> )           \u2013            <p>The button's style.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>LEFT_DOUBLE_TRIANGLE</code> )           \u2013            <p>Emoji to display on this button.</p> </li> <li> <code>id_metadata</code>               (<code>Mapping[str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Mapping of keys to the values of extra metadata to include in this button's custom ID.</p> <p>This will be encoded as a url query string.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Label to display on this button.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to make this button as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>To enable chained calls.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticComponentPaginator.add_interactive_button","title":"add_interactive_button","text":"<pre><code>add_interactive_button(style, callback, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add an interactive button to this action column.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>)           \u2013            <p>The button's style.</p> </li> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>The button's execution callback.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The button's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's emoji.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's label.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the button should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The action column to enable chained calls.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticComponentPaginator.add_last_button","title":"add_last_button","text":"<pre><code>add_last_button(*, style=hikari.ButtonStyle.SECONDARY, custom_id=_StaticPaginatorId.LAST, emoji=pagination.RIGHT_DOUBLE_TRIANGLE, id_metadata=None, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add the jump to last entry button to this paginator.</p> <p>You should pass <code>include_buttons=False</code> to StaticComponentPaginator.__init__ before calling this.</p> <p>Note</p> <p>These buttons will appear in the order these methods were called in.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>, default:                   <code>SECONDARY</code> )           \u2013            <p>The button's style.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>RIGHT_DOUBLE_TRIANGLE</code> )           \u2013            <p>Emoji to display on this button.</p> <p>Either this or <code>label</code> must be provided, but not both.</p> </li> <li> <code>id_metadata</code>               (<code>Mapping[str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Mapping of keys to the values of extra metadata to include in this button's custom ID.</p> <p>This will be encoded as a url query string.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Label to display on this button.</p> <p>Either this or <code>emoji</code> must be provided, but not both.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to make this button as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>To enable chained calls.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticComponentPaginator.add_link_button","title":"add_link_button","text":"<pre><code>add_link_button(url, /, *, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add a link button to this action column.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>url</code>               (<code>str</code>)           \u2013            <p>The button's url.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's emoji.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's label.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the button should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The action column to enable chained calls.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticComponentPaginator.add_mentionable_menu","title":"add_mentionable_menu","text":"<pre><code>add_mentionable_menu(callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a mentionable select menu to this action column.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The action column to enable chained calls.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticComponentPaginator.add_next_button","title":"add_next_button","text":"<pre><code>add_next_button(*, style=hikari.ButtonStyle.SECONDARY, custom_id=_StaticPaginatorId.NEXT, emoji=pagination.RIGHT_TRIANGLE, id_metadata=None, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add the next entry button to this paginator.</p> <p>You should pass <code>include_buttons=False</code> to StaticComponentPaginator.__init__ before calling this.</p> <p>Note</p> <p>These buttons will appear in the order these methods were called in.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>, default:                   <code>SECONDARY</code> )           \u2013            <p>The button's style.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>RIGHT_TRIANGLE</code> )           \u2013            <p>Emoji to display on this button.</p> <p>Either this or <code>label</code> must be provided, but not both.</p> </li> <li> <code>id_metadata</code>               (<code>Mapping[str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Mapping of keys to the values of extra metadata to include in this button's custom ID.</p> <p>This will be encoded as a url query string.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Label to display on this button.</p> <p>Either this or <code>emoji</code> must be provided, but not both.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to make this button as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>To enable chained calls.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticComponentPaginator.add_previous_button","title":"add_previous_button","text":"<pre><code>add_previous_button(*, style=hikari.ButtonStyle.SECONDARY, custom_id=_StaticPaginatorId.PREVIOUS, emoji=pagination.LEFT_TRIANGLE, id_metadata=None, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add the previous entry button to this paginator.</p> <p>You should pass <code>include_buttons=False</code> to StaticComponentPaginator.__init__ before calling this.</p> <p>Note</p> <p>These buttons will appear in the order these methods were called in.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>, default:                   <code>SECONDARY</code> )           \u2013            <p>The button's style.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>LEFT_TRIANGLE</code> )           \u2013            <p>Emoji to display on this button.</p> <p>Either this or <code>label</code> must be provided, but not both.</p> </li> <li> <code>id_metadata</code>               (<code>Mapping[str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Mapping of keys to the values of extra metadata to include in this button's custom ID.</p> <p>This will be encoded as a url query string.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Label to display on this button.</p> <p>Either this or <code>emoji</code> must be provided, but not both.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to make this button as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>To enable chained calls.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticComponentPaginator.add_role_menu","title":"add_role_menu","text":"<pre><code>add_role_menu(callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a role select menu to this action column.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The action column to enable chained calls.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticComponentPaginator.add_select_button","title":"add_select_button","text":"<pre><code>add_select_button(*, style=hikari.ButtonStyle.DANGER, custom_id=_StaticPaginatorId.SELECT, emoji=pagination.SELECT_PAGE_SYMBOL, id_metadata=None, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add the select page button to this paginator.</p> <p>You should pass <code>include_buttons=False</code> to StaticComponentPaginator.__init__ before calling this.</p> <p>Note</p> <p>These buttons will appear in the order these methods were called in.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>, default:                   <code>DANGER</code> )           \u2013            <p>The button's style.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>SELECT_PAGE_SYMBOL</code> )           \u2013            <p>Emoji to display on this button.</p> <p>Either this or <code>label</code> must be provided, but not both.</p> </li> <li> <code>id_metadata</code>               (<code>Mapping[str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Mapping of keys to the values of extra metadata to include in this button's custom ID.</p> <p>This will be encoded as a url query string.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Label to display on this button.</p> <p>Either this or <code>emoji</code> must be provided, but not both.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to make this button as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>To enable chained calls.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticComponentPaginator.add_select_menu","title":"add_select_menu","text":"<pre><code>add_select_menu(type_, callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a select menu to this action column.</p> <p>The following methods should be used instead:</p> <ul> <li>.add_channel_menu</li> <li>.add_mentionable_menu</li> <li>.add_role_menu</li> <li>.add_text_menu</li> <li>.add_user_menu</li> </ul>"},{"location":"reference/components/#yuyo.components.StaticComponentPaginator.add_static_builder","title":"add_static_builder  <code>classmethod</code>","text":"<pre><code>add_static_builder(builder)\n</code></pre> <p>Add a raw component builder to all subclasses and instances of this column.</p> <p>This is mostly for adding components where the custom ID is already registered as a separate constant executor.</p> <p>Parameters:</p> <ul> <li> <code>builder</code>               (<code>ComponentBuilder</code>)           \u2013            <p>The component builder to add to the column class.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticComponentPaginator.add_static_channel_menu","title":"add_static_channel_menu  <code>classmethod</code>","text":"<pre><code>add_static_channel_menu(callback, /, *, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a channel select menu to all subclasses and instances of this action column class.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>channel_types</code>               (<code>None | Sequence[ChannelType | type[PartialChannel]]</code>, default:                   <code>None</code> )           \u2013            <p>Sequence of the types of channels this select menu should show as options.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[Self]</code>           \u2013            <p>The action column class to enable chained calls.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticComponentPaginator.add_static_interactive_button","title":"add_static_interactive_button  <code>classmethod</code>","text":"<pre><code>add_static_interactive_button(style, callback, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add an interactive button to all subclasses and instances of this action column class.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>)           \u2013            <p>The button's style.</p> </li> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>The button's execution callback.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The button's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's emoji.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's label.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the button should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[Self]</code>           \u2013            <p>The action column class to enable chained calls.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticComponentPaginator.add_static_link_button","title":"add_static_link_button  <code>classmethod</code>","text":"<pre><code>add_static_link_button(url, /, *, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add a link button to all subclasses and instances of this action column class.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>url</code>               (<code>str</code>)           \u2013            <p>The button's url.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's emoji.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's label.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the button should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[Self]</code>           \u2013            <p>The action column class to enable chained calls.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticComponentPaginator.add_static_mentionable_menu","title":"add_static_mentionable_menu  <code>classmethod</code>","text":"<pre><code>add_static_mentionable_menu(callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a mentionable select menu to all subclasses and instances of this action column class.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[Self]</code>           \u2013            <p>The action column class to enable chained calls.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticComponentPaginator.add_static_role_menu","title":"add_static_role_menu  <code>classmethod</code>","text":"<pre><code>add_static_role_menu(callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a role select menu to all subclasses and instances of this action column class.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[Self]</code>           \u2013            <p>The action column class to enable chained calls.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticComponentPaginator.add_static_select_menu","title":"add_static_select_menu  <code>classmethod</code>","text":"<pre><code>add_static_select_menu(type_, callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a select menu to all subclasses and instances of this action column class.</p> <p>The following class methods should be used instead:</p> <ul> <li>.add_static_channel_menu</li> <li>.add_static_mentionable_menu</li> <li>.add_static_role_menu</li> <li>.add_static_text_menu</li> <li>.add_static_user_menu</li> </ul>"},{"location":"reference/components/#yuyo.components.StaticComponentPaginator.add_static_text_menu","title":"add_static_text_menu  <code>classmethod</code>","text":"<pre><code>add_static_text_menu(callback, /, *, custom_id=None, options=(), placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a text select menu to all subclasses and instances of this action column class.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>options</code>               (<code>Sequence[SelectOptionBuilder]</code>, default:                   <code>()</code> )           \u2013            <p>The text select's options.</p> <p>These can also be added by calling TextSelectMenuBuilder.add_option.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>TextSelectMenuBuilder</code>           \u2013            <p>Builder for the added text select menu.</p> <p>TextSelectMenuBuilder.add_option should be used to add options to this select menu.</p> <p>And the parent action column can be accessed by calling TextSelectMenuBuilder.parent.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticComponentPaginator.add_static_user_menu","title":"add_static_user_menu  <code>classmethod</code>","text":"<pre><code>add_static_user_menu(callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a user select menu to all subclasses and instances of this action column class.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[Self]</code>           \u2013            <p>The action column class to enable chained calls.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticComponentPaginator.add_text_menu","title":"add_text_menu","text":"<pre><code>add_text_menu(callback, /, *, custom_id=None, options=(), placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a text select menu to this action column.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>options</code>               (<code>Sequence[SelectOptionBuilder]</code>, default:                   <code>()</code> )           \u2013            <p>The text select's options.</p> <p>These can also be added by calling TextSelectMenuBuilder.add_option.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>TextSelectMenuBuilder</code>           \u2013            <p>Builder for the added text select menu.</p> <p>TextSelectMenuBuilder.add_option should be used to add options to this select menu.</p> <p>And the parent action column can be accessed by calling TextSelectMenuBuilder.parent.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticComponentPaginator.add_user_menu","title":"add_user_menu","text":"<pre><code>add_user_menu(callback, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a user select menu to this action column.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>Callback which is called when this select menu is used.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The action column to enable chained calls.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticComponentPaginator.with_channel_menu","title":"with_channel_menu","text":"<pre><code>with_channel_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_channel_menu(*, custom_id: str | None = None, channel_types: None | Sequence[ChannelType | type[PartialChannel]] = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_channel_menu(callback=None, /, *, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a channel select menu to this action column through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>channel_types</code>               (<code>None | Sequence[ChannelType | type[PartialChannel]]</code>, default:                   <code>None</code> )           \u2013            <p>Sequence of the types of channels this select menu should show as options.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticComponentPaginator.with_interactive_button","title":"with_interactive_button","text":"<pre><code>with_interactive_button(style, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add an interactive button to this action column through a decorator call.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>)           \u2013            <p>The button's style.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The button's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's emoji.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's label.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the button should be marked as disabled.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticComponentPaginator.with_mentionable_menu","title":"with_mentionable_menu","text":"<pre><code>with_mentionable_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_mentionable_menu(*, custom_id: str | None = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_mentionable_menu(callback=None, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a mentionable select menu to this action column through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticComponentPaginator.with_role_menu","title":"with_role_menu","text":"<pre><code>with_role_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_role_menu(*, custom_id: str | None = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_role_menu(callback=None, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a role select menu to this action column through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticComponentPaginator.with_static_channel_menu","title":"with_static_channel_menu  <code>classmethod</code>","text":"<pre><code>with_static_channel_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_static_channel_menu(*, custom_id: str | None = None, channel_types: None | Sequence[ChannelType | type[PartialChannel]] = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_static_channel_menu(callback=None, /, *, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a channel select menu to this action column class through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>channel_types</code>               (<code>None | Sequence[ChannelType | type[PartialChannel]]</code>, default:                   <code>None</code> )           \u2013            <p>Sequence of the types of channels this select menu should show as options.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticComponentPaginator.with_static_interactive_button","title":"with_static_interactive_button  <code>classmethod</code>","text":"<pre><code>with_static_interactive_button(style, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Add a static interactive button to this action column class through a decorator call.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>)           \u2013            <p>The button's style.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The button's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's emoji.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's label.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the button should be marked as disabled.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticComponentPaginator.with_static_mentionable_menu","title":"with_static_mentionable_menu  <code>classmethod</code>","text":"<pre><code>with_static_mentionable_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_static_mentionable_menu(*, custom_id: str | None = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_static_mentionable_menu(callback=None, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a static mentionable select menu to this action column class through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticComponentPaginator.with_static_role_menu","title":"with_static_role_menu  <code>classmethod</code>","text":"<pre><code>with_static_role_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_static_role_menu(*, custom_id: str | None = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_static_role_menu(callback=None, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a static role select menu to this action column class through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticComponentPaginator.with_static_text_menu","title":"with_static_text_menu  <code>classmethod</code>","text":"<pre><code>with_static_text_menu(callback: Callable[_P, _CoroT]) -&gt; _WrappedTextMenuBuilder[_P]\n</code></pre><pre><code>with_static_text_menu(*, custom_id: str | None = None, options: Sequence[SelectOptionBuilder] = (), placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[collections.Callable[_P, _CoroT]], _WrappedTextMenuBuilder[_P]]\n</code></pre> <pre><code>with_static_text_menu(callback=None, /, *, custom_id=None, options=(), placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a text select menu to this action column class through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>options</code>               (<code>Sequence[SelectOptionBuilder]</code>, default:                   <code>()</code> )           \u2013            <p>The text select's options.</p> <p>These can also be added using [yuyo.components.with_option].</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticComponentPaginator.with_static_user_menu","title":"with_static_user_menu  <code>classmethod</code>","text":"<pre><code>with_static_user_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_static_user_menu(*, custom_id: str | None = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_static_user_menu(callback=None, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a static user select menu to this action column class through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on ActionColumnExecutor (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticComponentPaginator.with_text_menu","title":"with_text_menu","text":"<pre><code>with_text_menu(callback: Callable[_P, _CoroT]) -&gt; _WrappedTextMenuBuilder[_P]\n</code></pre><pre><code>with_text_menu(*, custom_id: str | None = None, options: Sequence[SelectOptionBuilder] = (), placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[collections.Callable[_P, _CoroT]], _WrappedTextMenuBuilder[_P]]\n</code></pre> <pre><code>with_text_menu(callback=None, /, *, custom_id=None, options=(), placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a text select menu to this action column through a decorator callback.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>options</code>               (<code>Sequence[SelectOptionBuilder]</code>, default:                   <code>()</code> )           \u2013            <p>The text select's options.</p> <p>These can also be added using components.with_option.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticComponentPaginator.with_user_menu","title":"with_user_menu","text":"<pre><code>with_user_menu(callback: _CallbackSigT) -&gt; _CallbackSigT\n</code></pre><pre><code>with_user_menu(*, custom_id: str | None = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[_CallbackSigT], _CallbackSigT]\n</code></pre> <pre><code>with_user_menu(callback=None, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Add a user select menu to this action column through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticPaginatorData","title":"StaticPaginatorData","text":"<p>Represents a static paginator's data.</p>"},{"location":"reference/components/#yuyo.components.StaticPaginatorData.content_hash","title":"content_hash  <code>property</code>","text":"<pre><code>content_hash\n</code></pre> <p>Optional hash used to verify data sync.</p>"},{"location":"reference/components/#yuyo.components.StaticPaginatorData.pages","title":"pages  <code>property</code>","text":"<pre><code>pages\n</code></pre> <p>The paginator's pages.</p>"},{"location":"reference/components/#yuyo.components.StaticPaginatorData.__init__","title":"__init__","text":"<pre><code>__init__(paginator_id, pages, /, *, content_hash, make_components=lambda paginator_id, page_number, content_hash: StaticComponentPaginator(paginator_id, page_number, content_hash=content_hash))\n</code></pre> <p>Initialise a static paginator.</p> <p>Parameters:</p> <ul> <li> <code>pages</code>               (<code>Sequence[AbstractPage]</code>)           \u2013            <p>Sequence of the static paginator's pages.</p> </li> <li> <code>content_hash</code>               (<code>str | None</code>)           \u2013            <p>Optional hash used to verify data sync.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticPaginatorData.get_page","title":"get_page","text":"<pre><code>get_page(page_number)\n</code></pre> <p>Get a page from the paginator.</p> <p>Parameters:</p> <ul> <li> <code>page_number</code>               (<code>int</code>)           \u2013            <p>The zero-indexed page index.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AbstractPage | None</code>           \u2013            <p>The found page or None if out of bounds.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticPaginatorData.make_components","title":"make_components","text":"<pre><code>make_components(page_number)\n</code></pre> <p>Make the base message components used to start a paginted message.</p> <p>Parameters:</p> <ul> <li> <code>page_number</code>               (<code>int</code>)           \u2013            <p>Index of the starting page.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ActionColumnExecutor</code>           \u2013            <p>The created acion column execugtor.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>If paginator_id isn't found.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticPaginatorIndex","title":"StaticPaginatorIndex","text":"<p>Index of all the static paginators within a bot.</p>"},{"location":"reference/components/#yuyo.components.StaticPaginatorIndex.not_found_response","title":"not_found_response  <code>property</code>","text":"<pre><code>not_found_response\n</code></pre> <p>Response that's sent by the default implementation when a paginator ID isn't found.</p>"},{"location":"reference/components/#yuyo.components.StaticPaginatorIndex.out_of_date_response","title":"out_of_date_response  <code>property</code>","text":"<pre><code>out_of_date_response\n</code></pre> <p>Response that's sent by the default implementation when content hashes don't match.</p>"},{"location":"reference/components/#yuyo.components.StaticPaginatorIndex.__init__","title":"__init__","text":"<pre><code>__init__(*, make_components=lambda paginator_id, page_number, content_hash: StaticComponentPaginator(paginator_id, page_number, content_hash=content_hash), make_modal=static_paginator_model, modal_title='Select page', not_found_response=None, out_of_date_response=None)\n</code></pre> <p>Initialise a static paginator index.</p> <p>Parameters:</p> <ul> <li> <code>make_components</code>               (<code>Callable[[str, int, str | None], ActionColumnExecutor]</code>, default:                   <code>lambda paginator_id, page_number, content_hash: StaticComponentPaginator(paginator_id, page_number, content_hash=content_hash)</code> )           \u2013            <p>Callback that's used to make the default pagination message components.</p> </li> <li> <code>make_modal</code>               (<code>Callable[[], Modal]</code>, default:                   <code>static_paginator_model</code> )           \u2013            <p>Callback that's used to make a modal that handles the select page button.</p> </li> <li> <code>modal_title</code>               (<code>MaybeLocalsiedType[str]</code>, default:                   <code>'Select page'</code> )           \u2013            <p>Title of the modal that's sent when the select page button is pressed.</p> </li> <li> <code>not_found_response</code>               (<code>AbstractPage | None</code>, default:                   <code>None</code> )           \u2013            <p>The response to send when a paginator ID isn't found.</p> </li> <li> <code>out_of_date_response</code>               (<code>AbstractPage | None</code>, default:                   <code>None</code> )           \u2013            <p>The response to send when the content hashes don't match.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticPaginatorIndex.add_to_clients","title":"add_to_clients","text":"<pre><code>add_to_clients(component_client, modal_client)\n</code></pre> <p>Add this index to the component and modal clients to enable operation.</p> <p>Parameters:</p> <ul> <li> <code>component_client</code>               (<code>ComponentClient</code>)           \u2013            <p>The component client to add this to.</p> </li> <li> <code>modal_client</code>               (<code>ModalClient</code>)           \u2013            <p>The modal client to add this to.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticPaginatorIndex.callback","title":"callback  <code>async</code>","text":"<pre><code>callback(ctx, page_number)\n</code></pre> <p>Execute a static paginator interaction.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>BaseContext[ComponentInteraction] | BaseContext[ModalInteraction]</code>)           \u2013            <p>The context of the component or modal interaction being executed.</p> </li> <li> <code>page_number</code>               (<code>int</code>)           \u2013            <p>The paginator instance's current page.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticPaginatorIndex.create_select_modal","title":"create_select_modal  <code>async</code>","text":"<pre><code>create_select_modal(ctx)\n</code></pre> <p>Create the standard modal used to handle the select page button.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>ComponentContext</code>)           \u2013            <p>The component context this modal is being made for.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticPaginatorIndex.get_paginator","title":"get_paginator","text":"<pre><code>get_paginator(paginator_id)\n</code></pre> <p>Get a paginator.</p> <p>Parameters:</p> <ul> <li> <code>paginator_id</code>               (<code>str</code>)           \u2013            <p>ID of the paginator to get.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>StaticPaginatorData</code>           \u2013            <p>The found static paginator.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>If no paginator was found.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticPaginatorIndex.remove_paginator","title":"remove_paginator","text":"<pre><code>remove_paginator(paginator_id)\n</code></pre> <p>Remove a static paginator.</p> <p>Parameters:</p> <ul> <li> <code>paginator_id</code>               (<code>str</code>)           \u2013            <p>ID of the paginator to remove.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>If no paginator was found.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StaticPaginatorIndex.set_paginator","title":"set_paginator","text":"<pre><code>set_paginator(paginator_id, pages, /, *, content_hash=None)\n</code></pre> <p>Set the static paginator for a custom ID.</p> <p>Parameters:</p> <ul> <li> <code>paginator_id</code>               (<code>str</code>)           \u2013            <p>ID that's used to identify this paginator.</p> </li> <li> <code>pages</code>               (<code>Sequence[AbstractPage]</code>)           \u2013            <p>Sequence of the paginator's built pages.</p> </li> <li> <code>content_hash</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Content hash that's used to optionally ensure instances of the of the paginator's components are compatible with the bot's stored data.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>paginator_id</code> is already set.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.StreamExecutor","title":"StreamExecutor","text":"<p>               Bases: <code>AbstractComponentExecutor</code>, <code>AbstractTimeout</code></p> <p>Stream over the received component interactions.</p> <p>This should also be passed for <code>timeout=</code> and will reject contexts until it's opened.</p> <p>Examples:</p> <pre><code>message = await ctx.respond(\"hi, pick an option\", components=[...])\nstream = yuyo.components.Stream(authors=[ctx.author.id], timeout=datetime.timedelta(seconds=30))\ncomponent_client.register_executor(stream, message=message, timeout=stream)\n\nwith stream:\n    async for result in stream:\n        await result.respond(\"...\")\n</code></pre>"},{"location":"reference/components/#yuyo.components.StreamExecutor.__init__","title":"__init__","text":"<pre><code>__init__(*, authors, custom_ids=(), ephemeral_default=False, max_backlog=5, timeout)\n</code></pre> <p>Initialise a stream executor.</p> <p>Parameters:</p> <ul> <li> <code>authors</code>               (<code>Iterable[SnowflakeishOr[User]] | None</code>)           \u2013            <p>Users who are allowed to use the components this represents.</p> <p>If None is passed here then the paginator will be public (meaning that anybody can use it).</p> </li> <li> <code>custom_ids</code>               (<code>Collection[str]</code>, default:                   <code>()</code> )           \u2013            <p>Collection of the custom IDs this executor should be triggered by when registered globally.</p> </li> <li> <code>ephemeral_default</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether or not the responses made on contexts spawned from this paginator should default to ephemeral (meaning only the author can see them) unless <code>flags</code> is specified on the response method.</p> </li> <li> <code>max_backlog</code>               (<code>int</code>, default:                   <code>5</code> )           \u2013            <p>The maximum amount of interaction contexts this should store in its backlog.</p> <p>Any extra interactions will be rejected while the backlog is full.</p> </li> <li> <code>timeout</code>               (<code>float | int | timedelta | None</code>)           \u2013            <p>How long this should wait between iterations for a matching interaction to be recveived before ending the iteration.</p> <p>This alone does not close the stream.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.WaitForExecutor","title":"WaitForExecutor","text":"<p>               Bases: <code>AbstractComponentExecutor</code>, <code>AbstractTimeout</code></p> <p>Component executor used to wait for a single component interaction.</p> <p>This should also be passed for <code>timeout=</code>.</p> <p>Examples:</p> <pre><code>message = await ctx.respond(\"hi, pick an option\", components=[...], ensure_result=True)\n\nexecutor = yuyo.components.WaitFor(authors=[ctx.author.id], timeout=datetime.timedelta(seconds=30))\ncomponent_client.register_executor(executor, message=message, timeout=executor)\n\ntry:\n    result = await executor.wait_for()\nexcept asyncio.TimeoutError:\n    await ctx.respond(\"timed out\")\nelse:\n    await result.respond(\"...\")\n</code></pre>"},{"location":"reference/components/#yuyo.components.WaitForExecutor.__init__","title":"__init__","text":"<pre><code>__init__(*, authors=None, custom_ids=(), ephemeral_default=False, timeout)\n</code></pre> <p>Initialise a wait for executor.</p> <p>Parameters:</p> <ul> <li> <code>authors</code>               (<code>Iterable[SnowflakeishOr[User]] | None</code>, default:                   <code>None</code> )           \u2013            <p>Users who are allowed to use the components this represents.</p> <p>If no users are provided then the components will be public (meaning that anybody can use it).</p> </li> <li> <code>custom_ids</code>               (<code>Collection[str]</code>, default:                   <code>()</code> )           \u2013            <p>Collection of the custom IDs this executor should be triggered by when registered globally.</p> </li> <li> <code>ephemeral_default</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether or not the responses made on contexts spawned from this paginator should default to ephemeral (meaning only the author can see them) unless <code>flags</code> is specified on the response method.</p> </li> <li> <code>timeout</code>               (<code>timedelta | None</code>)           \u2013            <p>How long this should wait for a matching component interaction until it times-out.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.WaitForExecutor.wait_for","title":"wait_for  <code>async</code>","text":"<pre><code>wait_for()\n</code></pre> <p>Wait for the next matching interaction.</p> <p>Returns:</p> <ul> <li> <code>Context</code>           \u2013            <p>The next matching interaction.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If the executor is already being waited for.</p> </li> <li> <code>TimeoutError</code>             \u2013            <p>If the timeout is reached.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components._CallableComponentDescriptor","title":"_CallableComponentDescriptor","text":"<p>               Bases: <code>_ComponentDescriptor</code>, <code>Generic[_SelfT, _P]</code></p> <p>Base class used to represent components by decorating a callback.</p>"},{"location":"reference/components/#yuyo.components._CallableComponentDescriptor.to_field","title":"to_field  <code>abstractmethod</code>","text":"<pre><code>to_field(cls_path, name)\n</code></pre> <p>Convert this descriptor to a static field.</p>"},{"location":"reference/components/#yuyo.components._ComponentDescriptor","title":"_ComponentDescriptor","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract class used to mark components on an action column class.</p>"},{"location":"reference/components/#yuyo.components._ComponentDescriptor.to_field","title":"to_field  <code>abstractmethod</code>","text":"<pre><code>to_field(cls_path, name)\n</code></pre> <p>Convert this descriptor to a static field.</p>"},{"location":"reference/components/#yuyo.components._GatewayBotProto","title":"_GatewayBotProto","text":"<p>               Bases: <code>RESTAware</code>, <code>ShardAware</code>, <code>EventManagerAware</code>, <code>Protocol</code></p> <p>Trait of a cacheless gateway bot.</p>"},{"location":"reference/components/#yuyo.components._StaticButton","title":"_StaticButton","text":"<p>               Bases: <code>_CallableComponentDescriptor[_SelfT, _P]</code></p> <p>Used to represent a button method.</p>"},{"location":"reference/components/#yuyo.components._noop","title":"_noop","text":"<pre><code>_noop(ctx)\n</code></pre> <p>Create a noop initial response to a component context.</p>"},{"location":"reference/components/#yuyo.components._parse_channel_types","title":"_parse_channel_types","text":"<pre><code>_parse_channel_types(*channel_types)\n</code></pre> <p>Parse a channel types collection to a list of channel type integers.</p>"},{"location":"reference/components/#yuyo.components.as_channel_menu","title":"as_channel_menu","text":"<pre><code>as_channel_menu(callback: Callable[Concatenate[_SelfT, _P], _CoroT]) -&gt; _ChannelSelect[_SelfT, _P]\n</code></pre><pre><code>as_channel_menu(*, custom_id: str | None = None, channel_types: None | Sequence[ChannelType | type[PartialChannel]] = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[collections.Callable[typing.Concatenate[_SelfT, _P], _CoroT]], _ChannelSelect[_SelfT, _P]]\n</code></pre> <pre><code>as_channel_menu(callback=None, /, *, custom_id=None, channel_types=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Declare a channel select menu on an action column class.</p> <p>Parameters:</p> <ul> <li> <code>channel_types</code>               (<code>None | Sequence[ChannelType | type[PartialChannel]]</code>, default:                   <code>None</code> )           \u2013            <p>Sequence of the types of channels this select menu should show as options.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a constant ID that's generated from the path to the decorated callback (which includes the class and module qualnames).</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata and the custom ID cannot be longer than 100 characters in total.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Examples:</p> <pre><code>class CustomColumn(components.ActionColumnExecutor):\n    @components.as_channel_menu(channel_types=[hikari.TextableChannel])\n    async def on_channel_menu(self, ctx: components.Context) -&gt; None:\n        ...\n</code></pre>"},{"location":"reference/components/#yuyo.components.as_interactive_button","title":"as_interactive_button","text":"<pre><code>as_interactive_button(style, /, *, custom_id=None, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Declare an interactive button on an action column class.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>InteractiveButtonTypesT</code>)           \u2013            <p>The button's style.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The button's custom ID.</p> <p>Defaults to a constant ID that's generated from the path to the decorated callback (which includes the class and module qualnames).</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata and the custom ID cannot be longer than 100 characters in total.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's emoji.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's label.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the button should be marked as disabled.</p> </li> </ul> <p>Examples:</p> <pre><code>class CustomColumn(components.ActionColumnExecutor):\n    @components.as_interactive_button(ButtonStyle.DANGER, label=\"label\")\n    async def on_button(self, ctx: components.Context) -&gt; None:\n        ...\n</code></pre>"},{"location":"reference/components/#yuyo.components.as_mentionable_menu","title":"as_mentionable_menu","text":"<pre><code>as_mentionable_menu(callback: Callable[Concatenate[_SelfT, _P], _CoroT]) -&gt; _SelectMenu[_SelfT, _P]\n</code></pre><pre><code>as_mentionable_menu(*, custom_id: str | None = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[collections.Callable[typing.Concatenate[_SelfT, _P], _CoroT]], _SelectMenu[_SelfT, _P]]\n</code></pre> <pre><code>as_mentionable_menu(callback=None, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Declare a mentionable select menu on an action column class.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a constant ID that's generated from the path to the decorated callback (which includes the class and module qualnames).</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata and the custom ID cannot be longer than 100 characters in total.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Examples:</p> <pre><code>class CustomColumn(components.ActionColumnExecutor):\n    @components.as_mentionable_menu(max_values=5)\n    async def on_select_menu(self, ctx: components.Context) -&gt; None:\n        ...\n</code></pre>"},{"location":"reference/components/#yuyo.components.as_role_menu","title":"as_role_menu","text":"<pre><code>as_role_menu(callback: Callable[Concatenate[_SelfT, _P], _CoroT]) -&gt; _SelectMenu[_SelfT, _P]\n</code></pre><pre><code>as_role_menu(*, custom_id: str | None = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[collections.Callable[typing.Concatenate[_SelfT, _P], _CoroT]], _SelectMenu[_SelfT, _P]]\n</code></pre> <pre><code>as_role_menu(callback=None, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Declare a role select menu on an action column class.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a constant ID that's generated from the path to the decorated callback (which includes the class and module qualnames).</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata and the custom ID cannot be longer than 100 characters in total.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Examples:</p> <pre><code>class CustomColumn(components.ActionColumnExecutor):\n    @components.as_role_menu(max_values=5)\n    async def on_select_menu(self, ctx: components.Context) -&gt; None:\n        ...\n</code></pre>"},{"location":"reference/components/#yuyo.components.as_select_menu","title":"as_select_menu","text":"<pre><code>as_select_menu(type_, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Declare a select menu on an action column class.</p> <p>The following decorators should be used instead:</p> <ul> <li>as_channel_menu</li> <li>as_mentionable_menu</li> <li>as_role_menu</li> <li>as_text_menu</li> <li>as_user_menu</li> </ul>"},{"location":"reference/components/#yuyo.components.as_single_executor","title":"as_single_executor","text":"<pre><code>as_single_executor(custom_id, /, *, ephemeral_default=False)\n</code></pre> <p>Create an executor with a single callback by decorating the callback.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str</code>)           \u2013            <p>The custom ID this executor is triggered for.</p> <p>This will be matched against <code>interaction.custom_id.split(\":\", 1)[0]</code>, allowing metadata to be stored after a <code>\":\"</code>.</p> </li> <li> <code>ephemeral_default</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this executor's responses should default to being ephemeral.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SingleExecutor</code>           \u2013            <p>The created executor.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.as_text_menu","title":"as_text_menu","text":"<pre><code>as_text_menu(callback: Callable[Concatenate[_SelfT, _P], _CoroT]) -&gt; _TextMenuDescriptor[_SelfT, _P]\n</code></pre><pre><code>as_text_menu(*, custom_id: str | None = None, options: Sequence[SelectOptionBuilder] = (), placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[collections.Callable[typing.Concatenate[_SelfT, _P], _CoroT]], _TextMenuDescriptor[_SelfT, _P]]\n</code></pre> <pre><code>as_text_menu(callback=None, /, *, custom_id=None, options=(), placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Declare a text select menu on an action column class.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a constant ID that's generated from the path to the decorated callback (which includes the class and module qualnames).</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata and the custom ID cannot be longer than 100 characters in total.</p> </li> <li> <code>options</code>               (<code>Sequence[SelectOptionBuilder]</code>, default:                   <code>()</code> )           \u2013            <p>The text select's options.</p> <p>These can also be added by using components.with_option.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Examples:</p> <pre><code>class CustomColumn(components.ActionColumnExecutor):\n    @components.with_option(\"label\", \"value\")\n    @components.as_text_menu\n    async def on_text_menu(self, ctx: components.Context) -&gt; None:\n        ...\n</code></pre>"},{"location":"reference/components/#yuyo.components.as_user_menu","title":"as_user_menu","text":"<pre><code>as_user_menu(callback: Callable[Concatenate[_SelfT, _P], _CoroT]) -&gt; _SelectMenu[_SelfT, _P]\n</code></pre><pre><code>as_user_menu(*, custom_id: str | None = None, placeholder: UndefinedOr[str] = hikari.UNDEFINED, min_values: int = 0, max_values: int = 1, is_disabled: bool = False) -&gt; collections.Callable[[collections.Callable[typing.Concatenate[_SelfT, _P], _CoroT]], _SelectMenu[_SelfT, _P]]\n</code></pre> <pre><code>as_user_menu(callback=None, /, *, custom_id=None, placeholder=hikari.UNDEFINED, min_values=0, max_values=1, is_disabled=False)\n</code></pre> <p>Declare a user select menu on an action column class.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The select menu's custom ID.</p> <p>Defaults to a constant ID that's generated from the path to the decorated callback (which includes the class and module qualnames).</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata and the custom ID cannot be longer than 100 characters in total.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to show when no entries have been selected.</p> </li> <li> <code>min_values</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum amount of entries which need to be selected.</p> </li> <li> <code>max_values</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of entries which can be selected.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this select menu should be marked as disabled.</p> </li> </ul> <p>Examples:</p> <pre><code>class CustomColumn(components.ActionColumnExecutor):\n    @components.as_user_menu(max_values=5)\n    async def on_select_menu(self, ctx: components.Context) -&gt; None:\n        ...\n</code></pre>"},{"location":"reference/components/#yuyo.components.builder","title":"builder","text":"<pre><code>builder(builder)\n</code></pre> <p>Add a raw component builder to a column through a descriptor.</p> <p>This is mostly for adding components where the custom ID is already registered as a separate constant executor.</p> <p>Parameters:</p> <ul> <li> <code>builder</code>               (<code>ComponentBuilder</code>)           \u2013            <p>The component builder to add to the column.</p> </li> </ul> <p>Examples:</p> <pre><code>class CustomColumn(components.ActionColumnExecutor):\n    link_button = components.builder(hikari.impl.InteractiveButtonBuilder(\n        style=hikari.ButtonStyle.PRIMARY, custom_id=\"CUSTOM_ID\", label=\"yeet\"\n    ))\n</code></pre>"},{"location":"reference/components/#yuyo.components.column_template","title":"column_template","text":"<pre><code>column_template(ephemeral_default=False)\n</code></pre> <p>Create a column template through a decorator callback.</p> <p>The returned type acts like any other slotted action column subclass and supports the same <code>add_static</code> class methods and initialisation signature.</p> <p>Parameters:</p> <ul> <li> <code>ephemeral_default</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this column template's responses should default to ephemeral.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[ActionColumnExecutor]</code>           \u2013            <p>The new column template.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.link_button","title":"link_button","text":"<pre><code>link_button(url, /, *, emoji=hikari.UNDEFINED, label=hikari.UNDEFINED, is_disabled=False)\n</code></pre> <p>Declare an link button on an action column class.</p> <p>Either <code>emoji</code> xor <code>label</code> must be provided to be the button's displayed label.</p> <p>Parameters:</p> <ul> <li> <code>url</code>               (<code>str</code>)           \u2013            <p>The button's url.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's emoji.</p> </li> <li> <code>label</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The button's label.</p> </li> <li> <code>is_disabled</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the button should be marked as disabled.</p> </li> </ul> <p>Examples:</p> <pre><code>class CustomColumn(components.ActionColumnExecutor):\n    link_button = components.link_button(\"https://example.com\", label=\"label\")\n</code></pre>"},{"location":"reference/components/#yuyo.components.static_paginator_model","title":"static_paginator_model","text":"<pre><code>static_paginator_model(*, invalid_number_response=None, field_label='Page number')\n</code></pre> <p>Create a default implementation of the modal used for static paginator page jumping.</p> <p>Parameters:</p> <ul> <li> <code>invalid_number_response</code>               (<code>AbstractPage | None</code>, default:                   <code>None</code> )           \u2013            <p>The response to send when an invalid number is input.</p> </li> <li> <code>field_label</code>               (<code>str</code>, default:                   <code>'Page number'</code> )           \u2013            <p>Label to show for the number input field.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Modal</code>           \u2013            <p>The created modal.</p> </li> </ul>"},{"location":"reference/components/#yuyo.components.with_option","title":"with_option","text":"<pre><code>with_option(label, value, /, *, description=hikari.UNDEFINED, emoji=hikari.UNDEFINED, is_default=False)\n</code></pre> <p>Add an option to a text select menu through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>label</code>               (<code>str</code>)           \u2013            <p>The option's label.</p> </li> <li> <code>value</code>               (<code>str</code>)           \u2013            <p>The option's value.</p> </li> <li> <code>description</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The option's description.</p> </li> <li> <code>emoji</code>               (<code>Snowflakeish | Emoji | str | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Emoji to display for the option.</p> </li> <li> <code>is_default</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the option should be marked as selected by default.</p> </li> </ul> <p>Examples:</p> <pre><code>class Column(components.AbstractColumnExecutor):\n    @components.with_option(\"other label\", \"other value\")\n    @components.with_option(\"label\", \"value\")\n    @components.as_text_menu\n    async def on_text_menu(self, ctx: components.Context) -&gt; None:\n        ...\n</code></pre> <pre><code>column = components.ActionColumnExecutor()\n\n@components.with_option(\"name3\", \"value3\")\n@components.with_option(\"name2\", \"value2\")\n@components.with_option(\"name1\", \"value1\")\n@column.with_text_menu\nasync def on_text_menu(ctx: components.Context) -&gt; None:\n    ...\n</code></pre>"},{"location":"reference/interactions/","title":"yuyo.interactions","text":"<p>Base classes used for interaction handling.</p>"},{"location":"reference/interactions/#yuyo.interactions._ComponentResponseT","title":"_ComponentResponseT  <code>module-attribute</code>","text":"<pre><code>_ComponentResponseT = InteractionMessageBuilder | InteractionDeferredBuilder | InteractionModalBuilder\n</code></pre> <p>Type hint of the builder response types allows for component interactions.</p>"},{"location":"reference/interactions/#yuyo.interactions.BaseContext","title":"BaseContext","text":"<p>               Bases: <code>ABC</code>, <code>Generic[_InteractionT]</code></p> <p>Base class for components contexts.</p>"},{"location":"reference/interactions/#yuyo.interactions.BaseContext.alluka","title":"alluka  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>alluka\n</code></pre> <p>The Alluka client being used for callback dependency injection.</p>"},{"location":"reference/interactions/#yuyo.interactions.BaseContext.author","title":"author  <code>property</code>","text":"<pre><code>author\n</code></pre> <p>Author of this interaction.</p>"},{"location":"reference/interactions/#yuyo.interactions.BaseContext.cache","title":"cache  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>cache\n</code></pre> <p>Hikari cache instance this context's client was initialised with.</p>"},{"location":"reference/interactions/#yuyo.interactions.BaseContext.channel_id","title":"channel_id  <code>property</code>","text":"<pre><code>channel_id\n</code></pre> <p>ID of the channel this interaction was triggered in.</p>"},{"location":"reference/interactions/#yuyo.interactions.BaseContext.events","title":"events  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>events\n</code></pre> <p>Object of the event manager this context's client was initialised with.</p>"},{"location":"reference/interactions/#yuyo.interactions.BaseContext.expires_at","title":"expires_at  <code>property</code>","text":"<pre><code>expires_at\n</code></pre> <p>When this context expires.</p> <p>After this time is reached, the message/response methods on this context will always raise hikari.NotFoundError.</p>"},{"location":"reference/interactions/#yuyo.interactions.BaseContext.has_been_deferred","title":"has_been_deferred  <code>property</code>","text":"<pre><code>has_been_deferred\n</code></pre> <p>Whether this context's initial response has been deferred.</p> <p>This will be true if BaseContext.defer has been called.</p>"},{"location":"reference/interactions/#yuyo.interactions.BaseContext.has_responded","title":"has_responded  <code>property</code>","text":"<pre><code>has_responded\n</code></pre> <p>Whether an initial response has been made to this context yet.</p> <p>It's worth noting that a context must be either responded to or deferred within 3 seconds from it being received otherwise it'll be marked as failed.</p> <p>This will be true if either BaseContext.respond, BaseContext.create_initial_response or BaseContext.edit_initial_response (after a deferral) has been called.</p>"},{"location":"reference/interactions/#yuyo.interactions.BaseContext.id_match","title":"id_match  <code>property</code>","text":"<pre><code>id_match\n</code></pre> <p>Section of the ID used to identify the relevant executor.</p>"},{"location":"reference/interactions/#yuyo.interactions.BaseContext.id_metadata","title":"id_metadata  <code>property</code>","text":"<pre><code>id_metadata\n</code></pre> <p>Metadata from the interaction's custom ID.</p>"},{"location":"reference/interactions/#yuyo.interactions.BaseContext.interaction","title":"interaction  <code>property</code>","text":"<pre><code>interaction\n</code></pre> <p>Object of the interaction this context is for.</p>"},{"location":"reference/interactions/#yuyo.interactions.BaseContext.rest","title":"rest  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>rest\n</code></pre> <p>Object of the Hikari REST client this context's client was initialised with.</p>"},{"location":"reference/interactions/#yuyo.interactions.BaseContext.server","title":"server  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>server\n</code></pre> <p>Object of the Hikari interaction server provided for this context's client.</p>"},{"location":"reference/interactions/#yuyo.interactions.BaseContext.shard","title":"shard  <code>property</code>","text":"<pre><code>shard\n</code></pre> <p>Shard that triggered the interaction.</p> <p>Note</p> <p>This will be None if BaseContext.shards is also None.</p>"},{"location":"reference/interactions/#yuyo.interactions.BaseContext.shards","title":"shards  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>shards\n</code></pre> <p>Object of the Hikari shard manager this context's client was initialised with.</p>"},{"location":"reference/interactions/#yuyo.interactions.BaseContext.voice","title":"voice  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>voice\n</code></pre> <p>Object of the Hikari voice component this context's client was initialised with.</p>"},{"location":"reference/interactions/#yuyo.interactions.BaseContext.__init__","title":"__init__","text":"<pre><code>__init__(interaction, id_match, id_metadata, register_task, *, ephemeral_default=False, response_future=None)\n</code></pre> <p>Initialise a base context.</p>"},{"location":"reference/interactions/#yuyo.interactions.BaseContext.create_followup","title":"create_followup  <code>async</code>","text":"<pre><code>create_followup(content=hikari.UNDEFINED, *, delete_after=None, ephemeral=None, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, mentions_everyone=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED, tts=hikari.UNDEFINED, flags=hikari.UNDEFINED)\n</code></pre> <p>Create a followup response for this context.</p> <p>Warning</p> <p>Calling this on a context which hasn't had an initial response yet will lead to a hikari.NotFoundError being raised.</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>UndefinedOr[Any]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message content to send.</p> <p>If this is a hikari.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead be treated as an embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> </li> <li> <code>delete_after</code>               (<code>timedelta | float | int | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, the seconds after which the response message should be deleted.</p> <p>Interaction responses can only be deleted within 15 minutes of the interaction being received.</p> </li> <li> <code>ephemeral</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether the deferred response should be ephemeral. Passing True here is a shorthand for including <code>1 &lt;&lt; 64</code> in the passed flags.</p> </li> <li> <code>attachment</code>               (<code>UndefinedOr[Resourceish]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.</p> </li> <li> <code>attachments</code>               (<code>UndefinedOr[Sequence[Resourceish]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.</p> </li> <li> <code>component</code>               (<code>UndefinedOr[ComponentBuilder]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, builder object of the component to include in this message.</p> </li> <li> <code>components</code>               (<code>UndefinedOr[Sequence[ComponentBuilder]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, a sequence of the component builder objects to include in this message.</p> </li> <li> <code>embed</code>               (<code>UndefinedOr[Embed]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message embed.</p> </li> <li> <code>embeds</code>               (<code>UndefinedOr[Sequence[Embed]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message embeds.</p> </li> <li> <code>mentions_everyone</code>               (<code>UndefinedOr[bool]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, whether the message should parse @everyone/@here mentions.</p> </li> <li> <code>user_mentions</code>               (<code>SnowflakeishSequence[PartialUser] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialUser derivatives to enforce mentioning specific users.</p> </li> <li> <code>role_mentions</code>               (<code>SnowflakeishSequence[PartialRole] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialRole derivatives to enforce mentioning specific roles.</p> </li> <li> <code>tts</code>               (<code>UndefinedOr[bool]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, whether the message will be sent as a TTS message.</p> </li> <li> <code>flags</code>               (<code>UndefinedType | int | MessageFlag</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The flags to set for this response.</p> <p>As of writing this can only flag which can be provided is EPHEMERAL, other flags are just ignored.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Message</code>           \u2013            <p>The created message object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NotFoundError</code>             \u2013            <p>If the current interaction is not found or it hasn't had an initial response yet.</p> </li> <li> <code>BadRequestError</code>             \u2013            <p>This can be raised if the file is too large; if the embed exceeds the defined limits; if the message content is specified only and empty or greater than <code>2000</code> characters; if neither content, file or embeds are specified. If any invalid snowflake IDs are passed; a snowflake may be invalid due to it being outside of the range of a 64 bit integer.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If more than 100 unique objects/entities are passed for <code>role_mentions</code> or `user_mentions.</p> <p>If the interaction will have expired before <code>delete_after</code> is reached.</p> <p>If both <code>attachment</code> and <code>attachments</code> are passed or both <code>component</code> and <code>components</code> are passed or both <code>embed</code> and <code>embeds</code> are passed.</p> </li> </ul>"},{"location":"reference/interactions/#yuyo.interactions.BaseContext.create_initial_response","title":"create_initial_response  <code>async</code>","text":"<pre><code>create_initial_response(content=hikari.UNDEFINED, *, response_type=hikari.ResponseType.MESSAGE_CREATE, delete_after=None, ephemeral=None, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, mentions_everyone=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED, flags=hikari.UNDEFINED, tts=hikari.UNDEFINED)\n</code></pre> <p>Create the initial response for this context.</p> <p>Warning</p> <p>Calling this on a context which already has an initial response will result in this raising a hikari.NotFoundError. This includes if the REST interaction server has already responded to the request and deferrals.</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>UndefinedOr[Any]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message content to respond with.</p> <p>If this is a hikari.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead be treated as an embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> </li> <li> <code>response_type</code>               (<code>MessageResponseTypesT</code>, default:                   <code>MESSAGE_CREATE</code> )           \u2013            <p>The type of message response to give.</p> </li> <li> <code>delete_after</code>               (<code>timedelta | float | int | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, the seconds after which the response message should be deleted.</p> <p>Interaction responses can only be deleted within 15 minutes of the interaction being received.</p> </li> <li> <code>ephemeral</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether the deferred response should be ephemeral.</p> <p>Passing True here is a shorthand for including <code>1 &lt;&lt; 64</code> in the passed flags.</p> </li> <li> <code>attachment</code>               (<code>UndefinedOr[Resourceish]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.</p> </li> <li> <code>attachments</code>               (<code>UndefinedOr[Sequence[Resourceish]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.</p> </li> <li> <code>component</code>               (<code>UndefinedOr[ComponentBuilder]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, builder object of the component to include in this message.</p> </li> <li> <code>components</code>               (<code>UndefinedOr[Sequence[ComponentBuilder]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, a sequence of the component builder objects to include in this message.</p> </li> <li> <code>embed</code>               (<code>UndefinedOr[Embed]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message embed.</p> </li> <li> <code>embeds</code>               (<code>UndefinedOr[Sequence[Embed]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message embeds.</p> </li> <li> <code>flags</code>               (<code>int | MessageFlag | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message flags this response should have.</p> <p>As of writing the only message flag which can be set here is MessageFlag.EPHEMERAL.</p> </li> <li> <code>tts</code>               (<code>UndefinedOr[bool]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, whether the message will be read out by a screen reader using Discord's TTS (text-to-speech) system.</p> </li> <li> <code>mentions_everyone</code>               (<code>UndefinedOr[bool]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, whether the message should parse @everyone/@here mentions.</p> </li> <li> <code>user_mentions</code>               (<code>SnowflakeishSequence[PartialUser] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialUser derivatives to enforce mentioning specific users.</p> </li> <li> <code>role_mentions</code>               (<code>SnowflakeishSequence[PartialRole] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialRole derivatives to enforce mentioning specific roles.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If more than 100 unique objects/entities are passed for <code>role_mentions</code> or <code>user_mentions</code>.</p> <p>If the interaction will have expired before <code>delete_after</code> is reached.</p> <p>If both <code>attachment</code> and <code>attachments</code> are passed or both <code>component</code> and <code>components</code> are passed or both <code>embed</code> and <code>embeds</code> are passed.</p> </li> <li> <code>BadRequestError</code>             \u2013            <p>This may be raised in several discrete situations, such as messages being empty with no embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; invalid image URLs in embeds.</p> </li> <li> <code>UnauthorizedError</code>             \u2013            <p>If you are unauthorized to make the request (invalid/missing token).</p> </li> <li> <code>NotFoundError</code>             \u2013            <p>If the interaction is not found or if the interaction's initial response has already been created.</p> </li> <li> <code>RateLimitTooLongError</code>             \u2013            <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> </li> <li> <code>InternalServerError</code>             \u2013            <p>If an internal error occurs on Discord while handling the request.</p> </li> </ul>"},{"location":"reference/interactions/#yuyo.interactions.BaseContext.defer","title":"defer  <code>async</code>","text":"<pre><code>defer(*, defer_type=hikari.ResponseType.DEFERRED_MESSAGE_CREATE, ephemeral=None, flags=hikari.UNDEFINED)\n</code></pre> <p>Defer the initial response for this context.</p> <p>Note</p> <p>The ephemeral state of the first response is decided by whether the deferral is ephemeral.</p> <p>Parameters:</p> <ul> <li> <code>defer_type</code>               (<code>DeferredResponseTypesT</code>, default:                   <code>DEFERRED_MESSAGE_CREATE</code> )           \u2013            <p>The type of deferral this should be.</p> <p>This may any of the following:</p> <ul> <li>ResponseType.DEFERRED_MESSAGE_CREATE     to indicate that the following up call to     BaseContext.edit_initial_response     or BaseContext.respond     should create a new message.</li> <li>ResponseType.DEFERRED_MESSAGE_UPDATE     to indicate that the following call to the aforementioned     methods should update the existing message.</li> </ul> </li> <li> <code>ephemeral</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether the deferred response should be ephemeral.</p> <p>Passing True here is a shorthand for including <code>1 &lt;&lt; 64</code> in the passed flags.</p> </li> <li> <code>flags</code>               (<code>UndefinedType | int | MessageFlag</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The flags to use for the initial response.</p> </li> </ul>"},{"location":"reference/interactions/#yuyo.interactions.BaseContext.delete_initial_response","title":"delete_initial_response  <code>async</code>","text":"<pre><code>delete_initial_response()\n</code></pre> <p>Delete the initial response after invoking this context.</p> <p>Raises:</p> <ul> <li> <code>(LookupError, NotFoundError)</code>             \u2013            <p>The last context has no initial response.</p> </li> </ul>"},{"location":"reference/interactions/#yuyo.interactions.BaseContext.delete_last_response","title":"delete_last_response  <code>async</code>","text":"<pre><code>delete_last_response()\n</code></pre> <p>Delete the last response after invoking this context.</p> <p>Raises:</p> <ul> <li> <code>(LookupError, NotFoundError)</code>             \u2013            <p>The last context has no responses.</p> </li> </ul>"},{"location":"reference/interactions/#yuyo.interactions.BaseContext.edit_initial_response","title":"edit_initial_response  <code>async</code>","text":"<pre><code>edit_initial_response(content=hikari.UNDEFINED, *, delete_after=None, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, mentions_everyone=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED)\n</code></pre> <p>Edit the initial response for this context.</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>UndefinedOr[Any]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message content to edit the initial response with.</p> <p>If this is a hikari.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> </li> <li> <code>delete_after</code>               (<code>timedelta | float | int | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, the seconds after which the response message should be deleted.</p> <p>Interaction responses can only be deleted within 15 minutes of the interaction being received.</p> </li> <li> <code>attachment</code>               (<code>UndefinedNoneOr[Resourceish]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A singular attachment to edit the initial response with.</p> </li> <li> <code>attachments</code>               (<code>UndefinedNoneOr[Sequence[Resourceish]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A sequence of attachments to edit the initial response with.</p> </li> <li> <code>component</code>               (<code>UndefinedNoneOr[ComponentBuilder]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, builder object of the component to set for this message. This component will replace any previously set components and passing None will remove all components.</p> </li> <li> <code>components</code>               (<code>UndefinedNoneOr[Sequence[ComponentBuilder]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing None or an empty sequence will remove all components.</p> </li> <li> <code>embed</code>               (<code>UndefinedNoneOr[Embed]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>An embed to replace the initial response with.</p> </li> <li> <code>embeds</code>               (<code>UndefinedNoneOr[Sequence[Embed]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A sequence of embeds to replace the initial response with.</p> </li> <li> <code>mentions_everyone</code>               (<code>UndefinedOr[bool]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, whether the message should parse @everyone/@here mentions.</p> </li> <li> <code>user_mentions</code>               (<code>SnowflakeishSequence[PartialUser] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialUser derivatives to enforce mentioning specific users.</p> </li> <li> <code>role_mentions</code>               (<code>SnowflakeishSequence[PartialRole] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialRole derivatives to enforce mentioning specific roles.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Message</code>           \u2013            <p>The message that has been edited.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If more than 100 unique objects/entities are passed for <code>role_mentions</code> or <code>user_mentions</code>.</p> <p>If <code>delete_after</code> would be more than 15 minutes after the interaction was received.</p> <p>If both <code>attachment</code> and <code>attachments</code> are passed or both <code>component</code> and <code>components</code> are passed or both <code>embed</code> and <code>embeds</code> are passed.</p> </li> <li> <code>BadRequestError</code>             \u2013            <p>This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components.</p> </li> <li> <code>UnauthorizedError</code>             \u2013            <p>If you are unauthorized to make the request (invalid/missing token).</p> </li> <li> <code>ForbiddenError</code>             \u2013            <p>If you are missing the <code>SEND_MESSAGES</code> in the channel or the person you are trying to message has the DM's disabled.</p> </li> <li> <code>NotFoundError</code>             \u2013            <p>If the channel is not found.</p> </li> <li> <code>RateLimitTooLongError</code>             \u2013            <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> </li> <li> <code>InternalServerError</code>             \u2013            <p>If an internal error occurs on Discord while handling the request.</p> </li> </ul>"},{"location":"reference/interactions/#yuyo.interactions.BaseContext.edit_last_response","title":"edit_last_response  <code>async</code>","text":"<pre><code>edit_last_response(content=hikari.UNDEFINED, *, delete_after=None, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, mentions_everyone=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED)\n</code></pre> <p>Edit the last response for this context.</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>UndefinedOr[Any]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the content to edit the last response with.</p> <p>If this is a hikari.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> </li> <li> <code>delete_after</code>               (<code>timedelta | float | int | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, the seconds after which the response message should be deleted.</p> <p>Interaction responses can only be deleted within 15 minutes of the interaction being received.</p> </li> <li> <code>attachment</code>               (<code>UndefinedNoneOr[Resourceish]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A singular attachment to edit the last response with.</p> </li> <li> <code>attachments</code>               (<code>UndefinedNoneOr[Sequence[Resourceish]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A sequence of attachments to edit the last response with.</p> </li> <li> <code>component</code>               (<code>UndefinedNoneOr[ComponentBuilder]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, builder object of the component to set for this message. This component will replace any previously set components and passing None will remove all components.</p> </li> <li> <code>components</code>               (<code>UndefinedNoneOr[Sequence[ComponentBuilder]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing None or an empty sequence will remove all components.</p> </li> <li> <code>embed</code>               (<code>UndefinedNoneOr[Embed]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>An embed to replace the last response with.</p> </li> <li> <code>embeds</code>               (<code>UndefinedNoneOr[Sequence[Embed]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A sequence of embeds to replace the last response with.</p> </li> <li> <code>mentions_everyone</code>               (<code>UndefinedOr[bool]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, whether the message should parse @everyone/@here mentions.</p> </li> <li> <code>user_mentions</code>               (<code>SnowflakeishSequence[PartialUser] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialUser derivatives to enforce mentioning specific users.</p> </li> <li> <code>role_mentions</code>               (<code>SnowflakeishSequence[PartialRole] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialRole derivatives to enforce mentioning specific roles.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Message</code>           \u2013            <p>The message that has been edited.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If more than 100 unique objects/entities are passed for <code>role_mentions</code> or <code>user_mentions</code>.</p> <p>If <code>delete_after</code> would be more than 15 minutes after the slash interaction was received.</p> <p>If both <code>attachment</code> and <code>attachments</code> are passed or both <code>component</code> and <code>components</code> are passed or both <code>embed</code> and <code>embeds</code> are passed.</p> </li> <li> <code>BadRequestError</code>             \u2013            <p>This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components.</p> </li> <li> <code>UnauthorizedError</code>             \u2013            <p>If you are unauthorized to make the request (invalid/missing token).</p> </li> <li> <code>ForbiddenError</code>             \u2013            <p>If you are missing the <code>SEND_MESSAGES</code> in the channel or the person you are trying to message has the DM's disabled.</p> </li> <li> <code>NotFoundError</code>             \u2013            <p>If the channel is not found.</p> </li> <li> <code>RateLimitTooLongError</code>             \u2013            <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> </li> <li> <code>InternalServerError</code>             \u2013            <p>If an internal error occurs on Discord while handling the request.</p> </li> </ul>"},{"location":"reference/interactions/#yuyo.interactions.BaseContext.fetch_initial_response","title":"fetch_initial_response  <code>async</code>","text":"<pre><code>fetch_initial_response()\n</code></pre> <p>Fetch the initial response for this context.</p> <p>Returns:</p> <ul> <li> <code>Message</code>           \u2013            <p>The initial response's message object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>(LookupError, NotFoundError)</code>             \u2013            <p>The response was not found.</p> </li> </ul>"},{"location":"reference/interactions/#yuyo.interactions.BaseContext.fetch_last_response","title":"fetch_last_response  <code>async</code>","text":"<pre><code>fetch_last_response()\n</code></pre> <p>Fetch the last response for this context.</p> <p>Returns:</p> <ul> <li> <code>Message</code>           \u2013            <p>The most response response's message object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>(LookupError, NotFoundError)</code>             \u2013            <p>The response was not found.</p> </li> </ul>"},{"location":"reference/interactions/#yuyo.interactions.BaseContext.respond","title":"respond  <code>async</code>","text":"<pre><code>respond(content: UndefinedOr[Any] = hikari.UNDEFINED, *, ensure_result: Literal[True], delete_after: timedelta | float | int | None = None, attachment: UndefinedOr[Resourceish] = hikari.UNDEFINED, attachments: UndefinedOr[Sequence[Resourceish]] = hikari.UNDEFINED, component: UndefinedOr[ComponentBuilder] = hikari.UNDEFINED, components: UndefinedOr[Sequence[ComponentBuilder]] = hikari.UNDEFINED, embed: UndefinedOr[Embed] = hikari.UNDEFINED, embeds: UndefinedOr[Sequence[Embed]] = hikari.UNDEFINED, mentions_everyone: UndefinedOr[bool] = hikari.UNDEFINED, user_mentions: SnowflakeishSequence[PartialUser] | bool | UndefinedType = hikari.UNDEFINED, role_mentions: SnowflakeishSequence[PartialRole] | bool | UndefinedType = hikari.UNDEFINED) -&gt; hikari.Message\n</code></pre><pre><code>respond(content: UndefinedOr[Any] = hikari.UNDEFINED, *, ensure_result: bool = False, delete_after: timedelta | float | int | None = None, attachment: UndefinedOr[Resourceish] = hikari.UNDEFINED, attachments: UndefinedOr[Sequence[Resourceish]] = hikari.UNDEFINED, component: UndefinedOr[ComponentBuilder] = hikari.UNDEFINED, components: UndefinedOr[Sequence[ComponentBuilder]] = hikari.UNDEFINED, embed: UndefinedOr[Embed] = hikari.UNDEFINED, embeds: UndefinedOr[Sequence[Embed]] = hikari.UNDEFINED, mentions_everyone: UndefinedOr[bool] = hikari.UNDEFINED, user_mentions: SnowflakeishSequence[PartialUser] | bool | UndefinedType = hikari.UNDEFINED, role_mentions: SnowflakeishSequence[PartialRole] | bool | UndefinedType = hikari.UNDEFINED) -&gt; hikari.Message | None\n</code></pre> <pre><code>respond(content=hikari.UNDEFINED, *, ensure_result=False, delete_after=None, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, mentions_everyone=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED)\n</code></pre> <p>Respond to this context.</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>UndefinedOr[Any]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message content to respond with.</p> <p>If this is a hikari.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead be treated as an embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> </li> <li> <code>ensure_result</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Ensure that this call will always return a message object.</p> <p>If True then this will always return hikari.Message, otherwise this will return <code>hikari.Message | None</code>.</p> <p>It's worth noting that this may lead to an extre request being made under certain scenarios.</p> </li> <li> <code>delete_after</code>               (<code>timedelta | float | int | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, the seconds after which the response message should be deleted.</p> <p>Interaction responses can only be deleted within 15 minutes of the interaction being received.</p> </li> <li> <code>attachment</code>               (<code>UndefinedOr[Resourceish]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.</p> </li> <li> <code>attachments</code>               (<code>UndefinedOr[Sequence[Resourceish]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.</p> </li> <li> <code>component</code>               (<code>UndefinedOr[ComponentBuilder]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, builder object of the component to include in this response.</p> </li> <li> <code>components</code>               (<code>UndefinedOr[Sequence[ComponentBuilder]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, a sequence of the component builder objects to include in this response.</p> </li> <li> <code>embed</code>               (<code>UndefinedOr[Embed]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>An embed to respond with.</p> </li> <li> <code>embeds</code>               (<code>UndefinedOr[Sequence[Embed]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A sequence of embeds to respond with.</p> </li> <li> <code>mentions_everyone</code>               (<code>UndefinedOr[bool]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, whether the message should parse @everyone/@here mentions.</p> </li> <li> <code>user_mentions</code>               (<code>SnowflakeishSequence[PartialUser] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialUser derivatives to enforce mentioning specific users.</p> </li> <li> <code>role_mentions</code>               (<code>SnowflakeishSequence[PartialRole] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialRole derivatives to enforce mentioning specific roles.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Message | None</code>           \u2013            <p>The message that has been created if it was immedieatly available or <code>ensure_result</code> was set to True, else None.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If more than 100 unique objects/entities are passed for <code>role_mentions</code> or <code>user_mentions</code>.</p> <p>If <code>delete_after</code> would be more than 15 minutes after the interaction was received.</p> <p>If both <code>attachment</code> and <code>attachments</code> are passed or both <code>component</code> and <code>components</code> are passed or both <code>embed</code> and <code>embeds</code> are passed.</p> </li> <li> <code>BadRequestError</code>             \u2013            <p>This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components.</p> </li> <li> <code>UnauthorizedError</code>             \u2013            <p>If you are unauthorized to make the request (invalid/missing token).</p> </li> <li> <code>ForbiddenError</code>             \u2013            <p>If you are missing the <code>SEND_MESSAGES</code> in the channel or the person you are trying to message has the DM's disabled.</p> </li> <li> <code>NotFoundError</code>             \u2013            <p>If the channel is not found.</p> </li> <li> <code>RateLimitTooLongError</code>             \u2013            <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> </li> <li> <code>InternalServerError</code>             \u2013            <p>If an internal error occurs on Discord while handling the request.</p> </li> </ul>"},{"location":"reference/interactions/#yuyo.interactions.BaseContext.set_ephemeral_default","title":"set_ephemeral_default","text":"<pre><code>set_ephemeral_default(state)\n</code></pre> <p>Set the ephemeral default state for this context.</p> <p>Parameters:</p> <ul> <li> <code>state</code>               (<code>bool</code>)           \u2013            <p>The new ephemeral default state.</p> <p>If this is True then all calls to the response creating methods on this context will default to being ephemeral.</p> </li> </ul>"},{"location":"reference/interactions/#yuyo.interactions.InteractionError","title":"InteractionError","text":"<p>               Bases: <code>Exception</code></p> <p>Error which is sent as a response to a modal or component call.</p>"},{"location":"reference/interactions/#yuyo.interactions.InteractionError.__init__","title":"__init__","text":"<pre><code>__init__(content=hikari.UNDEFINED, *, delete_after=None, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, mentions_everyone=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED)\n</code></pre> <p>Initialise an interaction error.</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>UndefinedOr[Any]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message content to respond with.</p> <p>If this is a hikari.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead be treated as an embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> </li> <li> <code>delete_after</code>               (<code>timedelta | float | int | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, the seconds after which the response message should be deleted.</p> <p>Interaction responses can only be deleted within 15 minutes of the interaction being received.</p> </li> <li> <code>attachment</code>               (<code>UndefinedOr[Resourceish]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A singular attachment to respond with.</p> </li> <li> <code>attachments</code>               (<code>UndefinedOr[Sequence[Resourceish]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A sequence of attachments to respond with.</p> </li> <li> <code>component</code>               (<code>UndefinedOr[ComponentBuilder]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, builder object of the component to include in this response.</p> </li> <li> <code>components</code>               (<code>UndefinedOr[Sequence[ComponentBuilder]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, a sequence of the component builder objects to include in this response.</p> </li> <li> <code>embed</code>               (<code>UndefinedOr[Embed]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>An embed to respond with.</p> </li> <li> <code>embeds</code>               (<code>UndefinedOr[Sequence[Embed]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A sequence of embeds to respond with.</p> </li> <li> <code>mentions_everyone</code>               (<code>UndefinedOr[bool]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, whether the message should parse @everyone/@here mentions.</p> </li> <li> <code>user_mentions</code>               (<code>SnowflakeishSequence[PartialUser] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialUser derivatives to enforce mentioning specific users.</p> </li> <li> <code>role_mentions</code>               (<code>SnowflakeishSequence[PartialRole] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialRole derivatives to enforce mentioning specific roles.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>Raised for any of the following reasons:</p> <ul> <li>When both <code>attachment</code> and <code>attachments</code> are provided.</li> <li>When both <code>component</code> and <code>components</code> are passed.</li> <li>When both <code>embed</code> and <code>embeds</code> are passed.</li> <li>If more than 100 entries are passed for <code>role_mentions</code>.</li> <li>If more than 100 entries are passed for <code>user_mentions</code>.</li> </ul> </li> </ul>"},{"location":"reference/interactions/#yuyo.interactions.InteractionError.send","title":"send  <code>async</code>","text":"<pre><code>send(ctx: BaseContext[ComponentInteraction] | BaseContext[ModalInteraction], /, *, ensure_result: Literal[True]) -&gt; hikari.Message\n</code></pre><pre><code>send(ctx: BaseContext[ComponentInteraction] | BaseContext[ModalInteraction], /, *, ensure_result: bool = False) -&gt; hikari.Message | None\n</code></pre> <pre><code>send(ctx, /, *, ensure_result=False)\n</code></pre> <p>Send this error as an interaction response.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>BaseContext[ComponentInteraction] | BaseContext[ModalInteraction]</code>)           \u2013            <p>The interaction context to respond to.</p> </li> <li> <code>ensure_result</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Ensure that this call will always return a message object.</p> <p>If True then this will always return hikari.Message, otherwise this will return <code>hikari.Message | None</code>.</p> <p>It's worth noting that this may lead to an extra request being made under certain scenarios.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>delete_after</code> would be more than 15 minutes after the interaction was received.</p> </li> <li> <code>BadRequestError</code>             \u2013            <p>This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components.</p> </li> <li> <code>UnauthorizedError</code>             \u2013            <p>If you are unauthorized to make the request (invalid/missing token).</p> </li> <li> <code>ForbiddenError</code>             \u2013            <p>If you are missing the <code>SEND_MESSAGES</code> in the channel or the person you are trying to message has the DM's disabled.</p> </li> <li> <code>NotFoundError</code>             \u2013            <p>If the channel is not found.</p> </li> <li> <code>RateLimitTooLongError</code>             \u2013            <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> </li> <li> <code>InternalServerError</code>             \u2013            <p>If an internal error occurs on Discord while handling the request.</p> </li> </ul>"},{"location":"reference/links/","title":"yuyo.links","text":"<p>Classes and functions for handling Discord Links.</p>"},{"location":"reference/links/#yuyo.links.BaseLink","title":"BaseLink","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for all link objects.</p>"},{"location":"reference/links/#yuyo.links.BaseLink.find","title":"find  <code>classmethod</code>","text":"<pre><code>find(app, content)\n</code></pre> <p>Find the first link in a string.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>RESTAware</code>)           \u2013            <p>The Hikari bot or REST app this should be bound to.</p> </li> <li> <code>content</code>               (<code>str</code>)           \u2013            <p>The string to search in.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self | None</code>           \u2013            <p>Object of the found link or None.</p> </li> </ul>"},{"location":"reference/links/#yuyo.links.BaseLink.find_iter","title":"find_iter  <code>classmethod</code>","text":"<pre><code>find_iter(app, content)\n</code></pre> <p>Iterate over the links in a string.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>RESTAware</code>)           \u2013            <p>The Hikari bot or REST app this should be bound to.</p> </li> <li> <code>content</code>               (<code>str</code>)           \u2013            <p>The string to search in.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[Self]</code>           \u2013            <p>Iterator of the link objects in the passed string.</p> </li> </ul>"},{"location":"reference/links/#yuyo.links.BaseLink.from_link","title":"from_link  <code>classmethod</code>","text":"<pre><code>from_link(app, link)\n</code></pre> <p>Create a link object from a raw link.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>RESTAware</code>)           \u2013            <p>The Hikari bot or REST app this should be bound to.</p> </li> <li> <code>link</code>               (<code>str</code>)           \u2013            <p>The string link to use.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The created link object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the string doesn't match the expected link format.</p> </li> </ul>"},{"location":"reference/links/#yuyo.links.ChannelLink","title":"ChannelLink  <code>dataclass</code>","text":"<p>               Bases: <code>BaseLink</code></p> <p>Represents a link to a channel.</p> <p>The following class methods are used to initialise this:</p> <ul> <li>InviteLink.from_link to create this from   a raw channel link.</li> <li>InviteLink.find to find the first channel link   in a string.</li> <li>InviteLink.find_iter to iterate over the   channel links in a string.</li> </ul>"},{"location":"reference/links/#yuyo.links.ChannelLink.channel_id","title":"channel_id  <code>property</code>","text":"<pre><code>channel_id\n</code></pre> <p>ID of the channel this links to.</p>"},{"location":"reference/links/#yuyo.links.ChannelLink.guild_id","title":"guild_id  <code>property</code>","text":"<pre><code>guild_id\n</code></pre> <p>ID of the guild this links to.</p> <p>Will be None for DM links.</p>"},{"location":"reference/links/#yuyo.links.ChannelLink.is_dm_link","title":"is_dm_link  <code>property</code>","text":"<pre><code>is_dm_link\n</code></pre> <p>Whether this links to a DM channel.</p>"},{"location":"reference/links/#yuyo.links.ChannelLink.__str__","title":"__str__","text":"<pre><code>__str__()\n</code></pre> <p>Create a raw string representation of this link.</p>"},{"location":"reference/links/#yuyo.links.ChannelLink.fetch_channel","title":"fetch_channel  <code>async</code>","text":"<pre><code>fetch_channel()\n</code></pre> <p>Fetch the channel this links to.</p> <p>Returns:</p> <ul> <li> <code>PartialChannel</code>           \u2013            <p>The this links to channel. This will be a derivative of <code>hikari.channels.PartialChannel</code>, depending on the type of channel you request for.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>UnauthorizedError</code>             \u2013            <p>If you are unauthorized to make the request (invalid/missing token).</p> </li> <li> <code>ForbiddenError</code>             \u2013            <p>If you are missing the <code>READ_MESSAGES</code> permission in the channel.</p> </li> <li> <code>NotFoundError</code>             \u2013            <p>If the channel is not found.</p> </li> <li> <code>RateLimitTooLongError</code>             \u2013            <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> </li> <li> <code>InternalServerError</code>             \u2013            <p>If an internal error occurs on Discord while handling the request.</p> </li> </ul>"},{"location":"reference/links/#yuyo.links.ChannelLink.fetch_guild","title":"fetch_guild  <code>async</code>","text":"<pre><code>fetch_guild()\n</code></pre> <p>Fetch the guild this links to.</p> <p>Returns:</p> <ul> <li> <code>RESTGuild | None</code>           \u2013            <p>Object of the guild this links to.</p> <p>Will be None if this links to a DM channel.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ForbiddenError</code>             \u2013            <p>If you are not part of the guild.</p> </li> <li> <code>NotFoundError</code>             \u2013            <p>If the guild is not found.</p> </li> <li> <code>UnauthorizedError</code>             \u2013            <p>If you are unauthorized to make the request (invalid/missing token).</p> </li> <li> <code>RateLimitTooLongError</code>             \u2013            <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> </li> <li> <code>InternalServerError</code>             \u2013            <p>If an internal error occurs on Discord while handling the request.</p> </li> </ul>"},{"location":"reference/links/#yuyo.links.ChannelLink.find","title":"find  <code>classmethod</code>","text":"<pre><code>find(app, content)\n</code></pre> <p>Find the first link in a string.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>RESTAware</code>)           \u2013            <p>The Hikari bot or REST app this should be bound to.</p> </li> <li> <code>content</code>               (<code>str</code>)           \u2013            <p>The string to search in.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self | None</code>           \u2013            <p>Object of the found link or None.</p> </li> </ul>"},{"location":"reference/links/#yuyo.links.ChannelLink.find_iter","title":"find_iter  <code>classmethod</code>","text":"<pre><code>find_iter(app, content)\n</code></pre> <p>Iterate over the links in a string.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>RESTAware</code>)           \u2013            <p>The Hikari bot or REST app this should be bound to.</p> </li> <li> <code>content</code>               (<code>str</code>)           \u2013            <p>The string to search in.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[Self]</code>           \u2013            <p>Iterator of the link objects in the passed string.</p> </li> </ul>"},{"location":"reference/links/#yuyo.links.ChannelLink.from_link","title":"from_link  <code>classmethod</code>","text":"<pre><code>from_link(app, link)\n</code></pre> <p>Create a link object from a raw link.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>RESTAware</code>)           \u2013            <p>The Hikari bot or REST app this should be bound to.</p> </li> <li> <code>link</code>               (<code>str</code>)           \u2013            <p>The string link to use.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The created link object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the string doesn't match the expected link format.</p> </li> </ul>"},{"location":"reference/links/#yuyo.links.ChannelLink.get_channel","title":"get_channel","text":"<pre><code>get_channel()\n</code></pre> <p>Get the channel this links to from the cache.</p> <p>Returns:</p> <ul> <li> <code>GuildChannel | None</code>           \u2013            <p>Object of the guild channel that was found in the cache or None.</p> </li> </ul>"},{"location":"reference/links/#yuyo.links.ChannelLink.get_guild","title":"get_guild","text":"<pre><code>get_guild()\n</code></pre> <p>Get the guild this links to from the cache.</p> <p>Returns:</p> <ul> <li> <code>GuildChannel | None</code>           \u2013            <p>Object of the guild that was found in the cache or None.</p> <p>This will also be None if this links to a DM channel.</p> </li> </ul>"},{"location":"reference/links/#yuyo.links.InviteLink","title":"InviteLink  <code>dataclass</code>","text":"<p>               Bases: <code>InviteCode</code>, <code>BaseLink</code></p> <p>Represents a Discord invite link.</p> <p>The following class methods are used to initialise this:</p> <ul> <li>InviteLink.from_link to create this from   a raw invite link.</li> <li>InviteLink.find to find the first invite link   in a string.</li> <li>InviteLink.find_iter to iterate over the   invite links in a string.</li> </ul>"},{"location":"reference/links/#yuyo.links.InviteLink.code","title":"code  <code>property</code>","text":"<pre><code>code\n</code></pre> <p>The invite's code.</p>"},{"location":"reference/links/#yuyo.links.InviteLink.fetch_invite","title":"fetch_invite  <code>async</code>","text":"<pre><code>fetch_invite()\n</code></pre> <p>Fetch the invite this links to.</p> <p>Returns:</p> <ul> <li> <code>Invite</code>           \u2013            <p>Object of the invite this links to.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>UnauthorizedError</code>             \u2013            <p>If you are unauthorized to make the request (invalid/missing token).</p> </li> <li> <code>NotFoundError</code>             \u2013            <p>If the invite is not found.</p> </li> <li> <code>RateLimitTooLongError</code>             \u2013            <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> </li> <li> <code>InternalServerError</code>             \u2013            <p>If an internal error occurs on Discord while handling the request.</p> </li> </ul>"},{"location":"reference/links/#yuyo.links.InviteLink.find","title":"find  <code>classmethod</code>","text":"<pre><code>find(app, content)\n</code></pre> <p>Find the first link in a string.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>RESTAware</code>)           \u2013            <p>The Hikari bot or REST app this should be bound to.</p> </li> <li> <code>content</code>               (<code>str</code>)           \u2013            <p>The string to search in.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self | None</code>           \u2013            <p>Object of the found link or None.</p> </li> </ul>"},{"location":"reference/links/#yuyo.links.InviteLink.find_iter","title":"find_iter  <code>classmethod</code>","text":"<pre><code>find_iter(app, content)\n</code></pre> <p>Iterate over the links in a string.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>RESTAware</code>)           \u2013            <p>The Hikari bot or REST app this should be bound to.</p> </li> <li> <code>content</code>               (<code>str</code>)           \u2013            <p>The string to search in.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[Self]</code>           \u2013            <p>Iterator of the link objects in the passed string.</p> </li> </ul>"},{"location":"reference/links/#yuyo.links.InviteLink.from_link","title":"from_link  <code>classmethod</code>","text":"<pre><code>from_link(app, link)\n</code></pre> <p>Create a link object from a raw link.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>RESTAware</code>)           \u2013            <p>The Hikari bot or REST app this should be bound to.</p> </li> <li> <code>link</code>               (<code>str</code>)           \u2013            <p>The string link to use.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The created link object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the string doesn't match the expected link format.</p> </li> </ul>"},{"location":"reference/links/#yuyo.links.InviteLink.get_invite","title":"get_invite","text":"<pre><code>get_invite()\n</code></pre> <p>Get the invite this links to from the cache.</p> <p>Returns:</p> <ul> <li> <code>InviteWithMetadata | None</code>           \u2013            <p>Object of the invite that was found in the cache or None.</p> </li> </ul>"},{"location":"reference/links/#yuyo.links.MessageLink","title":"MessageLink  <code>dataclass</code>","text":"<p>               Bases: <code>ChannelLink</code></p> <p>Represents a link to a message on Discord.</p> <p>The following class methods are used to initialise this:</p> <ul> <li>MessageLink.from_link to create this   from a raw message link.</li> <li>MessageLink.find to find the first invite   link in a string.</li> <li>MessageLink.find_iter to iterate over   the message links in a string.</li> </ul>"},{"location":"reference/links/#yuyo.links.MessageLink.channel_id","title":"channel_id  <code>property</code>","text":"<pre><code>channel_id\n</code></pre> <p>ID of the channel this links to.</p>"},{"location":"reference/links/#yuyo.links.MessageLink.guild_id","title":"guild_id  <code>property</code>","text":"<pre><code>guild_id\n</code></pre> <p>ID of the guild this links to.</p> <p>Will be None for DM links.</p>"},{"location":"reference/links/#yuyo.links.MessageLink.is_dm_link","title":"is_dm_link  <code>property</code>","text":"<pre><code>is_dm_link\n</code></pre> <p>Whether this links to a DM channel.</p>"},{"location":"reference/links/#yuyo.links.MessageLink.message_id","title":"message_id  <code>property</code>","text":"<pre><code>message_id\n</code></pre> <p>ID of the message this links to.</p>"},{"location":"reference/links/#yuyo.links.MessageLink.__str__","title":"__str__","text":"<pre><code>__str__()\n</code></pre> <p>Create a raw string representation of this link.</p>"},{"location":"reference/links/#yuyo.links.MessageLink.fetch_channel","title":"fetch_channel  <code>async</code>","text":"<pre><code>fetch_channel()\n</code></pre> <p>Fetch the channel this links to.</p> <p>Returns:</p> <ul> <li> <code>PartialChannel</code>           \u2013            <p>The this links to channel. This will be a derivative of <code>hikari.channels.PartialChannel</code>, depending on the type of channel you request for.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>UnauthorizedError</code>             \u2013            <p>If you are unauthorized to make the request (invalid/missing token).</p> </li> <li> <code>ForbiddenError</code>             \u2013            <p>If you are missing the <code>READ_MESSAGES</code> permission in the channel.</p> </li> <li> <code>NotFoundError</code>             \u2013            <p>If the channel is not found.</p> </li> <li> <code>RateLimitTooLongError</code>             \u2013            <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> </li> <li> <code>InternalServerError</code>             \u2013            <p>If an internal error occurs on Discord while handling the request.</p> </li> </ul>"},{"location":"reference/links/#yuyo.links.MessageLink.fetch_guild","title":"fetch_guild  <code>async</code>","text":"<pre><code>fetch_guild()\n</code></pre> <p>Fetch the guild this links to.</p> <p>Returns:</p> <ul> <li> <code>RESTGuild | None</code>           \u2013            <p>Object of the guild this links to.</p> <p>Will be None if this links to a DM channel.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ForbiddenError</code>             \u2013            <p>If you are not part of the guild.</p> </li> <li> <code>NotFoundError</code>             \u2013            <p>If the guild is not found.</p> </li> <li> <code>UnauthorizedError</code>             \u2013            <p>If you are unauthorized to make the request (invalid/missing token).</p> </li> <li> <code>RateLimitTooLongError</code>             \u2013            <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> </li> <li> <code>InternalServerError</code>             \u2013            <p>If an internal error occurs on Discord while handling the request.</p> </li> </ul>"},{"location":"reference/links/#yuyo.links.MessageLink.fetch_message","title":"fetch_message  <code>async</code>","text":"<pre><code>fetch_message()\n</code></pre> <p>Fetch a the message this links to.</p> <p>Returns:</p> <ul> <li> <code>Message</code>           \u2013            <p>Object of the message this links to.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>UnauthorizedError</code>             \u2013            <p>If you are unauthorized to make the request (invalid/missing token).</p> </li> <li> <code>ForbiddenError</code>             \u2013            <p>If you are missing the <code>READ_MESSAGE_HISTORY</code> in the channel.</p> </li> <li> <code>NotFoundError</code>             \u2013            <p>If the channel is not found or the message is not found in the given text channel.</p> </li> <li> <code>RateLimitTooLongError</code>             \u2013            <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> </li> <li> <code>InternalServerError</code>             \u2013            <p>If an internal error occurs on Discord while handling the request.</p> </li> </ul>"},{"location":"reference/links/#yuyo.links.MessageLink.find","title":"find  <code>classmethod</code>","text":"<pre><code>find(app, content)\n</code></pre> <p>Find the first link in a string.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>RESTAware</code>)           \u2013            <p>The Hikari bot or REST app this should be bound to.</p> </li> <li> <code>content</code>               (<code>str</code>)           \u2013            <p>The string to search in.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self | None</code>           \u2013            <p>Object of the found link or None.</p> </li> </ul>"},{"location":"reference/links/#yuyo.links.MessageLink.find_iter","title":"find_iter  <code>classmethod</code>","text":"<pre><code>find_iter(app, content)\n</code></pre> <p>Iterate over the links in a string.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>RESTAware</code>)           \u2013            <p>The Hikari bot or REST app this should be bound to.</p> </li> <li> <code>content</code>               (<code>str</code>)           \u2013            <p>The string to search in.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[Self]</code>           \u2013            <p>Iterator of the link objects in the passed string.</p> </li> </ul>"},{"location":"reference/links/#yuyo.links.MessageLink.from_link","title":"from_link  <code>classmethod</code>","text":"<pre><code>from_link(app, link)\n</code></pre> <p>Create a link object from a raw link.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>RESTAware</code>)           \u2013            <p>The Hikari bot or REST app this should be bound to.</p> </li> <li> <code>link</code>               (<code>str</code>)           \u2013            <p>The string link to use.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The created link object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the string doesn't match the expected link format.</p> </li> </ul>"},{"location":"reference/links/#yuyo.links.MessageLink.get_channel","title":"get_channel","text":"<pre><code>get_channel()\n</code></pre> <p>Get the channel this links to from the cache.</p> <p>Returns:</p> <ul> <li> <code>GuildChannel | None</code>           \u2013            <p>Object of the guild channel that was found in the cache or None.</p> </li> </ul>"},{"location":"reference/links/#yuyo.links.MessageLink.get_guild","title":"get_guild","text":"<pre><code>get_guild()\n</code></pre> <p>Get the guild this links to from the cache.</p> <p>Returns:</p> <ul> <li> <code>GuildChannel | None</code>           \u2013            <p>Object of the guild that was found in the cache or None.</p> <p>This will also be None if this links to a DM channel.</p> </li> </ul>"},{"location":"reference/links/#yuyo.links.MessageLink.get_message","title":"get_message","text":"<pre><code>get_message()\n</code></pre> <p>Get the message this links to from the cache.</p> <p>Returns:</p> <ul> <li> <code>Message | None</code>           \u2013            <p>Object of the message that was found in the cache or None.</p> </li> </ul>"},{"location":"reference/links/#yuyo.links.TemplateLink","title":"TemplateLink  <code>dataclass</code>","text":"<p>               Bases: <code>BaseLink</code></p> <p>Represents a link to a guild template.</p> <p>The following class methods are used to initialise this:</p> <ul> <li>TemplateLink.from_link to create this   from a raw template link.</li> <li>TemplateLink.find to find the first template   link in a string.</li> <li>TemplateLink.find_iter to iterate over   the template links in a string.</li> </ul>"},{"location":"reference/links/#yuyo.links.TemplateLink.code","title":"code  <code>property</code>","text":"<pre><code>code\n</code></pre> <p>The template's code.</p>"},{"location":"reference/links/#yuyo.links.TemplateLink.__str__","title":"__str__","text":"<pre><code>__str__()\n</code></pre> <p>Create a raw string representation of this link.</p>"},{"location":"reference/links/#yuyo.links.TemplateLink.fetch_template","title":"fetch_template  <code>async</code>","text":"<pre><code>fetch_template()\n</code></pre> <p>Fetch the guild template this links to.</p> <p>Returns:</p> <ul> <li> <code>Template</code>           \u2013            <p>Object of the guild template this links to.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NotFoundError</code>             \u2013            <p>If the template was not found.</p> </li> <li> <code>UnauthorizedError</code>             \u2013            <p>If you are unauthorized to make the request (invalid/missing token).</p> </li> <li> <code>RateLimitTooLongError</code>             \u2013            <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> </li> <li> <code>InternalServerError</code>             \u2013            <p>If an internal error occurs on Discord while handling the request.</p> </li> </ul>"},{"location":"reference/links/#yuyo.links.TemplateLink.find","title":"find  <code>classmethod</code>","text":"<pre><code>find(app, content)\n</code></pre> <p>Find the first link in a string.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>RESTAware</code>)           \u2013            <p>The Hikari bot or REST app this should be bound to.</p> </li> <li> <code>content</code>               (<code>str</code>)           \u2013            <p>The string to search in.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self | None</code>           \u2013            <p>Object of the found link or None.</p> </li> </ul>"},{"location":"reference/links/#yuyo.links.TemplateLink.find_iter","title":"find_iter  <code>classmethod</code>","text":"<pre><code>find_iter(app, content)\n</code></pre> <p>Iterate over the links in a string.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>RESTAware</code>)           \u2013            <p>The Hikari bot or REST app this should be bound to.</p> </li> <li> <code>content</code>               (<code>str</code>)           \u2013            <p>The string to search in.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[Self]</code>           \u2013            <p>Iterator of the link objects in the passed string.</p> </li> </ul>"},{"location":"reference/links/#yuyo.links.TemplateLink.from_link","title":"from_link  <code>classmethod</code>","text":"<pre><code>from_link(app, link)\n</code></pre> <p>Create a link object from a raw link.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>RESTAware</code>)           \u2013            <p>The Hikari bot or REST app this should be bound to.</p> </li> <li> <code>link</code>               (<code>str</code>)           \u2013            <p>The string link to use.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The created link object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the string doesn't match the expected link format.</p> </li> </ul>"},{"location":"reference/links/#yuyo.links.WebhookLink","title":"WebhookLink  <code>dataclass</code>","text":"<p>               Bases: <code>ExecutableWebhook</code>, <code>BaseLink</code></p> <p>Represents a link to an incoming webhook.</p> <p>The following class methods are used to initialise this:</p> <ul> <li>WebhookLink.from_link to create this   from a raw webhook link.</li> <li>WebhookLink.find to find the first webhook   link in a string.</li> <li>WebhookLink.find_iter to iterate over   the webhook links in a string.</li> </ul>"},{"location":"reference/links/#yuyo.links.WebhookLink.app","title":"app  <code>property</code>","text":"<pre><code>app\n</code></pre> <p>The bot or REST client this is bound to.</p>"},{"location":"reference/links/#yuyo.links.WebhookLink.token","title":"token  <code>property</code>","text":"<pre><code>token\n</code></pre> <p>The webhook's token.</p>"},{"location":"reference/links/#yuyo.links.WebhookLink.webhook_id","title":"webhook_id  <code>property</code>","text":"<pre><code>webhook_id\n</code></pre> <p>ID of the webhook this links to.</p>"},{"location":"reference/links/#yuyo.links.WebhookLink.__str__","title":"__str__","text":"<pre><code>__str__()\n</code></pre> <p>Create a raw string representation of this link.</p>"},{"location":"reference/links/#yuyo.links.WebhookLink.fetch_webhook","title":"fetch_webhook  <code>async</code>","text":"<pre><code>fetch_webhook()\n</code></pre> <p>Fetch the incoming webhook this links to.</p> <p>Returns:</p> <ul> <li> <code>IncomingWebhook</code>           \u2013            <p>Object of the incoming webhook this links to.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>UnauthorizedError</code>             \u2013            <p>If you are unauthorized to make the request (invalid/missing token).</p> </li> <li> <code>NotFoundError</code>             \u2013            <p>If the webhook is not found.</p> </li> <li> <code>RateLimitTooLongError</code>             \u2013            <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> </li> <li> <code>InternalServerError</code>             \u2013            <p>If an internal error occurs on Discord while handling the request.</p> </li> </ul>"},{"location":"reference/links/#yuyo.links.WebhookLink.find","title":"find  <code>classmethod</code>","text":"<pre><code>find(app, content)\n</code></pre> <p>Find the first link in a string.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>RESTAware</code>)           \u2013            <p>The Hikari bot or REST app this should be bound to.</p> </li> <li> <code>content</code>               (<code>str</code>)           \u2013            <p>The string to search in.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self | None</code>           \u2013            <p>Object of the found link or None.</p> </li> </ul>"},{"location":"reference/links/#yuyo.links.WebhookLink.find_iter","title":"find_iter  <code>classmethod</code>","text":"<pre><code>find_iter(app, content)\n</code></pre> <p>Iterate over the links in a string.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>RESTAware</code>)           \u2013            <p>The Hikari bot or REST app this should be bound to.</p> </li> <li> <code>content</code>               (<code>str</code>)           \u2013            <p>The string to search in.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[Self]</code>           \u2013            <p>Iterator of the link objects in the passed string.</p> </li> </ul>"},{"location":"reference/links/#yuyo.links.WebhookLink.from_link","title":"from_link  <code>classmethod</code>","text":"<pre><code>from_link(app, link)\n</code></pre> <p>Create a link object from a raw link.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>RESTAware</code>)           \u2013            <p>The Hikari bot or REST app this should be bound to.</p> </li> <li> <code>link</code>               (<code>str</code>)           \u2013            <p>The string link to use.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The created link object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the string doesn't match the expected link format.</p> </li> </ul>"},{"location":"reference/links/#yuyo.links.make_bot_invite","title":"make_bot_invite","text":"<pre><code>make_bot_invite(client, /, *, disable_guild_select=None, guild=None, permissions=hikari.Permissions.NONE)\n</code></pre> <p>Create a Bot invite url.</p> <p>Parameters:</p> <ul> <li> <code>client</code>               (<code>SnowflakeishOr[PartialApplication]</code>)           \u2013            <p>Object or ID of the application to make an invite link for.</p> </li> <li> <code>disable_guild_select</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether users should be prevented from changing the pre-selected guild.</p> <p>This only works properly when <code>guild</code> is also passed.</p> </li> <li> <code>guild</code>               (<code>SnowflakeishOr[PartialGuild] | None</code>, default:                   <code>None</code> )           \u2013            <p>Object or ID of a guild to pre-select for the user.</p> </li> <li> <code>permissions</code>               (<code>Permissions | int | None</code>, default:                   <code>NONE</code> )           \u2013            <p>The permissions the bot is requesting.</p> <p>Defaults to requesting a role with no permissions.</p> <p>Passing None here will lead to no role being created for the bot.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The created bot invite.</p> </li> </ul>"},{"location":"reference/links/#yuyo.links.make_channel_link","title":"make_channel_link","text":"<pre><code>make_channel_link(channel, /, *, guild=None)\n</code></pre> <p>Make a raw link for a channel.</p> <p>Parameters:</p> <ul> <li> <code>channel</code>               (<code>SnowflakeishOr[PartialChannel]</code>)           \u2013            <p>Object or ID of the channel to link to.</p> </li> <li> <code>guild</code>               (<code>SnowflakeishOr[PartialGuild] | None</code>, default:                   <code>None</code> )           \u2013            <p>Object or ID of the guild the channel is in.</p> <p>This should be provided for guild links.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The raw channel link.</p> </li> </ul>"},{"location":"reference/links/#yuyo.links.make_invite_link","title":"make_invite_link","text":"<pre><code>make_invite_link(invite)\n</code></pre> <p>Make a raw link for an invite.</p> <p>Parameters:</p> <ul> <li> <code>invite</code>               (<code>str | InviteCode</code>)           \u2013            <p>Object or string code of the invite to make a raw link for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The raw invite link.</p> </li> </ul>"},{"location":"reference/links/#yuyo.links.make_message_link","title":"make_message_link","text":"<pre><code>make_message_link(channel, message, /, *, guild=None)\n</code></pre> <p>Make a raw link for a message.</p> <p>Parameters:</p> <ul> <li> <code>channel</code>               (<code>SnowflakeishOr[PartialChannel]</code>)           \u2013            <p>Object or ID of the channel the message is in.</p> </li> <li> <code>message</code>               (<code>SnowflakeishOr[PartialMessage]</code>)           \u2013            <p>Object or ID of the message to link to.</p> </li> <li> <code>guild</code>               (<code>SnowflakeishOr[PartialGuild] | None</code>, default:                   <code>None</code> )           \u2013            <p>Object or ID of the guild the message is in.</p> <p>This should be provided for messages in guilds.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The raw message link.</p> </li> </ul>"},{"location":"reference/links/#yuyo.links.make_oauth_link","title":"make_oauth_link","text":"<pre><code>make_oauth_link(client, scopes, /, *, disable_guild_select=None, guild=None, permissions=None, prompt=None, redirect_uri=None, response_type=None, state=None)\n</code></pre> <p>Create an Oauth2 authorize link.</p> <p>For more information on how Discord's Oauth2 system works see https://discord.com/developers/docs/topics/oauth2.</p> <p>Warning</p> <p><code>response_type</code> and <code>redirect_uri</code> are usually required.</p> <p>Parameters:</p> <ul> <li> <code>client</code>               (<code>SnowflakeishOr[PartialApplication]</code>)           \u2013            <p>Object or ID of the application this Oauth2 application is for.</p> </li> <li> <code>scopes</code>               (<code>Sequence[OAuth2Scope | str]</code>)           \u2013            <p>The Oauth2 scopes being requested.</p> </li> <li> <code>disable_guild_select</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether users should be prevented from changing the pre-selected guild.</p> <p>This only works properly when <code>guild</code> is also passed.</p> </li> <li> <code>guild</code>               (<code>SnowflakeishOr[PartialGuild] | None</code>, default:                   <code>None</code> )           \u2013            <p>Object or ID of a guild to pre-select for the user.</p> <p>This is only relevant when the <code>\"bot\"</code> scope is being requested.</p> </li> <li> <code>permissions</code>               (<code>Permissions | int | None</code>, default:                   <code>None</code> )           \u2013            <p>The permissions the bot is requesting.</p> <p>This is only relevant when the <code>\"bot\"</code> scope is being requested.</p> </li> <li> <code>prompt</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>How to handles existing authorization.</p> <p>For more information see https://discord.com/developers/docs/topics/oauth2#authorization-code-grant-authorization-url-example.</p> </li> <li> <code>redirect_uri</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>URI the user should be redirected to with the authorised access information.</p> </li> <li> <code>response_type</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The type of Oauth2 flow being initiated.</p> <p>This will likely either be <code>\"code\"</code> (Authorization Code Grant) or <code>\"token\"</code> (Implicit Grant).</p> </li> <li> <code>state</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A request-unique state generated for security purposes.</p> <p>For more information see https://discord.com/developers/docs/topics/oauth2#state-and-security.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The created Oauth2 authorize link.</p> </li> </ul>"},{"location":"reference/links/#yuyo.links.make_template_link","title":"make_template_link","text":"<pre><code>make_template_link(template)\n</code></pre> <p>Make a raw link for a guild template.</p> <p>Parameters:</p> <ul> <li> <code>template</code>               (<code>Template | str</code>)           \u2013            <p>Object or string code of the template to make a raw link to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The raw template link.</p> </li> </ul>"},{"location":"reference/links/#yuyo.links.make_webhook_link","title":"make_webhook_link","text":"<pre><code>make_webhook_link(webhook, token)\n</code></pre> <p>Make a raw link for an incoming webhook.</p> <p>Parameters:</p> <ul> <li> <code>webhook</code>               (<code>SnowflakeishOr[PartialWebhook]</code>)           \u2013            <p>Object or ID of the webhook to make a link for.</p> </li> <li> <code>token</code>               (<code>str</code>)           \u2013            <p>The webhook's token.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The raw webhook link.</p> </li> </ul>"},{"location":"reference/list_status/","title":"yuyo.list_status","text":"<p>Utility classes for updating a bot's guild count on several bot list services.</p>"},{"location":"reference/list_status/#yuyo.list_status.ServiceSig","title":"ServiceSig  <code>module-attribute</code>","text":"<pre><code>ServiceSig = Callable[['AbstractManager'], Coroutine[Any, Any, None]]\n</code></pre> <p>Signature of a callback used to update a service.</p>"},{"location":"reference/list_status/#yuyo.list_status.AbstractCountStrategy","title":"AbstractCountStrategy","text":"<p>               Bases: <code>ABC</code></p> <p>Protocol of a class used for calculating the bot's guild count.</p>"},{"location":"reference/list_status/#yuyo.list_status.AbstractCountStrategy.is_shard_bound","title":"is_shard_bound  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>is_shard_bound\n</code></pre> <p>Whether this count is just for the current shards.</p>"},{"location":"reference/list_status/#yuyo.list_status.AbstractCountStrategy.close","title":"close  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Close the counter.</p>"},{"location":"reference/list_status/#yuyo.list_status.AbstractCountStrategy.count","title":"count  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>count()\n</code></pre> <p>Get a possibly cached guild count from this counter.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The current guild count(s).</p> <p>If this is an int then this is a global count. If this is a mapping then this is shard-specific counts.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>CountUnknownError</code>             \u2013            <p>If the count is currently unknown.</p> </li> </ul>"},{"location":"reference/list_status/#yuyo.list_status.AbstractCountStrategy.open","title":"open  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>open()\n</code></pre> <p>Open the counter.</p>"},{"location":"reference/list_status/#yuyo.list_status.AbstractManager","title":"AbstractManager","text":"<p>               Bases: <code>Protocol</code></p> <p>Abstract class used for managing services.</p>"},{"location":"reference/list_status/#yuyo.list_status.AbstractManager.cache","title":"cache  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>cache\n</code></pre> <p>The cache service this manager is bound to.</p>"},{"location":"reference/list_status/#yuyo.list_status.AbstractManager.counter","title":"counter  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>counter\n</code></pre> <p>The country strategy this manager was initialised with.</p>"},{"location":"reference/list_status/#yuyo.list_status.AbstractManager.event_manager","title":"event_manager  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>event_manager\n</code></pre> <p>The event manager this manager is bound to.</p>"},{"location":"reference/list_status/#yuyo.list_status.AbstractManager.rest","title":"rest  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>rest\n</code></pre> <p>The REST client this manager is bound to.</p>"},{"location":"reference/list_status/#yuyo.list_status.AbstractManager.shards","title":"shards  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>shards\n</code></pre> <p>The shard aware client this manager is bound to.</p>"},{"location":"reference/list_status/#yuyo.list_status.AbstractManager.user_agent","title":"user_agent  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>user_agent\n</code></pre> <p>User agent services within this manager should use for requests.</p>"},{"location":"reference/list_status/#yuyo.list_status.AbstractManager.get_me","title":"get_me  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get_me()\n</code></pre> <p>Get user object of the bot this manager is bound to.</p> <p>Returns:</p> <ul> <li> <code>User</code>           \u2013            <p>User object of the bot this manager is bound to.</p> </li> </ul>"},{"location":"reference/list_status/#yuyo.list_status.AbstractManager.get_session","title":"get_session  <code>abstractmethod</code>","text":"<pre><code>get_session()\n</code></pre> <p>Get an aiohttp session to use to make requests within the services.</p> <p>Returns:</p> <ul> <li> <code>ClientSession</code>           \u2013            <p>an aiohttp session to use to make requests within the services.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <ul> <li>If this is called in an environment with no running event loop.</li> <li>If the client isn't running.</li> </ul> </li> </ul>"},{"location":"reference/list_status/#yuyo.list_status.BotsGGService","title":"BotsGGService","text":"<p>https://discord.bots.gg status update service.</p>"},{"location":"reference/list_status/#yuyo.list_status.BotsGGService.__init__","title":"__init__","text":"<pre><code>__init__(token)\n</code></pre> <p>Initialise a bots.gg service.</p> <p>Parameters:</p> <ul> <li> <code>token</code>               (<code>str</code>)           \u2013            <p>Authorization token used to update the bot's status.</p> </li> </ul>"},{"location":"reference/list_status/#yuyo.list_status.CacheStrategy","title":"CacheStrategy","text":"<p>               Bases: <code>_LoadableStrategy</code></p> <p>Cache based implementation of AbstractCountStrategy.</p> <p>This tracks per-shard guild counts.</p> <p>Warning</p> <p>This will only function properly if GUILD intents are declared and the guild cache resource is enabled.</p>"},{"location":"reference/list_status/#yuyo.list_status.CacheStrategy.__init__","title":"__init__","text":"<pre><code>__init__(cache, shards)\n</code></pre> <p>Initialise a cache strategy.</p> <p>Parameters:</p> <ul> <li> <code>cache</code>               (<code>Cache</code>)           \u2013            <p>The cache object this should use for getting the guild count.</p> </li> <li> <code>shards</code>               (<code>ShardAware</code>)           \u2013            <p>The shard aware client this should use for grouping counts per-shard.</p> </li> </ul>"},{"location":"reference/list_status/#yuyo.list_status.CountUnknownError","title":"CountUnknownError","text":"<p>               Bases: <code>RuntimeError</code></p> <p>Error raised when the count is currently unknown.</p>"},{"location":"reference/list_status/#yuyo.list_status.DiscordBotListService","title":"DiscordBotListService","text":"<p>https://discordbotlist.com status update service.</p>"},{"location":"reference/list_status/#yuyo.list_status.DiscordBotListService.__init__","title":"__init__","text":"<pre><code>__init__(token)\n</code></pre> <p>Initialise a discordbotlist.com service.</p> <p>Parameters:</p> <ul> <li> <code>token</code>               (<code>str</code>)           \u2013            <p>Authorization token used to update the bot's status.</p> </li> </ul>"},{"location":"reference/list_status/#yuyo.list_status.EventStrategy","title":"EventStrategy","text":"<p>               Bases: <code>_LoadableStrategy</code></p> <p>Cache based implementation of AbstractCountStrategy.</p> <p>This tracks per-guild counts.</p> <p>Warning</p> <p>This will only function properly if GUILD intents are declared.</p>"},{"location":"reference/list_status/#yuyo.list_status.EventStrategy.__init__","title":"__init__","text":"<pre><code>__init__(event_manager, shards)\n</code></pre> <p>Initialise an event etrategy.</p> <p>Note</p> <p>You usually won't need to initialise this yourself as ServiceManager will automatically pick this strategy if the bot config matches it.</p> <p>Parameters:</p> <ul> <li> <code>event_manager</code>               (<code>EventManager</code>)           \u2013            <p>The event manager this should use to track shard guild counts.</p> </li> <li> <code>shards</code>               (<code>ShardAware</code>)           \u2013            <p>The shard manager this should use to track shard guild counts.</p> </li> </ul>"},{"location":"reference/list_status/#yuyo.list_status.SakeStrategy","title":"SakeStrategy","text":"<p>               Bases: <code>AbstractCountStrategy</code></p> <p>Async cache based implementation of AbstractCountStrategy.</p> <p>This relies on Sake and tracks the global guild count.</p>"},{"location":"reference/list_status/#yuyo.list_status.SakeStrategy.__init__","title":"__init__","text":"<pre><code>__init__(cache)\n</code></pre> <p>Initialise a Sake strategy.</p> <p>Unlike CacheStrategy and EventStrategy this strategy must be directly initialised and passed to ServiceManager.__init__ as <code>strategy=</code>.</p> <p>Parameters:</p> <ul> <li> <code>cache</code>               (<code>GuildCache</code>)           \u2013            <p>The Sake guild cache to use to get the guild count.</p> </li> </ul>"},{"location":"reference/list_status/#yuyo.list_status.ServiceManager","title":"ServiceManager","text":"<p>               Bases: <code>AbstractManager</code></p> <p>Standard service manager.</p>"},{"location":"reference/list_status/#yuyo.list_status.ServiceManager.is_alive","title":"is_alive  <code>property</code>","text":"<pre><code>is_alive\n</code></pre> <p>Wwhether this manager is active.</p>"},{"location":"reference/list_status/#yuyo.list_status.ServiceManager.__init__","title":"__init__","text":"<pre><code>__init__(rest, /, *, cache=None, event_manager=None, shards=None, event_managed=None, strategy=None, user_agent=None)\n</code></pre> <p>Initialise a service manager.</p> <p>Note</p> <p>For an easier way to initialise the manager from a bot see ServiceManager.from_gateway_bot, and ServiceManager.from_tanjun.</p> <p>Parameters:</p> <ul> <li> <code>rest</code>               (<code>RESTClient</code>)           \u2013            <p>The RESTAware Hikari client to bind this manager to.</p> </li> <li> <code>cache</code>               (<code>Cache | None</code>, default:                   <code>None</code> )           \u2013            <p>The cache aware Hikari client this manager should use.</p> </li> <li> <code>event_manager</code>               (<code>EventManager | None</code>, default:                   <code>None</code> )           \u2013            <p>The event manager aware Hikari client this manager should use.</p> </li> <li> <code>shards</code>               (<code>ShardAware | None</code>, default:                   <code>None</code> )           \u2013            <p>The shard aware Hikari client this manager should use.</p> </li> <li> <code>event_managed</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether this client should be automatically opened and closed based on <code>event_manager</code>'s lifetime events.</p> <p>Defaults to True when <code>event_manager</code> is passed.</p> </li> <li> <code>strategy</code>               (<code>AbstractCountStrategy | None</code>, default:                   <code>None</code> )           \u2013            <p>The counter strategy this manager should expose to services.</p> <p>If this is left as None then the manager will try to pick a suitable standard strategy based on the provided Hikari clients.</p> </li> <li> <code>user_agent</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Override the standard user agent used during requests to bot list services.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the manager failed to find a suitable standard strategy to use when <code>strategy</code> was left as None.</p> <p>If <code>event_managed</code> is passed as True when <code>event_manager</code> is None.</p> </li> </ul>"},{"location":"reference/list_status/#yuyo.list_status.ServiceManager.add_service","title":"add_service","text":"<pre><code>add_service(service, /, *, repeat=datetime.timedelta(hours=1))\n</code></pre> <p>Add a service to this manager.</p> <p>Parameters:</p> <ul> <li> <code>service</code>               (<code>ServiceSig</code>)           \u2013            <p>Asynchronous callback used to update this service.</p> </li> <li> <code>repeat</code>               (<code>timedelta | int | float</code>, default:                   <code>timedelta(hours=1)</code> )           \u2013            <p>How often this service should be updated in seconds.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>Object of this service manager.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If repeat is less than 1 second.</p> </li> <li> <code>RuntimeError</code>             \u2013            <p>If the client is already running.</p> </li> </ul>"},{"location":"reference/list_status/#yuyo.list_status.ServiceManager.close","title":"close  <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Close this manager.</p>"},{"location":"reference/list_status/#yuyo.list_status.ServiceManager.from_gateway_bot","title":"from_gateway_bot  <code>classmethod</code>","text":"<pre><code>from_gateway_bot(bot, /, *, event_managed=True, strategy=None, user_agent=None)\n</code></pre> <p>Build a service manager from a gateway bot.</p> <p>Parameters:</p> <ul> <li> <code>bot</code>               (<code>ShardAware &amp; RESTAware &amp; EventManagerAware</code>)           \u2013            <p>The gateway bot to build a service manager from.</p> </li> <li> <code>event_managed</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether this client should be automatically opened and closed based on <code>bot</code>'s lifetime events.</p> </li> <li> <code>strategy</code>               (<code>AbstractCountStrategy | None</code>, default:                   <code>None</code> )           \u2013            <p>The counter strategy this manager should expose to services.</p> <p>If this is left as None then the manager will try to pick a suitable standard strategy based on the provided Hikari clients.</p> </li> <li> <code>user_agent</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Override the standard user agent used during requests to bot list services.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ServiceManager</code>           \u2013            <p>The build service manager.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the manager failed to find a suitable standard strategy to use when <code>strategy</code> was left as None.</p> </li> </ul>"},{"location":"reference/list_status/#yuyo.list_status.ServiceManager.from_tanjun","title":"from_tanjun  <code>classmethod</code>","text":"<pre><code>from_tanjun(tanjun_client, /, *, tanjun_managed=True, strategy=None, user_agent=None)\n</code></pre> <p>Build a service manager from a Tanjun client.</p> <p>This will use the Tanjun client's alluka client and registers ServiceManager and AbstractManager as type dependencies on Tanjun.</p> <p>Parameters:</p> <ul> <li> <code>tanjun_client</code>               (<code>Client</code>)           \u2013            <p>The Tanjun client to build a service manager from.</p> </li> <li> <code>tanjun_managed</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether this client should be automatically opened and closed based on the Tanjun client's lifetime client callback.</p> </li> <li> <code>strategy</code>               (<code>AbstractCountStrategy | None</code>, default:                   <code>None</code> )           \u2013            <p>The counter strategy this manager should expose to services.</p> <p>If this is left as None then the manager will try to pick a suitable standard strategy based on the provided Hikari clients.</p> </li> <li> <code>user_agent</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Override the standard user agent used during requests to bot list services.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ServiceManager</code>           \u2013            <p>The build service manager.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the manager failed to find a suitable standard strategy to use when <code>strategy</code> was left as None.</p> </li> </ul>"},{"location":"reference/list_status/#yuyo.list_status.ServiceManager.open","title":"open  <code>async</code>","text":"<pre><code>open()\n</code></pre> <p>Start this manager.</p> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If this manager is already running.</p> </li> </ul>"},{"location":"reference/list_status/#yuyo.list_status.ServiceManager.remove_service","title":"remove_service","text":"<pre><code>remove_service(service)\n</code></pre> <p>Remove the first found entry of the registered service.</p> <p>Parameters:</p> <ul> <li> <code>service</code>               (<code>ServiceSig</code>)           \u2013            <p>Service callback to unregister.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If called while the manager is active.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If the service callback isn't found.</p> </li> </ul>"},{"location":"reference/list_status/#yuyo.list_status.ServiceManager.with_service","title":"with_service","text":"<pre><code>with_service(*, repeat=datetime.timedelta(hours=1))\n</code></pre> <p>Add a service to this manager by decorating a function.</p> <p>Parameters:</p> <ul> <li> <code>repeat</code>               (<code>timedelta | int | float</code>, default:                   <code>timedelta(hours=1)</code> )           \u2013            <p>How often this service should be updated in seconds.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable[[ServiceSig], ServiceSig]</code>           \u2013            <p>Decorator callback used to add a service.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If repeat is less than 1 second.</p> </li> <li> <code>RuntimeError</code>             \u2013            <p>If the client is already running.</p> </li> </ul>"},{"location":"reference/list_status/#yuyo.list_status.TopGGService","title":"TopGGService","text":"<p>https://top.gg status update service.</p>"},{"location":"reference/list_status/#yuyo.list_status.TopGGService.__init__","title":"__init__","text":"<pre><code>__init__(token)\n</code></pre> <p>Initialise a top.gg service.</p> <p>Parameters:</p> <ul> <li> <code>token</code>               (<code>str</code>)           \u2013            <p>Authorization token used to update the bot's status.</p> </li> </ul>"},{"location":"reference/list_status/#yuyo.list_status._InvalidStrategyError","title":"_InvalidStrategyError","text":"<p>               Bases: <code>TypeError</code></p> <p>Error raised by spawn when the strategy isn't valid for the provided manager.</p>"},{"location":"reference/list_status/#yuyo.list_status._LoadableStrategy","title":"_LoadableStrategy","text":"<p>               Bases: <code>AbstractCountStrategy</code>, <code>ABC</code></p> <p>ABC of a count strategy which can be automatically loaded.</p>"},{"location":"reference/list_status/#yuyo.list_status._LoadableStrategy.is_shard_bound","title":"is_shard_bound  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>is_shard_bound\n</code></pre> <p>Whether this count is just for the current shards.</p>"},{"location":"reference/list_status/#yuyo.list_status._LoadableStrategy.close","title":"close  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Close the counter.</p>"},{"location":"reference/list_status/#yuyo.list_status._LoadableStrategy.count","title":"count  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>count()\n</code></pre> <p>Get a possibly cached guild count from this counter.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The current guild count(s).</p> <p>If this is an int then this is a global count. If this is a mapping then this is shard-specific counts.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>CountUnknownError</code>             \u2013            <p>If the count is currently unknown.</p> </li> </ul>"},{"location":"reference/list_status/#yuyo.list_status._LoadableStrategy.open","title":"open  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>open()\n</code></pre> <p>Open the counter.</p>"},{"location":"reference/list_status/#yuyo.list_status._LoadableStrategy.spawn","title":"spawn  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>spawn(manager)\n</code></pre> <p>Spawn a counter for a specific manager.</p> <p>Parameters:</p> <ul> <li> <code>manager</code>               (<code>AbstractManager</code>)           \u2013            <p>Object of the manager this counter is being spawned for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The spawned counter.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>_InvalidStrategyError</code>             \u2013            <p>If this strategy wouldn't be able to accurately get a guild count with the provided manager and it's resources.</p> </li> </ul>"},{"location":"reference/modals/","title":"yuyo.modals","text":"<p>Higher level client for modal execution.</p>"},{"location":"reference/modals/#yuyo.modals.Client","title":"Client  <code>module-attribute</code>","text":"<pre><code>Client = ModalClient\n</code></pre> <p>Alias of ModalClient.</p>"},{"location":"reference/modals/#yuyo.modals.Context","title":"Context  <code>module-attribute</code>","text":"<pre><code>Context = ModalContext\n</code></pre> <p>Alias of ModalContext.</p>"},{"location":"reference/modals/#yuyo.modals.NO_DEFAULT","title":"NO_DEFAULT  <code>module-attribute</code>","text":"<pre><code>NO_DEFAULT = VALUE\n</code></pre> <p>Singleton used to signify when a field has no default.</p>"},{"location":"reference/modals/#yuyo.modals.WaitFor","title":"WaitFor  <code>module-attribute</code>","text":"<pre><code>WaitFor = WaitForModal\n</code></pre> <p>Alias of WaitForModal.</p>"},{"location":"reference/modals/#yuyo.modals._ModalResponseT","title":"_ModalResponseT  <code>module-attribute</code>","text":"<pre><code>_ModalResponseT = InteractionMessageBuilder | InteractionDeferredBuilder\n</code></pre> <p>Type hint of the builder response types allows for modal interactions.</p>"},{"location":"reference/modals/#yuyo.modals.AbstractModal","title":"AbstractModal","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for a modal execution handler.</p>"},{"location":"reference/modals/#yuyo.modals.AbstractModal.execute","title":"execute  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>execute(ctx)\n</code></pre> <p>Execute this modal.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The context to execute this with.</p> </li> </ul>"},{"location":"reference/modals/#yuyo.modals.Modal","title":"Modal","text":"<p>               Bases: <code>AbstractModal</code></p> <p>Standard implementation of a modal executor.</p> <p>To send this modal pass Modal.rows as <code>components</code> when calling <code>create_modal_response</code>.</p> <p>Examples:</p> <p>There's a few different ways this can be used to create a modal.</p> <p>Sub-components can be added to an instance of a modal using chainable methods:</p> <pre><code>async def callback(\n    ctx: modals.Context, field: str, other_field: str | None\n) -&gt; None:\n    await ctx.respond(\"hi\")\n\nmodal = (\n    modals.modal(callback, ephemeral_default=True)\n    .add_text_input(\"Title A\", parameter=\"field\")\n    .add_text_input(\n        \"Title B\",\n        style=hikari.TextInputStyle.PARAGRAPH,\n        parameter=\"other_field\",\n        default=None,\n    )\n)\n</code></pre> <p>or using decorator methods:</p> <pre><code>@modals.with_text_input(\n    \"Title B\",\n    style=hikari.TextInputStyle.PARAGRAPH,\n    parameter=\"other_field\",\n    default=None,\n)\n@modals.with_text_input(\"Title A\", parameter=\"field\")\n@modals.as_modal(ephemeral_default=True)\nasync def callback(\n    ctx: modals.Context, field: str, other_field: str | None\n) -&gt; None:\n    await ctx.respond(\"bye\")\n</code></pre> <p>Note</p> <p>Since decorators are executed from the bottom upwards fields added through decorator calls will follow the same order.</p> <p>Subclasses of Modal can act as a template where \"static\" fields are included on all instances and subclasses of that class:</p> <pre><code>@modals.with_static_text_input(\n    \"Title B\",\n    style=hikari.TextInputStyle.PARAGRAPH,\n    parameter=\"other_field\",\n    default=None,\n)\n@modals.with_static_text_input(\"Title A\", parameter=\"field\")\nclass CustomModal(modals.Modal):\n    # The init can be overridden to store extra data on the column object when subclassing.\n    def __init__(self, special_string: str, ephemeral_default: bool = False):\n        super().__init__(ephemeral_default=ephemeral_default)\n        self.special_string = special_string\n\n    async def callback(\n        ctx: modals.Context,\n        field: str,\n        other_field: str | None,\n        value: str\n    ) -&gt; None:\n        await ctx.respond(\"Good job\")\n</code></pre> <p>Templates can be made by subclassing Modal and defining the method <code>callback</code> for handling context  menu execution (this must be valid for the signature signature <code>(modals.Context, ...) -&gt; Coroutine[Any, Any, None]</code>).</p> <pre><code>@modals.with_static_text_input(\n    \"Title B\",\n    style=hikari.TextInputStyle.PARAGRAPH,\n    parameter=\"other_field\",\n    default=None,\n)\n@modals.with_static_text_input(\"Title A\", parameter=\"field\")\n@modals.as_modal_template\nasync def custom_modal(\n    ctx: modals.Context,\n    field: str,\n    other_field: str | None,\n    value: str,\n) -&gt; None:\n    await ctx.respond(\"Bye\")\n</code></pre> <p>or by using as_modal_template (which returns a class which functions like a Modal subclass) The chainable <code>add_static_{}()</code> classmethods can also be used to add static fields to a Modal subclass.</p> <p>Modals also support declaring entries using the following parameter descriptors:</p> <ul> <li>text_input</li> </ul> <pre><code>class ModalOptions(modals.ModalOptions):\n    foo: str = modals.text_input(\"label\")\n    bar: str | None = modals.text_unput(\n        \"label\", style=hikari.TextInputStyle.PARAGRAPH, default=None\n    )\n\n@yuyo.modals.as_modal_template\nasync def callback(\n    ctx: modals.Context,\n    options: ModalOptions,\n    field: str = modals.text_input(\"label\", value=\"yeet\")\n)\n</code></pre> <p>These can either be applied to the default of an argument or defined as an attribute on a ModalOptions subclass ( <code>ModalOptions</code> should then be used as an argument's type-hint). This also works for Modal subclasses which have a <code>Modal.callback</code> method.</p>"},{"location":"reference/modals/#yuyo.modals.Modal.rows","title":"rows  <code>property</code>","text":"<pre><code>rows\n</code></pre> <p>Builder objects of the rows in this modal.</p>"},{"location":"reference/modals/#yuyo.modals.Modal.__init__","title":"__init__","text":"<pre><code>__init__(*, ephemeral_default=False, id_metadata=None)\n</code></pre> <p>Initialise a component executor.</p> <p>Parameters:</p> <ul> <li> <code>ephemeral_default</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this executor's responses should default to being ephemeral.</p> </li> <li> <code>id_metadata</code>               (<code>Mapping[str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Mapping of metadata to append to the custom IDs in this modal.</p> <p>The keys should be the match part of field custom IDs.</p> </li> </ul>"},{"location":"reference/modals/#yuyo.modals.Modal.add_static_text_input","title":"add_static_text_input  <code>classmethod</code>","text":"<pre><code>add_static_text_input(label, /, *, custom_id=None, style=hikari.TextInputStyle.SHORT, placeholder=hikari.UNDEFINED, value=hikari.UNDEFINED, default=NO_DEFAULT, min_length=0, max_length=4000, parameter=None)\n</code></pre> <p>Add a text input field to all instances and subclasses of this modal class.</p> <p>Parameters:</p> <ul> <li> <code>label</code>               (<code>str</code>)           \u2013            <p>The text input field's display label.</p> <p>This cannot be greater than 45 characters long.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The field's custom ID.</p> <p>Defaults to <code>parameter</code>, if provided, or a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>style</code>               (<code>TextInputStyle</code>, default:                   <code>SHORT</code> )           \u2013            <p>The text input's style.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to display when the text input is empty.</p> </li> <li> <code>value</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Default text to pre-fill the field with.</p> </li> <li> <code>default</code>               (<code>Any</code>, default:                   <code>NO_DEFAULT</code> )           \u2013            <p>Default value to pass if this text input field was not provided.</p> <p>The field will be marked as required unless this is supplied.</p> <p>This will also be used for <code>value</code> when it has been left undefined and the default is a string that's &lt;=4000 characters in length.</p> </li> <li> <code>min_length</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Minimum length the input text can be.</p> <p>This can be greater than or equal to 0 and less than or equal to 4000.</p> </li> <li> <code>max_length</code>               (<code>int</code>, default:                   <code>4000</code> )           \u2013            <p>Maximum length the input text can be.</p> <p>This can be greater than or equal to 1 and less than or equal to 4000.</p> </li> <li> <code>parameter</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Name of the parameter the text for this field should be passed to.</p> <p>This will be of type str and may also be the value passed for <code>default</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[Self]</code>           \u2013            <p>The class to enable call chaining.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When called directly on Modal (rather than on a subclass).</p> </li> </ul>"},{"location":"reference/modals/#yuyo.modals.Modal.add_text_input","title":"add_text_input","text":"<pre><code>add_text_input(label, /, *, custom_id=None, style=hikari.TextInputStyle.SHORT, placeholder=hikari.UNDEFINED, value=hikari.UNDEFINED, default=NO_DEFAULT, min_length=0, max_length=4000, parameter=None)\n</code></pre> <p>Add a text input field to this modal instance.</p> <p>Parameters:</p> <ul> <li> <code>label</code>               (<code>str</code>)           \u2013            <p>The text input field's display label.</p> <p>This cannot be greater than 45 characters long.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The field's custom ID.</p> <p>Defaults to <code>parameter</code>, if provided, or a UUID and cannot be longer than 100 characters.</p> <p>Only <code>custom_id.split(\":\", 1)[0]</code> will be used to match against interactions. Anything after <code>\":\"</code> is metadata.</p> </li> <li> <code>style</code>               (<code>TextInputStyle</code>, default:                   <code>SHORT</code> )           \u2013            <p>The text input's style.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to display when the text input is empty.</p> </li> <li> <code>value</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Default text to pre-fill the field with.</p> </li> <li> <code>default</code>               (<code>Any</code>, default:                   <code>NO_DEFAULT</code> )           \u2013            <p>Default value to pass if this text input field was not provided.</p> <p>The field will be marked as required unless this is supplied.</p> <p>This will also be used for <code>value</code> when it has been left undefined and the default is a string that's &lt;=4000 characters in length.</p> </li> <li> <code>min_length</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Minimum length the input text can be.</p> <p>This can be greater than or equal to 0 and less than or equal to 4000.</p> </li> <li> <code>max_length</code>               (<code>int</code>, default:                   <code>4000</code> )           \u2013            <p>Maximum length the input text can be.</p> <p>This can be greater than or equal to 1 and less than or equal to 4000.</p> </li> <li> <code>parameter</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Name of the parameter the text for this field should be passed to.</p> <p>This will be of type str and may also be the value passed for <code>default</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The modal instance to enable call chaining.</p> </li> </ul>"},{"location":"reference/modals/#yuyo.modals.ModalClient","title":"ModalClient","text":"<p>Client used to handle modals within a REST or gateway flow.</p>"},{"location":"reference/modals/#yuyo.modals.ModalClient.alluka","title":"alluka  <code>property</code>","text":"<pre><code>alluka\n</code></pre> <p>The Alluka client being used for callback dependency injection.</p>"},{"location":"reference/modals/#yuyo.modals.ModalClient.cache","title":"cache  <code>property</code>","text":"<pre><code>cache\n</code></pre> <p>Hikari cache instance this client was initialised with.</p>"},{"location":"reference/modals/#yuyo.modals.ModalClient.events","title":"events  <code>property</code>","text":"<pre><code>events\n</code></pre> <p>Object of the event manager this client was initialised with.</p>"},{"location":"reference/modals/#yuyo.modals.ModalClient.rest","title":"rest  <code>property</code>","text":"<pre><code>rest\n</code></pre> <p>Object of the Hikari REST client this client was initialised with.</p>"},{"location":"reference/modals/#yuyo.modals.ModalClient.server","title":"server  <code>property</code>","text":"<pre><code>server\n</code></pre> <p>Object of the Hikari interaction server provided for this client.</p>"},{"location":"reference/modals/#yuyo.modals.ModalClient.shards","title":"shards  <code>property</code>","text":"<pre><code>shards\n</code></pre> <p>Object of the Hikari shard manager this client was initialised with.</p>"},{"location":"reference/modals/#yuyo.modals.ModalClient.voice","title":"voice  <code>property</code>","text":"<pre><code>voice\n</code></pre> <p>Object of the Hikari voice component this client was initialised with.</p>"},{"location":"reference/modals/#yuyo.modals.ModalClient.__init__","title":"__init__","text":"<pre><code>__init__(*, alluka=None, cache=None, event_manager=None, event_managed=None, rest=None, server=None, shards=None, voice=None)\n</code></pre> <p>Initialise a modal client.</p> <p>This registers ModalClient as a type dependency when <code>alluka</code> isn't passed.</p> <p>Note</p> <p>For an easier way to initialise the client from a bot see ModalClient.from_gateway_bot, ModalClient.from_rest_bot, and ModalClient.from_tanjun.</p> <p>Parameters:</p> <ul> <li> <code>alluka</code>               (<code>Client | None</code>, default:                   <code>None</code> )           \u2013            <p>The Alluka client to use for callback dependency injection in this client.</p> <p>If not provided then this will initialise its own Alluka client.</p> </li> <li> <code>event_manager</code>               (<code>EventManager | None</code>, default:                   <code>None</code> )           \u2013            <p>The event manager this client should listen to dispatched modal interactions from if applicable.</p> </li> <li> <code>event_managed</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether this client should be automatically opened and closed based on the lifetime events dispatched by <code>event_manager</code>.</p> <p>Defaults to True if an event manager is passed.</p> </li> <li> <code>server</code>               (<code>InteractionServer | None</code>, default:                   <code>None</code> )           \u2013            <p>The server this client should listen to modal interactions from if applicable.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>event_managed</code> is passed as True when <code>event_manager</code> is None.</p> </li> </ul>"},{"location":"reference/modals/#yuyo.modals.ModalClient.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Close the modal client.</p>"},{"location":"reference/modals/#yuyo.modals.ModalClient.deregister_modal","title":"deregister_modal","text":"<pre><code>deregister_modal(custom_id)\n</code></pre> <p>Remove the modal set for a custom ID.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str</code>)           \u2013            <p>The custom_id to unset the modal for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The modal client to allow chaining.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>If the custom_id is not registered.</p> </li> </ul>"},{"location":"reference/modals/#yuyo.modals.ModalClient.from_gateway_bot","title":"from_gateway_bot  <code>classmethod</code>","text":"<pre><code>from_gateway_bot(bot, /, *, alluka=None, event_managed=True)\n</code></pre> <p>Build a modal client from a Gateway Bot.</p> <p>This registers ModalClient as a type dependency when <code>alluka</code> isn't passed.</p> <p>Parameters:</p> <ul> <li> <code>bot</code>               (<code>_GatewayBotProto</code>)           \u2013            <p>The Gateway bot this modal client should be bound to.</p> </li> <li> <code>alluka</code>               (<code>Client | None</code>, default:                   <code>None</code> )           \u2013            <p>The Alluka client to use for callback dependency injection in this client.</p> <p>If not provided then this will initialise its own Alluka client.</p> </li> <li> <code>event_managed</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the modal client should be automatically opened and closed based on the lifetime events dispatched by <code>bot</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ModalClient</code>           \u2013            <p>The initialised modal client.</p> </li> </ul>"},{"location":"reference/modals/#yuyo.modals.ModalClient.from_rest_bot","title":"from_rest_bot  <code>classmethod</code>","text":"<pre><code>from_rest_bot(bot, /, *, alluka=None, bot_managed=False)\n</code></pre> <p>Build a modal client from a REST Bot.</p> <p>This registers ModalClient as a type dependency when <code>alluka</code> isn't passed.</p> <p>Parameters:</p> <ul> <li> <code>bot</code>               (<code>RESTBotAware</code>)           \u2013            <p>The REST bot this modal client should be bound to.</p> </li> <li> <code>alluka</code>               (<code>Client | None</code>, default:                   <code>None</code> )           \u2013            <p>The Alluka client to use for callback dependency injection in this client.</p> <p>If not provided then this will initialise its own Alluka client.</p> </li> <li> <code>bot_managed</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the modal client should be automatically opened and closed based on the Bot's startup and shutdown callbacks.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ModalClient</code>           \u2013            <p>The initialised modal client.</p> </li> </ul>"},{"location":"reference/modals/#yuyo.modals.ModalClient.from_tanjun","title":"from_tanjun  <code>classmethod</code>","text":"<pre><code>from_tanjun(tanjun_client, /, *, tanjun_managed=True)\n</code></pre> <p>Build a modal client from a Tanjun client.</p> <p>This will use the Tanjun client's alluka client and registers ModalClient as a type dependency on Tanjun.</p> <p>Parameters:</p> <ul> <li> <code>tanjun_client</code>               (<code>Client</code>)           \u2013            <p>The Tanjun client this modal client should be bound to.</p> </li> <li> <code>tanjun_managed</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the modal client should be automatically opened and closed based on the Tanjun client's lifetime client callback.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ModalClient</code>           \u2013            <p>The initialised modal client.</p> </li> </ul>"},{"location":"reference/modals/#yuyo.modals.ModalClient.get_modal","title":"get_modal","text":"<pre><code>get_modal(custom_id)\n</code></pre> <p>Get the modal set for a custom ID.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str</code>)           \u2013            <p>The custom_id to get the modal for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AbstractModal | None</code>           \u2013            <p>The callback for the custom_id, or None if it doesn't exist.</p> </li> </ul>"},{"location":"reference/modals/#yuyo.modals.ModalClient.on_gateway_event","title":"on_gateway_event  <code>async</code>","text":"<pre><code>on_gateway_event(event)\n</code></pre> <p>Process an interaction create gateway event.</p> <p>Parameters:</p> <ul> <li> <code>event</code>               (<code>InteractionCreateEvent</code>)           \u2013            <p>The interaction create gateway event to process.</p> </li> </ul>"},{"location":"reference/modals/#yuyo.modals.ModalClient.on_rest_request","title":"on_rest_request  <code>async</code>","text":"<pre><code>on_rest_request(interaction)\n</code></pre> <p>Process a modal interaction REST request.</p> <p>Parameters:</p> <ul> <li> <code>interaction</code>               (<code>ModalInteraction</code>)           \u2013            <p>The interaction to process.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>InteractionMessageBuilder | InteractionDeferredBuilder</code>           \u2013            <p>The REST response.</p> </li> </ul>"},{"location":"reference/modals/#yuyo.modals.ModalClient.open","title":"open","text":"<pre><code>open()\n</code></pre> <p>Startup the modal client.</p>"},{"location":"reference/modals/#yuyo.modals.ModalClient.register_modal","title":"register_modal","text":"<pre><code>register_modal(custom_id, modal, /, *, timeout=_internal.NO_DEFAULT)\n</code></pre> <p>Register a modal for a custom ID.</p> <p>Parameters:</p> <ul> <li> <code>custom_id</code>               (<code>str</code>)           \u2013            <p>The custom_id to register the modal for.</p> <p>This will be matched against <code>interaction.custom_id.split(\":\", 1)[0]</code>, allowing metadata to be stored after a <code>\":\"</code>.</p> </li> <li> <code>modal</code>               (<code>AbstractModal</code>)           \u2013            <p>The modal to register.</p> </li> <li> <code>timeout</code>               (<code>AbstractTimeout | None | NoDefault</code>, default:                   <code>NO_DEFAULT</code> )           \u2013            <p>Timeout strategy for this modal.</p> <p>Passing None here will set NeverTimeout.</p> <p>This defaults to single use with a 2 minute timeout.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The modal client to allow chaining.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>custom_id</code> is already registered.</p> <p>If <code>\":\"</code> is in the custom ID.</p> </li> </ul>"},{"location":"reference/modals/#yuyo.modals.ModalContext","title":"ModalContext","text":"<p>               Bases: <code>BaseContext[ModalInteraction]</code></p> <p>The context used for modal triggers.</p>"},{"location":"reference/modals/#yuyo.modals.ModalContext.alluka","title":"alluka  <code>property</code>","text":"<pre><code>alluka\n</code></pre> <p>The Alluka client being used for callback dependency injection.</p>"},{"location":"reference/modals/#yuyo.modals.ModalContext.author","title":"author  <code>property</code>","text":"<pre><code>author\n</code></pre> <p>Author of this interaction.</p>"},{"location":"reference/modals/#yuyo.modals.ModalContext.cache","title":"cache  <code>property</code>","text":"<pre><code>cache\n</code></pre> <p>Hikari cache instance this context's client was initialised with.</p>"},{"location":"reference/modals/#yuyo.modals.ModalContext.channel_id","title":"channel_id  <code>property</code>","text":"<pre><code>channel_id\n</code></pre> <p>ID of the channel this interaction was triggered in.</p>"},{"location":"reference/modals/#yuyo.modals.ModalContext.client","title":"client  <code>property</code>","text":"<pre><code>client\n</code></pre> <p>The modal this context is bound to.</p>"},{"location":"reference/modals/#yuyo.modals.ModalContext.component_ids","title":"component_ids  <code>property</code>","text":"<pre><code>component_ids\n</code></pre> <p>Mapping of match ID parts to metadata ID parts for the modal's components.</p>"},{"location":"reference/modals/#yuyo.modals.ModalContext.events","title":"events  <code>property</code>","text":"<pre><code>events\n</code></pre> <p>Object of the event manager this context's client was initialised with.</p>"},{"location":"reference/modals/#yuyo.modals.ModalContext.expires_at","title":"expires_at  <code>property</code>","text":"<pre><code>expires_at\n</code></pre> <p>When this context expires.</p> <p>After this time is reached, the message/response methods on this context will always raise hikari.NotFoundError.</p>"},{"location":"reference/modals/#yuyo.modals.ModalContext.has_been_deferred","title":"has_been_deferred  <code>property</code>","text":"<pre><code>has_been_deferred\n</code></pre> <p>Whether this context's initial response has been deferred.</p> <p>This will be true if BaseContext.defer has been called.</p>"},{"location":"reference/modals/#yuyo.modals.ModalContext.has_responded","title":"has_responded  <code>property</code>","text":"<pre><code>has_responded\n</code></pre> <p>Whether an initial response has been made to this context yet.</p> <p>It's worth noting that a context must be either responded to or deferred within 3 seconds from it being received otherwise it'll be marked as failed.</p> <p>This will be true if either BaseContext.respond, BaseContext.create_initial_response or BaseContext.edit_initial_response (after a deferral) has been called.</p>"},{"location":"reference/modals/#yuyo.modals.ModalContext.id_match","title":"id_match  <code>property</code>","text":"<pre><code>id_match\n</code></pre> <p>Section of the ID used to identify the relevant executor.</p>"},{"location":"reference/modals/#yuyo.modals.ModalContext.id_metadata","title":"id_metadata  <code>property</code>","text":"<pre><code>id_metadata\n</code></pre> <p>Metadata from the interaction's custom ID.</p>"},{"location":"reference/modals/#yuyo.modals.ModalContext.interaction","title":"interaction  <code>property</code>","text":"<pre><code>interaction\n</code></pre> <p>Object of the interaction this context is for.</p>"},{"location":"reference/modals/#yuyo.modals.ModalContext.rest","title":"rest  <code>property</code>","text":"<pre><code>rest\n</code></pre> <p>Object of the Hikari REST client this context's client was initialised with.</p>"},{"location":"reference/modals/#yuyo.modals.ModalContext.server","title":"server  <code>property</code>","text":"<pre><code>server\n</code></pre> <p>Object of the Hikari interaction server provided for this context's client.</p>"},{"location":"reference/modals/#yuyo.modals.ModalContext.shard","title":"shard  <code>property</code>","text":"<pre><code>shard\n</code></pre> <p>Shard that triggered the interaction.</p> <p>Note</p> <p>This will be None if BaseContext.shards is also None.</p>"},{"location":"reference/modals/#yuyo.modals.ModalContext.shards","title":"shards  <code>property</code>","text":"<pre><code>shards\n</code></pre> <p>Object of the Hikari shard manager this context's client was initialised with.</p>"},{"location":"reference/modals/#yuyo.modals.ModalContext.voice","title":"voice  <code>property</code>","text":"<pre><code>voice\n</code></pre> <p>Object of the Hikari voice component this context's client was initialised with.</p>"},{"location":"reference/modals/#yuyo.modals.ModalContext.create_followup","title":"create_followup  <code>async</code>","text":"<pre><code>create_followup(content=hikari.UNDEFINED, *, delete_after=None, ephemeral=None, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, mentions_everyone=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED, tts=hikari.UNDEFINED, flags=hikari.UNDEFINED)\n</code></pre> <p>Create a followup response for this context.</p> <p>Warning</p> <p>Calling this on a context which hasn't had an initial response yet will lead to a hikari.NotFoundError being raised.</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>UndefinedOr[Any]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message content to send.</p> <p>If this is a hikari.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead be treated as an embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> </li> <li> <code>delete_after</code>               (<code>timedelta | float | int | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, the seconds after which the response message should be deleted.</p> <p>Interaction responses can only be deleted within 15 minutes of the interaction being received.</p> </li> <li> <code>ephemeral</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether the deferred response should be ephemeral. Passing True here is a shorthand for including <code>1 &lt;&lt; 64</code> in the passed flags.</p> </li> <li> <code>attachment</code>               (<code>UndefinedOr[Resourceish]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.</p> </li> <li> <code>attachments</code>               (<code>UndefinedOr[Sequence[Resourceish]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.</p> </li> <li> <code>component</code>               (<code>UndefinedOr[ComponentBuilder]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, builder object of the component to include in this message.</p> </li> <li> <code>components</code>               (<code>UndefinedOr[Sequence[ComponentBuilder]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, a sequence of the component builder objects to include in this message.</p> </li> <li> <code>embed</code>               (<code>UndefinedOr[Embed]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message embed.</p> </li> <li> <code>embeds</code>               (<code>UndefinedOr[Sequence[Embed]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message embeds.</p> </li> <li> <code>mentions_everyone</code>               (<code>UndefinedOr[bool]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, whether the message should parse @everyone/@here mentions.</p> </li> <li> <code>user_mentions</code>               (<code>SnowflakeishSequence[PartialUser] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialUser derivatives to enforce mentioning specific users.</p> </li> <li> <code>role_mentions</code>               (<code>SnowflakeishSequence[PartialRole] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialRole derivatives to enforce mentioning specific roles.</p> </li> <li> <code>tts</code>               (<code>UndefinedOr[bool]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, whether the message will be sent as a TTS message.</p> </li> <li> <code>flags</code>               (<code>UndefinedType | int | MessageFlag</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The flags to set for this response.</p> <p>As of writing this can only flag which can be provided is EPHEMERAL, other flags are just ignored.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Message</code>           \u2013            <p>The created message object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NotFoundError</code>             \u2013            <p>If the current interaction is not found or it hasn't had an initial response yet.</p> </li> <li> <code>BadRequestError</code>             \u2013            <p>This can be raised if the file is too large; if the embed exceeds the defined limits; if the message content is specified only and empty or greater than <code>2000</code> characters; if neither content, file or embeds are specified. If any invalid snowflake IDs are passed; a snowflake may be invalid due to it being outside of the range of a 64 bit integer.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If more than 100 unique objects/entities are passed for <code>role_mentions</code> or `user_mentions.</p> <p>If the interaction will have expired before <code>delete_after</code> is reached.</p> <p>If both <code>attachment</code> and <code>attachments</code> are passed or both <code>component</code> and <code>components</code> are passed or both <code>embed</code> and <code>embeds</code> are passed.</p> </li> </ul>"},{"location":"reference/modals/#yuyo.modals.ModalContext.create_initial_response","title":"create_initial_response  <code>async</code>","text":"<pre><code>create_initial_response(content=hikari.UNDEFINED, *, response_type=hikari.ResponseType.MESSAGE_CREATE, delete_after=None, ephemeral=None, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, mentions_everyone=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED, flags=hikari.UNDEFINED, tts=hikari.UNDEFINED)\n</code></pre> <p>Create the initial response for this context.</p> <p>Warning</p> <p>Calling this on a context which already has an initial response will result in this raising a hikari.NotFoundError. This includes if the REST interaction server has already responded to the request and deferrals.</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>UndefinedOr[Any]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message content to respond with.</p> <p>If this is a hikari.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead be treated as an embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> </li> <li> <code>response_type</code>               (<code>MessageResponseTypesT</code>, default:                   <code>MESSAGE_CREATE</code> )           \u2013            <p>The type of message response to give.</p> </li> <li> <code>delete_after</code>               (<code>timedelta | float | int | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, the seconds after which the response message should be deleted.</p> <p>Interaction responses can only be deleted within 15 minutes of the interaction being received.</p> </li> <li> <code>ephemeral</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether the deferred response should be ephemeral.</p> <p>Passing True here is a shorthand for including <code>1 &lt;&lt; 64</code> in the passed flags.</p> </li> <li> <code>attachment</code>               (<code>UndefinedOr[Resourceish]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.</p> </li> <li> <code>attachments</code>               (<code>UndefinedOr[Sequence[Resourceish]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.</p> </li> <li> <code>component</code>               (<code>UndefinedOr[ComponentBuilder]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, builder object of the component to include in this message.</p> </li> <li> <code>components</code>               (<code>UndefinedOr[Sequence[ComponentBuilder]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, a sequence of the component builder objects to include in this message.</p> </li> <li> <code>embed</code>               (<code>UndefinedOr[Embed]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message embed.</p> </li> <li> <code>embeds</code>               (<code>UndefinedOr[Sequence[Embed]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message embeds.</p> </li> <li> <code>flags</code>               (<code>int | MessageFlag | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message flags this response should have.</p> <p>As of writing the only message flag which can be set here is MessageFlag.EPHEMERAL.</p> </li> <li> <code>tts</code>               (<code>UndefinedOr[bool]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, whether the message will be read out by a screen reader using Discord's TTS (text-to-speech) system.</p> </li> <li> <code>mentions_everyone</code>               (<code>UndefinedOr[bool]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, whether the message should parse @everyone/@here mentions.</p> </li> <li> <code>user_mentions</code>               (<code>SnowflakeishSequence[PartialUser] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialUser derivatives to enforce mentioning specific users.</p> </li> <li> <code>role_mentions</code>               (<code>SnowflakeishSequence[PartialRole] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialRole derivatives to enforce mentioning specific roles.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If more than 100 unique objects/entities are passed for <code>role_mentions</code> or <code>user_mentions</code>.</p> <p>If the interaction will have expired before <code>delete_after</code> is reached.</p> <p>If both <code>attachment</code> and <code>attachments</code> are passed or both <code>component</code> and <code>components</code> are passed or both <code>embed</code> and <code>embeds</code> are passed.</p> </li> <li> <code>BadRequestError</code>             \u2013            <p>This may be raised in several discrete situations, such as messages being empty with no embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; invalid image URLs in embeds.</p> </li> <li> <code>UnauthorizedError</code>             \u2013            <p>If you are unauthorized to make the request (invalid/missing token).</p> </li> <li> <code>NotFoundError</code>             \u2013            <p>If the interaction is not found or if the interaction's initial response has already been created.</p> </li> <li> <code>RateLimitTooLongError</code>             \u2013            <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> </li> <li> <code>InternalServerError</code>             \u2013            <p>If an internal error occurs on Discord while handling the request.</p> </li> </ul>"},{"location":"reference/modals/#yuyo.modals.ModalContext.defer","title":"defer  <code>async</code>","text":"<pre><code>defer(*, defer_type=hikari.ResponseType.DEFERRED_MESSAGE_CREATE, ephemeral=None, flags=hikari.UNDEFINED)\n</code></pre> <p>Defer the initial response for this context.</p> <p>Note</p> <p>The ephemeral state of the first response is decided by whether the deferral is ephemeral.</p> <p>Parameters:</p> <ul> <li> <code>defer_type</code>               (<code>DeferredResponseTypesT</code>, default:                   <code>DEFERRED_MESSAGE_CREATE</code> )           \u2013            <p>The type of deferral this should be.</p> <p>This may any of the following:</p> <ul> <li>ResponseType.DEFERRED_MESSAGE_CREATE     to indicate that the following up call to     BaseContext.edit_initial_response     or BaseContext.respond     should create a new message.</li> <li>ResponseType.DEFERRED_MESSAGE_UPDATE     to indicate that the following call to the aforementioned     methods should update the existing message.</li> </ul> </li> <li> <code>ephemeral</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether the deferred response should be ephemeral.</p> <p>Passing True here is a shorthand for including <code>1 &lt;&lt; 64</code> in the passed flags.</p> </li> <li> <code>flags</code>               (<code>UndefinedType | int | MessageFlag</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The flags to use for the initial response.</p> </li> </ul>"},{"location":"reference/modals/#yuyo.modals.ModalContext.delete_initial_response","title":"delete_initial_response  <code>async</code>","text":"<pre><code>delete_initial_response()\n</code></pre> <p>Delete the initial response after invoking this context.</p> <p>Raises:</p> <ul> <li> <code>(LookupError, NotFoundError)</code>             \u2013            <p>The last context has no initial response.</p> </li> </ul>"},{"location":"reference/modals/#yuyo.modals.ModalContext.delete_last_response","title":"delete_last_response  <code>async</code>","text":"<pre><code>delete_last_response()\n</code></pre> <p>Delete the last response after invoking this context.</p> <p>Raises:</p> <ul> <li> <code>(LookupError, NotFoundError)</code>             \u2013            <p>The last context has no responses.</p> </li> </ul>"},{"location":"reference/modals/#yuyo.modals.ModalContext.edit_initial_response","title":"edit_initial_response  <code>async</code>","text":"<pre><code>edit_initial_response(content=hikari.UNDEFINED, *, delete_after=None, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, mentions_everyone=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED)\n</code></pre> <p>Edit the initial response for this context.</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>UndefinedOr[Any]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message content to edit the initial response with.</p> <p>If this is a hikari.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> </li> <li> <code>delete_after</code>               (<code>timedelta | float | int | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, the seconds after which the response message should be deleted.</p> <p>Interaction responses can only be deleted within 15 minutes of the interaction being received.</p> </li> <li> <code>attachment</code>               (<code>UndefinedNoneOr[Resourceish]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A singular attachment to edit the initial response with.</p> </li> <li> <code>attachments</code>               (<code>UndefinedNoneOr[Sequence[Resourceish]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A sequence of attachments to edit the initial response with.</p> </li> <li> <code>component</code>               (<code>UndefinedNoneOr[ComponentBuilder]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, builder object of the component to set for this message. This component will replace any previously set components and passing None will remove all components.</p> </li> <li> <code>components</code>               (<code>UndefinedNoneOr[Sequence[ComponentBuilder]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing None or an empty sequence will remove all components.</p> </li> <li> <code>embed</code>               (<code>UndefinedNoneOr[Embed]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>An embed to replace the initial response with.</p> </li> <li> <code>embeds</code>               (<code>UndefinedNoneOr[Sequence[Embed]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A sequence of embeds to replace the initial response with.</p> </li> <li> <code>mentions_everyone</code>               (<code>UndefinedOr[bool]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, whether the message should parse @everyone/@here mentions.</p> </li> <li> <code>user_mentions</code>               (<code>SnowflakeishSequence[PartialUser] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialUser derivatives to enforce mentioning specific users.</p> </li> <li> <code>role_mentions</code>               (<code>SnowflakeishSequence[PartialRole] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialRole derivatives to enforce mentioning specific roles.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Message</code>           \u2013            <p>The message that has been edited.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If more than 100 unique objects/entities are passed for <code>role_mentions</code> or <code>user_mentions</code>.</p> <p>If <code>delete_after</code> would be more than 15 minutes after the interaction was received.</p> <p>If both <code>attachment</code> and <code>attachments</code> are passed or both <code>component</code> and <code>components</code> are passed or both <code>embed</code> and <code>embeds</code> are passed.</p> </li> <li> <code>BadRequestError</code>             \u2013            <p>This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components.</p> </li> <li> <code>UnauthorizedError</code>             \u2013            <p>If you are unauthorized to make the request (invalid/missing token).</p> </li> <li> <code>ForbiddenError</code>             \u2013            <p>If you are missing the <code>SEND_MESSAGES</code> in the channel or the person you are trying to message has the DM's disabled.</p> </li> <li> <code>NotFoundError</code>             \u2013            <p>If the channel is not found.</p> </li> <li> <code>RateLimitTooLongError</code>             \u2013            <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> </li> <li> <code>InternalServerError</code>             \u2013            <p>If an internal error occurs on Discord while handling the request.</p> </li> </ul>"},{"location":"reference/modals/#yuyo.modals.ModalContext.edit_last_response","title":"edit_last_response  <code>async</code>","text":"<pre><code>edit_last_response(content=hikari.UNDEFINED, *, delete_after=None, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, mentions_everyone=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED)\n</code></pre> <p>Edit the last response for this context.</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>UndefinedOr[Any]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the content to edit the last response with.</p> <p>If this is a hikari.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> </li> <li> <code>delete_after</code>               (<code>timedelta | float | int | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, the seconds after which the response message should be deleted.</p> <p>Interaction responses can only be deleted within 15 minutes of the interaction being received.</p> </li> <li> <code>attachment</code>               (<code>UndefinedNoneOr[Resourceish]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A singular attachment to edit the last response with.</p> </li> <li> <code>attachments</code>               (<code>UndefinedNoneOr[Sequence[Resourceish]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A sequence of attachments to edit the last response with.</p> </li> <li> <code>component</code>               (<code>UndefinedNoneOr[ComponentBuilder]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, builder object of the component to set for this message. This component will replace any previously set components and passing None will remove all components.</p> </li> <li> <code>components</code>               (<code>UndefinedNoneOr[Sequence[ComponentBuilder]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing None or an empty sequence will remove all components.</p> </li> <li> <code>embed</code>               (<code>UndefinedNoneOr[Embed]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>An embed to replace the last response with.</p> </li> <li> <code>embeds</code>               (<code>UndefinedNoneOr[Sequence[Embed]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A sequence of embeds to replace the last response with.</p> </li> <li> <code>mentions_everyone</code>               (<code>UndefinedOr[bool]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, whether the message should parse @everyone/@here mentions.</p> </li> <li> <code>user_mentions</code>               (<code>SnowflakeishSequence[PartialUser] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialUser derivatives to enforce mentioning specific users.</p> </li> <li> <code>role_mentions</code>               (<code>SnowflakeishSequence[PartialRole] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialRole derivatives to enforce mentioning specific roles.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Message</code>           \u2013            <p>The message that has been edited.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If more than 100 unique objects/entities are passed for <code>role_mentions</code> or <code>user_mentions</code>.</p> <p>If <code>delete_after</code> would be more than 15 minutes after the slash interaction was received.</p> <p>If both <code>attachment</code> and <code>attachments</code> are passed or both <code>component</code> and <code>components</code> are passed or both <code>embed</code> and <code>embeds</code> are passed.</p> </li> <li> <code>BadRequestError</code>             \u2013            <p>This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components.</p> </li> <li> <code>UnauthorizedError</code>             \u2013            <p>If you are unauthorized to make the request (invalid/missing token).</p> </li> <li> <code>ForbiddenError</code>             \u2013            <p>If you are missing the <code>SEND_MESSAGES</code> in the channel or the person you are trying to message has the DM's disabled.</p> </li> <li> <code>NotFoundError</code>             \u2013            <p>If the channel is not found.</p> </li> <li> <code>RateLimitTooLongError</code>             \u2013            <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> </li> <li> <code>InternalServerError</code>             \u2013            <p>If an internal error occurs on Discord while handling the request.</p> </li> </ul>"},{"location":"reference/modals/#yuyo.modals.ModalContext.fetch_initial_response","title":"fetch_initial_response  <code>async</code>","text":"<pre><code>fetch_initial_response()\n</code></pre> <p>Fetch the initial response for this context.</p> <p>Returns:</p> <ul> <li> <code>Message</code>           \u2013            <p>The initial response's message object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>(LookupError, NotFoundError)</code>             \u2013            <p>The response was not found.</p> </li> </ul>"},{"location":"reference/modals/#yuyo.modals.ModalContext.fetch_last_response","title":"fetch_last_response  <code>async</code>","text":"<pre><code>fetch_last_response()\n</code></pre> <p>Fetch the last response for this context.</p> <p>Returns:</p> <ul> <li> <code>Message</code>           \u2013            <p>The most response response's message object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>(LookupError, NotFoundError)</code>             \u2013            <p>The response was not found.</p> </li> </ul>"},{"location":"reference/modals/#yuyo.modals.ModalContext.respond","title":"respond  <code>async</code>","text":"<pre><code>respond(content: UndefinedOr[Any] = hikari.UNDEFINED, *, ensure_result: Literal[True], delete_after: timedelta | float | int | None = None, attachment: UndefinedOr[Resourceish] = hikari.UNDEFINED, attachments: UndefinedOr[Sequence[Resourceish]] = hikari.UNDEFINED, component: UndefinedOr[ComponentBuilder] = hikari.UNDEFINED, components: UndefinedOr[Sequence[ComponentBuilder]] = hikari.UNDEFINED, embed: UndefinedOr[Embed] = hikari.UNDEFINED, embeds: UndefinedOr[Sequence[Embed]] = hikari.UNDEFINED, mentions_everyone: UndefinedOr[bool] = hikari.UNDEFINED, user_mentions: SnowflakeishSequence[PartialUser] | bool | UndefinedType = hikari.UNDEFINED, role_mentions: SnowflakeishSequence[PartialRole] | bool | UndefinedType = hikari.UNDEFINED) -&gt; hikari.Message\n</code></pre><pre><code>respond(content: UndefinedOr[Any] = hikari.UNDEFINED, *, ensure_result: bool = False, delete_after: timedelta | float | int | None = None, attachment: UndefinedOr[Resourceish] = hikari.UNDEFINED, attachments: UndefinedOr[Sequence[Resourceish]] = hikari.UNDEFINED, component: UndefinedOr[ComponentBuilder] = hikari.UNDEFINED, components: UndefinedOr[Sequence[ComponentBuilder]] = hikari.UNDEFINED, embed: UndefinedOr[Embed] = hikari.UNDEFINED, embeds: UndefinedOr[Sequence[Embed]] = hikari.UNDEFINED, mentions_everyone: UndefinedOr[bool] = hikari.UNDEFINED, user_mentions: SnowflakeishSequence[PartialUser] | bool | UndefinedType = hikari.UNDEFINED, role_mentions: SnowflakeishSequence[PartialRole] | bool | UndefinedType = hikari.UNDEFINED) -&gt; hikari.Message | None\n</code></pre> <pre><code>respond(content=hikari.UNDEFINED, *, ensure_result=False, delete_after=None, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, mentions_everyone=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED)\n</code></pre> <p>Respond to this context.</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>UndefinedOr[Any]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message content to respond with.</p> <p>If this is a hikari.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead be treated as an embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> </li> <li> <code>ensure_result</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Ensure that this call will always return a message object.</p> <p>If True then this will always return hikari.Message, otherwise this will return <code>hikari.Message | None</code>.</p> <p>It's worth noting that this may lead to an extre request being made under certain scenarios.</p> </li> <li> <code>delete_after</code>               (<code>timedelta | float | int | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, the seconds after which the response message should be deleted.</p> <p>Interaction responses can only be deleted within 15 minutes of the interaction being received.</p> </li> <li> <code>attachment</code>               (<code>UndefinedOr[Resourceish]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.</p> </li> <li> <code>attachments</code>               (<code>UndefinedOr[Sequence[Resourceish]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.</p> </li> <li> <code>component</code>               (<code>UndefinedOr[ComponentBuilder]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, builder object of the component to include in this response.</p> </li> <li> <code>components</code>               (<code>UndefinedOr[Sequence[ComponentBuilder]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, a sequence of the component builder objects to include in this response.</p> </li> <li> <code>embed</code>               (<code>UndefinedOr[Embed]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>An embed to respond with.</p> </li> <li> <code>embeds</code>               (<code>UndefinedOr[Sequence[Embed]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A sequence of embeds to respond with.</p> </li> <li> <code>mentions_everyone</code>               (<code>UndefinedOr[bool]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, whether the message should parse @everyone/@here mentions.</p> </li> <li> <code>user_mentions</code>               (<code>SnowflakeishSequence[PartialUser] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialUser derivatives to enforce mentioning specific users.</p> </li> <li> <code>role_mentions</code>               (<code>SnowflakeishSequence[PartialRole] | bool | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.Snowflake, or hikari.PartialRole derivatives to enforce mentioning specific roles.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Message | None</code>           \u2013            <p>The message that has been created if it was immedieatly available or <code>ensure_result</code> was set to True, else None.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If more than 100 unique objects/entities are passed for <code>role_mentions</code> or <code>user_mentions</code>.</p> <p>If <code>delete_after</code> would be more than 15 minutes after the interaction was received.</p> <p>If both <code>attachment</code> and <code>attachments</code> are passed or both <code>component</code> and <code>components</code> are passed or both <code>embed</code> and <code>embeds</code> are passed.</p> </li> <li> <code>BadRequestError</code>             \u2013            <p>This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components.</p> </li> <li> <code>UnauthorizedError</code>             \u2013            <p>If you are unauthorized to make the request (invalid/missing token).</p> </li> <li> <code>ForbiddenError</code>             \u2013            <p>If you are missing the <code>SEND_MESSAGES</code> in the channel or the person you are trying to message has the DM's disabled.</p> </li> <li> <code>NotFoundError</code>             \u2013            <p>If the channel is not found.</p> </li> <li> <code>RateLimitTooLongError</code>             \u2013            <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> </li> <li> <code>InternalServerError</code>             \u2013            <p>If an internal error occurs on Discord while handling the request.</p> </li> </ul>"},{"location":"reference/modals/#yuyo.modals.ModalContext.set_ephemeral_default","title":"set_ephemeral_default","text":"<pre><code>set_ephemeral_default(state)\n</code></pre> <p>Set the ephemeral default state for this context.</p> <p>Parameters:</p> <ul> <li> <code>state</code>               (<code>bool</code>)           \u2013            <p>The new ephemeral default state.</p> <p>If this is True then all calls to the response creating methods on this context will default to being ephemeral.</p> </li> </ul>"},{"location":"reference/modals/#yuyo.modals.ModalOptions","title":"ModalOptions","text":"<p>Data class used to define a modal's options.</p> <p>Examples:</p> <pre><code>class ModalOptions(modals.ModalOptions):\n    field: str = modals.text_input(\"label\")\n    optional_field: str | None = modals.text_input(\"label\", default=None)\n\n@modals.as_modal_template\nasync def modal_template(\n    ctx: modals.Context, fields: ModalOptions,\n) -&gt; None:\n    ...\n</code></pre>"},{"location":"reference/modals/#yuyo.modals.WaitForModal","title":"WaitForModal","text":"<p>               Bases: <code>AbstractModal</code>, <code>AbstractTimeout</code></p> <p>Executor used to wait for a single modal interaction.</p> <p>This should also be passed for <code>timeout=</code>.</p> <p>Examples:</p> <pre><code>executor = yuyo.modals.WaitFor(timeout=datetime.timedelta(seconds=30))\nmodal_client.register_modal(\"custom_id\", executor, timeout=executor)\n\nawait ctx.create_modal_response(\"Title\", \"custom_id\", components=[...])\n\ntry:\n    result = await executor.wait_for()\nexcept asyncio.TimeoutError:\n    await ctx.respond(\"Timed out\")\nelse:\n    await result.respond(\"...\")\n</code></pre>"},{"location":"reference/modals/#yuyo.modals.WaitForModal.__init__","title":"__init__","text":"<pre><code>__init__(*, ephemeral_default=False, timeout=_DEFAULT_TIMEOUT)\n</code></pre> <p>Initialise a wait for executor.</p> <p>Parameters:</p> <ul> <li> <code>ephemeral_default</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether or not the responses made on contexts spawned from this paginator should default to ephemeral (meaning only the author can see them) unless <code>flags</code> is specified on the response method.</p> </li> <li> <code>timeout</code>               (<code>timedelta | None</code>, default:                   <code>_DEFAULT_TIMEOUT</code> )           \u2013            <p>How long this should wait for a matching interaction until it times-out.</p> </li> </ul>"},{"location":"reference/modals/#yuyo.modals.WaitForModal.wait_for","title":"wait_for  <code>async</code>","text":"<pre><code>wait_for()\n</code></pre> <p>Wait for the next matching interaction.</p> <p>Returns:</p> <ul> <li> <code>Context</code>           \u2013            <p>The next matching interaction.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If the executor is already being waited for.</p> </li> <li> <code>TimeoutError</code>             \u2013            <p>If the timeout is reached.</p> </li> </ul>"},{"location":"reference/modals/#yuyo.modals._GatewayBotProto","title":"_GatewayBotProto","text":"<p>               Bases: <code>RESTAware</code>, <code>ShardAware</code>, <code>EventManagerAware</code>, <code>Protocol</code></p> <p>Trait of a cacheless gateway bot.</p>"},{"location":"reference/modals/#yuyo.modals.as_modal","title":"as_modal","text":"<pre><code>as_modal(callback: Callable[_P, _CoroT[None]]) -&gt; _DynamicModal[_P]\n</code></pre><pre><code>as_modal(*, ephemeral_default: bool = False, parse_signature: bool = False) -&gt; collections.abc.Callable[[collections.abc.Callable[_P, _CoroT[None]]], _DynamicModal[_P]]\n</code></pre> <pre><code>as_modal(callback=None, /, *, ephemeral_default=False, parse_signature=False)\n</code></pre> <p>Create a modal instance through a decorator call.</p> <p>Info</p> <p>This won't parse the callback for parameter descriptors and ModalOptions unless <code>parse_signature=True</code> is passed, unlike as_modal_template and Modal subclasses.</p> <p>Parameters:</p> <ul> <li> <code>ephemeral_default</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this modal's responses should default to ephemeral.</p> </li> <li> <code>parse_signature</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to parse the signature for parameter descriptors and ModalOptions type-hints.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Modal</code>           \u2013            <p>The new decorated modal.</p> </li> </ul>"},{"location":"reference/modals/#yuyo.modals.as_modal_template","title":"as_modal_template","text":"<pre><code>as_modal_template(callback: Callable[_P, _CoroT[None]]) -&gt; type[_GenericModal[_P]]\n</code></pre><pre><code>as_modal_template(*, ephemeral_default: bool = False, parse_signature: bool = True) -&gt; collections.abc.Callable[[collections.abc.Callable[_P, _CoroT[None]]], type[_GenericModal[_P]]]\n</code></pre> <pre><code>as_modal_template(callback=None, /, *, ephemeral_default=False, parse_signature=True)\n</code></pre> <p>Create a modal template through a decorator callback.</p> <p>The return type acts like any other slotted modal subclass and supports the same decorators and parameter descriptors for declaring the modal's entries.</p> <p>Parameters:</p> <ul> <li> <code>ephemeral_default</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this modal template's responses should default to ephemeral.</p> </li> <li> <code>parse_signature</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to parse the signature for parameter descriptors and ModalOptions type-hints.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[Modal]</code>           \u2013            <p>The new decorated modal class.</p> </li> </ul>"},{"location":"reference/modals/#yuyo.modals.modal","title":"modal","text":"<pre><code>modal(callback, /, *, ephemeral_default=False, parse_signature=False)\n</code></pre> <p>Create a modal instance for a callback.</p> <p>Info</p> <p>This won't parse the callback for parameter descriptors and ModalOptions unless <code>parse_signature=True</code> is passed, unlike as_modal_template and Modal subclasses.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>Callable[_P, _CoroT[None]]</code>)           \u2013            <p>Callback to use for modal execution.</p> </li> <li> <code>ephemeral_default</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this modal's responses should default to ephemeral.</p> </li> <li> <code>parse_signature</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to parse the signature for parameter descriptors and ModalOptions type-hints.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Modal</code>           \u2013            <p>The created modal.</p> </li> </ul>"},{"location":"reference/modals/#yuyo.modals.text_input","title":"text_input","text":"<pre><code>text_input(label: str, /, *, custom_id: str | None = None, style: TextInputStyle = hikari.TextInputStyle.SHORT, placeholder: UndefinedOr[str] = hikari.UNDEFINED, value: UndefinedOr[str] = hikari.UNDEFINED, default: _T, min_length: int = 0, max_length: int = 4000) -&gt; str | _T\n</code></pre><pre><code>text_input(label: str, /, *, custom_id: str | None = None, style: TextInputStyle = hikari.TextInputStyle.SHORT, placeholder: UndefinedOr[str] = hikari.UNDEFINED, value: UndefinedOr[str] = hikari.UNDEFINED, min_length: int = 0, max_length: int = 4000) -&gt; str\n</code></pre> <pre><code>text_input(label, /, *, custom_id=None, style=hikari.TextInputStyle.SHORT, placeholder=hikari.UNDEFINED, value=hikari.UNDEFINED, default=NO_DEFAULT, min_length=0, max_length=4000)\n</code></pre> <p>Descriptor used to declare a text input field.</p> <p>Parameters:</p> <ul> <li> <code>label</code>               (<code>str</code>)           \u2013            <p>The text input field's display label.</p> <p>This cannot be greater than 45 characters long.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The field's custom ID.</p> <p>Defaults to the name of the parameter/attribute this is assigned to.</p> </li> <li> <code>style</code>               (<code>TextInputStyle</code>, default:                   <code>SHORT</code> )           \u2013            <p>The text input's style.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to display when the text input is empty.</p> </li> <li> <code>value</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Default text to pre-fill the field with.</p> </li> <li> <code>default</code>               (<code>_T | Literal[VALUE]</code>, default:                   <code>NO_DEFAULT</code> )           \u2013            <p>Default value to pass if this text input field was not provided.</p> <p>The field will be marked as required unless this is supplied.</p> <p>This will also be used for <code>value</code> when it has been left undefined and the default is a string that's &lt;=4000 characters in length.</p> </li> <li> <code>min_length</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Minimum length the input text can be.</p> <p>This can be greater than or equal to 0 and less than or equal to 4000.</p> </li> <li> <code>max_length</code>               (<code>int</code>, default:                   <code>4000</code> )           \u2013            <p>Maximum length the input text can be.</p> <p>This can be greater than or equal to 1 and less than or equal to 4000.</p> </li> </ul> <p>Examples:</p> <p>This can either be applied to an argument's default</p> <pre><code>@modals.as_modal_template\nasync def modal_template(\n    ctx: modals.Context,\n    text_field: str = modals.text_input(\"label\"),\n    optional_field: str | None = modals.text_input(\"label\", default=None)\n) -&gt; None:\n    ...\n</code></pre> <p>Or as an attribute to a ModalOptions dataclass.</p> <pre><code>class ModalOptions(modals.ModalOptions):\n    field: str = modals.text_input(\"label\")\n    optional_field: str | None = modals.text_input(\"label\", default=None)\n\n@modals.as_modal_template\nasync def modal_template(\n    ctx: modals.Context, fields: ModalOptions,\n) -&gt; None:\n    ...\n</code></pre>"},{"location":"reference/modals/#yuyo.modals.with_static_text_input","title":"with_static_text_input","text":"<pre><code>with_static_text_input(label, /, *, custom_id=None, style=hikari.TextInputStyle.SHORT, placeholder=hikari.UNDEFINED, value=hikari.UNDEFINED, default=NO_DEFAULT, min_length=0, max_length=4000, parameter=None)\n</code></pre> <p>Add a static text input field to the decorated modal subclass.</p> <p>Parameters:</p> <ul> <li> <code>label</code>               (<code>str</code>)           \u2013            <p>The text input field's display label.</p> <p>This cannot be greater than 45 characters long.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The field's custom ID.</p> <p>Defaults to <code>parameter</code>, if provided, or a UUID and cannot be longer than 100 characters.</p> </li> <li> <code>style</code>               (<code>TextInputStyle</code>, default:                   <code>SHORT</code> )           \u2013            <p>The text input's style.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to display when the text input is empty.</p> </li> <li> <code>value</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Default text to pre-fill the field with.</p> </li> <li> <code>default</code>               (<code>Any</code>, default:                   <code>NO_DEFAULT</code> )           \u2013            <p>Default value to pass if this text input field was not provided.</p> <p>The field will be marked as required unless this is supplied.</p> <p>This will also be used for <code>value</code> when it has been left undefined and the default is a string that's &lt;=4000 characters in length.</p> </li> <li> <code>min_length</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Minimum length the input text can be.</p> <p>This can be greater than or equal to 0 and less than or equal to 4000.</p> </li> <li> <code>max_length</code>               (<code>int</code>, default:                   <code>4000</code> )           \u2013            <p>Maximum length the input text can be.</p> <p>This can be greater than or equal to 1 and less than or equal to 4000.</p> </li> <li> <code>parameter</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Name of the parameter the text for this field should be passed to.</p> <p>This will be of type str and may also be the value passed for <code>default</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[Modal]</code>           \u2013            <p>The decorated modal class.</p> </li> </ul>"},{"location":"reference/modals/#yuyo.modals.with_text_input","title":"with_text_input","text":"<pre><code>with_text_input(label, /, *, custom_id=None, style=hikari.TextInputStyle.SHORT, placeholder=hikari.UNDEFINED, value=hikari.UNDEFINED, default=NO_DEFAULT, min_length=0, max_length=4000, parameter=None)\n</code></pre> <p>Add a text input field to the decorated modal instance.</p> <p>Parameters:</p> <ul> <li> <code>label</code>               (<code>str</code>)           \u2013            <p>The text input field's display label.</p> <p>This cannot be greater than 45 characters long.</p> </li> <li> <code>custom_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The field's custom ID.</p> <p>Defaults to <code>parameter</code>, if provided, or a UUID and cannot be longer than 100 characters.</p> </li> <li> <code>style</code>               (<code>TextInputStyle</code>, default:                   <code>SHORT</code> )           \u2013            <p>The text input's style.</p> </li> <li> <code>placeholder</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Placeholder text to display when the text input is empty.</p> </li> <li> <code>value</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Default text to pre-fill the field with.</p> </li> <li> <code>default</code>               (<code>Any</code>, default:                   <code>NO_DEFAULT</code> )           \u2013            <p>Default value to pass if this text input field was not provided.</p> <p>The field will be marked as required unless this is supplied.</p> <p>This will also be used for <code>value</code> when it has been left undefined and the default is a string that's &lt;=4000 characters in length.</p> </li> <li> <code>min_length</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Minimum length the input text can be.</p> <p>This can be greater than or equal to 0 and less than or equal to 4000.</p> </li> <li> <code>max_length</code>               (<code>int</code>, default:                   <code>4000</code> )           \u2013            <p>Maximum length the input text can be.</p> <p>This can be greater than or equal to 1 and less than or equal to 4000.</p> </li> <li> <code>parameter</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Name of the parameter the text for this field should be passed to.</p> <p>This will be of type str and may also be the value passed for <code>default</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Modal</code>           \u2013            <p>The decorated modal instance.</p> </li> </ul>"},{"location":"reference/pagination/","title":"yuyo.pagination","text":"<p>Utilities used for quick pagination handling within reaction and component executors.</p>"},{"location":"reference/pagination/#yuyo.pagination.BLACK_CROSS","title":"BLACK_CROSS  <code>module-attribute</code>","text":"<pre><code>BLACK_CROSS = UnicodeEmoji('\u2716\ufe0f')\n</code></pre> <p>The emoji used to close a menu in a component context.</p>"},{"location":"reference/pagination/#yuyo.pagination.EntryT","title":"EntryT  <code>module-attribute</code>","text":"<pre><code>EntryT = Union[tuple[UndefinedOr[str], UndefinedOr[Embed]], 'AbstractPage']\n</code></pre> <p>A type hint used to represent a paginator entry.</p> <p>This may be either AbstractPage or <code>tuple[hikari.UndefinedOr[str], hikari.UndefinedOr[hikari.Embed]]</code> where tuple[0] is the message content and tuple[1] is an embed to send.</p>"},{"location":"reference/pagination/#yuyo.pagination.LEFT_DOUBLE_TRIANGLE","title":"LEFT_DOUBLE_TRIANGLE  <code>module-attribute</code>","text":"<pre><code>LEFT_DOUBLE_TRIANGLE = UnicodeEmoji('\u23ee\ufe0f')\n</code></pre> <p>The emoji used to go back to the first entry.</p>"},{"location":"reference/pagination/#yuyo.pagination.LEFT_TRIANGLE","title":"LEFT_TRIANGLE  <code>module-attribute</code>","text":"<pre><code>LEFT_TRIANGLE = UnicodeEmoji('\u25c0\ufe0f')\n</code></pre> <p>The emoji used to go back an entry.</p>"},{"location":"reference/pagination/#yuyo.pagination.LocalizedPage","title":"LocalizedPage  <code>module-attribute</code>","text":"<pre><code>LocalizedPage = LocalisedPage\n</code></pre> <p>Alias of LocalisedPage.</p>"},{"location":"reference/pagination/#yuyo.pagination.RIGHT_DOUBLE_TRIANGLE","title":"RIGHT_DOUBLE_TRIANGLE  <code>module-attribute</code>","text":"<pre><code>RIGHT_DOUBLE_TRIANGLE = UnicodeEmoji('\u23ed\ufe0f')\n</code></pre> <p>The emoji used for the (not enabled by default) skip to last entry button.</p>"},{"location":"reference/pagination/#yuyo.pagination.RIGHT_TRIANGLE","title":"RIGHT_TRIANGLE  <code>module-attribute</code>","text":"<pre><code>RIGHT_TRIANGLE = UnicodeEmoji('\u25b6\ufe0f')\n</code></pre> <p>The emoji used to continue to the next entry.</p>"},{"location":"reference/pagination/#yuyo.pagination.SELECT_PAGE_SYMBOL","title":"SELECT_PAGE_SYMBOL  <code>module-attribute</code>","text":"<pre><code>SELECT_PAGE_SYMBOL = UnicodeEmoji('\ud83d\udd22')\n</code></pre> <p>The emoji used for the select specific page button which triggers a modal.</p>"},{"location":"reference/pagination/#yuyo.pagination.STOP_SQUARE","title":"STOP_SQUARE  <code>module-attribute</code>","text":"<pre><code>STOP_SQUARE = UnicodeEmoji('\u23f9\ufe0f')\n</code></pre> <p>The emoji used to close a menu in a reaction context.</p>"},{"location":"reference/pagination/#yuyo.pagination.AbstractPage","title":"AbstractPage","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract representation of a paginated response.</p>"},{"location":"reference/pagination/#yuyo.pagination.AbstractPage.ctx_to_kwargs","title":"ctx_to_kwargs  <code>abstractmethod</code>","text":"<pre><code>ctx_to_kwargs(ctx)\n</code></pre> <p>Form create message <code>**kwargs</code> for this page based on a component or modal context.</p> <p>Returns:</p> <ul> <li> <code>ResponseKwargs</code>           \u2013            <p>The create message kwargs for this page.</p> </li> </ul>"},{"location":"reference/pagination/#yuyo.pagination.AbstractPage.to_kwargs","title":"to_kwargs  <code>abstractmethod</code>","text":"<pre><code>to_kwargs()\n</code></pre> <p>Form create message <code>**kwargs</code> for this page.</p> <p>Returns:</p> <ul> <li> <code>ResponseKwargs</code>           \u2013            <p>The create message kwargs for this page.</p> </li> </ul>"},{"location":"reference/pagination/#yuyo.pagination.LocalisedPage","title":"LocalisedPage","text":"<p>               Bases: <code>AbstractPage</code></p> <p>Implementation of a paginated response which returns locale specific pages..</p>"},{"location":"reference/pagination/#yuyo.pagination.Page","title":"Page","text":"<p>               Bases: <code>AbstractPage</code></p> <p>Represents a pagianted response.</p>"},{"location":"reference/pagination/#yuyo.pagination.Page.__init__","title":"__init__","text":"<pre><code>__init__(content: str | UndefinedType = hikari.UNDEFINED, *, attachment: UndefinedOr[Resourceish] = hikari.UNDEFINED, attachments: UndefinedOr[Sequence[Resourceish]] = hikari.UNDEFINED, embed: UndefinedOr[Embed] = hikari.UNDEFINED, embeds: UndefinedOr[Sequence[Embed]] = hikari.UNDEFINED) -&gt; None\n</code></pre><pre><code>__init__(content: Resourceish, *, embed: UndefinedOr[Embed] = hikari.UNDEFINED, embeds: UndefinedOr[Sequence[Embed]] = hikari.UNDEFINED) -&gt; None\n</code></pre><pre><code>__init__(content: Embed, *, attachment: UndefinedOr[Resourceish] = hikari.UNDEFINED, attachments: UndefinedOr[Sequence[Resourceish]] = hikari.UNDEFINED) -&gt; None\n</code></pre> <pre><code>__init__(content=hikari.UNDEFINED, *, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED)\n</code></pre> <p>Initialise a response page.</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>str | Embed | Resourceish | UndefinedType</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The message content to send.</p> <p>If this is a hikari.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead be treated as an embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> </li> <li> <code>attachment</code>               (<code>UndefinedOr[Resourceish]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A singular attachment to send.</p> </li> <li> <code>attachments</code>               (<code>UndefinedOr[Sequence[Resourceish]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Up to 10 attachments to include in the response.</p> </li> <li> <code>embed</code>               (<code>UndefinedOr[Embed]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>A singular embed to send.</p> </li> <li> <code>embeds</code>               (<code>UndefinedOr[Sequence[Embed]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>Up to 10 embeds to include in the response.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>Raised for any of the following reasons:</p> <ul> <li>When both <code>attachment</code> and <code>attachments</code> are provided.</li> <li>When both <code>embed</code> and <code>embeds</code> are passed.</li> </ul> </li> </ul>"},{"location":"reference/pagination/#yuyo.pagination.Page.ctx_to_kwargs","title":"ctx_to_kwargs","text":"<pre><code>ctx_to_kwargs(_)\n</code></pre> <p>Form create message <code>**kwargs</code> for this page based on a component or modal context.</p> <p>Returns:</p> <ul> <li> <code>ResponseKwargs</code>           \u2013            <p>The create message kwargs for this page.</p> </li> </ul>"},{"location":"reference/pagination/#yuyo.pagination.Page.from_entry","title":"from_entry  <code>classmethod</code>","text":"<pre><code>from_entry(entry)\n</code></pre> <p>Create a Page from a EntryT.</p> <p>Parameters:</p> <ul> <li> <code>entry</code>               (<code>EntryT</code>)           \u2013            <p>The EntryT to make a page from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AbstractPage</code>           \u2013            <p>The created page.</p> </li> </ul>"},{"location":"reference/pagination/#yuyo.pagination.Page.to_kwargs","title":"to_kwargs","text":"<pre><code>to_kwargs()\n</code></pre> <p>Form create message <code>**kwargs</code> for this page.</p> <p>Returns:</p> <ul> <li> <code>ResponseKwargs</code>           \u2013            <p>The create message kwargs for this page.</p> </li> </ul>"},{"location":"reference/pagination/#yuyo.pagination.Paginator","title":"Paginator","text":"<p>Standard implementation of a stateful paginator.</p> <p>To use this with components or reactions see the following classes:</p> <ul> <li>ComponentPaginator</li> <li>ReactionPaginator</li> </ul>"},{"location":"reference/pagination/#yuyo.pagination.Paginator.has_finished_iterating","title":"has_finished_iterating  <code>property</code>","text":"<pre><code>has_finished_iterating\n</code></pre> <p>Whether this has finished iterating over the original iterator.</p>"},{"location":"reference/pagination/#yuyo.pagination.Paginator.__init__","title":"__init__","text":"<pre><code>__init__(iterator)\n</code></pre> <p>Initialise a paginator.</p> <p>Parameters:</p> <ul> <li> <code>iterator</code>               (<code>Iterator[EntryT] | AsyncIterator[EntryT]</code>)           \u2013            <p>The iterator to paginate.</p> <p>This should be an iterator of AbstractPages.</p> </li> </ul>"},{"location":"reference/pagination/#yuyo.pagination.Paginator.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Close the paginator.</p>"},{"location":"reference/pagination/#yuyo.pagination.Paginator.jump_to_first","title":"jump_to_first","text":"<pre><code>jump_to_first()\n</code></pre> <p>Jump to the first page.</p> <p>Returns:</p> <ul> <li> <code>AbstractPage | None</code>           \u2013            <p>The first page in this paginator.</p> <p>This will be None if this is already on the first page or if the paginator hasn't been moved forward to the first entry yet.</p> </li> </ul>"},{"location":"reference/pagination/#yuyo.pagination.Paginator.jump_to_last","title":"jump_to_last  <code>async</code>","text":"<pre><code>jump_to_last()\n</code></pre> <p>Jump to the last page.</p> <p>Returns:</p> <ul> <li> <code>AbstractPage | None</code>           \u2013            <p>The last page in this paginator, or None if this is already on the last page.</p> </li> </ul>"},{"location":"reference/pagination/#yuyo.pagination.Paginator.step_back","title":"step_back","text":"<pre><code>step_back()\n</code></pre> <p>Move back a page.</p> <p>Returns:</p> <ul> <li> <code>AbstractPage | None</code>           \u2013            <p>The previous page in this paginator.</p> <p>This will be None if this is already on the first page or if the paginator hasn't been moved forward to the first entry yet.</p> </li> </ul>"},{"location":"reference/pagination/#yuyo.pagination.Paginator.step_forward","title":"step_forward  <code>async</code>","text":"<pre><code>step_forward()\n</code></pre> <p>Move this forward a page.</p> <p>Returns:</p> <ul> <li> <code>AbstractPage | None</code>           \u2013            <p>The next page in this paginator, or None if this is already on the last page.</p> </li> </ul>"},{"location":"reference/pagination/#yuyo.pagination.ResponseKwargs","title":"ResponseKwargs","text":"<p>               Bases: <code>TypedDict</code></p> <p>Typed dict of a message response's basic kwargs.</p> <p>This is returned by AbstractPage.to_kwargs and AbstractPage.ctx_to_kwargs.</p>"},{"location":"reference/pagination/#yuyo.pagination.ResponseKwargs.attachments","title":"attachments  <code>instance-attribute</code>","text":"<pre><code>attachments\n</code></pre> <p>A sequence of attachments to send.</p>"},{"location":"reference/pagination/#yuyo.pagination.ResponseKwargs.content","title":"content  <code>instance-attribute</code>","text":"<pre><code>content\n</code></pre> <p>String message content to send.</p>"},{"location":"reference/pagination/#yuyo.pagination.ResponseKwargs.embeds","title":"embeds  <code>instance-attribute</code>","text":"<pre><code>embeds\n</code></pre> <p>A sequence of embeds to send.</p>"},{"location":"reference/pagination/#yuyo.pagination.aenumerate","title":"aenumerate  <code>async</code>","text":"<pre><code>aenumerate(iterable)\n</code></pre> <p>Async equivalent of enumerate.</p> <p>Parameters:</p> <ul> <li> <code>iterable</code>               (<code>AsyncIterable[_T]</code>)           \u2013            <p>The async iterable to enumerate.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AsyncIterator[tuple[int, _T]]</code>           \u2013            <p>The enumerated async iterator.</p> </li> </ul>"},{"location":"reference/pagination/#yuyo.pagination.async_paginate_string","title":"async_paginate_string  <code>async</code>","text":"<pre><code>async_paginate_string(lines, /, *, char_limit=2000, line_limit=25, wrapper=None)\n</code></pre> <p>Lazily paginate an iterator of lines.</p> <p>Parameters:</p> <ul> <li> <code>lines</code>               (<code>AsyncIterable[str]</code>)           \u2013            <p>The asynchronous iterator of lines to paginate.</p> </li> <li> <code>char_limit</code>               (<code>int</code>, default:                   <code>2000</code> )           \u2013            <p>The limit for how many characters should be included per yielded page.</p> </li> <li> <code>line_limit</code>               (<code>int</code>, default:                   <code>25</code> )           \u2013            <p>The limit for how many lines should be included per yielded page.</p> </li> <li> <code>wrapper</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A wrapper for each yielded page. This should leave \"{}\" in it to be replaced by the page's content.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AsyncIterator[str]</code>           \u2013            <p>An async iterator of each page's content.</p> </li> </ul>"},{"location":"reference/pagination/#yuyo.pagination.paginate_string","title":"paginate_string","text":"<pre><code>paginate_string(lines: AsyncIterator[str], /, *, char_limit: int = 2000, line_limit: int = 25, wrapper: str | None = None) -&gt; collections.AsyncIterator[str]\n</code></pre><pre><code>paginate_string(lines: Iterator[str], /, *, char_limit: int = 2000, line_limit: int = 25, wrapper: str | None = None) -&gt; collections.Iterator[str]\n</code></pre> <pre><code>paginate_string(lines, /, *, char_limit=2000, line_limit=25, wrapper=None)\n</code></pre> <p>Lazily paginate an iterator of lines.</p> <p>Parameters:</p> <ul> <li> <code>lines</code>               (<code>Iterator[str] | AsyncIterator[str]</code>)           \u2013            <p>The iterator of lines to paginate. This iterator may be asynchronous or synchronous.</p> </li> <li> <code>char_limit</code>               (<code>int</code>, default:                   <code>2000</code> )           \u2013            <p>The limit for how many characters should be included per yielded page.</p> </li> <li> <code>line_limit</code>               (<code>int</code>, default:                   <code>25</code> )           \u2013            <p>The limit for how many lines should be included per yielded page.</p> </li> <li> <code>wrapper</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A wrapper for each yielded page. This should leave \"{}\" in it to be replaced by the page's content.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AsyncIterator[str] | Iterator[str]</code>           \u2013            <p>An iterator of each page's content.</p> </li> </ul>"},{"location":"reference/pagination/#yuyo.pagination.sync_paginate_string","title":"sync_paginate_string","text":"<pre><code>sync_paginate_string(lines, /, *, char_limit=2000, line_limit=25, wrapper=None)\n</code></pre> <p>Lazily paginate an iterator of lines.</p> <p>Parameters:</p> <ul> <li> <code>lines</code>               (<code>Iterable[str]</code>)           \u2013            <p>The iterator of lines to paginate.</p> </li> <li> <code>char_limit</code>               (<code>int</code>, default:                   <code>2000</code> )           \u2013            <p>The limit for how many characters should be included per yielded page.</p> </li> <li> <code>line_limit</code>               (<code>int</code>, default:                   <code>25</code> )           \u2013            <p>The limit for how many lines should be included per yielded page.</p> </li> <li> <code>wrapper</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A wrapper for each yielded page. This should leave \"{}\" in it to be replaced by the page's content.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterator[str]</code>           \u2013            <p>An iterator of each page's content.</p> </li> </ul>"},{"location":"reference/reactions/","title":"yuyo.reactions","text":"<p>Client for higher level callback based reaction menu handling.</p>"},{"location":"reference/reactions/#yuyo.reactions.CallbackSig","title":"CallbackSig  <code>module-attribute</code>","text":"<pre><code>CallbackSig = Callable[..., Coroutine[Any, Any, None]]\n</code></pre> <p>Type-hint of a callback used to handle matching reactions events.</p>"},{"location":"reference/reactions/#yuyo.reactions.Client","title":"Client  <code>module-attribute</code>","text":"<pre><code>Client = ReactionClient\n</code></pre> <p>Alias of ReactionClient.</p>"},{"location":"reference/reactions/#yuyo.reactions.Handler","title":"Handler  <code>module-attribute</code>","text":"<pre><code>Handler = ReactionHandler\n</code></pre> <p>Alias of ReactionHandler.</p>"},{"location":"reference/reactions/#yuyo.reactions.Paginator","title":"Paginator  <code>module-attribute</code>","text":"<pre><code>Paginator = ReactionPaginator\n</code></pre> <p>Alias of ReactionPaginator.</p>"},{"location":"reference/reactions/#yuyo.reactions.ReactionEventT","title":"ReactionEventT  <code>module-attribute</code>","text":"<pre><code>ReactionEventT = ReactionAddEvent | ReactionDeleteEvent\n</code></pre> <p>Type hint of the event types CallbackSig takes as its first argument.</p>"},{"location":"reference/reactions/#yuyo.reactions.AbstractReactionHandler","title":"AbstractReactionHandler","text":"<p>               Bases: <code>ABC</code></p> <p>The interface for a reaction handler used with ReactionClient.</p>"},{"location":"reference/reactions/#yuyo.reactions.AbstractReactionHandler.has_expired","title":"has_expired  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>has_expired\n</code></pre> <p>Whether this handler has ended.</p>"},{"location":"reference/reactions/#yuyo.reactions.AbstractReactionHandler.close","title":"close  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Close this handler.</p>"},{"location":"reference/reactions/#yuyo.reactions.AbstractReactionHandler.on_reaction_event","title":"on_reaction_event  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>on_reaction_event(event, /, *, alluka=None)\n</code></pre> <p>Handle a reaction event.</p> <p>Parameters:</p> <ul> <li> <code>event</code>               (<code>ReactionEventT</code>)           \u2013            <p>The event to handle.</p> </li> <li> <code>alluka</code>               (<code>Client | None</code>, default:                   <code>None</code> )           \u2013            <p>The Alluka client to use for callback dependency injection during callback calls.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>HandlerClosed</code>             \u2013            <p>If this reaction handler has been closed.</p> </li> </ul>"},{"location":"reference/reactions/#yuyo.reactions.AbstractReactionHandler.open","title":"open  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>open(message)\n</code></pre> <p>Open this handler.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>Message</code>)           \u2013            <p>The message to bind this handler to.</p> </li> </ul>"},{"location":"reference/reactions/#yuyo.reactions.HandlerClosed","title":"HandlerClosed","text":"<p>               Bases: <code>Exception</code></p> <p>Error raised when a reaction handler has been closed.</p>"},{"location":"reference/reactions/#yuyo.reactions.ReactionClient","title":"ReactionClient","text":"<p>A class which handles the events for multiple registered reaction handlers.</p>"},{"location":"reference/reactions/#yuyo.reactions.ReactionClient.alluka","title":"alluka  <code>property</code>","text":"<pre><code>alluka\n</code></pre> <p>The Alluka client being used for callback dependency injection.</p>"},{"location":"reference/reactions/#yuyo.reactions.ReactionClient.is_closed","title":"is_closed  <code>property</code>","text":"<pre><code>is_closed\n</code></pre> <p>Whether this client is closed.</p>"},{"location":"reference/reactions/#yuyo.reactions.ReactionClient.__init__","title":"__init__","text":"<pre><code>__init__(*, rest, event_manager, alluka=None, event_managed=True)\n</code></pre> <p>Initialise a reaction client.</p> <p>This registers ReactionClient as a type dependency when <code>alluka</code> isn't passed.</p> <p>Note</p> <p>For an easier way to initialise the client from a bot see ReactionClient.from_gateway_bot, and ReactionClient.from_tanjun.</p> <p>Parameters:</p> <ul> <li> <code>rest</code>               (<code>RESTClient</code>)           \u2013            <p>The REST client to register this reaction client with.</p> </li> <li> <code>event_manager</code>               (<code>EventManager</code>)           \u2013            <p>The event manager client to register this reaction client with.</p> </li> <li> <code>alluka</code>               (<code>Client | None</code>, default:                   <code>None</code> )           \u2013            <p>The Alluka client to use for callback dependency injection in this client.</p> <p>If not provided then this will initialise its own Alluka client.</p> </li> <li> <code>event_managed</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the reaction client should be automatically opened and closed based on the lifetime events dispatched by <code>event_managed</code>.</p> </li> </ul>"},{"location":"reference/reactions/#yuyo.reactions.ReactionClient.close","title":"close  <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Close this client by unregistering any registered tasks and event listeners.</p>"},{"location":"reference/reactions/#yuyo.reactions.ReactionClient.from_gateway_bot","title":"from_gateway_bot  <code>classmethod</code>","text":"<pre><code>from_gateway_bot(bot, /, *, alluka=None, event_managed=True)\n</code></pre> <p>Build a <code>ReactionClient</code> from a gateway bot.</p> <p>This registers ReactionClient as a type dependency when <code>alluka</code> isn't passed.</p> <p>Parameters:</p> <ul> <li> <code>bot</code>               (<code>EventManagerAware &amp; RESTAware</code>)           \u2013            <p>The bot to build a reaction client for.</p> </li> <li> <code>alluka</code>               (<code>Client | None</code>, default:                   <code>None</code> )           \u2013            <p>The Alluka client to use for callback dependency injection in this client.</p> <p>If not provided then this will initialise its own Alluka client.</p> </li> <li> <code>event_managed</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the reaction client should be automatically opened and closed based on the lifetime events dispatched by <code>bot</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ReactionClient</code>           \u2013            <p>The reaction client for the bot.</p> </li> </ul>"},{"location":"reference/reactions/#yuyo.reactions.ReactionClient.from_tanjun","title":"from_tanjun  <code>classmethod</code>","text":"<pre><code>from_tanjun(tanjun_client, /, *, tanjun_managed=True)\n</code></pre> <p>Build a <code>ReactionClient</code> from a gateway bot.</p> <p>This will use the Tanjun client's alluka client and registers ReactionClient as a type dependency on Tanjun.</p> <p>Parameters:</p> <ul> <li> <code>tanjun_client</code>               (<code>Client</code>)           \u2013            <p>The tanjun client to build a reaction client for.</p> </li> <li> <code>tanjun_managed</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the reaction client should be automatically opened and closed based on the Tanjun client's lifetime client callback.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ReactionClient</code>           \u2013            <p>The reaction client for the bot.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>tanjun_client.events</code> is None.</p> </li> </ul>"},{"location":"reference/reactions/#yuyo.reactions.ReactionClient.get_handler","title":"get_handler","text":"<pre><code>get_handler(message)\n</code></pre> <p>Get a reference to a handler registered in this reaction client.</p> <p>Note</p> <p>This does not call AbstractReactionHandler.close.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>SnowflakeishOr[Message]</code>)           \u2013            <p>The message ID to remove a handler for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AbstractReactionHandler | None</code>           \u2013            <p>The object of the registered handler if found else None.</p> </li> </ul>"},{"location":"reference/reactions/#yuyo.reactions.ReactionClient.open","title":"open  <code>async</code>","text":"<pre><code>open()\n</code></pre> <p>Start this client by registering the required tasks and event listeners for it to function.</p>"},{"location":"reference/reactions/#yuyo.reactions.ReactionClient.remove_handler","title":"remove_handler","text":"<pre><code>remove_handler(message)\n</code></pre> <p>Remove a handler from this reaction client.</p> <p>Note</p> <p>This does not call AbstractReactionHandler.close.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>SnowflakeishOr[Message]</code>)           \u2013            <p>The message ID to remove a handler for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AbstractReactionHandler | None</code>           \u2013            <p>The object of the registered handler if found else None.</p> </li> </ul>"},{"location":"reference/reactions/#yuyo.reactions.ReactionClient.set_handler","title":"set_handler","text":"<pre><code>set_handler(message, handler)\n</code></pre> <p>Add a reaction handler to this reaction client.</p> <p>Note</p> <p>This does not call AbstractReactionHandler.open.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>SnowflakeishOr[Message]</code>)           \u2013            <p>The message ID to add register a reaction handler with.</p> </li> <li> <code>handler</code>               (<code>AbstractReactionHandler</code>)           \u2013            <p>The object of the opened handler to register in this reaction client.</p> </li> </ul>"},{"location":"reference/reactions/#yuyo.reactions.ReactionHandler","title":"ReactionHandler","text":"<p>               Bases: <code>AbstractReactionHandler</code></p> <p>Standard basic implementation of a reaction handler.</p>"},{"location":"reference/reactions/#yuyo.reactions.ReactionHandler.authors","title":"authors  <code>property</code>","text":"<pre><code>authors\n</code></pre> <p>Set of the authors/owner of a enabled handler.</p> <p>Note</p> <p>If this is empty then the handler is considered public and any user will be able to trigger it.</p>"},{"location":"reference/reactions/#yuyo.reactions.ReactionHandler.__init__","title":"__init__","text":"<pre><code>__init__(*, authors=(), timeout=datetime.timedelta(seconds=30))\n</code></pre> <p>Initialise a reaction handler.</p> <p>Parameters:</p> <ul> <li> <code>authors</code>               (<code>Iterable[SnowflakeishOr[User]]</code>, default:                   <code>()</code> )           \u2013            <p>An iterable of IDs of the users who can call this handler.</p> <p>If no users are provided then the reactions will be public (meaning that anybody can use it).</p> </li> <li> <code>timeout</code>               (<code>timedelta | None</code>, default:                   <code>timedelta(seconds=30)</code> )           \u2013            <p>How long it should take for this handler to timeout.</p> </li> </ul>"},{"location":"reference/reactions/#yuyo.reactions.ReactionHandler.remove_callback","title":"remove_callback","text":"<pre><code>remove_callback(emoji_identifier)\n</code></pre> <p>Remove a callback from this reaction handler.</p> <p>Parameters:</p> <ul> <li> <code>emoji_identifier</code>               (<code>str | SnowflakeishOr[CustomEmoji]</code>)           \u2013            <p>Identifier of the emoji the callback to remove is for.</p> <p>This should be a snowfake if this is for a custom emoji or a string if this is for a unicode emoji.</p> </li> </ul>"},{"location":"reference/reactions/#yuyo.reactions.ReactionHandler.set_callback","title":"set_callback","text":"<pre><code>set_callback(emoji_identifier, callback)\n</code></pre> <p>Add a callback to this reaction handler.</p> <p>Parameters:</p> <ul> <li> <code>emoji_identifier</code>               (<code>str | SnowflakeishOr[CustomEmoji]</code>)           \u2013            <p>Identifier of the emoji this callback is for.</p> <p>This should be a snowfake if this is for a custom emoji or a string if this is for a unicode emoji.</p> </li> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>The callback to add.</p> <p>This should be a function that accepts a single parameter, which is the event that triggered this reaction.</p> </li> </ul>"},{"location":"reference/reactions/#yuyo.reactions.ReactionHandler.with_callback","title":"with_callback","text":"<pre><code>with_callback(emoji_identifier)\n</code></pre> <p>Add a callback to this reaction handler through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>emoji_identifier</code>               (<code>str | SnowflakeishOr[CustomEmoji]</code>)           \u2013            <p>Identifier of the emoji this callback is for.</p> <p>This should be a snowfake if this is for a custom emoji or a string if this is for a unicode emoji.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callback[[CallbackSig], CallbackSig]</code>           \u2013            <p>A decorator to add a callback to this reaction handler.</p> </li> </ul>"},{"location":"reference/reactions/#yuyo.reactions.ReactionPaginator","title":"ReactionPaginator","text":"<p>               Bases: <code>ReactionHandler</code></p> <p>Standard implementation of a reaction handler for pagination.</p>"},{"location":"reference/reactions/#yuyo.reactions.ReactionPaginator.authors","title":"authors  <code>property</code>","text":"<pre><code>authors\n</code></pre> <p>Set of the authors/owner of a enabled handler.</p> <p>Note</p> <p>If this is empty then the handler is considered public and any user will be able to trigger it.</p>"},{"location":"reference/reactions/#yuyo.reactions.ReactionPaginator.__init__","title":"__init__","text":"<pre><code>__init__(iterator, /, *, authors=(), triggers=(pagination.LEFT_TRIANGLE, pagination.STOP_SQUARE, pagination.RIGHT_TRIANGLE), timeout=datetime.timedelta(seconds=30))\n</code></pre> <p>Initialise a reaction paginator.</p> <p>Parameters:</p> <ul> <li> <code>iterator</code>               (<code>Iterator[EntryT] | AsyncIterator[EntryT]</code>)           \u2013            <p>Either an asynchronous or synchronous iterator of the entries this should paginate through.</p> <p>This should be an iterator of yuyo.pagination.AbstractPages.</p> </li> <li> <code>authors</code>               (<code>Iterable[SnowflakeishOr[User]]</code>, default:                   <code>()</code> )           \u2013            <p>An iterable of IDs of the users who can call this paginator.</p> <p>If no users are provided then the reactions will be public (meaning that anybody can use it).</p> </li> <li> <code>timeout</code>               (<code>timedelta | None</code>, default:                   <code>timedelta(seconds=30)</code> )           \u2013            <p>How long it should take for this paginator to timeout.</p> </li> </ul>"},{"location":"reference/reactions/#yuyo.reactions.ReactionPaginator.add_author","title":"add_author","text":"<pre><code>add_author(user)\n</code></pre> <p>Add a author/owner to this handler.</p> <p>Parameters:</p> <ul> <li> <code>user</code>               (<code>SnowflakeishOr[User]</code>)           \u2013            <p>The user to add as an owner for this handler.</p> </li> </ul>"},{"location":"reference/reactions/#yuyo.reactions.ReactionPaginator.add_first_button","title":"add_first_button","text":"<pre><code>add_first_button(*, emoji=pagination.LEFT_DOUBLE_TRIANGLE, add_reaction=True)\n</code></pre> <p>Add the jump to first entry reaction button to this paginator.</p> <p>You should pass <code>triggers=[]</code> to ReactionPaginator.__init__ before calling this.</p> <p>Note</p> <p>These reactions will appear in the order these methods were called in.</p> <p>Parameters:</p> <ul> <li> <code>emoji</code>               (<code>CustomEmoji | str</code>, default:                   <code>LEFT_DOUBLE_TRIANGLE</code> )           \u2013            <p>The emoji to react with for this button.</p> </li> <li> <code>add_reaction</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the bot should add this reaction to the message when ReactionPaginator.open is called with <code>add_reactions=True</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>To enable chained calls.</p> </li> </ul>"},{"location":"reference/reactions/#yuyo.reactions.ReactionPaginator.add_last_button","title":"add_last_button","text":"<pre><code>add_last_button(*, emoji=pagination.RIGHT_DOUBLE_TRIANGLE, add_reaction=True)\n</code></pre> <p>Add the jump to last entry reaction button to this paginator.</p> <p>You should pass <code>triggers=[]</code> to ReactionPaginator.__init__ before calling this.</p> <p>Note</p> <p>These reactions will appear in the order these methods were called in.</p> <p>Parameters:</p> <ul> <li> <code>emoji</code>               (<code>CustomEmoji | str</code>, default:                   <code>RIGHT_DOUBLE_TRIANGLE</code> )           \u2013            <p>The emoji to react with for this button.</p> </li> <li> <code>add_reaction</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the bot should add this reaction to the message when ReactionPaginator.open is called with <code>add_reactions=True</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>To enable chained calls.</p> </li> </ul>"},{"location":"reference/reactions/#yuyo.reactions.ReactionPaginator.add_next_button","title":"add_next_button","text":"<pre><code>add_next_button(*, emoji=pagination.RIGHT_TRIANGLE, add_reaction=True)\n</code></pre> <p>Add the next entry reaction button to this paginator.</p> <p>You should pass <code>triggers=[]</code> to ReactionPaginator.__init__ before calling this.</p> <p>Note</p> <p>These reactions will appear in the order these methods were called in.</p> <p>Parameters:</p> <ul> <li> <code>emoji</code>               (<code>CustomEmoji | str</code>, default:                   <code>RIGHT_TRIANGLE</code> )           \u2013            <p>The emoji to react with for this button.</p> </li> <li> <code>add_reaction</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the bot should add this reaction to the message when ReactionPaginator.open is called with <code>add_reactions=True</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>To enable chained calls.</p> </li> </ul>"},{"location":"reference/reactions/#yuyo.reactions.ReactionPaginator.add_previous_button","title":"add_previous_button","text":"<pre><code>add_previous_button(*, emoji=pagination.LEFT_TRIANGLE, add_reaction=True)\n</code></pre> <p>Add the previous entry reaction button to this paginator.</p> <p>You should pass <code>triggers=[]</code> to ReactionPaginator.__init__ before calling this.</p> <p>Note</p> <p>These reactions will appear in the order these methods were called in.</p> <p>Parameters:</p> <ul> <li> <code>emoji</code>               (<code>CustomEmoji | str</code>, default:                   <code>LEFT_TRIANGLE</code> )           \u2013            <p>The emoji to react with for this button.</p> </li> <li> <code>add_reaction</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the bot should add this reaction to the message when ReactionPaginator.open is called with <code>add_reactions=True</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>To enable chained calls.</p> </li> </ul>"},{"location":"reference/reactions/#yuyo.reactions.ReactionPaginator.add_stop_button","title":"add_stop_button","text":"<pre><code>add_stop_button(*, emoji=pagination.STOP_SQUARE, add_reaction=True)\n</code></pre> <p>Add the stop reaction button to this paginator.</p> <p>You should pass <code>triggers=[]</code> to ReactionPaginator.__init__ before calling this.</p> <p>Note</p> <p>These reactions will appear in the order these methods were called in.</p> <p>Parameters:</p> <ul> <li> <code>emoji</code>               (<code>CustomEmoji | str</code>, default:                   <code>STOP_SQUARE</code> )           \u2013            <p>The emoji to react with for this button.</p> </li> <li> <code>add_reaction</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the bot should add this reaction to the message when ReactionPaginator.open is called with <code>add_reactions=True</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>To enable chained calls.</p> </li> </ul>"},{"location":"reference/reactions/#yuyo.reactions.ReactionPaginator.close","title":"close  <code>async</code>","text":"<pre><code>close(*, remove_reactions=False)\n</code></pre> <p>Close this handler and deregister any previously registered message.</p> <p>Parameters:</p> <ul> <li> <code>remove_reactions</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this should remove the reactions that were being used to paginate through this from the previously registered message.</p> </li> </ul>"},{"location":"reference/reactions/#yuyo.reactions.ReactionPaginator.create_message","title":"create_message  <code>async</code>","text":"<pre><code>create_message(rest, channel_id, /, *, add_reactions=True)\n</code></pre> <p>Start this handler and link it to a bot message.</p> <p>Note</p> <p>Calling this multiple times will replace the previously registered message.</p> <p>Parameters:</p> <ul> <li> <code>rest</code>               (<code>RESTClient</code>)           \u2013            <p>Rest client to use to make the response.</p> </li> <li> <code>channel_id</code>               (<code>SnowflakeishOr[TextableChannel]</code>)           \u2013            <p>ID of the channel to respond in.</p> </li> <li> <code>add_reactions</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether this should add the paginator's reactions to the message after responding.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Message</code>           \u2013            <p>Object of the message this handler now targets. If <code>message</code> was not supplied then this will be the object of a newly created message, otherwise this will be what was supplied as <code>message</code>.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the provided iterator didn't yield any content for the first message.</p> </li> </ul>"},{"location":"reference/reactions/#yuyo.reactions.ReactionPaginator.get_next_entry","title":"get_next_entry  <code>async</code>","text":"<pre><code>get_next_entry()\n</code></pre> <p>Get the next entry in this paginator.</p> <p>Returns:</p> <ul> <li> <code>AbstractPage | None</code>           \u2013            <p>The next entry in this paginator, or None if there are no more entries.</p> </li> </ul>"},{"location":"reference/reactions/#yuyo.reactions.ReactionPaginator.open","title":"open  <code>async</code>","text":"<pre><code>open(message, /, *, add_reactions=True)\n</code></pre> <p>Start the reaction paginator and start accepting reactions..</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>Message</code>)           \u2013            <p>The message this paginator should target.</p> </li> <li> <code>add_reactions</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether this should add the paginator's reactions to the message.</p> </li> </ul>"},{"location":"reference/reactions/#yuyo.reactions.ReactionPaginator.remove_author","title":"remove_author","text":"<pre><code>remove_author(user)\n</code></pre> <p>Remove a author/owner from this handler.</p> <p>Note</p> <p>If the provided user isn't already a registered owner of this paginator then this should pass silently without raising.</p> <p>Parameters:</p> <ul> <li> <code>user</code>               (<code>SnowflakeishOr[User]</code>)           \u2013            <p>The user to remove from this handler's owners.</p> </li> </ul>"},{"location":"reference/reactions/#yuyo.reactions.ReactionPaginator.remove_callback","title":"remove_callback","text":"<pre><code>remove_callback(emoji_identifier)\n</code></pre> <p>Remove a callback from this reaction handler.</p> <p>Parameters:</p> <ul> <li> <code>emoji_identifier</code>               (<code>str | SnowflakeishOr[CustomEmoji]</code>)           \u2013            <p>Identifier of the emoji the callback to remove is for.</p> <p>This should be a snowfake if this is for a custom emoji or a string if this is for a unicode emoji.</p> </li> </ul>"},{"location":"reference/reactions/#yuyo.reactions.ReactionPaginator.set_callback","title":"set_callback","text":"<pre><code>set_callback(emoji_identifier, callback)\n</code></pre> <p>Add a callback to this reaction handler.</p> <p>Parameters:</p> <ul> <li> <code>emoji_identifier</code>               (<code>str | SnowflakeishOr[CustomEmoji]</code>)           \u2013            <p>Identifier of the emoji this callback is for.</p> <p>This should be a snowfake if this is for a custom emoji or a string if this is for a unicode emoji.</p> </li> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>The callback to add.</p> <p>This should be a function that accepts a single parameter, which is the event that triggered this reaction.</p> </li> </ul>"},{"location":"reference/reactions/#yuyo.reactions.ReactionPaginator.with_callback","title":"with_callback","text":"<pre><code>with_callback(emoji_identifier)\n</code></pre> <p>Add a callback to this reaction handler through a decorator call.</p> <p>Parameters:</p> <ul> <li> <code>emoji_identifier</code>               (<code>str | SnowflakeishOr[CustomEmoji]</code>)           \u2013            <p>Identifier of the emoji this callback is for.</p> <p>This should be a snowfake if this is for a custom emoji or a string if this is for a unicode emoji.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callback[[CallbackSig], CallbackSig]</code>           \u2013            <p>A decorator to add a callback to this reaction handler.</p> </li> </ul>"},{"location":"reference/reactions/#yuyo.reactions._GatewayBotProto","title":"_GatewayBotProto","text":"<p>               Bases: <code>EventManagerAware</code>, <code>RESTAware</code>, <code>Protocol</code></p> <p>Protocol of a cacheless Hikari Gateway bot.</p>"},{"location":"reference/timeouts/","title":"yuyo.timeouts","text":"<p>Classes used for handling timing out components and reaction handlers.</p>"},{"location":"reference/timeouts/#yuyo.timeouts.AbstractTimeout","title":"AbstractTimeout","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract interface used to manage timing out a modals and components.</p>"},{"location":"reference/timeouts/#yuyo.timeouts.AbstractTimeout.has_expired","title":"has_expired  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>has_expired\n</code></pre> <p>Whether this has timed-out.</p>"},{"location":"reference/timeouts/#yuyo.timeouts.AbstractTimeout.increment_uses","title":"increment_uses  <code>abstractmethod</code>","text":"<pre><code>increment_uses()\n</code></pre> <p>Add a use to this.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Whether this has now timed-out.</p> </li> </ul>"},{"location":"reference/timeouts/#yuyo.timeouts.NeverTimeout","title":"NeverTimeout","text":"<p>               Bases: <code>AbstractTimeout</code></p> <p>Timeout implementation which never expires.</p>"},{"location":"reference/timeouts/#yuyo.timeouts.SlidingTimeout","title":"SlidingTimeout","text":"<p>               Bases: <code>AbstractTimeout</code></p> <p>Timeout strategy which resets every use.</p> <p>This implementation times out if <code>timeout</code> passes since the last call or when <code>max_uses</code> is reached.</p>"},{"location":"reference/timeouts/#yuyo.timeouts.SlidingTimeout.__init__","title":"__init__","text":"<pre><code>__init__(timeout, /, *, max_uses=1)\n</code></pre> <p>Initialise a sliding timeout.</p> <p>Parameters:</p> <ul> <li> <code>timeout</code>               (<code>timedelta | int | float</code>)           \u2013            <p>How long this should wait between calls before timing-out.</p> </li> <li> <code>max_uses</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of uses this allows.</p> <p>Setting this to <code>-1</code> marks it as unlimited.</p> </li> </ul>"},{"location":"reference/timeouts/#yuyo.timeouts.StaticTimeout","title":"StaticTimeout","text":"<p>               Bases: <code>AbstractTimeout</code></p> <p>Timeout at a specific time.</p> <p>This implementation times out when <code>timeout_at</code> is reached or when <code>max_uses</code> is reached.</p>"},{"location":"reference/timeouts/#yuyo.timeouts.StaticTimeout.__init__","title":"__init__","text":"<pre><code>__init__(timeout_at, /, *, max_uses=1)\n</code></pre> <p>Initialise a static timeout.</p> <p>Parameters:</p> <ul> <li> <code>timeout_at</code>               (<code>datetime</code>)           \u2013            <p>When this should time out.</p> </li> <li> <code>max_uses</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum amount of uses this allows.</p> <p>Setting this to <code>-1</code> marks it as unlimited.</p> </li> </ul>"},{"location":"reference/to_builder/","title":"yuyo.to_builder","text":"<p>Utility functions for converting Hikari data modals to builders.</p>"},{"location":"reference/to_builder/#yuyo.to_builder.to_button_builder","title":"to_button_builder","text":"<pre><code>to_button_builder(button)\n</code></pre> <p>Convert a button component to a builder.</p> <p>Parameters:</p> <ul> <li> <code>button</code>               (<code>ButtonComponent</code>)           \u2013            <p>The button component to convert to a builder.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>LinkButtonBuilder | InteractiveButtonBuilder</code>           \u2013            <p>The buttion builder.</p> </li> </ul>"},{"location":"reference/to_builder/#yuyo.to_builder.to_channel_select_menu_builder","title":"to_channel_select_menu_builder","text":"<pre><code>to_channel_select_menu_builder(select_menu)\n</code></pre> <p>Convert a channel select menu component to a builder.</p> <p>Parameters:</p> <ul> <li> <code>select_menu</code>               (<code>ChannelSelectMenuComponent</code>)           \u2013            <p>The select menu to convert to a builder.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ChannelSelectMenuBuilder</code>           \u2013            <p>The select menu builder.</p> </li> </ul>"},{"location":"reference/to_builder/#yuyo.to_builder.to_cmd_builder","title":"to_cmd_builder","text":"<pre><code>to_cmd_builder(cmd)\n</code></pre> <p>Convert a partial command to a command builder.</p> <p>Parameters:</p> <ul> <li> <code>cmd</code>               (<code>PartialCommand</code>)           \u2013            <p>The command to convert to a builder.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CommandBuilder</code>           \u2013            <p>The command builder.</p> <p>This will always be a subclass.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NotImplementedError</code>             \u2013            <p>If an unsupported command type is passed.</p> <p>Currently hikari.SlashCommand and hikari.ContextMenuCommand are supported.</p> </li> </ul>"},{"location":"reference/to_builder/#yuyo.to_builder.to_context_menu_builder","title":"to_context_menu_builder","text":"<pre><code>to_context_menu_builder(cmd)\n</code></pre> <p>Convert a context menu command to a builder.</p> <p>Parameters:</p> <ul> <li> <code>cmd</code>               (<code>ContextMenuCommand</code>)           \u2013            <p>The context menu command to convert to a builder.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ContextMenuCommandBuilder</code>           \u2013            <p>The context menu command builder.</p> </li> </ul>"},{"location":"reference/to_builder/#yuyo.to_builder.to_msg_action_row_builder","title":"to_msg_action_row_builder","text":"<pre><code>to_msg_action_row_builder(action_row)\n</code></pre> <p>Convert a message action row component to a builder.</p> <p>Parameters:</p> <ul> <li> <code>action_row</code>               (<code>MessageActionRowComponent</code>)           \u2013            <p>The message action row to convert to a builder.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>MessageActionRowBuilder</code>           \u2013            <p>The message action row builder.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NotImplementedError</code>             \u2013            <p>If the action row contains an unsupported component type.</p> <p>The following are currently supported:</p> <ul> <li>ACTION_ROW</li> <li>BUTTON</li> <li>TEXT_SELECT_MENU</li> <li>USER_SELECT_MENU</li> <li>ROLE_SELECT_MENU</li> <li>MENTIONABLE_SELECT_MENU</li> <li>CHANNEL_SELECT_MENU</li> </ul> </li> </ul>"},{"location":"reference/to_builder/#yuyo.to_builder.to_select_menu_builder","title":"to_select_menu_builder","text":"<pre><code>to_select_menu_builder(select_menu)\n</code></pre> <p>Convert a select menu component to a builder.</p> <p>Parameters:</p> <ul> <li> <code>select_menu</code>               (<code>SelectMenuComponent</code>)           \u2013            <p>The select menu to convert to a builder.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SelectMenuBuilder</code>           \u2013            <p>The select menu builder.</p> </li> </ul>"},{"location":"reference/to_builder/#yuyo.to_builder.to_slash_cmd_builder","title":"to_slash_cmd_builder","text":"<pre><code>to_slash_cmd_builder(cmd)\n</code></pre> <p>Convert a slash command to a builder.</p> <p>Parameters:</p> <ul> <li> <code>cmd</code>               (<code>SlashCommand</code>)           \u2013            <p>The command to convert to a builder.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SlashCommandBuilder</code>           \u2013            <p>The slash command builder.</p> </li> </ul>"},{"location":"reference/to_builder/#yuyo.to_builder.to_text_select_menu_builder","title":"to_text_select_menu_builder","text":"<pre><code>to_text_select_menu_builder(select_menu)\n</code></pre> <p>Convert a text select menu component to a builder.</p> <p>Parameters:</p> <ul> <li> <code>select_menu</code>               (<code>TextSelectMenuComponent</code>)           \u2013            <p>The select menu to convert to a builder.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>TextSelectMenuBuilder</code>           \u2013            <p>The select menu builder.</p> </li> </ul>"},{"location":"usage/","title":"Usage guide","text":"<p>This usage guide goes into detail about how to use Yuyo with Hikari.</p> <p>A more general Hikari guide which includes some basic examples of how to use Yuyo for component and modal execution can be found here.</p>"},{"location":"usage/#sections","title":"Sections","text":"<ul> <li>Asgi - How to use Yuyo's ASGI implementation of a Hikari REST Bot.</li> <li>Builders - How to use Yuyo to convert models to builder objects.</li> <li>Chunk Tracker - How to use Yuyo to track a gateway bot's chunk requests.</li> <li>Components - How to use Yuyo to create and handle message components.</li> <li>Links - How to use Yuyo to parse and make Discord links.</li> <li>List Status - How to use Yuyo to update a bot's guild count on bot listing sites.</li> <li>Modals - How to use Yuyo to create and handle Modal prompts.</li> </ul>"},{"location":"usage/asgi/","title":"Asgi","text":"<p>The AsgiBot is a RESTBot implementation which acts as an ASGI application to handle the interaction requests received from Discord for slash commands, context menus, message components and modals as part of an ASGI server.</p> <pre><code>rest_bot = yuyo.asgi.AsgiBot(os.environ[\"TOKEN\"])\ntanjun.Client.from_rest_bot(rest_bot)\n\n# ... more setup\n</code></pre> <p>If the above example was saved in the file \"bot.py\" (within the current working directory) then the following may be run in the command line to run this bot using Uvicorn:</p> <pre><code>uvicorn bot:rest_bot\n</code></pre> <p>But since ASGI is a generic standard, you can also run this bot in other tooling such as Hypercorn, Daphne, or using FastAPI's sub-applications to mount this bot on a specific route within an existing FastAPI server:</p> <pre><code>bot = yuyo.asgi.AsgiBot(os.environ[\"TOKEN\"], asgi_managed=False)\n\napp = fastapi.FastAPI(on_startup=[bot.start], on_shutdown=[bot.close])\n\napp.mount(\"/bot\", bot)\n</code></pre> <p>The extra steps this example goes through to let FastAPI startup and shutdown the AsgiBot are only necessary when mounting as a FastAPI sub-application.</p>"},{"location":"usage/asgi/#serverless","title":"Serverless","text":"<pre><code>bot = yuyo.AsgiBot(os.environ[\"TOKEN\"].strip(), \"Bot\")\n\n# ... Setup bot\n\nentry_point = agraffe.Agraffe.entry_point(bot)\n</code></pre> <p>Thanks to the flexibility of the ASGI standard, this can also be used with serverless frameworks people have implemented ASGI adapters for. The above example uses agraffe to create an entry point for AWS Lambdas, Azure Functions, or Google Cloud Functions.</p>"},{"location":"usage/builders/","title":"Builders","text":"<p>Yuyo provides several methods for converting Hikari data objects to writeable builder objects.</p>"},{"location":"usage/builders/#commands","title":"Commands","text":"<pre><code>builder = yuyo.to_builder.to_cmd_builder(cmd)\n</code></pre> <p>to_cmd_builder converts a hikari.PartialCommand object to the relevant builder object.</p> <p>to_slash_cmd_builder and to_context_menu_builder can be used to convert command objects where the command type is already known without losing this information typing wise.</p>"},{"location":"usage/builders/#message-components","title":"Message components","text":"<pre><code>builder = yuyo.to_builder.to_msg_action_row_builder(row)\n</code></pre> <p>to_msg_action_row_builder converts a hikari.MessageActionRowComponent object to a hikari.api.MessageActionRowBuilder object.</p> <p>There's several other methods which can be used to convert the sub-component objects found in message action rows to builder objects:</p> <ul> <li>to_select_menu_builder</li> <li>to_channel_select_menu_builder</li> <li>to_text_select_menu_builder</li> <li>to_button_builder</li> </ul>"},{"location":"usage/chunk_tracker/","title":"Chunk Tracker","text":"<p>The chunk tracker in yuyo.chunk_tracker dispatches custom chunk request tracking events. This can be a useful way to work out when the cache will be reliable for a guild or globally (when combined with checking the intent and cache config).</p> <pre><code>yuyo.chunk_tracker.ChunkTracker.from_gateway_bot(bot)\n</code></pre> <p>While this is easy to setup, there are some things you need to account for. This will only track chunk requests (including startup chunk requests) as long if have a set nonce (luckily Hikari's startup requests include nonces). ChunkTracker.request_guild_members ensures that a nonce is always set.</p> <p>The chunk tracker can be configured to automatically send chunk requests (with nonces) on guild join itself using ChunkTracker.set_auto_chunk_members. This can be useful if you need auto chunking in scenarios where it otherwise would be disabled (e.g. when using a separate async cache instead of Hikari's builtin cache).</p>"},{"location":"usage/chunk_tracker/#events","title":"Events","text":""},{"location":"usage/chunk_tracker/#chunk-request-finished-event","title":"Chunk Request Finished Event","text":"<p>ChunkRequestFinishedEvent is dispatched when a specific chunk request has finished.</p> <pre><code>@bot.listen()\nasync def on_chunk_request_finished(event: yuyo.chunk_tracker.ChunkRequestFinishedEvent) -&gt; None:\n    event.app\n    event.shard  # type: hikari.api.GatewayShard\n    event.chunk_count  # type: int\n    event.first_received_at  # type: datetime.datetime\n    event.guild_id  # type: hikari.Snowflake\n    event.last_received_at  # type: datetime.datetime\n    event.missed_chunks  # type: collections.abc.Collection[int]\n    event.not_found_ids  # type: collections.abc.Collection[hikari.Snowflake]\n</code></pre> <p>This is only dispatch for chunk requests where a <code>nonce</code> has been set.</p>"},{"location":"usage/chunk_tracker/#finished-chunking-event","title":"Finished Chunking Event","text":"<p>FinishedChunkingEvent is dispatched when the startup chunking has finished for the bot to indicate that the member and presence caches should be complete (if enabled).</p> <pre><code>@bot.listen()\nasync def on_finished_chunking(event: yuyo.chunk_tracker.FinishedChunkingEvent) -&gt; None:\n    event.app\n</code></pre> <p>This is only dispatched once per-bot lifetime.</p>"},{"location":"usage/chunk_tracker/#shard-finished-chunking-event","title":"Shard Finished Chunking Event","text":"<p>ShardFinishedChunkingEvent is dispatched when the startup chunking has finished for a specific shard to indicate that the member and presence caches should be complete for the guilds covered by this shard.</p> <pre><code>@bot.listen()\nasync def on_shard_finished_chunking(event: yuyo.chunk_tracker.ShardFinishedChunkingEvent) -&gt; None:\n    event.app\n    event.shard  # type: hikari.api.GatewayShard\n    event.incomplete_guild_ids  # collections.abc.Sequence[hikari.Snowflake]\n    event.missed_guild_ids  # collections.abc.Sequence[hikari.Snowflake]\n</code></pre>"},{"location":"usage/components/","title":"Message Components","text":"<p>Message components are the interactive buttons and select menus you'll see on some messages sent by bots.</p>"},{"location":"usage/components/#making-a-component-client","title":"Making a Component Client","text":"<p>The Component client keeps track of registered components and handles executing them.</p> <p>This can be created with any of the following class methods:</p> <ul> <li>ComponentClient.from_gateway_bot:     Create a component client from a Hikari gateway bot (i.e.     hikari.GatewayBot).</li> <li>ComponentClient.from_rest_bot:     Create a component client from a Hikari REST bot (i.e.     hikari.RESTBot or yuyo.asgi.AsgiBot).</li> <li> <p>ComponentClient.from_tanjun:     Create a component client from a Tanjun Client.</p> <p>This method will make the component client use Tanjun's Alluka client for dependency injection, essentially mirroring the dependencies registered for Tanjun's DI while also registering ComponentClient as a type dependency.</p> </li> </ul> <p>Client state can be managed through dependency injection. This is implemented using Alluka and more information about it can be found in Alluka's usage guide. The Alluka client used for component execution can be found at ComponentClient.alluka.</p> <p>For the sake of simplicity, the following examples all assume the component client can be accessed through Alluka style dependency injection.</p>"},{"location":"usage/components/#types-of-components","title":"Types of components","text":""},{"location":"usage/components/#buttons","title":"Buttons","text":"<p>Message buttons have several different styles, as shown above. Most of these are interactive, meaning that an interaction will be sent to the bot when a user clicks on it. The only non-interactive style is link buttons which simply open the set link in a browser for the user who clicked on it.</p> <p>A row can have up to 5 buttons in it.</p>"},{"location":"usage/components/#select-menus","title":"Select Menus","text":"<p>Select menus let users select between 0 to 25 options (dependent on how the bot configured it). These selections are communicated to the bot once the user has finished selecting options via an interaction and there's several different resources they can be selecting:</p> <ul> <li>Text menus: lets the bot pre-define up to 25 text options</li> <li>User menus: lets the user pick up to 25 users</li> <li>Role menus: lets the user pick up to 25 roles</li> <li>Channel menus: lets the user pick up to 25 channels</li> <li>Mentionable menus: lets the user pick up to 25 roles and users</li> </ul> <p>Note</p> <p>As of writing user, role, channel and mentionable menus only let you select entities from the current guild. Only text menus work properly in DM channels.</p> <p>Each select menu takes up a whole row.</p>"},{"location":"usage/components/#declaring-components","title":"Declaring Components","text":"<p>When adding sub-components to a select menu, they'll either be appended to the last row or they'll be added to a new row if the new entry wouldn't fit in the last row.</p> <p>A message can only have up to 5 component rows on it.</p> <p>There's several different ways to declare components using Yuyo:</p>"},{"location":"usage/components/#subclassing","title":"Subclassing","text":"<pre><code>class Column(components.ActionColumnExecutor):\n    @components.as_channel_menu\n    async def on_channel_menu(self, ctx: components.Context) -&gt; None:\n        ctx.selected_channels\n\n    @components.as_role_menu\n    async def on_role_menu(self, ctx: components.Context) -&gt; None:\n        ctx.selected_roles\n\n    @components.with_option(\"opt3\", \"value3\")\n    @components.with_option(\"opt2\", \"value2\")\n    @components.with_option(\"opt1\", \"value1\")\n    @components.as_text_menu\n    async def on_text_menu(self, ctx: components.Context) -&gt; None:\n        ctx.selected_texts\n\n    @components.as_user_menu\n    async def on_user_menu(self, ctx: components.Context) -&gt; None:\n        ctx.selected_users\n\n    @components.as_mentionable_menu\n    async def on_mentionable_menu(self, ctx: components.Context) -&gt; None:\n        ctx.selected_roles\n        ctx.selected_users\n</code></pre> <p>When subclassing ActionColumnExecutor, you can use any of the following class descriptors to add \"static\" sub-components (which'll be included on every instance and subclass of the column) to it:</p> <ul> <li>as_channel_menu</li> <li>as_interactive_button</li> <li>as_mentionable_menu</li> <li>as_role_menu</li> <li>as_text_menu</li> <li>as_user_menu</li> <li>link_button</li> </ul> <pre><code>class Column(components.ActionColumnExecutor):\n    @components.as_interactive_button(hikari.ButtonStyle.DANGER, emoji=\"\ud83d\udc4d\")\n    async def on_button(self, ctx: components.Context) -&gt; None: ...\n\n    link_button = components.link_button(\"https://example.com\", label=\"label\")\n</code></pre> <p>Most of these descriptors decorate a callback which'll be called when that specific sub-component is used by a user, with the only exception being link buttons which open a link for the user instead of sending an interaction to the bot.</p> <p>Warning</p> <p>If you declare <code>__init__</code> on an ActionColumnExecutor subclass then you must make sure to first call <code>super().__init__()</code> in it.</p> <pre><code>column_template = (\n    components.column_template()\n    .add_static_channel_menu(callback)\n    .add_static_text_menu(callback)\n    .add_option(\"opt1\", \"value1\")\n    .add_option(\"opt2\", \"value2\")\n    .add_option(\"opt3\", \"value3\")\n    .parent\n    .add_static_role_menu(callback)\n    .add_static_link_button(\"https://example.com\")\n    .add_static_interactive_button(hikari.ButtonStyle.DANGER, callback, label=\"\ud83d\udc4d\")\n)\n</code></pre> <p>Alternatively, static sub-components can be added to an ActionColumnExecutor subclass using its chainable <code>add_static_{}</code> class methods.</p> <pre><code>column_template = components.column_template()\n\n@column_template.with_static_channel_menu\nasync def on_channel_menu(ctx: components.Context) -&gt; None: ...\n\n@components.with_option(\"opt3\", \"value3\")\n@components.with_option(\"opt2\", \"value2\")\n@components.with_option(\"opt1\", \"value1\")\n@column_template.with_static_text_menu\nasync def on_text_menu(ctx: components.Context) -&gt; None: ...\n\n@column_template.with_static_role_menu\nasync def on_role_menu(ctx: components.Context) -&gt; None: ...\n\n@column_template.with_static_interactive_button(hikari.ButtonStyle.DANGER, label=\"\ud83d\udc4d\")\nasync def on_button(ctx: components.Context) -&gt; None: ...\n</code></pre> <p>Or by using its <code>with_static_{}</code> decorator class methods. The only sub-component type which cannot be added through a decorator call is link buttons.</p> <p>Note</p> <p>column_template just provides a shorthand for creating an ActionColumnExecutor subclass and all of these class methods also work on a normal class.</p>"},{"location":"usage/components/#builder","title":"Builder","text":"<pre><code>column = (\n    components.ActionColumnExecutor()\n    .add_channel_menu(callback)\n    .add_text_menu(callback)\n    .add_option(\"opt1\", \"value1\")\n    .add_option(\"opt2\", \"value2\")\n    .add_option(\"opt3\", \"value3\")\n    .parent\n    .add_role_menu(callback)\n    .add_link_button(\"https://example.com\", label=\"label\")\n    .add_interactive_button(hikari.ButtonStyle.DANGER, callback, label=\"\ud83d\udc4d\")\n)\n</code></pre> <p>You can also dynamically build a ActionColumnExecutor after initialising it by using its chainable <code>add_{}</code> methods to add sub-components.</p> <pre><code>column = components.ActionColumnExecutor()\n\n@column.with_channel_menu\nasync def on_channel_menu(ctx: components.Context) -&gt; None: ...\n\n@components.with_option(\"opt3\", \"value3\")\n@components.with_option(\"opt2\", \"value2\")\n@components.with_option(\"opt1\", \"value1\")\n@column.with_text_menu\nasync def on_text_menu(ctx: components.Context) -&gt; None: ...\n\n@column.with_role_menu\nasync def on_role_menu(ctx: components.Context) -&gt; None: ...\n\n@column.with_interactive_button(hikari.ButtonStyle.DANGER, label=\"\ud83d\udc4d\")\nasync def on_button(ctx: components.Context) -&gt; None: ...\n</code></pre> <p>Or by using its <code>with_{}</code> decorator methods. The only sub-component type which can't be added through a decorator call is link buttons.</p>"},{"location":"usage/components/#handling-component-interactions","title":"Handling Component Interactions","text":"<p>There's two main ways to handle component interactions with Yuyo:</p>"},{"location":"usage/components/#stateful","title":"Stateful","text":"<pre><code>class ColumnCls(components.ActionColumnExecutor):\n    __slots__ = (\"state\",)\n\n    def __init__(self, state: int) -&gt; None:\n        super().__init__()\n        self.state = state\n\n    @components.as_interactive_button(hikari.ButtonStyle.DANGER, emoji=\"\ud83d\udc4d\")\n    async def on_button(self, ctx: components.Context) -&gt; None: ...\n\nasync def callback(ctx: components.Context, component_client: alluka.Injected[components.Client]) -&gt; None:\n    column = ColumnCls(123)\n    message = await ctx.respond(components=column.rows)\n    component_client.register_executor(column, message=message)\n</code></pre> <p>Subclassing ActionColumnExecutor allows you to associate state with a specific message's components through OOP.</p> <p>When doing this you'll usually be creating an instance of the components column per message.</p> <p>ComponentClient.register_executor defaults <code>timeout</code> to a 30 second sliding timeout (meaning that the timer resets every use).</p>"},{"location":"usage/components/#stateless","title":"Stateless","text":"<pre><code>class ColumnCls(components.ActionColumnExecutor):\n    @components.as_interactive_button(hikari.ButtonStyle.DANGER, emoji=\"\ud83d\udc4d\")\n    async def on_button(self, ctx: components.Context) -&gt; None:\n        session_id = uuid.UUID(ctx.id_metadata)\n\ncolumn = ColumnCls()\n\nclient = components.ComponentClient()\nclient.register_executor(column, timeout=None)\n\n...\n\nasync def callback(ctx: components.Context, component_client: alluka.Injected[components.Client]) -&gt; None:\n    session_id = uuid.uuid4()\n    await ctx.respond(components=ColumnCls(id_metadata={\"on_button\": str(session_id)}).rows)\n</code></pre> <p>Alternatively, components can be reused by registering the component to the client on startup with <code>timeout=None</code> and sending the same component's rows per-execution.</p> <p>Custom IDs have some special handling which allows you to track some metadata for a specific message's components. They are split into two parts as <code>\"{match}:{metadata}\"</code>, where the \"match\" part is what Yuyo will use to find the executor for a message's components and the \"metadata\" (ComponentContext.id_metadata) part represents any developer added metadata for that specific instance of the component.</p> <p>The <code>id_metadata</code> init argument lets you set the metadata for the static components in an action column while initiating it by passing a dict of match IDs/descriptor callback names to the metadata for each specified component.</p> <p>Custom IDs cannot be longer than 100 characters in total length and the match parts of the custom IDs in an executor have to be globally unique when registering it globally (i.e. without passing <code>message=</code>).</p> <p>Note</p> <p>For stateless components like described/above to work properly the match part of custom IDs needs to stay the same between bot restarts.</p> <p>The <code>as_</code> descriptors achieve this by generating a constant default ID from the path for the component's callback (which consists of the callback's name and the qualnames of the class and the relevant modules). This does, however, mean that any changes to the function's name or the name of the class/modules it's in will change this generated custom ID leading to it no-longer match any previously declared message components.</p> <p>However, the <code>add_</code> and <code>with_</code> (class)methods generate a random default whenever called and will have to be manually supplied a constant custom ID through the optional <code>custom_id</code> argument. The <code>as_</code> descriptors also have a <code>custom_id</code> argument which overrides the default path generated ID.</p>"},{"location":"usage/components/#responding-to-components","title":"Responding to Components","text":"<pre><code>class ColumnCls(components.ActionColumnExecutor):\n    @components.as_interactive_button(hikari.ButtonStyle.DANGER, emoji=\"\ud83d\udc4d\")\n    async def on_button(self, ctx: components.Context) -&gt; None:\n        await ctx.respond(\n            \"Message content\",\n            attachments=[hikari.URL(\"https://img3.gelbooru.com/images/40/5a/405ad89e26a8ec0e96fd09dd1ade334b.jpg\")],\n        )\n</code></pre> <p>ComponentContext.respond is used to respond to an interaction with a new message, this has a similar signature to Hikari's message respond method but will only be guaranteed to return a hikari.Message object when <code>ensure_result=True</code> is passed.</p> <p>Alternatively, yuyo.InteractionError can be raised to end the execution of a component with a response message.</p>"},{"location":"usage/components/#ephemeral-responses","title":"Ephemeral responses","text":"<pre><code>class ColumnCls(components.ActionColumnExecutor):\n    @components.as_interactive_button(hikari.ButtonStyle.DANGER, emoji=\"\ud83d\udc4d\")\n    async def on_button(self, ctx: components.Context) -&gt; None:\n        await ctx.create_initial_response(\"Starting cat\", ephemeral=True)\n        await ctx.create_followup(\"The cat rules us all now\", ephemeral=True)\n</code></pre> <p>Ephemeral responses mark the response message as private (so that only the author can see it) and temporary. A response can be marked as ephemeral by passing <code>ephemeral=True</code> to either ComponentContext.create_initial_response (when initially responding to the interaction with a message response) or ComponentContext.create_followup (for followup responses).</p>"},{"location":"usage/components/#deferrals","title":"Deferrals","text":"<p>Interactions need an initial response within 3 seconds but, if you can't give a response within 3 seconds, you can defer the first response using ComponentContext.defer.</p> <p>A deferral should then be finished by editing in the initial response using either ComponentContext.edit_initial_response or ComponentContext.respond and if you want a response to be an ephemeral message create then you'll have to pass <code>ephemeral=True</code> when deferring.</p>"},{"location":"usage/components/#updating-the-source-message","title":"Updating the source message","text":"<pre><code>class ColumnCls(components.ActionColumnExecutor):\n    @components.as_interactive_button(hikari.ButtonStyle.DANGER, emoji=\"\ud83d\udc4d\")\n    async def on_button(self, ctx: components.Context) -&gt; None:\n        await ctx.create_initial_response(response_type=hikari.ResponseType.MESSAGE_UPDATE, attachments=[])\n</code></pre> <p>You can also use the initial response to edit the message the component being used is on. To do this you need to pass <code>response_type=hikari.ResponseType.MESSAGE_UPDATE</code> while calling ComponentContext.create_initial_response. After doing this any further calls to ComponentContext.delete_initial_response and ComponentContext.edit_initial_response will target the source message as well.</p> <p>You cannot change the ephemeral state of the source message.</p> <p>You need to pass <code>response_type=hikari.ResponseType.DEFERRED_MESSAGE_UPDATE</code> When deferring with the intent to update the source message.</p>"},{"location":"usage/components/#modal-responses","title":"Modal responses","text":"<p>You can also create a Modal prompt as the initial response to a component interaction.</p> <p>For more information on how to handle modals see the Modals usage guide, where ComponentContext.create_modal_response should be used to create the initial prompt.</p>"},{"location":"usage/components/#other-executors","title":"Other Executors","text":""},{"location":"usage/components/#pagination","title":"Pagination","text":"<p>Yuyo provides standard component implementations for handling paginating message responses. These all function by adding buttons to the messages which are used to move between the response pages.</p>"},{"location":"usage/components/#runtime-pagination","title":"Runtime pagination","text":"<p>components.ComponentPaginator is a paginator implementation for creating transient paginators which are linked to specific responses/messages.</p> <pre><code>async def command(ctx: components.Context, component_client: alluka.Injected[components.Client]) -&gt; None:\n    pages = [pagination.Page(\"Page 1\"), pagination.Page(\"Page 2\"), pagination.Page(\"Page 3\")]\n    paginator = components.Paginator(iter(pages))\n\n    message = await ctx.respond(components=paginator.rows, ensure_result=True)\n    component_client.register_executor(paginator, message=message)\n</code></pre> <p>This paginator takes iterators/generators of yuyo.pagination.Pages and will only push the iterator forwards as the user interacts with the paginator. This allows for lazily generating responses.</p> <p>Because of this you must use iter before passing a list of pre-built data to its init.</p> <pre><code>pages = (pagination.Page(content) async for content in _async_iterator())\npaginator = components.Paginator(pages)\n</code></pre> <p>This also supports asynchronous iterators/generators, allowing for functionality like fetching data as the user scrolls through it.</p> <pre><code>paginator = (\n    components.Paginator(pages, triggers=[])\n    .add_first_button()\n    .add_previous_button()\n    .add_stop_button()\n    .add_next_button()\n    .add_last_button()\n)\n</code></pre> <p>The paginator only enables 3 buttons by default: step backwards, stop and step forwards. To enable the other 2 buttons or even just customise these buttons (i.e. set a specific custom_id or emoji/label) you should pass <code>triggers=[]</code> to ComponentPaginator.__init__ to disable the default triggers then use the provided builder methods as shown above.</p> <p>You can also add your own buttons to this alongside the pagination buttons using the methods provided by ActionColumnExecutor.</p>"},{"location":"usage/components/#static-pagination","title":"Static pagination","text":"<p>components.StaticPaginator is a static paginator implementation. For this you register paginator pages on bot startup and then use the chosen ID to add associated paginator components to messages/responses.</p> <pre><code>component_client = components.Client.from_gateway_bot(bot)\nmodal_client = modals.Client.from_gateway_bot(bot)\nPAGINATOR_ID = \"PAGINATOR_1\"\n\n(\n    components.StaticPaginatorIndex()\n    .set_paginator(PAGINATOR_ID, [pagination.Page(\"Page 1\"), pagination.Page(\"Page 2\"), pagination.Page(\"Page 3\")])\n    .add_to_clients(component_client, modal_client)\n)\n\n...\n\nasync def callback(\n    ctx: components.Context, paginator_index: alluka.Injected[components.StaticPaginatorIndex]\n) -&gt; None:\n    paginator = paginator_index.get_paginator(PAGINATOR_ID)\n    await ctx.respond(**paginator.pages[0].to_kwargs(), components=paginator.make_components(0).rows)\n</code></pre> <p>Buttons can be added or modified by extending components.StaticPaginator. <code>include_buttons=False</code> will need to be passed to components.StaticPaginator.__init__ if you want to override the default buttons using the relevant <code>set_</code> methods.</p> <pre><code>components.StaticPaginatorIndex().set_paginator(PAGINATOR_ID, pages, content_hash=\"v0.1.0\")\n</code></pre> <p><code>content_hash</code> can be passed to StaticPaginatorIndex.set_paginator to indicate the version of the state being stored by the bot for a paginator ID. Messages linked to old versions will be left in a no-op state when this is set.</p>"},{"location":"usage/links/","title":"Links","text":"<p>Yuyo provides some utilities for handling Discord links in yuyo.links.</p>"},{"location":"usage/links/#baselink","title":"BaseLink","text":"<p>All BaseLink implementations come with 3 classmethods for parsing them from strings.</p> <p>All of these methods take a Hikari \"app\" (Bot or REST app object) as their first argument.</p> <pre><code>link = links.TemplateLink.from_link(app, \"https://discord.new/aaaaaaaaaa\")\n</code></pre> <p>BaseLink.from_link lets you parse a raw link string. This is strict about validation and will raise a ValueError if the full passed string isn't a match for the expected link structure.</p> <pre><code>if link := links.InviteLink.find(app, \"meow you can nyaa us at discord.gg/nekosmeowers\"):\n    ...\n</code></pre> <p>BaseLink.find lets you extract the first link in a string. This will search for a link at any point in the string and returns the parsed link object or None if no link was found.</p> <pre><code>for _link in links.MessageLink.find_iter(app, \"message content\"):\n    ...\n</code></pre> <p>BaseLink.find_iter lets you iterate over the matching links in a string by iterating over link objects which were parsed from the string.</p>"},{"location":"usage/links/#baselink-implementations","title":"BaseLink implementations","text":"<p>There are 5 implementations of BaseLink provided by Yuyo (which all support the parsing methods listed above):</p>"},{"location":"usage/links/#channel-links","title":"Channel links","text":"<pre><code>link = links.ChannelLink.from_link(app, \"https://discord.com/channels/453123/67765564\")\n\nlink.is_dm_link  # value: False\nlink.guild_id  # value: 453123\nlink.channel_id  # value: 67765564\nawait link.fetch_channel()  # type: hikari.PartialChannel\nlink.get_channel()  # type: hikari.GuildChannel | None\nawait link.fetch_guild()  # type: hikari.RESTGuild | None\nlink.get_guild()  # type: hikari.GatewayGuild | None\nstr(link)  # value: \"https://discord.com/channels/453123/67765564\"\n</code></pre> <p>ChannelLink handles parsing channel links.</p> <p>ChannelLink.guild_id will be None for DM channels.</p> <pre><code>link = links.make_channel_link(123312, guild=6534234)\nlink  # value: \"https://discord.com/channels/6534234/123312\"\nlink = links.make_channel_link(543123)\nlink  # value: \"https://discord.com/channels/@me/543123\"\n</code></pre> <p>links.make_channel_link lets you make a channel link string.</p>"},{"location":"usage/links/#invite-links","title":"Invite links","text":"<pre><code>link = links.InviteLink.from_link(app, \"https://discord.gg/nekosmeowers\")\n\nlink.code  # value: \"nekosmeowers\"\nawait link.fetch_invite()  # type: hikari.Invite\nlink.get_invite()  # type: hikari.InviteWithMetadata | None\nstr(link)  # value: \"https://discord.gg/nekosmeowers\"\n</code></pre> <p>InviteLink handles parsing invite links.</p> <pre><code>link = links.make_invite_link(\"codecode\")\nlink  # value: \"https://discord.gg/codecode\"\n</code></pre> <p>links.make_invite_link lets you make an invite link string.</p>"},{"location":"usage/links/#message-links","title":"Message links","text":"<pre><code>link = links.MessageLink.from_link(app, \"https://discord.com/channels/54123123321123/2134432234342/56445234124\")\n\nlink.is_dm_link  # value: False\nlink.guild_id  # value: 54123123321123\nlink.channel_id  # value: 2134432234342\nlink.message_id  # value: 56445234124\nawait link.fetch_message()  # type: hikari.Message\nlink.get_message()  # type: hikari.Message | None\nawait link.fetch_channel()  # type: hikari.PartialChannel\nlink.get_channel()  # type: hikari.GuildChannel | None\nawait link.fetch_guild()  # type: hikari.RESTGuild | None\nlink.get_guild()  # type: hikari.GatewayGuild | None\nstr(link)  # value: \"https://discord.com/channels/54123123321123/2134432234342/56445234124\"\n</code></pre> <p>MessageLink handles parsing message links.</p> <p>MessageLink.guild_id will be None for DM messages.</p> <pre><code>#                             (channel_id, message_id)\nlink = links.make_message_link(654323412, 4534512332, guild=123321)\nlink  # value: \"https://discord.com/channels/123321/654323412/4534512332\"\nlink = links.make_message_link(333333333, 5555555555)\nlink  # value: \"https://discord.com/channels/@me/333333333/5555555555\"\n</code></pre> <p>links.make_message_link lets you make a message link string.</p>"},{"location":"usage/links/#guild-template-links","title":"Guild template links","text":"<pre><code>link = links.TemplateLink.from_link(app, \"https://discord.new/aaaaaaaaaa\")\n\nlink.code  # value: \"aaaaaaaaaa\"\nawait link.fetch_template()  # type: hikari.Template\nstr(link)  # value: \"https://discord.new/aaaaaaaaaa\"\n</code></pre> <p>TemplateLink handles parsing guild template links.</p> <pre><code>raw_link = links.make_template_link(\"cododododoe\")\nraw_link  # value: \"https://discord.new/cododododoe\"\n</code></pre> <p>links.make_template_link lets you make a template link string.</p>"},{"location":"usage/links/#webhook-links","title":"Webhook links","text":"<pre><code>link = links.WebhookLink.from_link(app, \"https://discord.com/api/webhooks/123321123/efsdfasdsa\")\n\nlink.webhook_id  # value: 123321123\nlink.token  # value: \"efsdfasdsa\"\nawait link.fetch_webhook()  # type: hikari.IncomingWebhook\nstr(link)  # value: \"https://discord.com/api/webhooks/123321123/efsdfasdsa\"\n</code></pre> <p>WebhookLink handles parsing webhook links.</p> <p>This class inherits from hikari.ExecutableWebhook and therefore has all the webhook execute methods you'll find on interaction and webhook objects.</p> <pre><code>raw_link = links.make_webhook_link(123321, \"hfdssdasd\")\nraw_link  # value: \"https://discord.com/api/webhooks/123321/hfdssdasd\"\n</code></pre> <p>links.make_webhook_link lets you make a webhook link string.</p>"},{"location":"usage/links/#bot-invite-links","title":"Bot invite links","text":"<pre><code>permissions = hikari.Permissions.BAN_MEMBERS | hikari.Permissions.MANAGE_CHANNELS\nraw_link = links.make_bot_invite(463183358445355009, permissions=permissions)\nraw_link  # value: https://discord.com/api/oauth2/authorize?client_id=463183358445355009&amp;scope=bot&amp;permissions=20\n</code></pre> <p>links.make_bot_invite lets you make a bot invite link.</p> <p>This takes the bot's ID as its first argument and has several optional parameters:</p> <ul> <li><code>permissions</code>: Specifies the permissions to request.</li> <li><code>guild</code>: ID of a specific guild to pre-select for the user.</li> <li><code>disable_guild_select</code>: Whether to stop the user from selecting another guild when   <code>guild</code> has also been passed.</li> </ul> <p>links.make_oauth_link can also be used to make more general Oauth2 authorize links.</p>"},{"location":"usage/list_status/","title":"List Status","text":"<p>yuyo.list_status provides an easy way to update a Bot's stats on bot lists.</p> <p>By default this will track the count per-shard, meaning that this'll have to be running on each shard cluster instance to properly keep track of the count. This will also be relying on the GUILDS intent being declared unless a custom counting strategy is passed.</p>"},{"location":"usage/list_status/#usage","title":"Usage","text":"<pre><code>manager = list_status.ServiceManager.from_gateway_bot(bot)\nmanager.add_service(list_status.TopGGService(\"TOKEN\"))\n</code></pre> <p>TopGGService is used to set https://top.gg as one of the targets for updating the bot's guild count.</p> <p>Top.GG API tokens are found in the \"webhooks\" tab while editing the bot's entry.</p> <pre><code>manager = list_status.ServiceManager.from_gateway_bot(bot)\nmanager.add_service(list_status.DiscordBotListService(\"TOKEN\"))\n</code></pre> <p>DiscordBotListService is used to set https://discordbotlist.com as one of the targets for updating the bot's guild count.</p> <pre><code>manager = list_status.ServiceManager.from_gateway_bot(bot)\nmanager.add_service(list_status.BotsGGService(\"TOKEN\"))\n</code></pre> <p>BotsGGService is used to set https://discord.bots.gg as one of the targets for updating the bot's guild count.</p> <p>Bots.gg API tokens are found at https://discord.bots.gg/docs (when logged in).</p>"},{"location":"usage/list_status/#custom-service","title":"Custom service","text":"<pre><code>manager = list_status.ServiceManager.from_gateway_bot(bot)\n\n@manager.with_service()\nasync def service(client: list_status.AbstractManager, /) -&gt; None:\n    count = await client.counter.count()\n\n    if isinstance(count, int):\n        ...  # This is a global count of how many guilds the bot is in.\n\n    else:\n        # This is a mapping of shard IDs to guild counts.\n        count  # type: collections.abc.Mapping[int, int]\n</code></pre> <p>Services are simply asynchronous callbacks which call <code>AbstractManager.counter.count</code> to get the most recent count(s) then pass it on.</p> <p><code>AbstractManager.counter.count</code> may raise CountUnknownError to indicate an unknown state and will return either int to indicate a global guild count or <code>Mapping[int, int]</code> to give per-shard guild counts.</p>"},{"location":"usage/list_status/#counting-strategies","title":"Counting Strategies","text":""},{"location":"usage/list_status/#sake-counting","title":"Sake counting","text":"<pre><code>cache  # type: sake.abc.GuildCache\ncounter = list_status.SakeStrategy(cache)\nmanager = list_status.ServiceManager.from_gateway_bot(bot, strategy=counter)\n</code></pre> <p>The Sake strategy lets this be used with an asynchronous Redis guild cache. This strategy will only be keeping track of a global guild count (rather than per-shard like the default counters) and therefore you should only ever need to have one instance of this running with Sake.</p>"},{"location":"usage/modals/","title":"Modals","text":"<p>Modals allow bots to prompt a user for more information as the initial response for a slash command, context menu or message component interaction.</p> <p></p> <p>Modals take the shape of dialogue boxes which show up on top of everything for the user who triggered the relevant interaction (as shown above).</p>"},{"location":"usage/modals/#making-a-modal-client","title":"Making a Modal client","text":"<p>The Modal client keeps track of registered modals and handles executing them.</p> <p>This can be created with any of the following class methods:</p> <ul> <li>ModalClient.from_gateway_bot:     Create a modal client from a Hikari gateway bot (i.e.     hikari.GatewayBot).</li> <li>ModalClient.from_rest_bot:     Create a modal client from a Hikari REST bot (i.e.     hikari.RESTBot or yuyo.asgi.AsgiBot).</li> <li> <p>ModalClient.from_tanjun:     Create a modal client from a Tanjun Client.</p> <p>This method will make the modal client use  Tanjun's Alluka client for dependency injection, essentially mirroring the dependencies registered for Tanjun's DI while also registering ModalClient as a type dependency.</p> </li> </ul> <p>Client state can be managed through dependency injection. This is implemented using Alluka and more information about it can be found in Alluka's usage guide. The Alluka client used for modal execution can be found at ModalClient.alluka.</p> <p>For the sake of simplicity, the following examples all assume the modal client can be accessed through Alluka style dependency injection.</p>"},{"location":"usage/modals/#declaring-modals","title":"Declaring Modals","text":"<p>The only field type supported for modals right now are text inputs.</p> <p>A modal can have up to 5 text inputs in it and there are two different flavours of text inputs: the default \"sentence\" style which only lets users input a single line of text and the \"paragraph\" style which allows multiple lines of text.</p> <p>There's several different ways to declare modals using Yuyo:</p>"},{"location":"usage/modals/#subclasses","title":"Subclasses","text":"<p>When working with modal classes you'll be adding \"static\" fields which are included on every instance of the modal class. There's a couple of ways to declare these:</p> <pre><code>class Modal(modals.Modal):\n    async def callback(\n        self,\n        ctx: modals.Context,\n        field: str = modals.text_input(\"label\", min_length=5, max_length=50, default=\"John Doe\"),\n        other_field: str | None = modals.text_input(\n            \"other label\", style=hikari.TextInputStyle.PARAGRAPH, default=None\n        ),\n    ) -&gt; None:\n        await ctx.respond(\"hi\")\n</code></pre> <p>Subclassing Modal lets you create a unique modal template. <code>Modal</code> subclasses will never inherit fields. The modal's execution callback must always be called <code>callback</code> when subclassing.</p> <p>You can define the fields that'll appear on all instances of a modal template by setting field descriptors as argument defaults for the modal's callback (as shown above).</p> <p>The following descriptors are supported:</p> <ul> <li>text_input</li> </ul> <p>Warning</p> <p>If you declare <code>__init__</code> on a Modal subclass then you must make sure to first call <code>super().__init__()</code> in it.</p> <pre><code>@modals.with_static_text_input(\"label\", parameter=\"field\", default=None)\nclass Modal(modals.Modal):\n    async def callback(self, ctx: modals.Context, field: str | None, other_field: str) -&gt; None:\n        ctx.interaction.components\n\nModal.add_static_text_input(\"other label\", parameter=\"other_field\")\n</code></pre> <p>You can also define the template's fields by manually calling the <code>add_static_{}</code> class methods either directly or through one of the provided <code>with_static_{}</code> decorator functions. Note that decorators are executed from the bottom upwards and this will be reflected in the order of these fields.</p> <p>When using this approach the field's value/default will only be passed to the callback if you explicitly pass the relevant argument's name as <code>parameter=</code> to the add (class) method.</p> <pre><code>@modals.with_static_text_input(\"label\", parameter=\"field\", default=None)\n@modals.as_modal_template\nasync def modal_template(ctx: modals.Context, field: str, other_field: str = modals.text_input(\"label\")) -&gt; None:\n    await ctx.respond(\"hi\")\n</code></pre> <p>as_modal_template provides a short hand for creating a Modal subclass from a callback.</p>"},{"location":"usage/modals/#instances","title":"Instances","text":"<pre><code>@modals.with_text_input(\"other label\", parameter=\"other\")\n@modals.with_text_input(\"label\", parameter=\"field\")\n@modals.as_modal\nasync def modal(ctx: modals.Context, field: str, other_field: str | None) -&gt; None: ...\n</code></pre> <pre><code>async def callback(ctx: modals.Context, field: str, other_field: str | None) -&gt; None: ...\n\nmodal = (\n    modals.modal(callback)\n    .add_text_input(\"label\", parameter=\"field\")\n    .add_text_input(\"other label\", parameter=\"other_field\", default=None)\n)\n</code></pre> <p>as_modal and modal both provide ways to create instances of modals from a callback.</p> <p>These only support the signature field descriptors and modal dataclasses when <code>parse_signature=True</code> is explicitly passed.</p>"},{"location":"usage/modals/#options-dataclass","title":"Options Dataclass","text":"<pre><code>class ModalOptions(modals.ModalOptions):\n    field: str = modals.text_input(\"label\", min_length=5, max_length=500)\n    other_field: str | None = modals.text_input(\"other label\", default=None, style=hikari.TextInputStyle.PARAGRAPH)\n\n@modals.as_modal(parse_signature=True)\nasync def modal(ctx: modals.Context, options: ModalOptions) -&gt; None:\n    options.field\n</code></pre> <p>Another aspect of signature parsing is ModalOptions. This is a dataclass of modal fields which supports declaring said fields by using the same descriptors listed earlier as class variables.</p> <p>To use this dataclass with a modal you then have to use it as type-hint for one of the modal callback's arguments.</p> <p>This supports inheriting fields from other modal options dataclasses (including mixed inheritance) but does not support slotting nor custom <code>__init__</code>s.</p>"},{"location":"usage/modals/#handling-modal-interactions","title":"Handling Modal Interactions","text":"<p>There's two main ways to handle modal interactions with Yuyo:</p>"},{"location":"usage/modals/#stateful","title":"Stateful","text":"<pre><code>class Modal(modals.Modal):\n    __slots__ = (\"state\",)\n\n    def __init__(self, state: str) -&gt; None:\n        super().__init__()\n        self.state = state\n\n    async def callback(self, ctx: modals.Context, field: str = modals.text_input(\"field\")) -&gt; None:\n        await ctx.respond(self.state)\n\nasync def command_callback(ctx: tanjun.abc.AppCommandContext, modal_client: alluka.Injected[modals.Client]) -&gt; None:\n    modal = Modal(\"state\")\n    custom_id = str(ctx.interaction.id)\n    modal_client.register_modal(custom_id, modal)\n    await ctx.create_modal_response(\"Title\", custom_id, components=modal.rows)\n</code></pre> <p>Subclassing Modal let you associate state with a specific modal execution through OOP.</p> <p>When doing this you'll usually be creating an instance of the modal per interaction and associating this with a specific modal execution by using the parent interaction's custom ID as the modal's custom ID (as shown above).</p> <p>ModalClient.register_modal defaults <code>timeout</code> to a 2 minute one use timeout.</p>"},{"location":"usage/modals/#stateless","title":"Stateless","text":"<pre><code># parse_signature defaults to False for as_modal and modal (unlike as_modal_template).\n@modals.as_modal(parse_signature=True)\nasync def modal(ctx: modals.Context, field: str = modals.text_input(\"field\")) -&gt; None:\n    session_id = uuid.UUID(ctx.id_metadata)\n\nMODAL_ID = \"MODAL_ID\"\n\nclient = modals.ModalClient()\nclient.register_modal(MODAL_ID, modal, timeout=None)\n\n...\n\nasync def command_callback(\n    ctx: tanjun.abc.AppCommandContext, modal_client: alluka.Injected[modals.ModalClient]\n) -&gt; None:\n    session_id = uuid.uuid4()\n    await ctx.create_modal_response(\"Title\", f\"{MODAL_ID}:{session_id}\", components=modal.rows)\n</code></pre> <p>Alternatively, modals can be reused by using a global custom ID and registering the modal to the client on startup with <code>timeout=None</code> and sending the same modal's rows per-execution.</p> <p>Custom IDs have some special handling which allows you to track some metadata for specific modal executions. They are split into two parts as <code>\"{match}:{metadata}\"</code>, where the \"match\" part is what Yuyo will use to find the executor for a modal call and the \"metadata\" (ModalContext.id_metadata) part represents any developer added metadata for that instance of the modal.</p> <p>If should be noted that Custom IDs can never be longer than 100 characters in total length.</p>"},{"location":"usage/modals/#responding-to-modals","title":"Responding to Modals","text":"<pre><code>@modals.as_modal(parse_signature=True)\nasync def modal(ctx: modals.Context) -&gt; None:\n    await ctx.respond(\n        \"Message content\",\n        attachments=[hikari.URL(\"https://img3.gelbooru.com/images/81/f2/81f26993b71525683a3267b16ecd0ea9.jpg\")],\n    )\n</code></pre> <p>ModalContext.respond is used to respond to an interaction with a new message, this has a similar signature to Hikari's message respond method but will only be guaranteed to return a hikari.Message object when <code>ensure_result=True</code> is passed.</p> <p>Alternatively, yuyo.InteractionError can be raised to end the execution of a modal with a response message.</p> <p>Note</p> <p>You cannot create another modal prompt in response to a modal interaction.</p>"},{"location":"usage/modals/#ephemeral-responses","title":"Ephemeral responses","text":"<pre><code>@modals.as_modal(parse_signature=True)\nasync def modal(ctx: modals.Context) -&gt; None:\n    await ctx.create_initial_response(\"Initiating Mower\", ephemeral=True)\n    await ctx.create_followup(\"Meowing finished\", ephemeral=True)\n</code></pre> <p>Ephemeral responses mark the response message as private (so that only the author can see it) and temporary. A response can be marked as ephemeral by passing <code>ephemeral=True</code> to either ModalContext.create_initial_response (when initially responding to the interaction) or ModalContext.create_followup (for followup responses).</p>"},{"location":"usage/modals/#deferrals","title":"Deferrals","text":"<p>Interactions need an initial response within 3 seconds but, if you can't give a response within 3 seconds, you can defer the first response using ModalContext.defer.</p> <p>A deferral should then be finished by editing in the initial response using either ModalContext.edit_initial_response or ModalContext.respond and if you want a response to be ephemeral then you'll have to pass <code>ephemeral=True</code> when deferring.</p>"},{"location":"usage/modals/#updating-the-source-message","title":"Updating the source message","text":"<pre><code>@modals.as_modal()\nasync def modal(ctx: modals.Context) -&gt; None:\n    await ctx.create_initial_response(\"content\", response_type=hikari.ResponseType.MESSAGE_UPDATE, attachments=[])\n</code></pre> <p>When a modal is triggered by a button which is attached to a message you can also use the initial response to edit said message. To do this you need to pass <code>response_type=hikari.ResponseType.MESSAGE_UPDATE</code> while calling ModalContext.create_initial_response. After doing this any further calls to ModalContext.delete_initial_response and ModalContext.edit_initial_response will target the source message as well.</p> <p>You cannot change the ephemeral state of the source message.</p> <p>You need to pass <code>response_type=hikari.ResponseType.DEFERRED_MESSAGE_UPDATE</code> When deferring with the intent to update the source message.</p>"}]}