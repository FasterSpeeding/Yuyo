{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Yuyo # A collection of utility classes and functions designed to expand Hikari. Instillation # You can install yuyo from PyPI using the following command. python -m pip install -U hikari-yuyo The following feature flags ensure feature-specific optional dependencies are also installed: hikari-yuyo[asgi] ensures the dependencies required to run the Asgi RESTBot adapter. hikari-yuyo[sake] can be used to ensure the installed Sake version is compatible with Yuyo's functionality which uses Sake. You should still have a Sake version pinned in your own requirements as this just provides an accepted range for the dependency. Quick Usage. # For usage see the the documentation and soon to come examples. Support # Hikari's support guild provides for support for Yuyo. Contributing # Before contributing you should read through the contributing guidelines and the code of conduct .","title":"Home"},{"location":"#yuyo","text":"A collection of utility classes and functions designed to expand Hikari.","title":"Yuyo"},{"location":"#instillation","text":"You can install yuyo from PyPI using the following command. python -m pip install -U hikari-yuyo The following feature flags ensure feature-specific optional dependencies are also installed: hikari-yuyo[asgi] ensures the dependencies required to run the Asgi RESTBot adapter. hikari-yuyo[sake] can be used to ensure the installed Sake version is compatible with Yuyo's functionality which uses Sake. You should still have a Sake version pinned in your own requirements as this just provides an accepted range for the dependency.","title":"Instillation"},{"location":"#quick-usage","text":"For usage see the the documentation and soon to come examples.","title":"Quick Usage."},{"location":"#support","text":"Hikari's support guild provides for support for Yuyo.","title":"Support"},{"location":"#contributing","text":"Before contributing you should read through the contributing guidelines and the code of conduct .","title":"Contributing"},{"location":"changelog/","text":"Changelog # All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . Unreleased # Added # Helper functions for converting some Hikrai models to builder objects in yuyo.to_builder . These support application commands and message components. Changed # Bumped minimum Hikari version to v2.0.0.dev114 . 1.5.0a1 - 2023-01-10 # Added # Add classes and functions for handling message, webhook, invite and template links. Changed # Officially drop support for Python 3.8. 1.4.0a1.post1 - 2022-11-20 # Changed # CacheStrategy. init now takes two arguments (hikari.api.Cache, hikari.ShardAware) . Fixed # yuyo.list_status.DiscordBotListService 's logging when declaring per-shard stats. Declare bot stats per-shard instead of for the whole bot when list status is using the standard cache or event strategies. 1.4.0a1 - 2022-11-20 # Added # A system for automatically declaring a bot's guild count on the bot lists top.gg, bots.gg and discordbotlist.com. See yuyo.list_status for more information. \"asgi\" feature flag for ensuring this installs with the dependencies required to run the Asgi REST bot adapter. Changed # yuyo.backoff.Backoff now increments the internal counter regardless of whether yuyo.backoff.Backoff.set_next_backoff has been called. yuyo.backoff.Backoff now iterates over the retry counter ( int ), starting at 0, rather than just None . yuyo.backoff.Backoff.backoff now returns the current retry count as int or None if it has reached max retries or the finished flag has been set. Allow None to be passed for attachment and attachments to edit response methods. Star imports are no-longer used on the top level (at yuyo ) so only the attributes present in yuyo.__all__ can be accessed there now. yuyo.components.AbstractComponentExecutor , yuyo.components.ChildActionRowExecutor , InteractiveButtonBuilder , yuyo.components.as_child_executor , yuyo.components.as_component_callback , yuyo.reactions.AbstractReactionHandler , and yuyo.reactions.as_reaction_callback are no longer included in yuyo.__all__ /exported top-level. Deprecated # yuyo.components.as_child_executor , yuyo.components.as_component_callback , and yuyo.components.as_reaction_callback are no longer documented (included in their relevant module's __all__ ) as these are considered deprecated and undocumented. Fixed # yuyo.backoff.Backoff.backoff now respects the max retires config and finished flag. For this it will now return None without sleeping when either has been reached. Removed # backoff option from yuyo.backoff.Backoff.backoff to better match the aiter flow. 1.3.1a1 - 2022-11-07 # Added # A chunk request tracker implementation. Changed # Bumped the minimum Hikari version to 2.0.0.dev112 . yuyo.asgi.AsgiAdapter 's startup and shutdown callbacks now take 1 argument, must return None and must be asynchronous to match the methods added to hikari.traits.RESTBotAware in https://github.com/hikari-py/hikari/releases/tag/2.0.0.dev112 . This argument will be of type yuyo.asgi.AsgiAdapter when these methods are called of an asgi adapter and of type yuyo.asgi.AsgiBot when called on an asgi bot instance. Removed # replace_attachments argument from the relevant context edit response methods. For more information see https://github.com/hikari-py/hikari/releases/tag/2.0.0.dev112 . 1.2.1a1 - 2022-11-04 # Added # ephemeral keyword-argument to yuyo.components.ComponentContext 's create_initial_response , create_follow_up and defer methods as a shorthand for including 1 << 6 in the passed flags. delete_after option to yuyo.components.ComponentContext response methods. expires_at property to yuyo.components.ComponentContext . Support for dependency injection through Alluka to the reaction and component clients. Changed # ComponentExecutor.execute now takes a context object instead of interaction and future objects. yuyo.pagination.async_paginate_string , yuyo.pagination.sync_paginate_string and yuyo.pagination.paginate_string now return an (async) iterator of the str pages rather than an iterator of tuple[str, int] . If you need page counts, use enumerate or yuyo.pagination.aenumerate . (Async) iterables can now be passed to yuyo.pagination.async_paginate_string , yuyo.pagination.sync_paginate_string and yuyo.pagination.paginate_string instead of just iterators. Fixed # yuyo.components.ComponentContext.respond trying to edit in the initial response instead of create a follow up if a deferred initial response was deleted. Long running delete_after and component execution tasks will no-longer be cancelled by GC. Removed # The project metadata dunder attributes from yuyo . importlib.metadata should be used to get this metadata instead. 1.1.1a1 - 2022-08-28 # Added # Support for sending attachments in the initial response to the ASGI server implementation. Support for sending attachments on initial response to the ComponentContext . Changed # Bumped the minimum hikari version to dev109. Async functions must be typed as returning typing.Coroutine / collections.abc.Coroutine rather than typing.Awaitable now. Fixed # Several bug fixes on handling context response tracking have been copied over from Tanjun to ComponentContext . 1.0.6a1 - 2022-05-24 # Changed # Bumped the minimum hikari version to dev108. Fixed # WaitForExecutor now has better semantics/behaviour around being called when it's inactive. Timeouts are now handled better meaning that a wait for executor timeout will mark it to be de-registered. Execute calls to an executor that hasn't been waited for yet will 1.0.5a1.post1 - 2021-12-21 # Changed # AsgiBot is now (by default) started and closed based on the ASGI lifespan events with the asgi_managed keyword argument to AsgiBot.__init__ allowing this to be disabled. 1.0.5a1 - 2021-12-21 # Added # AsgiBot extension for AsgiAdapter which can be run by itself (manages a rest client). Changed # Renamed WaitForComponent to WaitForExecutor . 1.0.4a1 - 2021-11-22 # Added # prefix_match option to ComponentClient custom ids to make storing metadata in custom ids possible. Fixed # custom id methods now raise ValueError on conflict rather than KeyError. 1.0.3a1 - 2021-10-27 # Added # An ASGI/3 adapter for Hikari's interaction server. Ability to register a callback for a constant custom_id in the component client. This takes precedence over any registered component executors. Changed # Renamed components.WaitFor to WaitForComponent and added it to components.__all__ and yuyo.__all__ . Fixed # Context.defer is now used in the ComponentPaginator instead of Context.create_initial_response to defer the initial response since before deleting it as Context.create_initial_response errors in the REST flow when a defer type is passed. Context.create_initial_response is no longer typed as taking deferred types. Handling of authors in WaitForComponent. Added timeout handling to the future returned by WaitForComponent.wait_for. [1.0.2a1.post1] - 2021-10-02 # Fixed # ComponentClient erroneously garbage collecting unexpired executors. ComponentPaginator and ReactionPaginator both starting on index 1 instead of 0. 1.0.2a1 - 2021-10-02 # Added # Option to have the ComponentClient be event managed when linked to an event manager. This is True by default. Changed # The client now gives a ephemeral timed out response when an unknown message is received. Fixed # ComponentClient's gc task not being started when its opened. Handling of access errors in the component client. MultiComponentExecutor slots. 1.0.1a1 - 2021-09-21 # Added # Higher level component execution client and a pagination specific implementation of its executor. Changed # Totally refactored reaction pagination client to make it more abstract and abstracted away from pagination where the pagination is just a standard use case specific implementation of its executor. Renamed module pagnation to pagination. Move the reaction handling logic over to \"reactions.py\" Renamed string_patinator functions to paginate_string Fixed # Iffy behaviour around \"locking\" the reaction executor which lead to some requests just being ignored.","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#unreleased","text":"","title":"Unreleased"},{"location":"changelog/#added","text":"Helper functions for converting some Hikrai models to builder objects in yuyo.to_builder . These support application commands and message components.","title":"Added"},{"location":"changelog/#changed","text":"Bumped minimum Hikari version to v2.0.0.dev114 .","title":"Changed"},{"location":"changelog/#150a1-2023-01-10","text":"","title":"1.5.0a1 - 2023-01-10"},{"location":"changelog/#added_1","text":"Add classes and functions for handling message, webhook, invite and template links.","title":"Added"},{"location":"changelog/#changed_1","text":"Officially drop support for Python 3.8.","title":"Changed"},{"location":"changelog/#140a1post1-2022-11-20","text":"","title":"1.4.0a1.post1 - 2022-11-20"},{"location":"changelog/#changed_2","text":"CacheStrategy. init now takes two arguments (hikari.api.Cache, hikari.ShardAware) .","title":"Changed"},{"location":"changelog/#fixed","text":"yuyo.list_status.DiscordBotListService 's logging when declaring per-shard stats. Declare bot stats per-shard instead of for the whole bot when list status is using the standard cache or event strategies.","title":"Fixed"},{"location":"changelog/#140a1-2022-11-20","text":"","title":"1.4.0a1 - 2022-11-20"},{"location":"changelog/#added_2","text":"A system for automatically declaring a bot's guild count on the bot lists top.gg, bots.gg and discordbotlist.com. See yuyo.list_status for more information. \"asgi\" feature flag for ensuring this installs with the dependencies required to run the Asgi REST bot adapter.","title":"Added"},{"location":"changelog/#changed_3","text":"yuyo.backoff.Backoff now increments the internal counter regardless of whether yuyo.backoff.Backoff.set_next_backoff has been called. yuyo.backoff.Backoff now iterates over the retry counter ( int ), starting at 0, rather than just None . yuyo.backoff.Backoff.backoff now returns the current retry count as int or None if it has reached max retries or the finished flag has been set. Allow None to be passed for attachment and attachments to edit response methods. Star imports are no-longer used on the top level (at yuyo ) so only the attributes present in yuyo.__all__ can be accessed there now. yuyo.components.AbstractComponentExecutor , yuyo.components.ChildActionRowExecutor , InteractiveButtonBuilder , yuyo.components.as_child_executor , yuyo.components.as_component_callback , yuyo.reactions.AbstractReactionHandler , and yuyo.reactions.as_reaction_callback are no longer included in yuyo.__all__ /exported top-level.","title":"Changed"},{"location":"changelog/#deprecated","text":"yuyo.components.as_child_executor , yuyo.components.as_component_callback , and yuyo.components.as_reaction_callback are no longer documented (included in their relevant module's __all__ ) as these are considered deprecated and undocumented.","title":"Deprecated"},{"location":"changelog/#fixed_1","text":"yuyo.backoff.Backoff.backoff now respects the max retires config and finished flag. For this it will now return None without sleeping when either has been reached.","title":"Fixed"},{"location":"changelog/#removed","text":"backoff option from yuyo.backoff.Backoff.backoff to better match the aiter flow.","title":"Removed"},{"location":"changelog/#131a1-2022-11-07","text":"","title":"1.3.1a1 - 2022-11-07"},{"location":"changelog/#added_3","text":"A chunk request tracker implementation.","title":"Added"},{"location":"changelog/#changed_4","text":"Bumped the minimum Hikari version to 2.0.0.dev112 . yuyo.asgi.AsgiAdapter 's startup and shutdown callbacks now take 1 argument, must return None and must be asynchronous to match the methods added to hikari.traits.RESTBotAware in https://github.com/hikari-py/hikari/releases/tag/2.0.0.dev112 . This argument will be of type yuyo.asgi.AsgiAdapter when these methods are called of an asgi adapter and of type yuyo.asgi.AsgiBot when called on an asgi bot instance.","title":"Changed"},{"location":"changelog/#removed_1","text":"replace_attachments argument from the relevant context edit response methods. For more information see https://github.com/hikari-py/hikari/releases/tag/2.0.0.dev112 .","title":"Removed"},{"location":"changelog/#121a1-2022-11-04","text":"","title":"1.2.1a1 - 2022-11-04"},{"location":"changelog/#added_4","text":"ephemeral keyword-argument to yuyo.components.ComponentContext 's create_initial_response , create_follow_up and defer methods as a shorthand for including 1 << 6 in the passed flags. delete_after option to yuyo.components.ComponentContext response methods. expires_at property to yuyo.components.ComponentContext . Support for dependency injection through Alluka to the reaction and component clients.","title":"Added"},{"location":"changelog/#changed_5","text":"ComponentExecutor.execute now takes a context object instead of interaction and future objects. yuyo.pagination.async_paginate_string , yuyo.pagination.sync_paginate_string and yuyo.pagination.paginate_string now return an (async) iterator of the str pages rather than an iterator of tuple[str, int] . If you need page counts, use enumerate or yuyo.pagination.aenumerate . (Async) iterables can now be passed to yuyo.pagination.async_paginate_string , yuyo.pagination.sync_paginate_string and yuyo.pagination.paginate_string instead of just iterators.","title":"Changed"},{"location":"changelog/#fixed_2","text":"yuyo.components.ComponentContext.respond trying to edit in the initial response instead of create a follow up if a deferred initial response was deleted. Long running delete_after and component execution tasks will no-longer be cancelled by GC.","title":"Fixed"},{"location":"changelog/#removed_2","text":"The project metadata dunder attributes from yuyo . importlib.metadata should be used to get this metadata instead.","title":"Removed"},{"location":"changelog/#111a1-2022-08-28","text":"","title":"1.1.1a1 - 2022-08-28"},{"location":"changelog/#added_5","text":"Support for sending attachments in the initial response to the ASGI server implementation. Support for sending attachments on initial response to the ComponentContext .","title":"Added"},{"location":"changelog/#changed_6","text":"Bumped the minimum hikari version to dev109. Async functions must be typed as returning typing.Coroutine / collections.abc.Coroutine rather than typing.Awaitable now.","title":"Changed"},{"location":"changelog/#fixed_3","text":"Several bug fixes on handling context response tracking have been copied over from Tanjun to ComponentContext .","title":"Fixed"},{"location":"changelog/#106a1-2022-05-24","text":"","title":"1.0.6a1 - 2022-05-24"},{"location":"changelog/#changed_7","text":"Bumped the minimum hikari version to dev108.","title":"Changed"},{"location":"changelog/#fixed_4","text":"WaitForExecutor now has better semantics/behaviour around being called when it's inactive. Timeouts are now handled better meaning that a wait for executor timeout will mark it to be de-registered. Execute calls to an executor that hasn't been waited for yet will","title":"Fixed"},{"location":"changelog/#105a1post1-2021-12-21","text":"","title":"1.0.5a1.post1 - 2021-12-21"},{"location":"changelog/#changed_8","text":"AsgiBot is now (by default) started and closed based on the ASGI lifespan events with the asgi_managed keyword argument to AsgiBot.__init__ allowing this to be disabled.","title":"Changed"},{"location":"changelog/#105a1-2021-12-21","text":"","title":"1.0.5a1 - 2021-12-21"},{"location":"changelog/#added_6","text":"AsgiBot extension for AsgiAdapter which can be run by itself (manages a rest client).","title":"Added"},{"location":"changelog/#changed_9","text":"Renamed WaitForComponent to WaitForExecutor .","title":"Changed"},{"location":"changelog/#104a1-2021-11-22","text":"","title":"1.0.4a1 - 2021-11-22"},{"location":"changelog/#added_7","text":"prefix_match option to ComponentClient custom ids to make storing metadata in custom ids possible.","title":"Added"},{"location":"changelog/#fixed_5","text":"custom id methods now raise ValueError on conflict rather than KeyError.","title":"Fixed"},{"location":"changelog/#103a1-2021-10-27","text":"","title":"1.0.3a1 - 2021-10-27"},{"location":"changelog/#added_8","text":"An ASGI/3 adapter for Hikari's interaction server. Ability to register a callback for a constant custom_id in the component client. This takes precedence over any registered component executors.","title":"Added"},{"location":"changelog/#changed_10","text":"Renamed components.WaitFor to WaitForComponent and added it to components.__all__ and yuyo.__all__ .","title":"Changed"},{"location":"changelog/#fixed_6","text":"Context.defer is now used in the ComponentPaginator instead of Context.create_initial_response to defer the initial response since before deleting it as Context.create_initial_response errors in the REST flow when a defer type is passed. Context.create_initial_response is no longer typed as taking deferred types. Handling of authors in WaitForComponent. Added timeout handling to the future returned by WaitForComponent.wait_for.","title":"Fixed"},{"location":"changelog/#102a1post1-2021-10-02","text":"","title":"[1.0.2a1.post1] - 2021-10-02"},{"location":"changelog/#fixed_7","text":"ComponentClient erroneously garbage collecting unexpired executors. ComponentPaginator and ReactionPaginator both starting on index 1 instead of 0.","title":"Fixed"},{"location":"changelog/#102a1-2021-10-02","text":"","title":"1.0.2a1 - 2021-10-02"},{"location":"changelog/#added_9","text":"Option to have the ComponentClient be event managed when linked to an event manager. This is True by default.","title":"Added"},{"location":"changelog/#changed_11","text":"The client now gives a ephemeral timed out response when an unknown message is received.","title":"Changed"},{"location":"changelog/#fixed_8","text":"ComponentClient's gc task not being started when its opened. Handling of access errors in the component client. MultiComponentExecutor slots.","title":"Fixed"},{"location":"changelog/#101a1-2021-09-21","text":"","title":"1.0.1a1 - 2021-09-21"},{"location":"changelog/#added_10","text":"Higher level component execution client and a pagination specific implementation of its executor.","title":"Added"},{"location":"changelog/#changed_12","text":"Totally refactored reaction pagination client to make it more abstract and abstracted away from pagination where the pagination is just a standard use case specific implementation of its executor. Renamed module pagnation to pagination. Move the reaction handling logic over to \"reactions.py\" Renamed string_patinator functions to paginate_string","title":"Changed"},{"location":"changelog/#fixed_9","text":"Iffy behaviour around \"locking\" the reaction executor which lead to some requests just being ignored.","title":"Fixed"},{"location":"usage/","text":"Usage # Coming soon.","title":"Usage"},{"location":"usage/#usage","text":"Coming soon.","title":"Usage"},{"location":"reference/","text":"yuyo # A collection of utility functions and classes designed to enhances Hikari. ActionRowExecutor # Bases: ComponentExecutor , hikari . api . ComponentBuilder Class used for handling the execution of an action row. __init__ # __init__ ( * , ephemeral_default = False , load_from_attributes = False , timeout = datetime . timedelta ( seconds = 30 )) Initialise an action row executor. PARAMETER DESCRIPTION ephemeral_default Whether this executor's responses should default to being ephemeral. TYPE: bool DEFAULT: False timeout How long this component should last until its marked as timed out. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30) AsgiAdapter # Asgi/3 adapter for Hikari's interaction server interface. For this to work, hikari has to be installed with the optional \"server\" feature (e.g python -m pip install hikari[server] ). server property # server : hikari . api . InteractionServer The interaction server this adapter is bound to. __call__ async # __call__ ( scope , receive , send ) Call the adapter. Note This method is called by the ASGI server. PARAMETER DESCRIPTION scope The scope of the request. TYPE: asgiref . Scope receive The receive function to use. TYPE: asgiref . ASGIReceiveCallable send The send function to use. TYPE: asgiref . ASGISendCallable RAISES DESCRIPTION NotImplementedError If this is called with a websocket scope. RuntimeError If an invalid scope event is passed. __init__ # __init__ ( server , / , * , executor = None ) Initialise the adapter. PARAMETER DESCRIPTION server The interaction server to use. TYPE: hikari . api . InteractionServer executor If non- None , then this executor is used instead of the concurrent.futures.ThreadPoolExecutor attached to the asyncio.AbstractEventLoop that the bot will run on. This executor is used primarily for file-IO. While mainly supporting the concurrent.futures.ThreadPoolExecutor implementation in the standard lib, Hikari's file handling systems should also work with concurrent.futures.ProcessPoolExecutor , which relies on all objects used in IPC to be pickle able. Many third-party libraries will not support this fully though, so your mileage may vary on using ProcessPoolExecutor implementations with this parameter. TYPE: typing . Optional [ concurrent . futures . Executor ] DEFAULT: None add_shutdown_callback # add_shutdown_callback ( callback ) Add a callback to be called when the ASGI server shuts down. Warning These callbacks will block the ASGI server from shutting down until they complete and any raised errors will lead to a failed shutdown. PARAMETER DESCRIPTION callback The shutdown callback to add. TYPE: collections . Callable [[ Self ], collections . Coroutine [ typing . Any , typing . Any , None]] add_startup_callback # add_startup_callback ( callback ) Add a callback to be called when the ASGI server starts up. Warning These callbacks will block the ASGI server from starting until they complete and any raised errors will lead to a failed startup. PARAMETER DESCRIPTION callback The startup callback to add. TYPE: collections . Callable [[ Self ], collections . Coroutine [ typing . Any , typing . Any , None]] process_lifespan_event async # process_lifespan_event ( receive , send ) Process a lifespan ASGI event. Note This function is used internally by the adapter. PARAMETER DESCRIPTION receive The receive function to use. TYPE: asgiref . ASGIReceiveCallable send The send function to use. TYPE: asgiref . ASGISendCallable RAISES DESCRIPTION RuntimeError If an invalid lifespan event is passed. process_request async # process_request ( scope , receive , send ) Process an HTTP request. Note This function is used internally by the adapter. PARAMETER DESCRIPTION scope The scope of the request. TYPE: asgiref . HTTPScope receive The receive function to use. TYPE: asgiref . ASGIReceiveCallable send The send function to use. TYPE: asgiref . ASGISendCallable remove_shutdown_callback # remove_shutdown_callback ( callback ) Remove a shutdown callback. PARAMETER DESCRIPTION callback The shutdown callback to remove. TYPE: collections . Callable [[ Self ], collections . Coroutine [ typing . Any , typing . Any , None]] RAISES DESCRIPTION ValueError If the callback was not registered. remove_startup_callback # remove_startup_callback ( callback ) Remove a startup callback. PARAMETER DESCRIPTION callback The startup callback to remove. TYPE: collections . Callable [[ Self ], collections . Coroutine [ typing . Any , typing . Any , None]] RAISES DESCRIPTION ValueError If the callback was not registered. AsgiBot # Bases: AsgiAdapter , hikari . RESTBotAware Bot implementation which acts as an ASGI adapter. This bot doesn't initiate a server internally but instead relies on being called as an ASGI app. For this to work, hikari has to be installed with the optional \"server\" feature (e.g python -m pip install hikari[server] ). __init__ # __init__ ( token , token_type = None , public_key = None , * , asgi_managed = True , executor = None , http_settings = None , max_rate_limit = 300.0 , max_retries = 3 , proxy_settings = None , rest_url = None ) Initialise a new ASGI bot. PARAMETER DESCRIPTION token The bot or bearer token. If no token is to be used, this can be undefined. TYPE: typing . Union [ str , hikari . api . TokenStrategy ] token_type The type of token in use. This should only be passed when str is passed for token , can be \"Bot\" or \"Bearer\" and will be defaulted to \"Bearer\" in this situation. This should be left as None when either hikari.api.rest.TokenStrategy or None is passed for token . TYPE: typing . Union [ hikari . TokenType , str , None] DEFAULT: None asgi_managed Whether this bot's internal components should be automatically started and stopped based on the Asgi lifespan events. TYPE: bool DEFAULT: True executor If non- None , then this executor is used instead of the concurrent.futures.ThreadPoolExecutor attached to the asyncio.AbstractEventLoop that the bot will run on. This executor is used primarily for file-IO. While mainly supporting the concurrent.futures.ThreadPoolExecutor implementation in the standard lib, Hikari's file handling systems should also work with concurrent.futures.ProcessPoolExecutor , which relies on all objects used in IPC to be pickle able. Many third-party libraries will not support this fully though, so your mileage may vary on using ProcessPoolExecutor implementations with this parameter. TYPE: typing . Optional [ concurrent . futures . Executor ] DEFAULT: None http_settings Optional custom HTTP configuration settings to use. Allows you to customise functionality such as whether SSL-verification is enabled, what timeouts aiohttp should expect to use for requests, and behavior regarding HTTP-redirects. TYPE: typing . Optional [ hikari . impl . HTTPSettings ] DEFAULT: None max_rate_limit The max number of seconds to backoff for when rate limited. Anything greater than this will instead raise an error. This defaults to five minutes to stop potentially indefinitely waiting on an endpoint, which is almost never what you want to do if giving a response to a user. You can set this to float(\"inf\") to disable this check entirely. Note that this only applies to the REST API component that communicates with Discord, and will not affect sharding or third party HTTP endpoints that may be in use. TYPE: float DEFAULT: 300.0 max_retries Maximum number of times a request will be retried if it fails with a 5xx status. Defaults to 3 if set to None . TYPE: int DEFAULT: 3 proxy_settings Custom proxy settings to use with network-layer logic in your application to get through an HTTP-proxy. TYPE: typing . Optional [ hikari . impl . ProxySettings ] DEFAULT: None public_key The public key to use to verify received interaction requests. This may be a hex encoded str or the raw bytes . If left as None then the client will try to work this value out based on token . TYPE: typing . Union [ bytes , str , None] DEFAULT: None rest_url Defaults to the Discord REST API URL if None . Can be overridden if you are attempting to point to an unofficial endpoint, or if you are attempting to mock/stub the Discord API for any reason. Generally you do not want to change this. TYPE: typing . Optional [ str ] DEFAULT: None RAISES DESCRIPTION ValueError If token_type is provided when a token strategy is passed for token . if token_type is left as None when a string is passed for token . close async # close () Close the bot's REST client. Warning Unless asgi_managed=False is passed to AsgiBot.__init__ , the bot will be automatically closed based on the ASGI lifespan events and any other calls to this function will raise a RuntimeError . RAISES DESCRIPTION RuntimeError If the client isn't alive. If the client is ASGI managed. run # run () Start the bot's REST client and wait until the bot's closed. Warning Unless asgi_managed=False is passed to yuyo.asgi.AsgiBot. init , the bot will be automatically started and closed based on the ASGI lifespan events and any other calls to this function will raise a RuntimeError . RAISES DESCRIPTION RuntimeError If the client is already alive. If the client is ASGI managed. start async # start () Start the bot's REST client. Warning Unless asgi_managed=False is passed to yuyo.asgi.AsgiBot. init , the bot will be automatically started based on the ASGI lifespan events and any other calls to this function will raise a RuntimeError . RAISES DESCRIPTION RuntimeError If the client is already alive. If the client is ASGI managed. Backoff # Used to exponentially backoff asynchronously. This class acts as an asynchronous iterator and can be iterated over to provide implicit backoff where for every iteration other than the first this will either back off for the time passed to yuyo.backoff.Backoff.set_next_backoff if applicable or a time calculated exponentially. Each iteration yields the current retry count (starting at 0). Examples: An example of using this class as an asynchronous iterator may look like the following # While we can directly do `async for _ in Backoff()`, by assigning it to a # variable we allow ourself to provide a specific backoff time in some cases. backoff = Backoff () async for _ in backoff : try : message = await bot . rest . fetch_message ( channel_id , message_id ) except errors . RateLimitedError as exc : # If we have a specific backoff time then set it for the next iteration backoff . set_next_backoff ( exc . retry_after ) except errors . InternalServerError : # Else let the iterator calculate an exponential backoff before the next loop. pass else : # We need to break out of the iterator to make sure it doesn't backoff again. # Alternatively `Backoff.finish()` can be called to break out of the loop. break Alternatively you may want to explicitly call yuyo.backoff.Backoff.backoff , a alternative of the previous example which uses yuyo.backoff.Backoff.backoff may look like the following backoff = Backoff () message : typing . Optional [ messages . Message ] = None while not message : try : message = await bot . rest . fetch_message ( channel_id , message_id ) except errors . RateLimitedError as exc : # If we have a specific backoff time then set it for the next iteration. await backoff . backoff ( exc . retry_after ) except errors . InternalServerError : # Else let the iterator calculate an exponential backoff before the next loop. await backoff . backoff () is_depleted property # is_depleted : bool Whether \"max_retries\" has been reached. This can be used to workout whether the loop was explicitly broken out of using yuyo.backoff.Backoff.finish / break or if it hit \"max_retries\". __init__ # __init__ ( max_retries = None , * , base = 2.0 , maximum = 64.0 , jitter_multiplier = 1.0 , initial_increment = 0 ) Initialise a backoff instance. PARAMETER DESCRIPTION max_retries The maximum amount of times this should iterate for between resets. If left as None then this iterator will be unlimited. This must be greater than or equal to 1. TYPE: typing . Optional [ int ] DEFAULT: None base The base to use. TYPE: float DEFAULT: 2.0 maximum The max value the backoff can be in a single iteration. Anything above this will be capped to this base value plus random jitter. TYPE: float DEFAULT: 64.0 jitter_multiplier The multiplier for the random jitter. Set to 0 to disable jitter. TYPE: float DEFAULT: 1.0 initial_increment The initial increment to start at. TYPE: int DEFAULT: 0 RAISES DESCRIPTION ValueError If an int that's too big to be represented as a float or a non-finite value is passed in place of a field that's annotated as float or if max_retries is less than 1 . backoff async # backoff () Sleep for the provided backoff or for the next exponent. This provides an alternative to iterating over this class. RETURNS DESCRIPTION int | None Whether this has reached the end of its iteration. If this returns True then that call didn't sleep as this has been marked as finished or has reached the max retries. finish # finish () Mark the iterator as finished to break out of the current loop. reset # reset () Reset the backoff to it's original state to reuse it. set_next_backoff # set_next_backoff ( backoff_ ) Specify a backoff time for the next iteration or yuyo.backoff.Backoff.backoff call. If this is called then the exponent won't be increased for this iteration. Note Calling this multiple times in a single iteration will overwrite any previously set next backoff. BotsGGService # https://discord.bots.gg status update service. __init__ # __init__ ( token ) Initialise a bots.gg service. PARAMETER DESCRIPTION token Authorization token used to update the bot's status. TYPE: str ChunkRequestFinishedEvent # Bases: hikari . ShardEvent Event that's dispatched when a specific chunk request has finished. This will be fired for every chunk request which has a nonce. chunk_count property # chunk_count : int The amount of chunk events which should've been received for this request. first_received_at property # first_received_at : datetime . datetime When the first response was received. guild_id property # guild_id : hikari . Snowflake Id of the guild this chunk request was for. last_received_at property # last_received_at : datetime . datetime When the last response was received. missed_chunks property # missed_chunks : collections . Collection [ int ] Collection of the chunk responses which were missed (if any). not_found_ids property # not_found_ids : collections . Collection [ hikari . Snowflake ] Collection of the User IDs which weren't found. This is only relevant when users was specified while requesting the members. __init__ # __init__ ( app , shard , data ) Initialise a chunk request finished event. This should never be initialised directly. ChunkTracker # Chunk payload event tracker. This will dispatch ShardFinishedChunkingEvent , FinishedChunkingEvent and ChunkRequestFinishedEvent events. To configure this to automatically request member chunks to fill a member and/or presence cache on startup and guild join see ChunkTracker.set_auto_chunk_members . Note ChunkTracker.request_guild_members ensures a request will be tracked as this only tracks chunk requests with a set nonce. __init__ # __init__ ( event_manager , rest , shards ) Initialise a chunk tracker. For a shorthand for initialising this from a hikari.traits.GatewayBotAware see ChunkTracker.from_gateway_bot . PARAMETER DESCRIPTION event_manager The event manager this chunk tracker should dispatch events over. TYPE: hikari . api . EventManager shards The shard aware object this should use. TYPE: hikari . ShardAware from_gateway_bot classmethod # from_gateway_bot ( bot ) Initialise a chunk tracker from a gateway bot. PARAMETER DESCRIPTION bot The gateway bot this chunk tracker should use. TYPE: hikari . GatewayBotAware request_guild_members async # request_guild_members ( guild , * , include_presences = hikari . UNDEFINED , query = '' , limit = 0 , users = hikari . UNDEFINED ) Request guild members. Note To request the full list of members, leave query as \"\" (empty string) and limit as 0 . PARAMETER DESCRIPTION guild The guild to request chunk for. TYPE: hikari . SnowflakeishOr [ hikari . PartialGuild ] include_presences If provided, whether to request presences. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED query If not \"\" , request the members who's usernames starts with the string. TYPE: str DEFAULT: '' limit Maximum number of members to send matching the query. TYPE: int DEFAULT: 0 users If provided, the users to request for. TYPE: hikari . UndefinedOr [ hikari . SnowflakeishSequence [ hikari . User ]] DEFAULT: hikari.UNDEFINED RAISES DESCRIPTION ValueError When trying to specify users with query / limit , if limit is not between 0 and 100, both inclusive or if users length is over 100. hikari . errors . MissingIntentError When trying to request presences without the GUILD_MEMBERS or when trying to request the full list of members without GUILD_PRESENCES . set_auto_chunk_members # set_auto_chunk_members ( state , / , * , chunk_presences = True ) Configure whether this should request member chunks in response to GUILD_CREATE. This may be useful for filling 3rd party caches but may conflict with the auto_chunk_members config of hikari.impl.bot.GatewayBot if it's enabled. Warning This will be ignored if Intents.GUILD_MEMBERS hasn't been declared. PARAMETER DESCRIPTION state Whether this should request member chunks when GUILD_CREATE events are received. TYPE: bool chunk_presences Whether this should also request member presences on these member chunks. This will be ignored if Intents.GUILD_PRESENCES hasn't been declared. TYPE: bool DEFAULT: True RETURNS DESCRIPTION Self The chunk tracker object to enable call chaining. ComponentClient # Client used to handle component executors within a REST or gateway flow. alluka property # alluka : alluka_ . abc . Client The Alluka client being used for callback dependency injection. __init__ # __init__ ( * , alluka = None , event_manager = None , event_managed = None , server = None ) Initialise a component client. Note For an easier way to initialise the client from a bot see yuyo.components.ComponentClient.from_gateway_bot and yuyo.components.ComponentClient.from_rest_bot . PARAMETER DESCRIPTION alluka The Alluka client to use for callback dependency injection in this client. If not provided then this will initialise its own Alluka client. TYPE: typing . Optional [ alluka_ . abc . Client ] DEFAULT: None event_manager The event manager this client should listen to dispatched component interactions from if applicable. TYPE: typing . Optional [ hikari . api . EventManager ] DEFAULT: None event_managed Whether this client should be automatically opened and closed based on the lifetime events dispatched by event_manager . Defaults to True if an event manager is passed. TYPE: typing . Optional [ bool ] DEFAULT: None server The server this client should listen to component interactions from if applicable. TYPE: typing . Optional [ hikari . api . InteractionServer ] DEFAULT: None RAISES DESCRIPTION ValueError If event_managed is passed as True when event_manager is None . add_executor # add_executor ( message , executor ) Deprecated alias of yuyo.components.ComponentClient.add_executor . close # close () Close the component client. from_gateway_bot classmethod # from_gateway_bot ( bot , / , * , event_managed = True ) Build a component client froma Gateway Bot. PARAMETER DESCRIPTION bot The Gateway bot this component client should be bound to. TYPE: hikari . GatewayBotAware event_managed Whether the component client should be automatically opened and closed based on the lifetime events dispatched by bot . TYPE: bool DEFAULT: True RETURNS DESCRIPTION ComponentClient The initialised component client. from_rest_bot classmethod # from_rest_bot ( bot ) Build a component client froma REST Bot. PARAMETER DESCRIPTION bot The REST bot this component client should be bound to. TYPE: hikari . RESTBotAware RETURNS DESCRIPTION ComponentClient The initialised component client. get_constant_id # get_constant_id ( custom_id ) Get a set constant \"custom_id\" callback. PARAMETER DESCRIPTION custom_id The custom_id to get the callback for. TYPE: str RETURNS DESCRIPTION CallbackSig | None The callback for the custom_id, or None if it doesn't exist. get_executor # get_executor ( message ) Get the component executor set for a message. PARAMETER DESCRIPTION message The message to get the executor for. TYPE: hikari . SnowflakeishOr [ hikari . Message ] RETURNS DESCRIPTION yuyo . components . AbstractComponentExecutor | None The executor set for the message or None if none is set. open # open () Startup the component client. remove_constant_id # remove_constant_id ( custom_id ) Remove a constant \"custom_id\" callback. PARAMETER DESCRIPTION custom_id The custom_id to remove the callback for. TYPE: str RETURNS DESCRIPTION Self The component client to allow chaining. RAISES DESCRIPTION KeyError If the custom_id is not registered. remove_executor # remove_executor ( message ) Remove the component executor for a message. PARAMETER DESCRIPTION message The message to remove the executor for. TYPE: hikari . SnowflakeishOr [ hikari . Message ] RETURNS DESCRIPTION Self The component client to allow chaining. set_constant_id # set_constant_id ( custom_id , callback , / , * , prefix_match = False ) Add a constant \"custom_id\" callback. These are callbacks which'll always be called for a specific custom_id while taking priority over executors. PARAMETER DESCRIPTION custom_id The custom_id to register the callback for. TYPE: str callback The callback to register. This should take a single argument of type yuyo.components.ComponentContext , be asynchronous and return None . TYPE: CallbackSig prefix_match Whether the custom_id should be treated as a prefix match. This allows for further state to be held in the custom id after the prefix and is lower priority than normal custom id match. TYPE: bool DEFAULT: False RETURNS DESCRIPTION Self The component client to allow chaining. RAISES DESCRIPTION ValueError If the custom_id is already registered. set_executor # set_executor ( message , executor ) Set the component executor for a message. PARAMETER DESCRIPTION message The message to set the executor for. TYPE: hikari . SnowflakeishOr [ hikari . Message ] executor The executor to set. This will be called for every component interaction for the message unless the component's custom_id is registered as a constant id callback. TYPE: AbstractComponentExecutor RETURNS DESCRIPTION Self The component client to allow chaining. with_constant_id # with_constant_id ( custom_id , / , * , prefix_match = False ) Add a constant \"custom_id\" callback through a decorator call. These are callbacks which'll always be called for a specific custom_id while taking priority over executors. PARAMETER DESCRIPTION custom_id The custom_id to register the callback for. TYPE: str prefix_match Whether the custom_id should be treated as a prefix match. This allows for further state to be held in the custom id after the prefix and is lower priority than normal custom id match. TYPE: bool DEFAULT: False RETURNS DESCRIPTION Callable [[ CallbackSigT ], CallbackSigT ] A decorator to register the callback. RAISES DESCRIPTION KeyError If the custom_id is already registered. ComponentContext # The general context passed around for a component trigger. expires_at property # expires_at : datetime . datetime When this application command context expires. After this time is reached, the message/response methods on this context will always raise hikari.errors.NotFoundError . has_been_deferred property # has_been_deferred : bool Whether this context's initial response has been deferred. This will be true if yuyo.components.ComponentContext.defer has been called. has_responded property # has_responded : bool Whether an initial response has been made to this context yet. It's worth noting that a context must be either responded to or deferred within 3 seconds from it being received otherwise it'll be marked as failed. This will be true if either yuyo.components.ComponentContext.respond , yuyo.components.ComponentContext.create_initial_response or yuyo.components.ComponentContext.edit_initial_response (after a deferral) has been called. interaction property # interaction : hikari . ComponentInteraction Object of the interaction this context is for. create_followup async # create_followup ( content = hikari . UNDEFINED , * , delete_after = None , ephemeral = False , attachment = hikari . UNDEFINED , attachments = hikari . UNDEFINED , component = hikari . UNDEFINED , components = hikari . UNDEFINED , embed = hikari . UNDEFINED , embeds = hikari . UNDEFINED , mentions_everyone = hikari . UNDEFINED , user_mentions = hikari . UNDEFINED , role_mentions = hikari . UNDEFINED , tts = hikari . UNDEFINED , flags = hikari . UNDEFINED ) Create a followup response for this context. Warning Calling this on a context which hasn't had an initial response yet will lead to a hikari.errors.NotFoundError being raised. PARAMETER DESCRIPTION content If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED delete_after If provided, the seconds after which the response message should be deleted. Slash command responses can only be deleted within 15 minutes of the command being received. TYPE: typing . Union [ datetime . timedelta , float , int , None] DEFAULT: None ephemeral Whether the deferred response should be ephemeral. Passing True here is a shorthand for including 1 << 64 in the passed flags. TYPE: bool DEFAULT: False attachment If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL. TYPE: hikari . UndefinedOr [ hikari . Resourceish ] DEFAULT: hikari.UNDEFINED attachments If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs. TYPE: hikari . UndefinedOr [ collections . Sequence [ hikari . Resourceish ]] DEFAULT: hikari.UNDEFINED component If provided, builder object of the component to include in this message. TYPE: hikari . UndefinedOr [ hikari . api . ComponentBuilder ] DEFAULT: hikari.UNDEFINED components If provided, a sequence of the component builder objects to include in this message. TYPE: hikari . UndefinedOr [ collections . Sequence [ hikari . api . ComponentBuilder ]] DEFAULT: hikari.UNDEFINED embed If provided, the message embed. TYPE: hikari . UndefinedOr [ hikari . Embed ] DEFAULT: hikari.UNDEFINED embeds If provided, the message embeds. TYPE: hikari . UndefinedOr [ collections . Sequence [ hikari . Embed ]] DEFAULT: hikari.UNDEFINED mentions_everyone If provided, whether the message should parse @everyone/@here mentions. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED user_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialUser ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED role_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialRole ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED tts If provided, whether the message will be sent as a TTS message. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED flags The flags to set for this response. As of writing this can only flag which can be provided is EPHEMERAL, other flags are just ignored. TYPE: typing . Union [ hikari . UndefinedType , int , hikari . MessageFlag ] DEFAULT: hikari.UNDEFINED RETURNS DESCRIPTION hikari . Message The created message object. RAISES DESCRIPTION hikari . NotFoundError If the current interaction is not found or it hasn't had an initial response yet. hikari . BadRequestError This can be raised if the file is too large; if the embed exceeds the defined limits; if the message content is specified only and empty or greater than 2000 characters; if neither content, file or embeds are specified. If any invalid snowflake IDs are passed; a snowflake may be invalid due to it being outside of the range of a 64 bit integer. ValueError If more than 100 unique objects/entities are passed for role_mentions or `user_mentions. If the interaction will have expired before delete_after is reached. If both attachment and attachments are passed or both component and components are passed or both embed and embeds are passed. create_initial_response async # create_initial_response ( response_type , / , content = hikari . UNDEFINED , * , delete_after = None , ephemeral = False , attachment = hikari . UNDEFINED , attachments = hikari . UNDEFINED , component = hikari . UNDEFINED , components = hikari . UNDEFINED , embed = hikari . UNDEFINED , embeds = hikari . UNDEFINED , mentions_everyone = hikari . UNDEFINED , user_mentions = hikari . UNDEFINED , role_mentions = hikari . UNDEFINED , flags = hikari . UNDEFINED , tts = hikari . UNDEFINED ) Create the initial response for this context. Warning Calling this on a context which already has an initial response will result in this raising a hikari.errors.NotFoundError . This includes if the REST interaction server has already responded to the request and deferrals. PARAMETER DESCRIPTION response_type The type of message response to give. TYPE: hikari . MessageResponseTypesT content The content to edit the last response with. If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED delete_after If provided, the seconds after which the response message should be deleted. Slash command responses can only be deleted within 15 minutes of the command being received. TYPE: typing . Union [ datetime . timedelta , float , int , None] DEFAULT: None ephemeral Whether the deferred response should be ephemeral. Passing True here is a shorthand for including 1 << 64 in the passed flags. TYPE: bool DEFAULT: False content If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED attachment If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL. TYPE: hikari . UndefinedOr [ hikari . Resourceish ] DEFAULT: hikari.UNDEFINED attachments If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs. TYPE: hikari . UndefinedOr [ collections . Sequence [ hikari . Resourceish ]] DEFAULT: hikari.UNDEFINED component If provided, builder object of the component to include in this message. TYPE: hikari . UndefinedOr [ hikari . api . ComponentBuilder ] DEFAULT: hikari.UNDEFINED components If provided, a sequence of the component builder objects to include in this message. TYPE: hikari . UndefinedOr [ collections . Sequence [ hikari . api . ComponentBuilder ]] DEFAULT: hikari.UNDEFINED embed If provided, the message embed. TYPE: hikari . UndefinedOr [ hikari . Embed ] DEFAULT: hikari.UNDEFINED embeds If provided, the message embeds. TYPE: hikari . UndefinedOr [ collections . Sequence [ hikari . Embed ]] DEFAULT: hikari.UNDEFINED flags If provided, the message flags this response should have. As of writing the only message flag which can be set here is hikari.messages.MessageFlag.EPHEMERAL . TYPE: typing . Union [ int , hikari . MessageFlag , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED tts If provided, whether the message will be read out by a screen reader using Discord's TTS (text-to-speech) system. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED mentions_everyone If provided, whether the message should parse @everyone/@here mentions. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED user_mentions If provided, and True , all user mentions will be detected. If provided, and False , all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialUser ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED role_mentions If provided, and True , all role mentions will be detected. If provided, and False , all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of [hikari.snowflakes.Snowflake], or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialRole ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED RAISES DESCRIPTION ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions . If the interaction will have expired before delete_after is reached. If both attachment and attachments are passed or both component and components are passed or both embed and embeds are passed. hikari . BadRequestError This may be raised in several discrete situations, such as messages being empty with no embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; invalid image URLs in embeds. hikari . UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari . NotFoundError If the interaction is not found or if the interaction's initial response has already been created. hikari . RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request. hikari . RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari . InternalServerError If an internal error occurs on Discord while handling the request. defer async # defer ( defer_type , / , * , ephemeral = False , flags = hikari . UNDEFINED ) Defer the initial response for this context. Note The ephemeral state of the first response is decided by whether the deferral is ephemeral. PARAMETER DESCRIPTION defer_type The type of deferral this should be. This may any of the following * ResponseType.DEFERRED_MESSAGE_CREATE to indicate that the following up call to yuyo.components.ComponentContext.edit_initial_response or yuyo.components.ComponentContext.respond should create a new message. * ResponseType.DEFERRED_MESSAGE_UPDATE to indicate that the following call to the aforementioned methods should update the existing message. TYPE: hikari . DeferredResponseTypesT ephemeral Whether the deferred response should be ephemeral. Passing True here is a shorthand for including 1 << 64 in the passed flags. TYPE: bool DEFAULT: False flags The flags to use for the initial response. TYPE: typing . Union [ hikari . UndefinedType , int , hikari . MessageFlag ] DEFAULT: hikari.UNDEFINED delete_initial_response async # delete_initial_response () Delete the initial response after invoking this context. RAISES DESCRIPTION LookupError , hikari . NotFoundError The last context has no initial response. delete_last_response async # delete_last_response () Delete the last response after invoking this context. RAISES DESCRIPTION LookupError , hikari . NotFoundError The last context has no responses. edit_initial_response async # edit_initial_response ( content = hikari . UNDEFINED , * , delete_after = None , attachment = hikari . UNDEFINED , attachments = hikari . UNDEFINED , component = hikari . UNDEFINED , components = hikari . UNDEFINED , embed = hikari . UNDEFINED , embeds = hikari . UNDEFINED , mentions_everyone = hikari . UNDEFINED , user_mentions = hikari . UNDEFINED , role_mentions = hikari . UNDEFINED ) Edit the initial response for this context. PARAMETER DESCRIPTION content The content to edit the initial response with. If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED delete_after If provided, the seconds after which the response message should be deleted. Slash command responses can only be deleted within 15 minutes of the command being received. TYPE: typing . Union [ datetime . timedelta , float , int , None] DEFAULT: None attachment A singular attachment to edit the initial response with. TYPE: hikari . UndefinedNoneOr [ hikari . Resourceish ] DEFAULT: hikari.UNDEFINED attachments A sequence of attachments to edit the initial response with. TYPE: hikari . UndefinedNoneOr [ collections . Sequence [ hikari . Resourceish ]] DEFAULT: hikari.UNDEFINED component If provided, builder object of the component to set for this message. This component will replace any previously set components and passing None will remove all components. TYPE: hikari . UndefinedNoneOr [ hikari . api . ComponentBuilder ] DEFAULT: hikari.UNDEFINED components If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing None or an empty sequence will remove all components. TYPE: hikari . UndefinedNoneOr [ collections . Sequence [ hikari . api . ComponentBuilder ]] DEFAULT: hikari.UNDEFINED embed An embed to replace the initial response with. TYPE: hikari . UndefinedNoneOr [ hikari . Embed ] DEFAULT: hikari.UNDEFINED embeds A sequence of embeds to replace the initial response with. TYPE: hikari . UndefinedNoneOr [ collections . Sequence [ hikari . Embed ]] DEFAULT: hikari.UNDEFINED mentions_everyone If provided, whether the message should parse @everyone/@here mentions. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED user_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialUser ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED role_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialRole ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED RETURNS DESCRIPTION hikari . Message The message that has been edited. RAISES DESCRIPTION ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions . If delete_after would be more than 15 minutes after the slash command was called. If both attachment and attachments are passed or both component and components are passed or both embed and embeds are passed. hikari . BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components. hikari . UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari . ForbiddenError If you are missing the SEND_MESSAGES in the channel or the person you are trying to message has the DM's disabled. hikari . NotFoundError If the channel is not found. hikari . RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request. hikari . RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari . InternalServerError If an internal error occurs on Discord while handling the request. edit_last_response async # edit_last_response ( content = hikari . UNDEFINED , * , delete_after = None , attachment = hikari . UNDEFINED , attachments = hikari . UNDEFINED , component = hikari . UNDEFINED , components = hikari . UNDEFINED , embed = hikari . UNDEFINED , embeds = hikari . UNDEFINED , mentions_everyone = hikari . UNDEFINED , user_mentions = hikari . UNDEFINED , role_mentions = hikari . UNDEFINED ) Edit the last response for this context. PARAMETER DESCRIPTION content The content to edit the last response with. If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED delete_after If provided, the seconds after which the response message should be deleted. Slash command responses can only be deleted within 15 minutes of the command being received. TYPE: typing . Union [ datetime . timedelta , float , int , None] DEFAULT: None attachment A singular attachment to edit the last response with. TYPE: hikari . UndefinedNoneOr [ hikari . Resourceish ] DEFAULT: hikari.UNDEFINED attachments A sequence of attachments to edit the last response with. TYPE: hikari . UndefinedNoneOr [ collections . Sequence [ hikari . Resourceish ]] DEFAULT: hikari.UNDEFINED component If provided, builder object of the component to set for this message. This component will replace any previously set components and passing None will remove all components. TYPE: hikari . UndefinedNoneOr [ hikari . api . ComponentBuilder ] DEFAULT: hikari.UNDEFINED components If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing None or an empty sequence will remove all components. TYPE: hikari . UndefinedNoneOr [ collections . Sequence [ hikari . api . ComponentBuilder ]] DEFAULT: hikari.UNDEFINED embed An embed to replace the last response with. TYPE: hikari . UndefinedNoneOr [ hikari . Embed ] DEFAULT: hikari.UNDEFINED embeds A sequence of embeds to replace the last response with. TYPE: hikari . UndefinedNoneOr [ collections . Sequence [ hikari . Embed ]] DEFAULT: hikari.UNDEFINED mentions_everyone If provided, whether the message should parse @everyone/@here mentions. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED user_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialUser ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED role_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialRole ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED RETURNS DESCRIPTION hikari . Message The message that has been edited. RAISES DESCRIPTION ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions . If delete_after would be more than 15 minutes after the slash command was called. If both attachment and attachments are passed or both component and components are passed or both embed and embeds are passed. hikari . BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components. hikari . UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari . ForbiddenError If you are missing the SEND_MESSAGES in the channel or the person you are trying to message has the DM's disabled. hikari . NotFoundError If the channel is not found. hikari . RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request. hikari . RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari . InternalServerError If an internal error occurs on Discord while handling the request. fetch_initial_response async # fetch_initial_response () Fetch the initial response for this context. RETURNS DESCRIPTION hikari . messages . Message The initial response's message object. RAISES DESCRIPTION LookupError , hikari . NotFoundError The response was not found. fetch_last_response async # fetch_last_response () Fetch the last response for this context. RETURNS DESCRIPTION hikari . messages . Message The most response response's message object. RAISES DESCRIPTION LookupError , hikari . NotFoundError The response was not found. respond async # respond ( content = hikari . UNDEFINED , * , ensure_result = False , delete_after = None , attachment = hikari . UNDEFINED , attachments = hikari . UNDEFINED , component = hikari . UNDEFINED , components = hikari . UNDEFINED , embed = hikari . UNDEFINED , embeds = hikari . UNDEFINED , mentions_everyone = hikari . UNDEFINED , user_mentions = hikari . UNDEFINED , role_mentions = hikari . UNDEFINED ) Respond to this context. PARAMETER DESCRIPTION content The content to respond with. If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED ensure_result Ensure that this call will always return a message object. If True then this will always return hikari.messages.Message , otherwise this will return hikari.Message | None . It's worth noting that, under certain scenarios within the slash command flow, this may lead to an extre request being made. TYPE: bool DEFAULT: False delete_after If provided, the seconds after which the response message should be deleted. Slash command responses can only be deleted within 15 minutes of the command being received. TYPE: typing . Union [ datetime . timedelta , float , int , None] DEFAULT: None attachment If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL. TYPE: hikari . UndefinedOr [ hikari . Resourceish ] DEFAULT: hikari.UNDEFINED attachments If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs. TYPE: hikari . UndefinedOr [ collections . Sequence [ hikari . Resourceish ]] DEFAULT: hikari.UNDEFINED component If provided, builder object of the component to include in this response. TYPE: hikari . UndefinedOr [ hikari . api . ComponentBuilder ] DEFAULT: hikari.UNDEFINED components If provided, a sequence of the component builder objects to include in this response. TYPE: hikari . UndefinedOr [ collections . Sequence [ hikari . api . ComponentBuilder ]] DEFAULT: hikari.UNDEFINED embed An embed to respond with. TYPE: hikari . UndefinedOr [ hikari . Embed ] DEFAULT: hikari.UNDEFINED embeds A sequence of embeds to respond with. TYPE: hikari . UndefinedOr [ collections . Sequence [ hikari . Embed ]] DEFAULT: hikari.UNDEFINED mentions_everyone If provided, whether the message should parse @everyone/@here mentions. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED user_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialUser ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED role_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialRole ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED RETURNS DESCRIPTION hikari . Message | None The message that has been created if it was immedieatly available or ensure_result was set to True , else None . RAISES DESCRIPTION ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions . If delete_after would be more than 15 minutes after the slash command was called. If both attachment and attachments are passed or both component and components are passed or both embed and embeds are passed. hikari . BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components. hikari . UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari . ForbiddenError If you are missing the SEND_MESSAGES in the channel or the person you are trying to message has the DM's disabled. hikari . NotFoundError If the channel is not found. hikari . RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request. hikari . RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari . InternalServerError If an internal error occurs on Discord while handling the request. set_ephemeral_default # set_ephemeral_default ( state ) Set the ephemeral default state for this context. PARAMETER DESCRIPTION state The new ephemeral default state. If this is True then all calls to the response creating methods on this context will default to being ephemeral. TYPE: bool ComponentExecutor # Bases: AbstractComponentExecutor Basic implementation of a class used for handling the execution of a message component. __init__ # __init__ ( * , ephemeral_default = False , load_from_attributes = True , timeout = datetime . timedelta ( seconds = 30 )) Initialise a component executor. PARAMETER DESCRIPTION ephemeral_default Whether this executor's responses should default to being ephemeral. TYPE: bool DEFAULT: False timeout How long this component should last until its marked as timed out. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30) ComponentPaginator # Bases: ActionRowExecutor Standard implementation of an action row executor used for pagination. This is a convenience class that allows you to easily implement a paginator. __init__ # __init__ ( iterator , * , authors , ephemeral_default = False , triggers = ( pagination . LEFT_TRIANGLE , pagination . STOP_SQUARE , pagination . RIGHT_TRIANGLE ), load_from_attributes = False , timeout = datetime . timedelta ( seconds = 30 )) Initialise a component paginator. PARAMETER DESCRIPTION iterator The iterator to paginate. This should be an iterator of tuples of (hikari.UndefinedOr[str], hikari.UndefinedOr[hikari.Embed]) . TYPE: collections . Iterator [ yuyo . pagination . EntryT ] | collections . AsyncIterator [ yuyo . pagination . EntryT ] authors The authors of the entries. If None is passed here then the paginator will be public (meaning that anybody can use it). TYPE: typing . Optional [ collections . Iterable [ hikari . SnowflakeishOr [ hikari . User ]]] ephemeral_default Whether or not the responses made on contexts spawned from this paginator should default to ephemeral (meaning only the author can see them) unless flags is specified on the response method. TYPE: bool DEFAULT: False triggers Collection of the unicode emojis that should trigger this paginator. As of current the only usable emojis are yuyo.pagination.LEFT_TRIANGLE , yuyo.pagination.RIGHT_TRIANGLE , yuyo.pagination.STOP_SQUARE , yuyo.pagination.LEFT_DOUBLE_TRIANGLE and yuyo.pagination.LEFT_TRIANGLE . TYPE: collections . Collection [ str ] DEFAULT: (pagination.LEFT_TRIANGLE, pagination.STOP_SQUARE, pagination.RIGHT_TRIANGLE) timeout The amount of time to wait after the component's last execution or creation until it times out. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30) builder # builder () Get a sequence of the component builders for this paginator. RETURNS DESCRIPTION collections . abc . Sequence [ hikari . api . ComponentBuilder ] The component builders for this paginator. get_next_entry async # get_next_entry () Get the next entry in this paginator. This is generally helpful for making the message which the paginator will be based off and will still internally store the entry and increment the position of the paginator. Examples: response_paginator = yuyo . ComponentPaginator ( pages , authors = ( ctx . author . id ,) ) first_response = await response_paginator . get_next_entry () assert first_response content , embed = first_response message = await ctx . respond ( content = content , embed = embed , component = response_paginator , ensure_result = True ) component_client . set_executor ( message , response_paginator ) RETURNS DESCRIPTION yuyo . pagination . EntryT | None The next entry in this paginator, or None if there are no more entries. DiscordBotListService # https://discordbotlist.com status update service. __init__ # __init__ ( token ) Initialise a discordbotlist.com service. PARAMETER DESCRIPTION token Authorization token used to update the bot's status. TYPE: str ErrorManager # A context manager provided to allow for more concise error handling with yuyo.backoff.Backoff . Examples: The following is an example of using yuyo.backoff.ErrorManager alongside yuyo.backoff.Backoff in-order to handle the exceptions which may be raised while trying to reply to a message. retry = Backoff () # Rules can either be passed to `ErrorManager`'s initiate as variable arguments # or one at a time to `ErrorManager.with_rule` through possibly chained-calls. error_handler = ( # For the 1st rule we catch two errors which would indicate the bot # no-longer has access to the target channel and break out of the # retry loop using `Backoff.retry`. ErrorManager ((( errors . NotFoundError , errors . ForbiddenError ), lambda _ : retry . finish ())) # For the 2nd rule we catch rate limited errors and set their # `retry` value as the next backoff time before suppressing the # error to allow this to retry the request. . with_rule (( errors . RateLimitedError ,), lambda exc : retry . set_next_backoff ( exc . retry_after )) # For the 3rd rule we suppress the internal server error to allow # backoff to reach the next retry and exponentially backoff as we # don't have any specific retry time for this error. . with_rule (( errors . InternalServerError ,), lambda _ : False ) ) async for _ in retry : # We entre this context manager each iteration to catch errors before # they cause us to break out of the `Backoff` loop. with error_handler : await message . respond ( \"General Kenobi\" ) # We need to break out of `retry` if this request succeeds. break __init__ # __init__ ( * rules ) Initialise an error manager instance. PARAMETER DESCRIPTION *rules Rules to initiate this error context manager with. These are each a 2-length tuple where the tuple[0] is an iterable of types of the exceptions this rule should apply to and tuple[1] is the rule's callback function. The callback function will be called with the raised exception when it matches one of the passed exceptions for the relevant rule and may raise, return True to indicate that the current error should be raised outside of the context manager or False / None to suppress the current error. TYPE: tuple [ collections . Iterable [ type [ BaseException ]], collections . Callable [[ typing . Any ], typing . Optional [ bool ]]] DEFAULT: () clear_rules # clear_rules () Clear the rules registered with this handler. with_rule # with_rule ( exceptions , result ) Add a rule to this exception context manager. PARAMETER DESCRIPTION exceptions An iterable of types of the exceptions this rule should apply to. TYPE: collections . Iterable [ type [ BaseException ]] result The function called with the raised exception when it matches one of the passed exceptions . This may raise, return True to indicate that the current error should be raised outside of the context manager or False / None to suppress the current error. TYPE: collections . Callable [[ typing . Any ], typing . Optional [ bool ]] RETURNS DESCRIPTION Self This returns the handler a rule was being added to in-order to allow for chained calls. FinishedChunkingEvent # Bases: hikari . Event Event that's dispatched when the startup chunking has finished for the bot. This indicates that any cache member and presences resources should be complete globally. This will only be fired once after bot startups. __init__ # __init__ ( app ) Initialise a chunking finished event. This should never be initialised directly. MultiComponentExecutor # Bases: AbstractComponentExecutor Multi-component implementation of a component executor. This implementation allows for multiple components to be executed as a single view. builders property # builders : collections . Sequence [ hikari . api . ComponentBuilder ] Sequence of the component builders within this executor. executors property # executors : collections . Sequence [ AbstractComponentExecutor ] Sequence of the child executors within this multi-executor. __init__ # __init__ ( * , load_from_attributes = False , timeout = datetime . timedelta ( seconds = 30 )) Initialise a multi-component executor. PARAMETER DESCRIPTION timeout The amount of time to wait after the component's last execution or creation until it times out. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30) add_action_row # add_action_row () Create a builder class to add an action row to this executor. For the most part this follows the same implementation as yuyo.components.ActionRowExecutor except with the added detail that yuyo.components.ChildActionRowExecutor.add_to_parent must be called to add the action row to the parent executor. RETURNS DESCRIPTION ChildActionRowExecutor [ Self ] A builder class to add an action row to this executor. yuyo.components.ChildActionRowExecutor.add_to_parent should be called to finalise the action row and will return the parent executor for chained calls. add_builder # add_builder ( builder ) Add a non-executable component builder to this executor. This is useful for adding components that are not meant to be executed, such as a a row of link buttons. PARAMETER DESCRIPTION builder The component builder to add. TYPE: hikari . api . ComponentBuilder RETURNS DESCRIPTION Self add_executor # add_executor ( executor ) Add a component executor to this multi-component executor. This method is internally used by the add_{component} methods. PARAMETER DESCRIPTION executor The component executor to add. TYPE: AbstractComponentExecutor RETURNS DESCRIPTION Self The multi-component executor instance to enable chained calls. ReactionClient # A class which handles the events for multiple registered reaction handlers. Note For a quicker way to initialise this client from a bot, see yuyo.reactions.ReactionClient.from_gateway_bot . alluka property # alluka : alluka_ . abc . Client The Alluka client being used for callback dependency injection. is_closed property # is_closed : bool Whether this client is closed. __init__ # __init__ ( * , rest , event_manager , alluka = None , event_managed = True ) Initialise a reaction client. PARAMETER DESCRIPTION rest The REST client to register this reaction client with. TYPE: hikari . api . RESTClient event_manager The event manager client to register this reaction client with. TYPE: hikari . api . EventManager alluka The alluka client to use for callback DI. TYPE: typing . Optional [ alluka_ . abc . Client ] DEFAULT: None event_managed Whether the reaction client should be automatically opened and closed based on the lifetime events dispatched by event_managed . TYPE: bool DEFAULT: True add_handler # add_handler ( message , / , paginator ) Add a reaction handler to this reaction client. Note This does not call yuyo.reactions.AbstractReactionHandler.open . PARAMETER DESCRIPTION message The message ID to add register a reaction handler with. TYPE: hikari . SnowflakeishOr [ hikari . Message ] paginator The object of the opened paginator to register in this reaction client. TYPE: AbstractReactionHandler close async # close () Close this client by unregistering any registered tasks and event listeners. from_gateway_bot classmethod # from_gateway_bot ( bot , / , * , event_managed = True ) Build a ReactionClient from a gateway bot. PARAMETER DESCRIPTION bot The bot to build a reaction client for. TYPE: hikari . GatewayBotAware event_managed Whether the reaction client should be automatically opened and closed based on the lifetime events dispatched by bot . TYPE: bool DEFAULT: True RETURNS DESCRIPTION ReactionClient The reaction client for the bot. get_handler # get_handler ( message ) Get a reference to a paginator registered in this reaction client. Note This does not call yuyo.reactions.AbstractReactionHandler.close . PARAMETER DESCRIPTION message The message ID to remove a paginator for. TYPE: hikari . SnowflakeishOr [ hikari . Message ] RETURNS DESCRIPTION AbstractReactionHandler | None The object of the registered paginator if found else None . open async # open () Start this client by registering the required tasks and event listeners for it to function. remove_handler # remove_handler ( message ) Remove a paginator from this reaction client. Note This does not call yuyo.reactions.AbstractReactionHandler.close . PARAMETER DESCRIPTION message The message ID to remove a paginator for. TYPE: hikari . SnowflakeishOr [ hikari . Message ] RETURNS DESCRIPTION AbstractReactionHandler | None The object of the registered paginator if found else None . ReactionHandler # Bases: AbstractReactionHandler Standard basic implementation of a reaction handler. authors property # authors : collections . Set [ hikari . Snowflake ] Set of the authors/owner of a enabled handler. Note If this is empty then the handler is considered public and any user will be able to trigger it. timeout property # timeout : datetime . timedelta How long this handler will wait since the last event before timing out. __init__ # __init__ ( * , authors = (), timeout = datetime . timedelta ( seconds = 30 ), load_from_attributes = True ) Initialise a reaction handler. PARAMETER DESCRIPTION authors An iterable of IDs of the users who can call this paginator. If left empty then all users will be able to call this paginator. TYPE: collections . Iterable [ hikari . SnowflakeishOr [ hikari . User ]] DEFAULT: () timeout How long it should take for this paginator to timeout. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30) add_callback # add_callback ( emoji_identifier , callback ) Add a callback to this reaction handler. PARAMETER DESCRIPTION emoji_identifier Identifier of the emoji this callback is for. This should be a snowfake if this is for a custom emoji or a string if this is for a unicode emoji. TYPE: typing . Union [ str , hikari . SnowflakeishOr [ hikari . CustomEmoji ]] callback The callback to add. This should be a function that accepts a single parameter, which is the event that triggered this reaction. TYPE: CallbackSig remove_callback # remove_callback ( emoji_identifier ) Remove a callback from this reaction handler. PARAMETER DESCRIPTION emoji_identifier Identifier of the emoji the callback to remove is for. This should be a snowfake if this is for a custom emoji or a string if this is for a unicode emoji. TYPE: typing . Union [ str , hikari . SnowflakeishOr [ hikari . CustomEmoji ]] with_callback # with_callback ( emoji_identifier ) Add a callback to this reaction handler through a decorator call. PARAMETER DESCRIPTION emoji_identifier Identifier of the emoji this callback is for. This should be a snowfake if this is for a custom emoji or a string if this is for a unicode emoji. TYPE: typing . Union [ str , hikari . SnowflakeishOr [ hikari . CustomEmoji ]] RETURNS DESCRIPTION collections . abc . Callabke [[ CallbackSigT ], CallbackSigT ] A decorator to add a callback to this reaction handler. ReactionPaginator # Bases: ReactionHandler Standard implementation of a reaction handler for pagination. __init__ # __init__ ( iterator , * , authors , triggers = ( pagination . LEFT_TRIANGLE , pagination . STOP_SQUARE , pagination . RIGHT_TRIANGLE ), timeout = datetime . timedelta ( seconds = 30 )) Initialise a reaction paginator. PARAMETER DESCRIPTION iterator Either an asynchronous or synchronous iterator of the entries this should paginate through. entry[0] represents the message's possible content and can either be str or hikari.undefined.UNDEFINED and entry[1] represents the message's possible embed and can either be hikari.embeds.Embed or hikari.undefined.UNDEFINED . TYPE: collections . Iterator [ yuyo . pagination . EntryT ] | collections . AsyncIterator [ yuyo . pagination . EntryT ] authors An iterable of IDs of the users who can call this paginator. If left empty then all users will be able to call this paginator. TYPE: collections . Iterable [ hikari . SnowflakeishOr [ hikari . User ]] timeout How long it should take for this paginator to timeout. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30) add_author # add_author ( user ) Add a author/owner to this handler. PARAMETER DESCRIPTION user The user to add as an owner for this handler. TYPE: hikari . SnowflakeishOr [ hikari . User ] close async # close ( * , remove_reactions = False , max_retries = 5 , max_backoff = 2.0 ) Close this handler and deregister any previously registered message. PARAMETER DESCRIPTION remove_reactions Whether this should remove the reactions that were being used to paginate through this from the previously registered message. TYPE: bool DEFAULT: False create_message async # create_message ( rest , channel_id , / , * , add_reactions = True , max_retries = 5 , max_backoff = 2.0 ) Start this handler and link it to a bot message. Note Calling this multiple times will replace the previously registered message. PARAMETER DESCRIPTION rest Rest client to use to make the response. TYPE: hikari . api . RESTClient channel_id ID of the channel to respond in. TYPE: hikari . SnowflakeishOr [ hikari . TextableChannel ] add_reactions Whether this should add the paginator's reactions to the message after responding. TYPE: bool DEFAULT: True max_retries How many times this should retry to respond if Hikari raises any ratelimit errors. TYPE: int DEFAULT: 5 max_backoff The maximum time this should backoff for before trying if Hikari raises any ratelimit errors. TYPE: float DEFAULT: 2.0 RETURNS DESCRIPTION hikari . messages . Message Object of the message this handler now targets. If message was not supplied then this will be the object of a newly created message, otherwise this will be what was supplied as message . RAISES DESCRIPTION ValueError If the provided iterator didn't yield any content for the first message. remove_author # remove_author ( user ) Remove a author/owner from this handler. Note If the provided user isn't already a registered owner of this paginator then this should pass silently without raising. PARAMETER DESCRIPTION user The user to remove from this handler's owners. TYPE: hikari . SnowflakeishOr [ hikari . User ] ServiceManager # Bases: AbstractManager Standard service manager. is_alive property # is_alive : bool Wwhether this manager is active. __init__ # __init__ ( rest , / , * , cache = None , event_manager = None , shards = None , event_managed = None , strategy = None , user_agent = None ) Initialise a service manager. PARAMETER DESCRIPTION rest The RESTAware Hikari client to bind this manager to. TYPE: hikari . api . RESTClient cache The cache aware Hikari client this manager should use. TYPE: typing . Optional [ hikari . api . Cache ] DEFAULT: None event_manager The event manager aware Hikari client this manager should use. TYPE: typing . Optional [ hikari . api . EventManager ] DEFAULT: None shards The shard aware Hikari client this manager should use. TYPE: typing . Optional [ traits . ShardAware ] DEFAULT: None event_managed Whether this client should be automatically opened and closed based on event_manager 's lifetime events. Defaults to True when event_manager is passed. TYPE: typing . Optional [ bool ] DEFAULT: None strategy The counter strategy this manager should expose to services. If this is left as None then the manager will try to pick a suitable standard strategy based on the provided Hikari clients. TYPE: typing . Optional [ AbstractCountStrategy ] DEFAULT: None user_agent Override the standard user agent used during requests to bot list services. TYPE: typing . Optional [ str ] DEFAULT: None RAISES DESCRIPTION ValueError If the manager failed to find a suitable standard strategy to use when strategy was left as None . If event_managed is passed as True when event_manager is None . add_service # add_service ( service , / , * , repeat = datetime . timedelta ( hours = 1 )) Add a service to this manager. PARAMETER DESCRIPTION service Asynchronous callback used to update this service. TYPE: ServiceSig repeat How often this service should be updated in seconds. TYPE: typing . Union [ datetime . timedelta , int , float ] DEFAULT: datetime.timedelta(hours=1) RETURNS DESCRIPTION Self Object of this service manager. RAISES DESCRIPTION ValueError If repeat is less than 1 second. RuntimeError If the client is already running. close async # close () Close this manager. from_gateway_bot classmethod # from_gateway_bot ( bot , / , * , event_managed = True , strategy = None , user_agent = None ) Build a service manager from a gateway bot. PARAMETER DESCRIPTION bot The gateway bot to build a service manager from. TYPE: traits . GatewayBotAware event_managed Whether this client should be automatically opened and closed based on bot 's lifetime events. TYPE: bool DEFAULT: True strategy The counter strategy this manager should expose to services. If this is left as None then the manager will try to pick a suitable standard strategy based on the provided Hikari clients. TYPE: typing . Optional [ AbstractCountStrategy ] DEFAULT: None user_agent Override the standard user agent used during requests to bot list services. TYPE: typing . Optional [ str ] DEFAULT: None RETURNS DESCRIPTION ServiceManager The build service manager. RAISES DESCRIPTION ValueError If the manager failed to find a suitable standard strategy to use when strategy was left as None . open async # open () Start this manager. RAISES DESCRIPTION RuntimeError If this manager is already running. remove_service # remove_service ( service ) Remove the first found entry of the registered service. PARAMETER DESCRIPTION service Service callback to unregister. TYPE: ServiceSig RAISES DESCRIPTION RuntimeError If called while the manager is active. ValueError If the service callback isn't found. with_service # with_service ( * , repeat = datetime . timedelta ( hours = 1 )) Add a service to this manager by decorating a function. PARAMETER DESCRIPTION repeat How often this service should be updated in seconds. TYPE: typing . Union [ datetime . timedelta , int , float ] DEFAULT: datetime.timedelta(hours=1) RETURNS DESCRIPTION collections . abc . Callable [[ ServiceSig ], ServiceSig ] Decorator callback used to add a service. RAISES DESCRIPTION ValueError If repeat is less than 1 second. RuntimeError If the client is already running. ShardFinishedChunkingEvent # Bases: hikari . ShardEvent Event that's dispatched when the startup chunking has finished for a shard. This indicates that any cache member and presences resources should be complete for guilds covered by this shard. This will be fired after every shard identify which triggers chunking (including re-identifies). incomplete_guild_ids property # incomplete_guild_ids : collections . Sequence [ hikari . Snowflake ] Sequence of the IDs of guilds some chunk responses were missed for. missed_guild_ids property # missed_guild_ids : collections . Sequence [ hikari . Snowflake ] Sequence of the IDs of guilds no chunk responses were received for. __init__ # __init__ ( app , shard , / , * , incomplete_guild_ids = (), missed_guild_ids = ()) Initialise a shard chunking finished event. This should never be initialised directly. TopGGService # https://top.gg status update service. __init__ # __init__ ( token ) Initialise a top.gg service. PARAMETER DESCRIPTION token Authorization token used to update the bot's status. TYPE: str WaitForExecutor # Bases: AbstractComponentExecutor Component executor used to wait for a single component interaction. Examples: responses : dict [ str , str ] message = await ctx . respond ( \"hi, pick an option\" , components = [ ... ]) executor = yuyo . components . WaitFor ( authors = ( ctx . author . id ,), timeout = datetime . timedelta ( seconds = 30 )) component_client . set_executor ( message . id , executor ) try : result = await executor . wait_for () except asyncio . TimeoutError : await ctx . respond ( \"timed out\" ) else : await result . respond ( responses [ result . interaction . custom_id ]) __init__ # __init__ ( * , authors , ephemeral_default = False , timeout ) Initialise a wait for executor. PARAMETER DESCRIPTION authors The authors of the entries. If None is passed here then the paginator will be public (meaning that anybody can use it). TYPE: typing . Optional [ collections . Iterable [ hikari . SnowflakeishOr [ hikari . User ]]] ephemeral_default Whether or not the responses made on contexts spawned from this paginator should default to ephemeral (meaning only the author can see them) unless flags is specified on the response method. TYPE: bool DEFAULT: False timeout How long this should wait for a matching component interaction until it times-out. TYPE: datetime . timedelta wait_for async # wait_for () Wait for the next matching interaction. RETURNS DESCRIPTION ComponentContext The next matching interaction. RAISES DESCRIPTION RuntimeError If the executor is already being waited for. asyncio . TimeoutError If the timeout is reached. aenumerate async # aenumerate ( iterable ) Async equivalent of enumerate . PARAMETER DESCRIPTION iterable The async iterable to enumerate. TYPE: collections . AsyncIterable [ _T ] RETURNS DESCRIPTION collections . abc . AsyncIterator [ tuple [ int , _T ]] The enumerated async iterator. async_paginate_string async # async_paginate_string ( lines , * , char_limit = 2000 , line_limit = 25 , wrapper = None ) Lazily paginate an iterator of lines. PARAMETER DESCRIPTION lines The asynchronous iterator of lines to paginate. TYPE: collections . AsyncIterable [ str ] char_limit The limit for how many characters should be included per yielded page. TYPE: int DEFAULT: 2000 line_limit The limit for how many lines should be included per yielded page. TYPE: int DEFAULT: 25 wrapper A wrapper for each yielded page. This should leave \"{}\" in it to be replaced by the page's content. TYPE: typing . Optional [ str ] DEFAULT: None RETURNS DESCRIPTION typing . AsyncIterator [ tuple [ str , int ]] An async iterator of page tuples (string context to int zero-based index). paginate_string # paginate_string ( lines , * , char_limit = 2000 , line_limit = 25 , wrapper = None ) Lazily paginate an iterator of lines. PARAMETER DESCRIPTION lines The iterator of lines to paginate. This iterator may be asynchronous or synchronous. TYPE: collections . abc . Iterator [ str ] | collections . abc . AsyncIterator [ str ] char_limit The limit for how many characters should be included per yielded page. TYPE: int DEFAULT: 2000 line_limit The limit for how many lines should be included per yielded page. TYPE: int DEFAULT: 25 wrapper A wrapper for each yielded page. This should leave \"{}\" in it to be replaced by the page's content. TYPE: typing . Optional [ str ] DEFAULT: None RETURNS DESCRIPTION collections . abc . AsyncIterator [ tuple [ str , int ]] | collections . abc . Iterator [ tuple [ str , int ]] An iterator of page tuples (string context to int zero-based index). sync_paginate_string # sync_paginate_string ( lines , * , char_limit = 2000 , line_limit = 25 , wrapper = None ) Lazily paginate an iterator of lines. PARAMETER DESCRIPTION lines The iterator of lines to paginate. TYPE: collections . Iterable [ str ] char_limit The limit for how many characters should be included per yielded page. TYPE: int DEFAULT: 2000 line_limit The limit for how many lines should be included per yielded page. TYPE: int DEFAULT: 25 wrapper A wrapper for each yielded page. This should leave \"{}\" in it to be replaced by the page's content. TYPE: typing . Optional [ str ] DEFAULT: None RETURNS DESCRIPTION collections . abc . Iterator [ tuple [ str , int ]] An iterator of page tuples (string context to int zero-based index).","title":"yuyo"},{"location":"reference/#yuyo_1","text":"A collection of utility functions and classes designed to enhances Hikari.","title":"yuyo"},{"location":"reference/#yuyo.ActionRowExecutor","text":"Bases: ComponentExecutor , hikari . api . ComponentBuilder Class used for handling the execution of an action row.","title":"ActionRowExecutor"},{"location":"reference/#yuyo.components.ActionRowExecutor.__init__","text":"__init__ ( * , ephemeral_default = False , load_from_attributes = False , timeout = datetime . timedelta ( seconds = 30 )) Initialise an action row executor. PARAMETER DESCRIPTION ephemeral_default Whether this executor's responses should default to being ephemeral. TYPE: bool DEFAULT: False timeout How long this component should last until its marked as timed out. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30)","title":"__init__()"},{"location":"reference/#yuyo.AsgiAdapter","text":"Asgi/3 adapter for Hikari's interaction server interface. For this to work, hikari has to be installed with the optional \"server\" feature (e.g python -m pip install hikari[server] ).","title":"AsgiAdapter"},{"location":"reference/#yuyo.asgi.AsgiAdapter.server","text":"server : hikari . api . InteractionServer The interaction server this adapter is bound to.","title":"server"},{"location":"reference/#yuyo.asgi.AsgiAdapter.__call__","text":"__call__ ( scope , receive , send ) Call the adapter. Note This method is called by the ASGI server. PARAMETER DESCRIPTION scope The scope of the request. TYPE: asgiref . Scope receive The receive function to use. TYPE: asgiref . ASGIReceiveCallable send The send function to use. TYPE: asgiref . ASGISendCallable RAISES DESCRIPTION NotImplementedError If this is called with a websocket scope. RuntimeError If an invalid scope event is passed.","title":"__call__()"},{"location":"reference/#yuyo.asgi.AsgiAdapter.__init__","text":"__init__ ( server , / , * , executor = None ) Initialise the adapter. PARAMETER DESCRIPTION server The interaction server to use. TYPE: hikari . api . InteractionServer executor If non- None , then this executor is used instead of the concurrent.futures.ThreadPoolExecutor attached to the asyncio.AbstractEventLoop that the bot will run on. This executor is used primarily for file-IO. While mainly supporting the concurrent.futures.ThreadPoolExecutor implementation in the standard lib, Hikari's file handling systems should also work with concurrent.futures.ProcessPoolExecutor , which relies on all objects used in IPC to be pickle able. Many third-party libraries will not support this fully though, so your mileage may vary on using ProcessPoolExecutor implementations with this parameter. TYPE: typing . Optional [ concurrent . futures . Executor ] DEFAULT: None","title":"__init__()"},{"location":"reference/#yuyo.asgi.AsgiAdapter.add_shutdown_callback","text":"add_shutdown_callback ( callback ) Add a callback to be called when the ASGI server shuts down. Warning These callbacks will block the ASGI server from shutting down until they complete and any raised errors will lead to a failed shutdown. PARAMETER DESCRIPTION callback The shutdown callback to add. TYPE: collections . Callable [[ Self ], collections . Coroutine [ typing . Any , typing . Any , None]]","title":"add_shutdown_callback()"},{"location":"reference/#yuyo.asgi.AsgiAdapter.add_startup_callback","text":"add_startup_callback ( callback ) Add a callback to be called when the ASGI server starts up. Warning These callbacks will block the ASGI server from starting until they complete and any raised errors will lead to a failed startup. PARAMETER DESCRIPTION callback The startup callback to add. TYPE: collections . Callable [[ Self ], collections . Coroutine [ typing . Any , typing . Any , None]]","title":"add_startup_callback()"},{"location":"reference/#yuyo.asgi.AsgiAdapter.process_lifespan_event","text":"process_lifespan_event ( receive , send ) Process a lifespan ASGI event. Note This function is used internally by the adapter. PARAMETER DESCRIPTION receive The receive function to use. TYPE: asgiref . ASGIReceiveCallable send The send function to use. TYPE: asgiref . ASGISendCallable RAISES DESCRIPTION RuntimeError If an invalid lifespan event is passed.","title":"process_lifespan_event()"},{"location":"reference/#yuyo.asgi.AsgiAdapter.process_request","text":"process_request ( scope , receive , send ) Process an HTTP request. Note This function is used internally by the adapter. PARAMETER DESCRIPTION scope The scope of the request. TYPE: asgiref . HTTPScope receive The receive function to use. TYPE: asgiref . ASGIReceiveCallable send The send function to use. TYPE: asgiref . ASGISendCallable","title":"process_request()"},{"location":"reference/#yuyo.asgi.AsgiAdapter.remove_shutdown_callback","text":"remove_shutdown_callback ( callback ) Remove a shutdown callback. PARAMETER DESCRIPTION callback The shutdown callback to remove. TYPE: collections . Callable [[ Self ], collections . Coroutine [ typing . Any , typing . Any , None]] RAISES DESCRIPTION ValueError If the callback was not registered.","title":"remove_shutdown_callback()"},{"location":"reference/#yuyo.asgi.AsgiAdapter.remove_startup_callback","text":"remove_startup_callback ( callback ) Remove a startup callback. PARAMETER DESCRIPTION callback The startup callback to remove. TYPE: collections . Callable [[ Self ], collections . Coroutine [ typing . Any , typing . Any , None]] RAISES DESCRIPTION ValueError If the callback was not registered.","title":"remove_startup_callback()"},{"location":"reference/#yuyo.AsgiBot","text":"Bases: AsgiAdapter , hikari . RESTBotAware Bot implementation which acts as an ASGI adapter. This bot doesn't initiate a server internally but instead relies on being called as an ASGI app. For this to work, hikari has to be installed with the optional \"server\" feature (e.g python -m pip install hikari[server] ).","title":"AsgiBot"},{"location":"reference/#yuyo.asgi.AsgiBot.__init__","text":"__init__ ( token , token_type = None , public_key = None , * , asgi_managed = True , executor = None , http_settings = None , max_rate_limit = 300.0 , max_retries = 3 , proxy_settings = None , rest_url = None ) Initialise a new ASGI bot. PARAMETER DESCRIPTION token The bot or bearer token. If no token is to be used, this can be undefined. TYPE: typing . Union [ str , hikari . api . TokenStrategy ] token_type The type of token in use. This should only be passed when str is passed for token , can be \"Bot\" or \"Bearer\" and will be defaulted to \"Bearer\" in this situation. This should be left as None when either hikari.api.rest.TokenStrategy or None is passed for token . TYPE: typing . Union [ hikari . TokenType , str , None] DEFAULT: None asgi_managed Whether this bot's internal components should be automatically started and stopped based on the Asgi lifespan events. TYPE: bool DEFAULT: True executor If non- None , then this executor is used instead of the concurrent.futures.ThreadPoolExecutor attached to the asyncio.AbstractEventLoop that the bot will run on. This executor is used primarily for file-IO. While mainly supporting the concurrent.futures.ThreadPoolExecutor implementation in the standard lib, Hikari's file handling systems should also work with concurrent.futures.ProcessPoolExecutor , which relies on all objects used in IPC to be pickle able. Many third-party libraries will not support this fully though, so your mileage may vary on using ProcessPoolExecutor implementations with this parameter. TYPE: typing . Optional [ concurrent . futures . Executor ] DEFAULT: None http_settings Optional custom HTTP configuration settings to use. Allows you to customise functionality such as whether SSL-verification is enabled, what timeouts aiohttp should expect to use for requests, and behavior regarding HTTP-redirects. TYPE: typing . Optional [ hikari . impl . HTTPSettings ] DEFAULT: None max_rate_limit The max number of seconds to backoff for when rate limited. Anything greater than this will instead raise an error. This defaults to five minutes to stop potentially indefinitely waiting on an endpoint, which is almost never what you want to do if giving a response to a user. You can set this to float(\"inf\") to disable this check entirely. Note that this only applies to the REST API component that communicates with Discord, and will not affect sharding or third party HTTP endpoints that may be in use. TYPE: float DEFAULT: 300.0 max_retries Maximum number of times a request will be retried if it fails with a 5xx status. Defaults to 3 if set to None . TYPE: int DEFAULT: 3 proxy_settings Custom proxy settings to use with network-layer logic in your application to get through an HTTP-proxy. TYPE: typing . Optional [ hikari . impl . ProxySettings ] DEFAULT: None public_key The public key to use to verify received interaction requests. This may be a hex encoded str or the raw bytes . If left as None then the client will try to work this value out based on token . TYPE: typing . Union [ bytes , str , None] DEFAULT: None rest_url Defaults to the Discord REST API URL if None . Can be overridden if you are attempting to point to an unofficial endpoint, or if you are attempting to mock/stub the Discord API for any reason. Generally you do not want to change this. TYPE: typing . Optional [ str ] DEFAULT: None RAISES DESCRIPTION ValueError If token_type is provided when a token strategy is passed for token . if token_type is left as None when a string is passed for token .","title":"__init__()"},{"location":"reference/#yuyo.asgi.AsgiBot.close","text":"close () Close the bot's REST client. Warning Unless asgi_managed=False is passed to AsgiBot.__init__ , the bot will be automatically closed based on the ASGI lifespan events and any other calls to this function will raise a RuntimeError . RAISES DESCRIPTION RuntimeError If the client isn't alive. If the client is ASGI managed.","title":"close()"},{"location":"reference/#yuyo.asgi.AsgiBot.run","text":"run () Start the bot's REST client and wait until the bot's closed. Warning Unless asgi_managed=False is passed to yuyo.asgi.AsgiBot. init , the bot will be automatically started and closed based on the ASGI lifespan events and any other calls to this function will raise a RuntimeError . RAISES DESCRIPTION RuntimeError If the client is already alive. If the client is ASGI managed.","title":"run()"},{"location":"reference/#yuyo.asgi.AsgiBot.start","text":"start () Start the bot's REST client. Warning Unless asgi_managed=False is passed to yuyo.asgi.AsgiBot. init , the bot will be automatically started based on the ASGI lifespan events and any other calls to this function will raise a RuntimeError . RAISES DESCRIPTION RuntimeError If the client is already alive. If the client is ASGI managed.","title":"start()"},{"location":"reference/#yuyo.Backoff","text":"Used to exponentially backoff asynchronously. This class acts as an asynchronous iterator and can be iterated over to provide implicit backoff where for every iteration other than the first this will either back off for the time passed to yuyo.backoff.Backoff.set_next_backoff if applicable or a time calculated exponentially. Each iteration yields the current retry count (starting at 0). Examples: An example of using this class as an asynchronous iterator may look like the following # While we can directly do `async for _ in Backoff()`, by assigning it to a # variable we allow ourself to provide a specific backoff time in some cases. backoff = Backoff () async for _ in backoff : try : message = await bot . rest . fetch_message ( channel_id , message_id ) except errors . RateLimitedError as exc : # If we have a specific backoff time then set it for the next iteration backoff . set_next_backoff ( exc . retry_after ) except errors . InternalServerError : # Else let the iterator calculate an exponential backoff before the next loop. pass else : # We need to break out of the iterator to make sure it doesn't backoff again. # Alternatively `Backoff.finish()` can be called to break out of the loop. break Alternatively you may want to explicitly call yuyo.backoff.Backoff.backoff , a alternative of the previous example which uses yuyo.backoff.Backoff.backoff may look like the following backoff = Backoff () message : typing . Optional [ messages . Message ] = None while not message : try : message = await bot . rest . fetch_message ( channel_id , message_id ) except errors . RateLimitedError as exc : # If we have a specific backoff time then set it for the next iteration. await backoff . backoff ( exc . retry_after ) except errors . InternalServerError : # Else let the iterator calculate an exponential backoff before the next loop. await backoff . backoff ()","title":"Backoff"},{"location":"reference/#yuyo.backoff.Backoff.is_depleted","text":"is_depleted : bool Whether \"max_retries\" has been reached. This can be used to workout whether the loop was explicitly broken out of using yuyo.backoff.Backoff.finish / break or if it hit \"max_retries\".","title":"is_depleted"},{"location":"reference/#yuyo.backoff.Backoff.__init__","text":"__init__ ( max_retries = None , * , base = 2.0 , maximum = 64.0 , jitter_multiplier = 1.0 , initial_increment = 0 ) Initialise a backoff instance. PARAMETER DESCRIPTION max_retries The maximum amount of times this should iterate for between resets. If left as None then this iterator will be unlimited. This must be greater than or equal to 1. TYPE: typing . Optional [ int ] DEFAULT: None base The base to use. TYPE: float DEFAULT: 2.0 maximum The max value the backoff can be in a single iteration. Anything above this will be capped to this base value plus random jitter. TYPE: float DEFAULT: 64.0 jitter_multiplier The multiplier for the random jitter. Set to 0 to disable jitter. TYPE: float DEFAULT: 1.0 initial_increment The initial increment to start at. TYPE: int DEFAULT: 0 RAISES DESCRIPTION ValueError If an int that's too big to be represented as a float or a non-finite value is passed in place of a field that's annotated as float or if max_retries is less than 1 .","title":"__init__()"},{"location":"reference/#yuyo.backoff.Backoff.backoff","text":"backoff () Sleep for the provided backoff or for the next exponent. This provides an alternative to iterating over this class. RETURNS DESCRIPTION int | None Whether this has reached the end of its iteration. If this returns True then that call didn't sleep as this has been marked as finished or has reached the max retries.","title":"backoff()"},{"location":"reference/#yuyo.backoff.Backoff.finish","text":"finish () Mark the iterator as finished to break out of the current loop.","title":"finish()"},{"location":"reference/#yuyo.backoff.Backoff.reset","text":"reset () Reset the backoff to it's original state to reuse it.","title":"reset()"},{"location":"reference/#yuyo.backoff.Backoff.set_next_backoff","text":"set_next_backoff ( backoff_ ) Specify a backoff time for the next iteration or yuyo.backoff.Backoff.backoff call. If this is called then the exponent won't be increased for this iteration. Note Calling this multiple times in a single iteration will overwrite any previously set next backoff.","title":"set_next_backoff()"},{"location":"reference/#yuyo.BotsGGService","text":"https://discord.bots.gg status update service.","title":"BotsGGService"},{"location":"reference/#yuyo.list_status.BotsGGService.__init__","text":"__init__ ( token ) Initialise a bots.gg service. PARAMETER DESCRIPTION token Authorization token used to update the bot's status. TYPE: str","title":"__init__()"},{"location":"reference/#yuyo.ChunkRequestFinishedEvent","text":"Bases: hikari . ShardEvent Event that's dispatched when a specific chunk request has finished. This will be fired for every chunk request which has a nonce.","title":"ChunkRequestFinishedEvent"},{"location":"reference/#yuyo.chunk_tracker.ChunkRequestFinishedEvent.chunk_count","text":"chunk_count : int The amount of chunk events which should've been received for this request.","title":"chunk_count"},{"location":"reference/#yuyo.chunk_tracker.ChunkRequestFinishedEvent.first_received_at","text":"first_received_at : datetime . datetime When the first response was received.","title":"first_received_at"},{"location":"reference/#yuyo.chunk_tracker.ChunkRequestFinishedEvent.guild_id","text":"guild_id : hikari . Snowflake Id of the guild this chunk request was for.","title":"guild_id"},{"location":"reference/#yuyo.chunk_tracker.ChunkRequestFinishedEvent.last_received_at","text":"last_received_at : datetime . datetime When the last response was received.","title":"last_received_at"},{"location":"reference/#yuyo.chunk_tracker.ChunkRequestFinishedEvent.missed_chunks","text":"missed_chunks : collections . Collection [ int ] Collection of the chunk responses which were missed (if any).","title":"missed_chunks"},{"location":"reference/#yuyo.chunk_tracker.ChunkRequestFinishedEvent.not_found_ids","text":"not_found_ids : collections . Collection [ hikari . Snowflake ] Collection of the User IDs which weren't found. This is only relevant when users was specified while requesting the members.","title":"not_found_ids"},{"location":"reference/#yuyo.chunk_tracker.ChunkRequestFinishedEvent.__init__","text":"__init__ ( app , shard , data ) Initialise a chunk request finished event. This should never be initialised directly.","title":"__init__()"},{"location":"reference/#yuyo.ChunkTracker","text":"Chunk payload event tracker. This will dispatch ShardFinishedChunkingEvent , FinishedChunkingEvent and ChunkRequestFinishedEvent events. To configure this to automatically request member chunks to fill a member and/or presence cache on startup and guild join see ChunkTracker.set_auto_chunk_members . Note ChunkTracker.request_guild_members ensures a request will be tracked as this only tracks chunk requests with a set nonce.","title":"ChunkTracker"},{"location":"reference/#yuyo.chunk_tracker.ChunkTracker.__init__","text":"__init__ ( event_manager , rest , shards ) Initialise a chunk tracker. For a shorthand for initialising this from a hikari.traits.GatewayBotAware see ChunkTracker.from_gateway_bot . PARAMETER DESCRIPTION event_manager The event manager this chunk tracker should dispatch events over. TYPE: hikari . api . EventManager shards The shard aware object this should use. TYPE: hikari . ShardAware","title":"__init__()"},{"location":"reference/#yuyo.chunk_tracker.ChunkTracker.from_gateway_bot","text":"from_gateway_bot ( bot ) Initialise a chunk tracker from a gateway bot. PARAMETER DESCRIPTION bot The gateway bot this chunk tracker should use. TYPE: hikari . GatewayBotAware","title":"from_gateway_bot()"},{"location":"reference/#yuyo.chunk_tracker.ChunkTracker.request_guild_members","text":"request_guild_members ( guild , * , include_presences = hikari . UNDEFINED , query = '' , limit = 0 , users = hikari . UNDEFINED ) Request guild members. Note To request the full list of members, leave query as \"\" (empty string) and limit as 0 . PARAMETER DESCRIPTION guild The guild to request chunk for. TYPE: hikari . SnowflakeishOr [ hikari . PartialGuild ] include_presences If provided, whether to request presences. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED query If not \"\" , request the members who's usernames starts with the string. TYPE: str DEFAULT: '' limit Maximum number of members to send matching the query. TYPE: int DEFAULT: 0 users If provided, the users to request for. TYPE: hikari . UndefinedOr [ hikari . SnowflakeishSequence [ hikari . User ]] DEFAULT: hikari.UNDEFINED RAISES DESCRIPTION ValueError When trying to specify users with query / limit , if limit is not between 0 and 100, both inclusive or if users length is over 100. hikari . errors . MissingIntentError When trying to request presences without the GUILD_MEMBERS or when trying to request the full list of members without GUILD_PRESENCES .","title":"request_guild_members()"},{"location":"reference/#yuyo.chunk_tracker.ChunkTracker.set_auto_chunk_members","text":"set_auto_chunk_members ( state , / , * , chunk_presences = True ) Configure whether this should request member chunks in response to GUILD_CREATE. This may be useful for filling 3rd party caches but may conflict with the auto_chunk_members config of hikari.impl.bot.GatewayBot if it's enabled. Warning This will be ignored if Intents.GUILD_MEMBERS hasn't been declared. PARAMETER DESCRIPTION state Whether this should request member chunks when GUILD_CREATE events are received. TYPE: bool chunk_presences Whether this should also request member presences on these member chunks. This will be ignored if Intents.GUILD_PRESENCES hasn't been declared. TYPE: bool DEFAULT: True RETURNS DESCRIPTION Self The chunk tracker object to enable call chaining.","title":"set_auto_chunk_members()"},{"location":"reference/#yuyo.ComponentClient","text":"Client used to handle component executors within a REST or gateway flow.","title":"ComponentClient"},{"location":"reference/#yuyo.components.ComponentClient.alluka","text":"alluka : alluka_ . abc . Client The Alluka client being used for callback dependency injection.","title":"alluka"},{"location":"reference/#yuyo.components.ComponentClient.__init__","text":"__init__ ( * , alluka = None , event_manager = None , event_managed = None , server = None ) Initialise a component client. Note For an easier way to initialise the client from a bot see yuyo.components.ComponentClient.from_gateway_bot and yuyo.components.ComponentClient.from_rest_bot . PARAMETER DESCRIPTION alluka The Alluka client to use for callback dependency injection in this client. If not provided then this will initialise its own Alluka client. TYPE: typing . Optional [ alluka_ . abc . Client ] DEFAULT: None event_manager The event manager this client should listen to dispatched component interactions from if applicable. TYPE: typing . Optional [ hikari . api . EventManager ] DEFAULT: None event_managed Whether this client should be automatically opened and closed based on the lifetime events dispatched by event_manager . Defaults to True if an event manager is passed. TYPE: typing . Optional [ bool ] DEFAULT: None server The server this client should listen to component interactions from if applicable. TYPE: typing . Optional [ hikari . api . InteractionServer ] DEFAULT: None RAISES DESCRIPTION ValueError If event_managed is passed as True when event_manager is None .","title":"__init__()"},{"location":"reference/#yuyo.components.ComponentClient.add_executor","text":"add_executor ( message , executor ) Deprecated alias of yuyo.components.ComponentClient.add_executor .","title":"add_executor()"},{"location":"reference/#yuyo.components.ComponentClient.close","text":"close () Close the component client.","title":"close()"},{"location":"reference/#yuyo.components.ComponentClient.from_gateway_bot","text":"from_gateway_bot ( bot , / , * , event_managed = True ) Build a component client froma Gateway Bot. PARAMETER DESCRIPTION bot The Gateway bot this component client should be bound to. TYPE: hikari . GatewayBotAware event_managed Whether the component client should be automatically opened and closed based on the lifetime events dispatched by bot . TYPE: bool DEFAULT: True RETURNS DESCRIPTION ComponentClient The initialised component client.","title":"from_gateway_bot()"},{"location":"reference/#yuyo.components.ComponentClient.from_rest_bot","text":"from_rest_bot ( bot ) Build a component client froma REST Bot. PARAMETER DESCRIPTION bot The REST bot this component client should be bound to. TYPE: hikari . RESTBotAware RETURNS DESCRIPTION ComponentClient The initialised component client.","title":"from_rest_bot()"},{"location":"reference/#yuyo.components.ComponentClient.get_constant_id","text":"get_constant_id ( custom_id ) Get a set constant \"custom_id\" callback. PARAMETER DESCRIPTION custom_id The custom_id to get the callback for. TYPE: str RETURNS DESCRIPTION CallbackSig | None The callback for the custom_id, or None if it doesn't exist.","title":"get_constant_id()"},{"location":"reference/#yuyo.components.ComponentClient.get_executor","text":"get_executor ( message ) Get the component executor set for a message. PARAMETER DESCRIPTION message The message to get the executor for. TYPE: hikari . SnowflakeishOr [ hikari . Message ] RETURNS DESCRIPTION yuyo . components . AbstractComponentExecutor | None The executor set for the message or None if none is set.","title":"get_executor()"},{"location":"reference/#yuyo.components.ComponentClient.open","text":"open () Startup the component client.","title":"open()"},{"location":"reference/#yuyo.components.ComponentClient.remove_constant_id","text":"remove_constant_id ( custom_id ) Remove a constant \"custom_id\" callback. PARAMETER DESCRIPTION custom_id The custom_id to remove the callback for. TYPE: str RETURNS DESCRIPTION Self The component client to allow chaining. RAISES DESCRIPTION KeyError If the custom_id is not registered.","title":"remove_constant_id()"},{"location":"reference/#yuyo.components.ComponentClient.remove_executor","text":"remove_executor ( message ) Remove the component executor for a message. PARAMETER DESCRIPTION message The message to remove the executor for. TYPE: hikari . SnowflakeishOr [ hikari . Message ] RETURNS DESCRIPTION Self The component client to allow chaining.","title":"remove_executor()"},{"location":"reference/#yuyo.components.ComponentClient.set_constant_id","text":"set_constant_id ( custom_id , callback , / , * , prefix_match = False ) Add a constant \"custom_id\" callback. These are callbacks which'll always be called for a specific custom_id while taking priority over executors. PARAMETER DESCRIPTION custom_id The custom_id to register the callback for. TYPE: str callback The callback to register. This should take a single argument of type yuyo.components.ComponentContext , be asynchronous and return None . TYPE: CallbackSig prefix_match Whether the custom_id should be treated as a prefix match. This allows for further state to be held in the custom id after the prefix and is lower priority than normal custom id match. TYPE: bool DEFAULT: False RETURNS DESCRIPTION Self The component client to allow chaining. RAISES DESCRIPTION ValueError If the custom_id is already registered.","title":"set_constant_id()"},{"location":"reference/#yuyo.components.ComponentClient.set_executor","text":"set_executor ( message , executor ) Set the component executor for a message. PARAMETER DESCRIPTION message The message to set the executor for. TYPE: hikari . SnowflakeishOr [ hikari . Message ] executor The executor to set. This will be called for every component interaction for the message unless the component's custom_id is registered as a constant id callback. TYPE: AbstractComponentExecutor RETURNS DESCRIPTION Self The component client to allow chaining.","title":"set_executor()"},{"location":"reference/#yuyo.components.ComponentClient.with_constant_id","text":"with_constant_id ( custom_id , / , * , prefix_match = False ) Add a constant \"custom_id\" callback through a decorator call. These are callbacks which'll always be called for a specific custom_id while taking priority over executors. PARAMETER DESCRIPTION custom_id The custom_id to register the callback for. TYPE: str prefix_match Whether the custom_id should be treated as a prefix match. This allows for further state to be held in the custom id after the prefix and is lower priority than normal custom id match. TYPE: bool DEFAULT: False RETURNS DESCRIPTION Callable [[ CallbackSigT ], CallbackSigT ] A decorator to register the callback. RAISES DESCRIPTION KeyError If the custom_id is already registered.","title":"with_constant_id()"},{"location":"reference/#yuyo.ComponentContext","text":"The general context passed around for a component trigger.","title":"ComponentContext"},{"location":"reference/#yuyo.components.ComponentContext.expires_at","text":"expires_at : datetime . datetime When this application command context expires. After this time is reached, the message/response methods on this context will always raise hikari.errors.NotFoundError .","title":"expires_at"},{"location":"reference/#yuyo.components.ComponentContext.has_been_deferred","text":"has_been_deferred : bool Whether this context's initial response has been deferred. This will be true if yuyo.components.ComponentContext.defer has been called.","title":"has_been_deferred"},{"location":"reference/#yuyo.components.ComponentContext.has_responded","text":"has_responded : bool Whether an initial response has been made to this context yet. It's worth noting that a context must be either responded to or deferred within 3 seconds from it being received otherwise it'll be marked as failed. This will be true if either yuyo.components.ComponentContext.respond , yuyo.components.ComponentContext.create_initial_response or yuyo.components.ComponentContext.edit_initial_response (after a deferral) has been called.","title":"has_responded"},{"location":"reference/#yuyo.components.ComponentContext.interaction","text":"interaction : hikari . ComponentInteraction Object of the interaction this context is for.","title":"interaction"},{"location":"reference/#yuyo.components.ComponentContext.create_followup","text":"create_followup ( content = hikari . UNDEFINED , * , delete_after = None , ephemeral = False , attachment = hikari . UNDEFINED , attachments = hikari . UNDEFINED , component = hikari . UNDEFINED , components = hikari . UNDEFINED , embed = hikari . UNDEFINED , embeds = hikari . UNDEFINED , mentions_everyone = hikari . UNDEFINED , user_mentions = hikari . UNDEFINED , role_mentions = hikari . UNDEFINED , tts = hikari . UNDEFINED , flags = hikari . UNDEFINED ) Create a followup response for this context. Warning Calling this on a context which hasn't had an initial response yet will lead to a hikari.errors.NotFoundError being raised. PARAMETER DESCRIPTION content If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED delete_after If provided, the seconds after which the response message should be deleted. Slash command responses can only be deleted within 15 minutes of the command being received. TYPE: typing . Union [ datetime . timedelta , float , int , None] DEFAULT: None ephemeral Whether the deferred response should be ephemeral. Passing True here is a shorthand for including 1 << 64 in the passed flags. TYPE: bool DEFAULT: False attachment If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL. TYPE: hikari . UndefinedOr [ hikari . Resourceish ] DEFAULT: hikari.UNDEFINED attachments If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs. TYPE: hikari . UndefinedOr [ collections . Sequence [ hikari . Resourceish ]] DEFAULT: hikari.UNDEFINED component If provided, builder object of the component to include in this message. TYPE: hikari . UndefinedOr [ hikari . api . ComponentBuilder ] DEFAULT: hikari.UNDEFINED components If provided, a sequence of the component builder objects to include in this message. TYPE: hikari . UndefinedOr [ collections . Sequence [ hikari . api . ComponentBuilder ]] DEFAULT: hikari.UNDEFINED embed If provided, the message embed. TYPE: hikari . UndefinedOr [ hikari . Embed ] DEFAULT: hikari.UNDEFINED embeds If provided, the message embeds. TYPE: hikari . UndefinedOr [ collections . Sequence [ hikari . Embed ]] DEFAULT: hikari.UNDEFINED mentions_everyone If provided, whether the message should parse @everyone/@here mentions. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED user_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialUser ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED role_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialRole ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED tts If provided, whether the message will be sent as a TTS message. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED flags The flags to set for this response. As of writing this can only flag which can be provided is EPHEMERAL, other flags are just ignored. TYPE: typing . Union [ hikari . UndefinedType , int , hikari . MessageFlag ] DEFAULT: hikari.UNDEFINED RETURNS DESCRIPTION hikari . Message The created message object. RAISES DESCRIPTION hikari . NotFoundError If the current interaction is not found or it hasn't had an initial response yet. hikari . BadRequestError This can be raised if the file is too large; if the embed exceeds the defined limits; if the message content is specified only and empty or greater than 2000 characters; if neither content, file or embeds are specified. If any invalid snowflake IDs are passed; a snowflake may be invalid due to it being outside of the range of a 64 bit integer. ValueError If more than 100 unique objects/entities are passed for role_mentions or `user_mentions. If the interaction will have expired before delete_after is reached. If both attachment and attachments are passed or both component and components are passed or both embed and embeds are passed.","title":"create_followup()"},{"location":"reference/#yuyo.components.ComponentContext.create_initial_response","text":"create_initial_response ( response_type , / , content = hikari . UNDEFINED , * , delete_after = None , ephemeral = False , attachment = hikari . UNDEFINED , attachments = hikari . UNDEFINED , component = hikari . UNDEFINED , components = hikari . UNDEFINED , embed = hikari . UNDEFINED , embeds = hikari . UNDEFINED , mentions_everyone = hikari . UNDEFINED , user_mentions = hikari . UNDEFINED , role_mentions = hikari . UNDEFINED , flags = hikari . UNDEFINED , tts = hikari . UNDEFINED ) Create the initial response for this context. Warning Calling this on a context which already has an initial response will result in this raising a hikari.errors.NotFoundError . This includes if the REST interaction server has already responded to the request and deferrals. PARAMETER DESCRIPTION response_type The type of message response to give. TYPE: hikari . MessageResponseTypesT content The content to edit the last response with. If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED delete_after If provided, the seconds after which the response message should be deleted. Slash command responses can only be deleted within 15 minutes of the command being received. TYPE: typing . Union [ datetime . timedelta , float , int , None] DEFAULT: None ephemeral Whether the deferred response should be ephemeral. Passing True here is a shorthand for including 1 << 64 in the passed flags. TYPE: bool DEFAULT: False content If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED attachment If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL. TYPE: hikari . UndefinedOr [ hikari . Resourceish ] DEFAULT: hikari.UNDEFINED attachments If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs. TYPE: hikari . UndefinedOr [ collections . Sequence [ hikari . Resourceish ]] DEFAULT: hikari.UNDEFINED component If provided, builder object of the component to include in this message. TYPE: hikari . UndefinedOr [ hikari . api . ComponentBuilder ] DEFAULT: hikari.UNDEFINED components If provided, a sequence of the component builder objects to include in this message. TYPE: hikari . UndefinedOr [ collections . Sequence [ hikari . api . ComponentBuilder ]] DEFAULT: hikari.UNDEFINED embed If provided, the message embed. TYPE: hikari . UndefinedOr [ hikari . Embed ] DEFAULT: hikari.UNDEFINED embeds If provided, the message embeds. TYPE: hikari . UndefinedOr [ collections . Sequence [ hikari . Embed ]] DEFAULT: hikari.UNDEFINED flags If provided, the message flags this response should have. As of writing the only message flag which can be set here is hikari.messages.MessageFlag.EPHEMERAL . TYPE: typing . Union [ int , hikari . MessageFlag , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED tts If provided, whether the message will be read out by a screen reader using Discord's TTS (text-to-speech) system. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED mentions_everyone If provided, whether the message should parse @everyone/@here mentions. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED user_mentions If provided, and True , all user mentions will be detected. If provided, and False , all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialUser ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED role_mentions If provided, and True , all role mentions will be detected. If provided, and False , all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of [hikari.snowflakes.Snowflake], or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialRole ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED RAISES DESCRIPTION ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions . If the interaction will have expired before delete_after is reached. If both attachment and attachments are passed or both component and components are passed or both embed and embeds are passed. hikari . BadRequestError This may be raised in several discrete situations, such as messages being empty with no embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; invalid image URLs in embeds. hikari . UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari . NotFoundError If the interaction is not found or if the interaction's initial response has already been created. hikari . RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request. hikari . RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari . InternalServerError If an internal error occurs on Discord while handling the request.","title":"create_initial_response()"},{"location":"reference/#yuyo.components.ComponentContext.defer","text":"defer ( defer_type , / , * , ephemeral = False , flags = hikari . UNDEFINED ) Defer the initial response for this context. Note The ephemeral state of the first response is decided by whether the deferral is ephemeral. PARAMETER DESCRIPTION defer_type The type of deferral this should be. This may any of the following * ResponseType.DEFERRED_MESSAGE_CREATE to indicate that the following up call to yuyo.components.ComponentContext.edit_initial_response or yuyo.components.ComponentContext.respond should create a new message. * ResponseType.DEFERRED_MESSAGE_UPDATE to indicate that the following call to the aforementioned methods should update the existing message. TYPE: hikari . DeferredResponseTypesT ephemeral Whether the deferred response should be ephemeral. Passing True here is a shorthand for including 1 << 64 in the passed flags. TYPE: bool DEFAULT: False flags The flags to use for the initial response. TYPE: typing . Union [ hikari . UndefinedType , int , hikari . MessageFlag ] DEFAULT: hikari.UNDEFINED","title":"defer()"},{"location":"reference/#yuyo.components.ComponentContext.delete_initial_response","text":"delete_initial_response () Delete the initial response after invoking this context. RAISES DESCRIPTION LookupError , hikari . NotFoundError The last context has no initial response.","title":"delete_initial_response()"},{"location":"reference/#yuyo.components.ComponentContext.delete_last_response","text":"delete_last_response () Delete the last response after invoking this context. RAISES DESCRIPTION LookupError , hikari . NotFoundError The last context has no responses.","title":"delete_last_response()"},{"location":"reference/#yuyo.components.ComponentContext.edit_initial_response","text":"edit_initial_response ( content = hikari . UNDEFINED , * , delete_after = None , attachment = hikari . UNDEFINED , attachments = hikari . UNDEFINED , component = hikari . UNDEFINED , components = hikari . UNDEFINED , embed = hikari . UNDEFINED , embeds = hikari . UNDEFINED , mentions_everyone = hikari . UNDEFINED , user_mentions = hikari . UNDEFINED , role_mentions = hikari . UNDEFINED ) Edit the initial response for this context. PARAMETER DESCRIPTION content The content to edit the initial response with. If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED delete_after If provided, the seconds after which the response message should be deleted. Slash command responses can only be deleted within 15 minutes of the command being received. TYPE: typing . Union [ datetime . timedelta , float , int , None] DEFAULT: None attachment A singular attachment to edit the initial response with. TYPE: hikari . UndefinedNoneOr [ hikari . Resourceish ] DEFAULT: hikari.UNDEFINED attachments A sequence of attachments to edit the initial response with. TYPE: hikari . UndefinedNoneOr [ collections . Sequence [ hikari . Resourceish ]] DEFAULT: hikari.UNDEFINED component If provided, builder object of the component to set for this message. This component will replace any previously set components and passing None will remove all components. TYPE: hikari . UndefinedNoneOr [ hikari . api . ComponentBuilder ] DEFAULT: hikari.UNDEFINED components If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing None or an empty sequence will remove all components. TYPE: hikari . UndefinedNoneOr [ collections . Sequence [ hikari . api . ComponentBuilder ]] DEFAULT: hikari.UNDEFINED embed An embed to replace the initial response with. TYPE: hikari . UndefinedNoneOr [ hikari . Embed ] DEFAULT: hikari.UNDEFINED embeds A sequence of embeds to replace the initial response with. TYPE: hikari . UndefinedNoneOr [ collections . Sequence [ hikari . Embed ]] DEFAULT: hikari.UNDEFINED mentions_everyone If provided, whether the message should parse @everyone/@here mentions. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED user_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialUser ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED role_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialRole ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED RETURNS DESCRIPTION hikari . Message The message that has been edited. RAISES DESCRIPTION ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions . If delete_after would be more than 15 minutes after the slash command was called. If both attachment and attachments are passed or both component and components are passed or both embed and embeds are passed. hikari . BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components. hikari . UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari . ForbiddenError If you are missing the SEND_MESSAGES in the channel or the person you are trying to message has the DM's disabled. hikari . NotFoundError If the channel is not found. hikari . RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request. hikari . RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari . InternalServerError If an internal error occurs on Discord while handling the request.","title":"edit_initial_response()"},{"location":"reference/#yuyo.components.ComponentContext.edit_last_response","text":"edit_last_response ( content = hikari . UNDEFINED , * , delete_after = None , attachment = hikari . UNDEFINED , attachments = hikari . UNDEFINED , component = hikari . UNDEFINED , components = hikari . UNDEFINED , embed = hikari . UNDEFINED , embeds = hikari . UNDEFINED , mentions_everyone = hikari . UNDEFINED , user_mentions = hikari . UNDEFINED , role_mentions = hikari . UNDEFINED ) Edit the last response for this context. PARAMETER DESCRIPTION content The content to edit the last response with. If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED delete_after If provided, the seconds after which the response message should be deleted. Slash command responses can only be deleted within 15 minutes of the command being received. TYPE: typing . Union [ datetime . timedelta , float , int , None] DEFAULT: None attachment A singular attachment to edit the last response with. TYPE: hikari . UndefinedNoneOr [ hikari . Resourceish ] DEFAULT: hikari.UNDEFINED attachments A sequence of attachments to edit the last response with. TYPE: hikari . UndefinedNoneOr [ collections . Sequence [ hikari . Resourceish ]] DEFAULT: hikari.UNDEFINED component If provided, builder object of the component to set for this message. This component will replace any previously set components and passing None will remove all components. TYPE: hikari . UndefinedNoneOr [ hikari . api . ComponentBuilder ] DEFAULT: hikari.UNDEFINED components If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing None or an empty sequence will remove all components. TYPE: hikari . UndefinedNoneOr [ collections . Sequence [ hikari . api . ComponentBuilder ]] DEFAULT: hikari.UNDEFINED embed An embed to replace the last response with. TYPE: hikari . UndefinedNoneOr [ hikari . Embed ] DEFAULT: hikari.UNDEFINED embeds A sequence of embeds to replace the last response with. TYPE: hikari . UndefinedNoneOr [ collections . Sequence [ hikari . Embed ]] DEFAULT: hikari.UNDEFINED mentions_everyone If provided, whether the message should parse @everyone/@here mentions. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED user_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialUser ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED role_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialRole ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED RETURNS DESCRIPTION hikari . Message The message that has been edited. RAISES DESCRIPTION ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions . If delete_after would be more than 15 minutes after the slash command was called. If both attachment and attachments are passed or both component and components are passed or both embed and embeds are passed. hikari . BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components. hikari . UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari . ForbiddenError If you are missing the SEND_MESSAGES in the channel or the person you are trying to message has the DM's disabled. hikari . NotFoundError If the channel is not found. hikari . RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request. hikari . RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari . InternalServerError If an internal error occurs on Discord while handling the request.","title":"edit_last_response()"},{"location":"reference/#yuyo.components.ComponentContext.fetch_initial_response","text":"fetch_initial_response () Fetch the initial response for this context. RETURNS DESCRIPTION hikari . messages . Message The initial response's message object. RAISES DESCRIPTION LookupError , hikari . NotFoundError The response was not found.","title":"fetch_initial_response()"},{"location":"reference/#yuyo.components.ComponentContext.fetch_last_response","text":"fetch_last_response () Fetch the last response for this context. RETURNS DESCRIPTION hikari . messages . Message The most response response's message object. RAISES DESCRIPTION LookupError , hikari . NotFoundError The response was not found.","title":"fetch_last_response()"},{"location":"reference/#yuyo.components.ComponentContext.respond","text":"respond ( content = hikari . UNDEFINED , * , ensure_result = False , delete_after = None , attachment = hikari . UNDEFINED , attachments = hikari . UNDEFINED , component = hikari . UNDEFINED , components = hikari . UNDEFINED , embed = hikari . UNDEFINED , embeds = hikari . UNDEFINED , mentions_everyone = hikari . UNDEFINED , user_mentions = hikari . UNDEFINED , role_mentions = hikari . UNDEFINED ) Respond to this context. PARAMETER DESCRIPTION content The content to respond with. If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED ensure_result Ensure that this call will always return a message object. If True then this will always return hikari.messages.Message , otherwise this will return hikari.Message | None . It's worth noting that, under certain scenarios within the slash command flow, this may lead to an extre request being made. TYPE: bool DEFAULT: False delete_after If provided, the seconds after which the response message should be deleted. Slash command responses can only be deleted within 15 minutes of the command being received. TYPE: typing . Union [ datetime . timedelta , float , int , None] DEFAULT: None attachment If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL. TYPE: hikari . UndefinedOr [ hikari . Resourceish ] DEFAULT: hikari.UNDEFINED attachments If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs. TYPE: hikari . UndefinedOr [ collections . Sequence [ hikari . Resourceish ]] DEFAULT: hikari.UNDEFINED component If provided, builder object of the component to include in this response. TYPE: hikari . UndefinedOr [ hikari . api . ComponentBuilder ] DEFAULT: hikari.UNDEFINED components If provided, a sequence of the component builder objects to include in this response. TYPE: hikari . UndefinedOr [ collections . Sequence [ hikari . api . ComponentBuilder ]] DEFAULT: hikari.UNDEFINED embed An embed to respond with. TYPE: hikari . UndefinedOr [ hikari . Embed ] DEFAULT: hikari.UNDEFINED embeds A sequence of embeds to respond with. TYPE: hikari . UndefinedOr [ collections . Sequence [ hikari . Embed ]] DEFAULT: hikari.UNDEFINED mentions_everyone If provided, whether the message should parse @everyone/@here mentions. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED user_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialUser ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED role_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialRole ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED RETURNS DESCRIPTION hikari . Message | None The message that has been created if it was immedieatly available or ensure_result was set to True , else None . RAISES DESCRIPTION ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions . If delete_after would be more than 15 minutes after the slash command was called. If both attachment and attachments are passed or both component and components are passed or both embed and embeds are passed. hikari . BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components. hikari . UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari . ForbiddenError If you are missing the SEND_MESSAGES in the channel or the person you are trying to message has the DM's disabled. hikari . NotFoundError If the channel is not found. hikari . RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request. hikari . RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari . InternalServerError If an internal error occurs on Discord while handling the request.","title":"respond()"},{"location":"reference/#yuyo.components.ComponentContext.set_ephemeral_default","text":"set_ephemeral_default ( state ) Set the ephemeral default state for this context. PARAMETER DESCRIPTION state The new ephemeral default state. If this is True then all calls to the response creating methods on this context will default to being ephemeral. TYPE: bool","title":"set_ephemeral_default()"},{"location":"reference/#yuyo.ComponentExecutor","text":"Bases: AbstractComponentExecutor Basic implementation of a class used for handling the execution of a message component.","title":"ComponentExecutor"},{"location":"reference/#yuyo.components.ComponentExecutor.__init__","text":"__init__ ( * , ephemeral_default = False , load_from_attributes = True , timeout = datetime . timedelta ( seconds = 30 )) Initialise a component executor. PARAMETER DESCRIPTION ephemeral_default Whether this executor's responses should default to being ephemeral. TYPE: bool DEFAULT: False timeout How long this component should last until its marked as timed out. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30)","title":"__init__()"},{"location":"reference/#yuyo.ComponentPaginator","text":"Bases: ActionRowExecutor Standard implementation of an action row executor used for pagination. This is a convenience class that allows you to easily implement a paginator.","title":"ComponentPaginator"},{"location":"reference/#yuyo.components.ComponentPaginator.__init__","text":"__init__ ( iterator , * , authors , ephemeral_default = False , triggers = ( pagination . LEFT_TRIANGLE , pagination . STOP_SQUARE , pagination . RIGHT_TRIANGLE ), load_from_attributes = False , timeout = datetime . timedelta ( seconds = 30 )) Initialise a component paginator. PARAMETER DESCRIPTION iterator The iterator to paginate. This should be an iterator of tuples of (hikari.UndefinedOr[str], hikari.UndefinedOr[hikari.Embed]) . TYPE: collections . Iterator [ yuyo . pagination . EntryT ] | collections . AsyncIterator [ yuyo . pagination . EntryT ] authors The authors of the entries. If None is passed here then the paginator will be public (meaning that anybody can use it). TYPE: typing . Optional [ collections . Iterable [ hikari . SnowflakeishOr [ hikari . User ]]] ephemeral_default Whether or not the responses made on contexts spawned from this paginator should default to ephemeral (meaning only the author can see them) unless flags is specified on the response method. TYPE: bool DEFAULT: False triggers Collection of the unicode emojis that should trigger this paginator. As of current the only usable emojis are yuyo.pagination.LEFT_TRIANGLE , yuyo.pagination.RIGHT_TRIANGLE , yuyo.pagination.STOP_SQUARE , yuyo.pagination.LEFT_DOUBLE_TRIANGLE and yuyo.pagination.LEFT_TRIANGLE . TYPE: collections . Collection [ str ] DEFAULT: (pagination.LEFT_TRIANGLE, pagination.STOP_SQUARE, pagination.RIGHT_TRIANGLE) timeout The amount of time to wait after the component's last execution or creation until it times out. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30)","title":"__init__()"},{"location":"reference/#yuyo.components.ComponentPaginator.builder","text":"builder () Get a sequence of the component builders for this paginator. RETURNS DESCRIPTION collections . abc . Sequence [ hikari . api . ComponentBuilder ] The component builders for this paginator.","title":"builder()"},{"location":"reference/#yuyo.components.ComponentPaginator.get_next_entry","text":"get_next_entry () Get the next entry in this paginator. This is generally helpful for making the message which the paginator will be based off and will still internally store the entry and increment the position of the paginator. Examples: response_paginator = yuyo . ComponentPaginator ( pages , authors = ( ctx . author . id ,) ) first_response = await response_paginator . get_next_entry () assert first_response content , embed = first_response message = await ctx . respond ( content = content , embed = embed , component = response_paginator , ensure_result = True ) component_client . set_executor ( message , response_paginator ) RETURNS DESCRIPTION yuyo . pagination . EntryT | None The next entry in this paginator, or None if there are no more entries.","title":"get_next_entry()"},{"location":"reference/#yuyo.DiscordBotListService","text":"https://discordbotlist.com status update service.","title":"DiscordBotListService"},{"location":"reference/#yuyo.list_status.DiscordBotListService.__init__","text":"__init__ ( token ) Initialise a discordbotlist.com service. PARAMETER DESCRIPTION token Authorization token used to update the bot's status. TYPE: str","title":"__init__()"},{"location":"reference/#yuyo.ErrorManager","text":"A context manager provided to allow for more concise error handling with yuyo.backoff.Backoff . Examples: The following is an example of using yuyo.backoff.ErrorManager alongside yuyo.backoff.Backoff in-order to handle the exceptions which may be raised while trying to reply to a message. retry = Backoff () # Rules can either be passed to `ErrorManager`'s initiate as variable arguments # or one at a time to `ErrorManager.with_rule` through possibly chained-calls. error_handler = ( # For the 1st rule we catch two errors which would indicate the bot # no-longer has access to the target channel and break out of the # retry loop using `Backoff.retry`. ErrorManager ((( errors . NotFoundError , errors . ForbiddenError ), lambda _ : retry . finish ())) # For the 2nd rule we catch rate limited errors and set their # `retry` value as the next backoff time before suppressing the # error to allow this to retry the request. . with_rule (( errors . RateLimitedError ,), lambda exc : retry . set_next_backoff ( exc . retry_after )) # For the 3rd rule we suppress the internal server error to allow # backoff to reach the next retry and exponentially backoff as we # don't have any specific retry time for this error. . with_rule (( errors . InternalServerError ,), lambda _ : False ) ) async for _ in retry : # We entre this context manager each iteration to catch errors before # they cause us to break out of the `Backoff` loop. with error_handler : await message . respond ( \"General Kenobi\" ) # We need to break out of `retry` if this request succeeds. break","title":"ErrorManager"},{"location":"reference/#yuyo.backoff.ErrorManager.__init__","text":"__init__ ( * rules ) Initialise an error manager instance. PARAMETER DESCRIPTION *rules Rules to initiate this error context manager with. These are each a 2-length tuple where the tuple[0] is an iterable of types of the exceptions this rule should apply to and tuple[1] is the rule's callback function. The callback function will be called with the raised exception when it matches one of the passed exceptions for the relevant rule and may raise, return True to indicate that the current error should be raised outside of the context manager or False / None to suppress the current error. TYPE: tuple [ collections . Iterable [ type [ BaseException ]], collections . Callable [[ typing . Any ], typing . Optional [ bool ]]] DEFAULT: ()","title":"__init__()"},{"location":"reference/#yuyo.backoff.ErrorManager.clear_rules","text":"clear_rules () Clear the rules registered with this handler.","title":"clear_rules()"},{"location":"reference/#yuyo.backoff.ErrorManager.with_rule","text":"with_rule ( exceptions , result ) Add a rule to this exception context manager. PARAMETER DESCRIPTION exceptions An iterable of types of the exceptions this rule should apply to. TYPE: collections . Iterable [ type [ BaseException ]] result The function called with the raised exception when it matches one of the passed exceptions . This may raise, return True to indicate that the current error should be raised outside of the context manager or False / None to suppress the current error. TYPE: collections . Callable [[ typing . Any ], typing . Optional [ bool ]] RETURNS DESCRIPTION Self This returns the handler a rule was being added to in-order to allow for chained calls.","title":"with_rule()"},{"location":"reference/#yuyo.FinishedChunkingEvent","text":"Bases: hikari . Event Event that's dispatched when the startup chunking has finished for the bot. This indicates that any cache member and presences resources should be complete globally. This will only be fired once after bot startups.","title":"FinishedChunkingEvent"},{"location":"reference/#yuyo.chunk_tracker.FinishedChunkingEvent.__init__","text":"__init__ ( app ) Initialise a chunking finished event. This should never be initialised directly.","title":"__init__()"},{"location":"reference/#yuyo.MultiComponentExecutor","text":"Bases: AbstractComponentExecutor Multi-component implementation of a component executor. This implementation allows for multiple components to be executed as a single view.","title":"MultiComponentExecutor"},{"location":"reference/#yuyo.components.MultiComponentExecutor.builders","text":"builders : collections . Sequence [ hikari . api . ComponentBuilder ] Sequence of the component builders within this executor.","title":"builders"},{"location":"reference/#yuyo.components.MultiComponentExecutor.executors","text":"executors : collections . Sequence [ AbstractComponentExecutor ] Sequence of the child executors within this multi-executor.","title":"executors"},{"location":"reference/#yuyo.components.MultiComponentExecutor.__init__","text":"__init__ ( * , load_from_attributes = False , timeout = datetime . timedelta ( seconds = 30 )) Initialise a multi-component executor. PARAMETER DESCRIPTION timeout The amount of time to wait after the component's last execution or creation until it times out. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30)","title":"__init__()"},{"location":"reference/#yuyo.components.MultiComponentExecutor.add_action_row","text":"add_action_row () Create a builder class to add an action row to this executor. For the most part this follows the same implementation as yuyo.components.ActionRowExecutor except with the added detail that yuyo.components.ChildActionRowExecutor.add_to_parent must be called to add the action row to the parent executor. RETURNS DESCRIPTION ChildActionRowExecutor [ Self ] A builder class to add an action row to this executor. yuyo.components.ChildActionRowExecutor.add_to_parent should be called to finalise the action row and will return the parent executor for chained calls.","title":"add_action_row()"},{"location":"reference/#yuyo.components.MultiComponentExecutor.add_builder","text":"add_builder ( builder ) Add a non-executable component builder to this executor. This is useful for adding components that are not meant to be executed, such as a a row of link buttons. PARAMETER DESCRIPTION builder The component builder to add. TYPE: hikari . api . ComponentBuilder RETURNS DESCRIPTION Self","title":"add_builder()"},{"location":"reference/#yuyo.components.MultiComponentExecutor.add_executor","text":"add_executor ( executor ) Add a component executor to this multi-component executor. This method is internally used by the add_{component} methods. PARAMETER DESCRIPTION executor The component executor to add. TYPE: AbstractComponentExecutor RETURNS DESCRIPTION Self The multi-component executor instance to enable chained calls.","title":"add_executor()"},{"location":"reference/#yuyo.ReactionClient","text":"A class which handles the events for multiple registered reaction handlers. Note For a quicker way to initialise this client from a bot, see yuyo.reactions.ReactionClient.from_gateway_bot .","title":"ReactionClient"},{"location":"reference/#yuyo.reactions.ReactionClient.alluka","text":"alluka : alluka_ . abc . Client The Alluka client being used for callback dependency injection.","title":"alluka"},{"location":"reference/#yuyo.reactions.ReactionClient.is_closed","text":"is_closed : bool Whether this client is closed.","title":"is_closed"},{"location":"reference/#yuyo.reactions.ReactionClient.__init__","text":"__init__ ( * , rest , event_manager , alluka = None , event_managed = True ) Initialise a reaction client. PARAMETER DESCRIPTION rest The REST client to register this reaction client with. TYPE: hikari . api . RESTClient event_manager The event manager client to register this reaction client with. TYPE: hikari . api . EventManager alluka The alluka client to use for callback DI. TYPE: typing . Optional [ alluka_ . abc . Client ] DEFAULT: None event_managed Whether the reaction client should be automatically opened and closed based on the lifetime events dispatched by event_managed . TYPE: bool DEFAULT: True","title":"__init__()"},{"location":"reference/#yuyo.reactions.ReactionClient.add_handler","text":"add_handler ( message , / , paginator ) Add a reaction handler to this reaction client. Note This does not call yuyo.reactions.AbstractReactionHandler.open . PARAMETER DESCRIPTION message The message ID to add register a reaction handler with. TYPE: hikari . SnowflakeishOr [ hikari . Message ] paginator The object of the opened paginator to register in this reaction client. TYPE: AbstractReactionHandler","title":"add_handler()"},{"location":"reference/#yuyo.reactions.ReactionClient.close","text":"close () Close this client by unregistering any registered tasks and event listeners.","title":"close()"},{"location":"reference/#yuyo.reactions.ReactionClient.from_gateway_bot","text":"from_gateway_bot ( bot , / , * , event_managed = True ) Build a ReactionClient from a gateway bot. PARAMETER DESCRIPTION bot The bot to build a reaction client for. TYPE: hikari . GatewayBotAware event_managed Whether the reaction client should be automatically opened and closed based on the lifetime events dispatched by bot . TYPE: bool DEFAULT: True RETURNS DESCRIPTION ReactionClient The reaction client for the bot.","title":"from_gateway_bot()"},{"location":"reference/#yuyo.reactions.ReactionClient.get_handler","text":"get_handler ( message ) Get a reference to a paginator registered in this reaction client. Note This does not call yuyo.reactions.AbstractReactionHandler.close . PARAMETER DESCRIPTION message The message ID to remove a paginator for. TYPE: hikari . SnowflakeishOr [ hikari . Message ] RETURNS DESCRIPTION AbstractReactionHandler | None The object of the registered paginator if found else None .","title":"get_handler()"},{"location":"reference/#yuyo.reactions.ReactionClient.open","text":"open () Start this client by registering the required tasks and event listeners for it to function.","title":"open()"},{"location":"reference/#yuyo.reactions.ReactionClient.remove_handler","text":"remove_handler ( message ) Remove a paginator from this reaction client. Note This does not call yuyo.reactions.AbstractReactionHandler.close . PARAMETER DESCRIPTION message The message ID to remove a paginator for. TYPE: hikari . SnowflakeishOr [ hikari . Message ] RETURNS DESCRIPTION AbstractReactionHandler | None The object of the registered paginator if found else None .","title":"remove_handler()"},{"location":"reference/#yuyo.ReactionHandler","text":"Bases: AbstractReactionHandler Standard basic implementation of a reaction handler.","title":"ReactionHandler"},{"location":"reference/#yuyo.reactions.ReactionHandler.authors","text":"authors : collections . Set [ hikari . Snowflake ] Set of the authors/owner of a enabled handler. Note If this is empty then the handler is considered public and any user will be able to trigger it.","title":"authors"},{"location":"reference/#yuyo.reactions.ReactionHandler.timeout","text":"timeout : datetime . timedelta How long this handler will wait since the last event before timing out.","title":"timeout"},{"location":"reference/#yuyo.reactions.ReactionHandler.__init__","text":"__init__ ( * , authors = (), timeout = datetime . timedelta ( seconds = 30 ), load_from_attributes = True ) Initialise a reaction handler. PARAMETER DESCRIPTION authors An iterable of IDs of the users who can call this paginator. If left empty then all users will be able to call this paginator. TYPE: collections . Iterable [ hikari . SnowflakeishOr [ hikari . User ]] DEFAULT: () timeout How long it should take for this paginator to timeout. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30)","title":"__init__()"},{"location":"reference/#yuyo.reactions.ReactionHandler.add_callback","text":"add_callback ( emoji_identifier , callback ) Add a callback to this reaction handler. PARAMETER DESCRIPTION emoji_identifier Identifier of the emoji this callback is for. This should be a snowfake if this is for a custom emoji or a string if this is for a unicode emoji. TYPE: typing . Union [ str , hikari . SnowflakeishOr [ hikari . CustomEmoji ]] callback The callback to add. This should be a function that accepts a single parameter, which is the event that triggered this reaction. TYPE: CallbackSig","title":"add_callback()"},{"location":"reference/#yuyo.reactions.ReactionHandler.remove_callback","text":"remove_callback ( emoji_identifier ) Remove a callback from this reaction handler. PARAMETER DESCRIPTION emoji_identifier Identifier of the emoji the callback to remove is for. This should be a snowfake if this is for a custom emoji or a string if this is for a unicode emoji. TYPE: typing . Union [ str , hikari . SnowflakeishOr [ hikari . CustomEmoji ]]","title":"remove_callback()"},{"location":"reference/#yuyo.reactions.ReactionHandler.with_callback","text":"with_callback ( emoji_identifier ) Add a callback to this reaction handler through a decorator call. PARAMETER DESCRIPTION emoji_identifier Identifier of the emoji this callback is for. This should be a snowfake if this is for a custom emoji or a string if this is for a unicode emoji. TYPE: typing . Union [ str , hikari . SnowflakeishOr [ hikari . CustomEmoji ]] RETURNS DESCRIPTION collections . abc . Callabke [[ CallbackSigT ], CallbackSigT ] A decorator to add a callback to this reaction handler.","title":"with_callback()"},{"location":"reference/#yuyo.ReactionPaginator","text":"Bases: ReactionHandler Standard implementation of a reaction handler for pagination.","title":"ReactionPaginator"},{"location":"reference/#yuyo.reactions.ReactionPaginator.__init__","text":"__init__ ( iterator , * , authors , triggers = ( pagination . LEFT_TRIANGLE , pagination . STOP_SQUARE , pagination . RIGHT_TRIANGLE ), timeout = datetime . timedelta ( seconds = 30 )) Initialise a reaction paginator. PARAMETER DESCRIPTION iterator Either an asynchronous or synchronous iterator of the entries this should paginate through. entry[0] represents the message's possible content and can either be str or hikari.undefined.UNDEFINED and entry[1] represents the message's possible embed and can either be hikari.embeds.Embed or hikari.undefined.UNDEFINED . TYPE: collections . Iterator [ yuyo . pagination . EntryT ] | collections . AsyncIterator [ yuyo . pagination . EntryT ] authors An iterable of IDs of the users who can call this paginator. If left empty then all users will be able to call this paginator. TYPE: collections . Iterable [ hikari . SnowflakeishOr [ hikari . User ]] timeout How long it should take for this paginator to timeout. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30)","title":"__init__()"},{"location":"reference/#yuyo.reactions.ReactionPaginator.add_author","text":"add_author ( user ) Add a author/owner to this handler. PARAMETER DESCRIPTION user The user to add as an owner for this handler. TYPE: hikari . SnowflakeishOr [ hikari . User ]","title":"add_author()"},{"location":"reference/#yuyo.reactions.ReactionPaginator.close","text":"close ( * , remove_reactions = False , max_retries = 5 , max_backoff = 2.0 ) Close this handler and deregister any previously registered message. PARAMETER DESCRIPTION remove_reactions Whether this should remove the reactions that were being used to paginate through this from the previously registered message. TYPE: bool DEFAULT: False","title":"close()"},{"location":"reference/#yuyo.reactions.ReactionPaginator.create_message","text":"create_message ( rest , channel_id , / , * , add_reactions = True , max_retries = 5 , max_backoff = 2.0 ) Start this handler and link it to a bot message. Note Calling this multiple times will replace the previously registered message. PARAMETER DESCRIPTION rest Rest client to use to make the response. TYPE: hikari . api . RESTClient channel_id ID of the channel to respond in. TYPE: hikari . SnowflakeishOr [ hikari . TextableChannel ] add_reactions Whether this should add the paginator's reactions to the message after responding. TYPE: bool DEFAULT: True max_retries How many times this should retry to respond if Hikari raises any ratelimit errors. TYPE: int DEFAULT: 5 max_backoff The maximum time this should backoff for before trying if Hikari raises any ratelimit errors. TYPE: float DEFAULT: 2.0 RETURNS DESCRIPTION hikari . messages . Message Object of the message this handler now targets. If message was not supplied then this will be the object of a newly created message, otherwise this will be what was supplied as message . RAISES DESCRIPTION ValueError If the provided iterator didn't yield any content for the first message.","title":"create_message()"},{"location":"reference/#yuyo.reactions.ReactionPaginator.remove_author","text":"remove_author ( user ) Remove a author/owner from this handler. Note If the provided user isn't already a registered owner of this paginator then this should pass silently without raising. PARAMETER DESCRIPTION user The user to remove from this handler's owners. TYPE: hikari . SnowflakeishOr [ hikari . User ]","title":"remove_author()"},{"location":"reference/#yuyo.ServiceManager","text":"Bases: AbstractManager Standard service manager.","title":"ServiceManager"},{"location":"reference/#yuyo.list_status.ServiceManager.is_alive","text":"is_alive : bool Wwhether this manager is active.","title":"is_alive"},{"location":"reference/#yuyo.list_status.ServiceManager.__init__","text":"__init__ ( rest , / , * , cache = None , event_manager = None , shards = None , event_managed = None , strategy = None , user_agent = None ) Initialise a service manager. PARAMETER DESCRIPTION rest The RESTAware Hikari client to bind this manager to. TYPE: hikari . api . RESTClient cache The cache aware Hikari client this manager should use. TYPE: typing . Optional [ hikari . api . Cache ] DEFAULT: None event_manager The event manager aware Hikari client this manager should use. TYPE: typing . Optional [ hikari . api . EventManager ] DEFAULT: None shards The shard aware Hikari client this manager should use. TYPE: typing . Optional [ traits . ShardAware ] DEFAULT: None event_managed Whether this client should be automatically opened and closed based on event_manager 's lifetime events. Defaults to True when event_manager is passed. TYPE: typing . Optional [ bool ] DEFAULT: None strategy The counter strategy this manager should expose to services. If this is left as None then the manager will try to pick a suitable standard strategy based on the provided Hikari clients. TYPE: typing . Optional [ AbstractCountStrategy ] DEFAULT: None user_agent Override the standard user agent used during requests to bot list services. TYPE: typing . Optional [ str ] DEFAULT: None RAISES DESCRIPTION ValueError If the manager failed to find a suitable standard strategy to use when strategy was left as None . If event_managed is passed as True when event_manager is None .","title":"__init__()"},{"location":"reference/#yuyo.list_status.ServiceManager.add_service","text":"add_service ( service , / , * , repeat = datetime . timedelta ( hours = 1 )) Add a service to this manager. PARAMETER DESCRIPTION service Asynchronous callback used to update this service. TYPE: ServiceSig repeat How often this service should be updated in seconds. TYPE: typing . Union [ datetime . timedelta , int , float ] DEFAULT: datetime.timedelta(hours=1) RETURNS DESCRIPTION Self Object of this service manager. RAISES DESCRIPTION ValueError If repeat is less than 1 second. RuntimeError If the client is already running.","title":"add_service()"},{"location":"reference/#yuyo.list_status.ServiceManager.close","text":"close () Close this manager.","title":"close()"},{"location":"reference/#yuyo.list_status.ServiceManager.from_gateway_bot","text":"from_gateway_bot ( bot , / , * , event_managed = True , strategy = None , user_agent = None ) Build a service manager from a gateway bot. PARAMETER DESCRIPTION bot The gateway bot to build a service manager from. TYPE: traits . GatewayBotAware event_managed Whether this client should be automatically opened and closed based on bot 's lifetime events. TYPE: bool DEFAULT: True strategy The counter strategy this manager should expose to services. If this is left as None then the manager will try to pick a suitable standard strategy based on the provided Hikari clients. TYPE: typing . Optional [ AbstractCountStrategy ] DEFAULT: None user_agent Override the standard user agent used during requests to bot list services. TYPE: typing . Optional [ str ] DEFAULT: None RETURNS DESCRIPTION ServiceManager The build service manager. RAISES DESCRIPTION ValueError If the manager failed to find a suitable standard strategy to use when strategy was left as None .","title":"from_gateway_bot()"},{"location":"reference/#yuyo.list_status.ServiceManager.open","text":"open () Start this manager. RAISES DESCRIPTION RuntimeError If this manager is already running.","title":"open()"},{"location":"reference/#yuyo.list_status.ServiceManager.remove_service","text":"remove_service ( service ) Remove the first found entry of the registered service. PARAMETER DESCRIPTION service Service callback to unregister. TYPE: ServiceSig RAISES DESCRIPTION RuntimeError If called while the manager is active. ValueError If the service callback isn't found.","title":"remove_service()"},{"location":"reference/#yuyo.list_status.ServiceManager.with_service","text":"with_service ( * , repeat = datetime . timedelta ( hours = 1 )) Add a service to this manager by decorating a function. PARAMETER DESCRIPTION repeat How often this service should be updated in seconds. TYPE: typing . Union [ datetime . timedelta , int , float ] DEFAULT: datetime.timedelta(hours=1) RETURNS DESCRIPTION collections . abc . Callable [[ ServiceSig ], ServiceSig ] Decorator callback used to add a service. RAISES DESCRIPTION ValueError If repeat is less than 1 second. RuntimeError If the client is already running.","title":"with_service()"},{"location":"reference/#yuyo.ShardFinishedChunkingEvent","text":"Bases: hikari . ShardEvent Event that's dispatched when the startup chunking has finished for a shard. This indicates that any cache member and presences resources should be complete for guilds covered by this shard. This will be fired after every shard identify which triggers chunking (including re-identifies).","title":"ShardFinishedChunkingEvent"},{"location":"reference/#yuyo.chunk_tracker.ShardFinishedChunkingEvent.incomplete_guild_ids","text":"incomplete_guild_ids : collections . Sequence [ hikari . Snowflake ] Sequence of the IDs of guilds some chunk responses were missed for.","title":"incomplete_guild_ids"},{"location":"reference/#yuyo.chunk_tracker.ShardFinishedChunkingEvent.missed_guild_ids","text":"missed_guild_ids : collections . Sequence [ hikari . Snowflake ] Sequence of the IDs of guilds no chunk responses were received for.","title":"missed_guild_ids"},{"location":"reference/#yuyo.chunk_tracker.ShardFinishedChunkingEvent.__init__","text":"__init__ ( app , shard , / , * , incomplete_guild_ids = (), missed_guild_ids = ()) Initialise a shard chunking finished event. This should never be initialised directly.","title":"__init__()"},{"location":"reference/#yuyo.TopGGService","text":"https://top.gg status update service.","title":"TopGGService"},{"location":"reference/#yuyo.list_status.TopGGService.__init__","text":"__init__ ( token ) Initialise a top.gg service. PARAMETER DESCRIPTION token Authorization token used to update the bot's status. TYPE: str","title":"__init__()"},{"location":"reference/#yuyo.WaitForExecutor","text":"Bases: AbstractComponentExecutor Component executor used to wait for a single component interaction. Examples: responses : dict [ str , str ] message = await ctx . respond ( \"hi, pick an option\" , components = [ ... ]) executor = yuyo . components . WaitFor ( authors = ( ctx . author . id ,), timeout = datetime . timedelta ( seconds = 30 )) component_client . set_executor ( message . id , executor ) try : result = await executor . wait_for () except asyncio . TimeoutError : await ctx . respond ( \"timed out\" ) else : await result . respond ( responses [ result . interaction . custom_id ])","title":"WaitForExecutor"},{"location":"reference/#yuyo.components.WaitForExecutor.__init__","text":"__init__ ( * , authors , ephemeral_default = False , timeout ) Initialise a wait for executor. PARAMETER DESCRIPTION authors The authors of the entries. If None is passed here then the paginator will be public (meaning that anybody can use it). TYPE: typing . Optional [ collections . Iterable [ hikari . SnowflakeishOr [ hikari . User ]]] ephemeral_default Whether or not the responses made on contexts spawned from this paginator should default to ephemeral (meaning only the author can see them) unless flags is specified on the response method. TYPE: bool DEFAULT: False timeout How long this should wait for a matching component interaction until it times-out. TYPE: datetime . timedelta","title":"__init__()"},{"location":"reference/#yuyo.components.WaitForExecutor.wait_for","text":"wait_for () Wait for the next matching interaction. RETURNS DESCRIPTION ComponentContext The next matching interaction. RAISES DESCRIPTION RuntimeError If the executor is already being waited for. asyncio . TimeoutError If the timeout is reached.","title":"wait_for()"},{"location":"reference/#yuyo.aenumerate","text":"aenumerate ( iterable ) Async equivalent of enumerate . PARAMETER DESCRIPTION iterable The async iterable to enumerate. TYPE: collections . AsyncIterable [ _T ] RETURNS DESCRIPTION collections . abc . AsyncIterator [ tuple [ int , _T ]] The enumerated async iterator.","title":"aenumerate()"},{"location":"reference/#yuyo.async_paginate_string","text":"async_paginate_string ( lines , * , char_limit = 2000 , line_limit = 25 , wrapper = None ) Lazily paginate an iterator of lines. PARAMETER DESCRIPTION lines The asynchronous iterator of lines to paginate. TYPE: collections . AsyncIterable [ str ] char_limit The limit for how many characters should be included per yielded page. TYPE: int DEFAULT: 2000 line_limit The limit for how many lines should be included per yielded page. TYPE: int DEFAULT: 25 wrapper A wrapper for each yielded page. This should leave \"{}\" in it to be replaced by the page's content. TYPE: typing . Optional [ str ] DEFAULT: None RETURNS DESCRIPTION typing . AsyncIterator [ tuple [ str , int ]] An async iterator of page tuples (string context to int zero-based index).","title":"async_paginate_string()"},{"location":"reference/#yuyo.paginate_string","text":"paginate_string ( lines , * , char_limit = 2000 , line_limit = 25 , wrapper = None ) Lazily paginate an iterator of lines. PARAMETER DESCRIPTION lines The iterator of lines to paginate. This iterator may be asynchronous or synchronous. TYPE: collections . abc . Iterator [ str ] | collections . abc . AsyncIterator [ str ] char_limit The limit for how many characters should be included per yielded page. TYPE: int DEFAULT: 2000 line_limit The limit for how many lines should be included per yielded page. TYPE: int DEFAULT: 25 wrapper A wrapper for each yielded page. This should leave \"{}\" in it to be replaced by the page's content. TYPE: typing . Optional [ str ] DEFAULT: None RETURNS DESCRIPTION collections . abc . AsyncIterator [ tuple [ str , int ]] | collections . abc . Iterator [ tuple [ str , int ]] An iterator of page tuples (string context to int zero-based index).","title":"paginate_string()"},{"location":"reference/#yuyo.sync_paginate_string","text":"sync_paginate_string ( lines , * , char_limit = 2000 , line_limit = 25 , wrapper = None ) Lazily paginate an iterator of lines. PARAMETER DESCRIPTION lines The iterator of lines to paginate. TYPE: collections . Iterable [ str ] char_limit The limit for how many characters should be included per yielded page. TYPE: int DEFAULT: 2000 line_limit The limit for how many lines should be included per yielded page. TYPE: int DEFAULT: 25 wrapper A wrapper for each yielded page. This should leave \"{}\" in it to be replaced by the page's content. TYPE: typing . Optional [ str ] DEFAULT: None RETURNS DESCRIPTION collections . abc . Iterator [ tuple [ str , int ]] An iterator of page tuples (string context to int zero-based index).","title":"sync_paginate_string()"},{"location":"reference/asgi/","text":"yuyo.asgi # ASGI/3 adapter for Hikari's interaction server. AsgiAdapter # Asgi/3 adapter for Hikari's interaction server interface. For this to work, hikari has to be installed with the optional \"server\" feature (e.g python -m pip install hikari[server] ). server property # server : hikari . api . InteractionServer The interaction server this adapter is bound to. __call__ async # __call__ ( scope , receive , send ) Call the adapter. Note This method is called by the ASGI server. PARAMETER DESCRIPTION scope The scope of the request. TYPE: asgiref . Scope receive The receive function to use. TYPE: asgiref . ASGIReceiveCallable send The send function to use. TYPE: asgiref . ASGISendCallable RAISES DESCRIPTION NotImplementedError If this is called with a websocket scope. RuntimeError If an invalid scope event is passed. __init__ # __init__ ( server , / , * , executor = None ) Initialise the adapter. PARAMETER DESCRIPTION server The interaction server to use. TYPE: hikari . api . InteractionServer executor If non- None , then this executor is used instead of the concurrent.futures.ThreadPoolExecutor attached to the asyncio.AbstractEventLoop that the bot will run on. This executor is used primarily for file-IO. While mainly supporting the concurrent.futures.ThreadPoolExecutor implementation in the standard lib, Hikari's file handling systems should also work with concurrent.futures.ProcessPoolExecutor , which relies on all objects used in IPC to be pickle able. Many third-party libraries will not support this fully though, so your mileage may vary on using ProcessPoolExecutor implementations with this parameter. TYPE: typing . Optional [ concurrent . futures . Executor ] DEFAULT: None add_shutdown_callback # add_shutdown_callback ( callback ) Add a callback to be called when the ASGI server shuts down. Warning These callbacks will block the ASGI server from shutting down until they complete and any raised errors will lead to a failed shutdown. PARAMETER DESCRIPTION callback The shutdown callback to add. TYPE: collections . Callable [[ Self ], collections . Coroutine [ typing . Any , typing . Any , None]] add_startup_callback # add_startup_callback ( callback ) Add a callback to be called when the ASGI server starts up. Warning These callbacks will block the ASGI server from starting until they complete and any raised errors will lead to a failed startup. PARAMETER DESCRIPTION callback The startup callback to add. TYPE: collections . Callable [[ Self ], collections . Coroutine [ typing . Any , typing . Any , None]] process_lifespan_event async # process_lifespan_event ( receive , send ) Process a lifespan ASGI event. Note This function is used internally by the adapter. PARAMETER DESCRIPTION receive The receive function to use. TYPE: asgiref . ASGIReceiveCallable send The send function to use. TYPE: asgiref . ASGISendCallable RAISES DESCRIPTION RuntimeError If an invalid lifespan event is passed. process_request async # process_request ( scope , receive , send ) Process an HTTP request. Note This function is used internally by the adapter. PARAMETER DESCRIPTION scope The scope of the request. TYPE: asgiref . HTTPScope receive The receive function to use. TYPE: asgiref . ASGIReceiveCallable send The send function to use. TYPE: asgiref . ASGISendCallable remove_shutdown_callback # remove_shutdown_callback ( callback ) Remove a shutdown callback. PARAMETER DESCRIPTION callback The shutdown callback to remove. TYPE: collections . Callable [[ Self ], collections . Coroutine [ typing . Any , typing . Any , None]] RAISES DESCRIPTION ValueError If the callback was not registered. remove_startup_callback # remove_startup_callback ( callback ) Remove a startup callback. PARAMETER DESCRIPTION callback The startup callback to remove. TYPE: collections . Callable [[ Self ], collections . Coroutine [ typing . Any , typing . Any , None]] RAISES DESCRIPTION ValueError If the callback was not registered. AsgiBot # Bases: AsgiAdapter , hikari . RESTBotAware Bot implementation which acts as an ASGI adapter. This bot doesn't initiate a server internally but instead relies on being called as an ASGI app. For this to work, hikari has to be installed with the optional \"server\" feature (e.g python -m pip install hikari[server] ). __init__ # __init__ ( token , token_type = None , public_key = None , * , asgi_managed = True , executor = None , http_settings = None , max_rate_limit = 300.0 , max_retries = 3 , proxy_settings = None , rest_url = None ) Initialise a new ASGI bot. PARAMETER DESCRIPTION token The bot or bearer token. If no token is to be used, this can be undefined. TYPE: typing . Union [ str , hikari . api . TokenStrategy ] token_type The type of token in use. This should only be passed when str is passed for token , can be \"Bot\" or \"Bearer\" and will be defaulted to \"Bearer\" in this situation. This should be left as None when either hikari.api.rest.TokenStrategy or None is passed for token . TYPE: typing . Union [ hikari . TokenType , str , None] DEFAULT: None asgi_managed Whether this bot's internal components should be automatically started and stopped based on the Asgi lifespan events. TYPE: bool DEFAULT: True executor If non- None , then this executor is used instead of the concurrent.futures.ThreadPoolExecutor attached to the asyncio.AbstractEventLoop that the bot will run on. This executor is used primarily for file-IO. While mainly supporting the concurrent.futures.ThreadPoolExecutor implementation in the standard lib, Hikari's file handling systems should also work with concurrent.futures.ProcessPoolExecutor , which relies on all objects used in IPC to be pickle able. Many third-party libraries will not support this fully though, so your mileage may vary on using ProcessPoolExecutor implementations with this parameter. TYPE: typing . Optional [ concurrent . futures . Executor ] DEFAULT: None http_settings Optional custom HTTP configuration settings to use. Allows you to customise functionality such as whether SSL-verification is enabled, what timeouts aiohttp should expect to use for requests, and behavior regarding HTTP-redirects. TYPE: typing . Optional [ hikari . impl . HTTPSettings ] DEFAULT: None max_rate_limit The max number of seconds to backoff for when rate limited. Anything greater than this will instead raise an error. This defaults to five minutes to stop potentially indefinitely waiting on an endpoint, which is almost never what you want to do if giving a response to a user. You can set this to float(\"inf\") to disable this check entirely. Note that this only applies to the REST API component that communicates with Discord, and will not affect sharding or third party HTTP endpoints that may be in use. TYPE: float DEFAULT: 300.0 max_retries Maximum number of times a request will be retried if it fails with a 5xx status. Defaults to 3 if set to None . TYPE: int DEFAULT: 3 proxy_settings Custom proxy settings to use with network-layer logic in your application to get through an HTTP-proxy. TYPE: typing . Optional [ hikari . impl . ProxySettings ] DEFAULT: None public_key The public key to use to verify received interaction requests. This may be a hex encoded str or the raw bytes . If left as None then the client will try to work this value out based on token . TYPE: typing . Union [ bytes , str , None] DEFAULT: None rest_url Defaults to the Discord REST API URL if None . Can be overridden if you are attempting to point to an unofficial endpoint, or if you are attempting to mock/stub the Discord API for any reason. Generally you do not want to change this. TYPE: typing . Optional [ str ] DEFAULT: None RAISES DESCRIPTION ValueError If token_type is provided when a token strategy is passed for token . if token_type is left as None when a string is passed for token . close async # close () Close the bot's REST client. Warning Unless asgi_managed=False is passed to AsgiBot.__init__ , the bot will be automatically closed based on the ASGI lifespan events and any other calls to this function will raise a RuntimeError . RAISES DESCRIPTION RuntimeError If the client isn't alive. If the client is ASGI managed. run # run () Start the bot's REST client and wait until the bot's closed. Warning Unless asgi_managed=False is passed to yuyo.asgi.AsgiBot. init , the bot will be automatically started and closed based on the ASGI lifespan events and any other calls to this function will raise a RuntimeError . RAISES DESCRIPTION RuntimeError If the client is already alive. If the client is ASGI managed. start async # start () Start the bot's REST client. Warning Unless asgi_managed=False is passed to yuyo.asgi.AsgiBot. init , the bot will be automatically started based on the ASGI lifespan events and any other calls to this function will raise a RuntimeError . RAISES DESCRIPTION RuntimeError If the client is already alive. If the client is ASGI managed.","title":"yuyo.asgi"},{"location":"reference/asgi/#yuyoasgi","text":"ASGI/3 adapter for Hikari's interaction server.","title":"yuyo.asgi"},{"location":"reference/asgi/#yuyo.asgi.AsgiAdapter","text":"Asgi/3 adapter for Hikari's interaction server interface. For this to work, hikari has to be installed with the optional \"server\" feature (e.g python -m pip install hikari[server] ).","title":"AsgiAdapter"},{"location":"reference/asgi/#yuyo.asgi.AsgiAdapter.server","text":"server : hikari . api . InteractionServer The interaction server this adapter is bound to.","title":"server"},{"location":"reference/asgi/#yuyo.asgi.AsgiAdapter.__call__","text":"__call__ ( scope , receive , send ) Call the adapter. Note This method is called by the ASGI server. PARAMETER DESCRIPTION scope The scope of the request. TYPE: asgiref . Scope receive The receive function to use. TYPE: asgiref . ASGIReceiveCallable send The send function to use. TYPE: asgiref . ASGISendCallable RAISES DESCRIPTION NotImplementedError If this is called with a websocket scope. RuntimeError If an invalid scope event is passed.","title":"__call__()"},{"location":"reference/asgi/#yuyo.asgi.AsgiAdapter.__init__","text":"__init__ ( server , / , * , executor = None ) Initialise the adapter. PARAMETER DESCRIPTION server The interaction server to use. TYPE: hikari . api . InteractionServer executor If non- None , then this executor is used instead of the concurrent.futures.ThreadPoolExecutor attached to the asyncio.AbstractEventLoop that the bot will run on. This executor is used primarily for file-IO. While mainly supporting the concurrent.futures.ThreadPoolExecutor implementation in the standard lib, Hikari's file handling systems should also work with concurrent.futures.ProcessPoolExecutor , which relies on all objects used in IPC to be pickle able. Many third-party libraries will not support this fully though, so your mileage may vary on using ProcessPoolExecutor implementations with this parameter. TYPE: typing . Optional [ concurrent . futures . Executor ] DEFAULT: None","title":"__init__()"},{"location":"reference/asgi/#yuyo.asgi.AsgiAdapter.add_shutdown_callback","text":"add_shutdown_callback ( callback ) Add a callback to be called when the ASGI server shuts down. Warning These callbacks will block the ASGI server from shutting down until they complete and any raised errors will lead to a failed shutdown. PARAMETER DESCRIPTION callback The shutdown callback to add. TYPE: collections . Callable [[ Self ], collections . Coroutine [ typing . Any , typing . Any , None]]","title":"add_shutdown_callback()"},{"location":"reference/asgi/#yuyo.asgi.AsgiAdapter.add_startup_callback","text":"add_startup_callback ( callback ) Add a callback to be called when the ASGI server starts up. Warning These callbacks will block the ASGI server from starting until they complete and any raised errors will lead to a failed startup. PARAMETER DESCRIPTION callback The startup callback to add. TYPE: collections . Callable [[ Self ], collections . Coroutine [ typing . Any , typing . Any , None]]","title":"add_startup_callback()"},{"location":"reference/asgi/#yuyo.asgi.AsgiAdapter.process_lifespan_event","text":"process_lifespan_event ( receive , send ) Process a lifespan ASGI event. Note This function is used internally by the adapter. PARAMETER DESCRIPTION receive The receive function to use. TYPE: asgiref . ASGIReceiveCallable send The send function to use. TYPE: asgiref . ASGISendCallable RAISES DESCRIPTION RuntimeError If an invalid lifespan event is passed.","title":"process_lifespan_event()"},{"location":"reference/asgi/#yuyo.asgi.AsgiAdapter.process_request","text":"process_request ( scope , receive , send ) Process an HTTP request. Note This function is used internally by the adapter. PARAMETER DESCRIPTION scope The scope of the request. TYPE: asgiref . HTTPScope receive The receive function to use. TYPE: asgiref . ASGIReceiveCallable send The send function to use. TYPE: asgiref . ASGISendCallable","title":"process_request()"},{"location":"reference/asgi/#yuyo.asgi.AsgiAdapter.remove_shutdown_callback","text":"remove_shutdown_callback ( callback ) Remove a shutdown callback. PARAMETER DESCRIPTION callback The shutdown callback to remove. TYPE: collections . Callable [[ Self ], collections . Coroutine [ typing . Any , typing . Any , None]] RAISES DESCRIPTION ValueError If the callback was not registered.","title":"remove_shutdown_callback()"},{"location":"reference/asgi/#yuyo.asgi.AsgiAdapter.remove_startup_callback","text":"remove_startup_callback ( callback ) Remove a startup callback. PARAMETER DESCRIPTION callback The startup callback to remove. TYPE: collections . Callable [[ Self ], collections . Coroutine [ typing . Any , typing . Any , None]] RAISES DESCRIPTION ValueError If the callback was not registered.","title":"remove_startup_callback()"},{"location":"reference/asgi/#yuyo.asgi.AsgiBot","text":"Bases: AsgiAdapter , hikari . RESTBotAware Bot implementation which acts as an ASGI adapter. This bot doesn't initiate a server internally but instead relies on being called as an ASGI app. For this to work, hikari has to be installed with the optional \"server\" feature (e.g python -m pip install hikari[server] ).","title":"AsgiBot"},{"location":"reference/asgi/#yuyo.asgi.AsgiBot.__init__","text":"__init__ ( token , token_type = None , public_key = None , * , asgi_managed = True , executor = None , http_settings = None , max_rate_limit = 300.0 , max_retries = 3 , proxy_settings = None , rest_url = None ) Initialise a new ASGI bot. PARAMETER DESCRIPTION token The bot or bearer token. If no token is to be used, this can be undefined. TYPE: typing . Union [ str , hikari . api . TokenStrategy ] token_type The type of token in use. This should only be passed when str is passed for token , can be \"Bot\" or \"Bearer\" and will be defaulted to \"Bearer\" in this situation. This should be left as None when either hikari.api.rest.TokenStrategy or None is passed for token . TYPE: typing . Union [ hikari . TokenType , str , None] DEFAULT: None asgi_managed Whether this bot's internal components should be automatically started and stopped based on the Asgi lifespan events. TYPE: bool DEFAULT: True executor If non- None , then this executor is used instead of the concurrent.futures.ThreadPoolExecutor attached to the asyncio.AbstractEventLoop that the bot will run on. This executor is used primarily for file-IO. While mainly supporting the concurrent.futures.ThreadPoolExecutor implementation in the standard lib, Hikari's file handling systems should also work with concurrent.futures.ProcessPoolExecutor , which relies on all objects used in IPC to be pickle able. Many third-party libraries will not support this fully though, so your mileage may vary on using ProcessPoolExecutor implementations with this parameter. TYPE: typing . Optional [ concurrent . futures . Executor ] DEFAULT: None http_settings Optional custom HTTP configuration settings to use. Allows you to customise functionality such as whether SSL-verification is enabled, what timeouts aiohttp should expect to use for requests, and behavior regarding HTTP-redirects. TYPE: typing . Optional [ hikari . impl . HTTPSettings ] DEFAULT: None max_rate_limit The max number of seconds to backoff for when rate limited. Anything greater than this will instead raise an error. This defaults to five minutes to stop potentially indefinitely waiting on an endpoint, which is almost never what you want to do if giving a response to a user. You can set this to float(\"inf\") to disable this check entirely. Note that this only applies to the REST API component that communicates with Discord, and will not affect sharding or third party HTTP endpoints that may be in use. TYPE: float DEFAULT: 300.0 max_retries Maximum number of times a request will be retried if it fails with a 5xx status. Defaults to 3 if set to None . TYPE: int DEFAULT: 3 proxy_settings Custom proxy settings to use with network-layer logic in your application to get through an HTTP-proxy. TYPE: typing . Optional [ hikari . impl . ProxySettings ] DEFAULT: None public_key The public key to use to verify received interaction requests. This may be a hex encoded str or the raw bytes . If left as None then the client will try to work this value out based on token . TYPE: typing . Union [ bytes , str , None] DEFAULT: None rest_url Defaults to the Discord REST API URL if None . Can be overridden if you are attempting to point to an unofficial endpoint, or if you are attempting to mock/stub the Discord API for any reason. Generally you do not want to change this. TYPE: typing . Optional [ str ] DEFAULT: None RAISES DESCRIPTION ValueError If token_type is provided when a token strategy is passed for token . if token_type is left as None when a string is passed for token .","title":"__init__()"},{"location":"reference/asgi/#yuyo.asgi.AsgiBot.close","text":"close () Close the bot's REST client. Warning Unless asgi_managed=False is passed to AsgiBot.__init__ , the bot will be automatically closed based on the ASGI lifespan events and any other calls to this function will raise a RuntimeError . RAISES DESCRIPTION RuntimeError If the client isn't alive. If the client is ASGI managed.","title":"close()"},{"location":"reference/asgi/#yuyo.asgi.AsgiBot.run","text":"run () Start the bot's REST client and wait until the bot's closed. Warning Unless asgi_managed=False is passed to yuyo.asgi.AsgiBot. init , the bot will be automatically started and closed based on the ASGI lifespan events and any other calls to this function will raise a RuntimeError . RAISES DESCRIPTION RuntimeError If the client is already alive. If the client is ASGI managed.","title":"run()"},{"location":"reference/asgi/#yuyo.asgi.AsgiBot.start","text":"start () Start the bot's REST client. Warning Unless asgi_managed=False is passed to yuyo.asgi.AsgiBot. init , the bot will be automatically started based on the ASGI lifespan events and any other calls to this function will raise a RuntimeError . RAISES DESCRIPTION RuntimeError If the client is already alive. If the client is ASGI managed.","title":"start()"},{"location":"reference/backoff/","text":"yuyo.backoff # Utility used for handling automatic back-off. This can be used to cover cases such as hitting rate-limits and failed requests. Backoff # Used to exponentially backoff asynchronously. This class acts as an asynchronous iterator and can be iterated over to provide implicit backoff where for every iteration other than the first this will either back off for the time passed to yuyo.backoff.Backoff.set_next_backoff if applicable or a time calculated exponentially. Each iteration yields the current retry count (starting at 0). Examples: An example of using this class as an asynchronous iterator may look like the following # While we can directly do `async for _ in Backoff()`, by assigning it to a # variable we allow ourself to provide a specific backoff time in some cases. backoff = Backoff () async for _ in backoff : try : message = await bot . rest . fetch_message ( channel_id , message_id ) except errors . RateLimitedError as exc : # If we have a specific backoff time then set it for the next iteration backoff . set_next_backoff ( exc . retry_after ) except errors . InternalServerError : # Else let the iterator calculate an exponential backoff before the next loop. pass else : # We need to break out of the iterator to make sure it doesn't backoff again. # Alternatively `Backoff.finish()` can be called to break out of the loop. break Alternatively you may want to explicitly call yuyo.backoff.Backoff.backoff , a alternative of the previous example which uses yuyo.backoff.Backoff.backoff may look like the following backoff = Backoff () message : typing . Optional [ messages . Message ] = None while not message : try : message = await bot . rest . fetch_message ( channel_id , message_id ) except errors . RateLimitedError as exc : # If we have a specific backoff time then set it for the next iteration. await backoff . backoff ( exc . retry_after ) except errors . InternalServerError : # Else let the iterator calculate an exponential backoff before the next loop. await backoff . backoff () is_depleted property # is_depleted : bool Whether \"max_retries\" has been reached. This can be used to workout whether the loop was explicitly broken out of using yuyo.backoff.Backoff.finish / break or if it hit \"max_retries\". __init__ # __init__ ( max_retries = None , * , base = 2.0 , maximum = 64.0 , jitter_multiplier = 1.0 , initial_increment = 0 ) Initialise a backoff instance. PARAMETER DESCRIPTION max_retries The maximum amount of times this should iterate for between resets. If left as None then this iterator will be unlimited. This must be greater than or equal to 1. TYPE: typing . Optional [ int ] DEFAULT: None base The base to use. TYPE: float DEFAULT: 2.0 maximum The max value the backoff can be in a single iteration. Anything above this will be capped to this base value plus random jitter. TYPE: float DEFAULT: 64.0 jitter_multiplier The multiplier for the random jitter. Set to 0 to disable jitter. TYPE: float DEFAULT: 1.0 initial_increment The initial increment to start at. TYPE: int DEFAULT: 0 RAISES DESCRIPTION ValueError If an int that's too big to be represented as a float or a non-finite value is passed in place of a field that's annotated as float or if max_retries is less than 1 . backoff async # backoff () Sleep for the provided backoff or for the next exponent. This provides an alternative to iterating over this class. RETURNS DESCRIPTION int | None Whether this has reached the end of its iteration. If this returns True then that call didn't sleep as this has been marked as finished or has reached the max retries. finish # finish () Mark the iterator as finished to break out of the current loop. reset # reset () Reset the backoff to it's original state to reuse it. set_next_backoff # set_next_backoff ( backoff_ ) Specify a backoff time for the next iteration or yuyo.backoff.Backoff.backoff call. If this is called then the exponent won't be increased for this iteration. Note Calling this multiple times in a single iteration will overwrite any previously set next backoff. ErrorManager # A context manager provided to allow for more concise error handling with yuyo.backoff.Backoff . Examples: The following is an example of using yuyo.backoff.ErrorManager alongside yuyo.backoff.Backoff in-order to handle the exceptions which may be raised while trying to reply to a message. retry = Backoff () # Rules can either be passed to `ErrorManager`'s initiate as variable arguments # or one at a time to `ErrorManager.with_rule` through possibly chained-calls. error_handler = ( # For the 1st rule we catch two errors which would indicate the bot # no-longer has access to the target channel and break out of the # retry loop using `Backoff.retry`. ErrorManager ((( errors . NotFoundError , errors . ForbiddenError ), lambda _ : retry . finish ())) # For the 2nd rule we catch rate limited errors and set their # `retry` value as the next backoff time before suppressing the # error to allow this to retry the request. . with_rule (( errors . RateLimitedError ,), lambda exc : retry . set_next_backoff ( exc . retry_after )) # For the 3rd rule we suppress the internal server error to allow # backoff to reach the next retry and exponentially backoff as we # don't have any specific retry time for this error. . with_rule (( errors . InternalServerError ,), lambda _ : False ) ) async for _ in retry : # We entre this context manager each iteration to catch errors before # they cause us to break out of the `Backoff` loop. with error_handler : await message . respond ( \"General Kenobi\" ) # We need to break out of `retry` if this request succeeds. break __init__ # __init__ ( * rules ) Initialise an error manager instance. PARAMETER DESCRIPTION *rules Rules to initiate this error context manager with. These are each a 2-length tuple where the tuple[0] is an iterable of types of the exceptions this rule should apply to and tuple[1] is the rule's callback function. The callback function will be called with the raised exception when it matches one of the passed exceptions for the relevant rule and may raise, return True to indicate that the current error should be raised outside of the context manager or False / None to suppress the current error. TYPE: tuple [ collections . Iterable [ type [ BaseException ]], collections . Callable [[ typing . Any ], typing . Optional [ bool ]]] DEFAULT: () clear_rules # clear_rules () Clear the rules registered with this handler. with_rule # with_rule ( exceptions , result ) Add a rule to this exception context manager. PARAMETER DESCRIPTION exceptions An iterable of types of the exceptions this rule should apply to. TYPE: collections . Iterable [ type [ BaseException ]] result The function called with the raised exception when it matches one of the passed exceptions . This may raise, return True to indicate that the current error should be raised outside of the context manager or False / None to suppress the current error. TYPE: collections . Callable [[ typing . Any ], typing . Optional [ bool ]] RETURNS DESCRIPTION Self This returns the handler a rule was being added to in-order to allow for chained calls.","title":"yuyo.backoff"},{"location":"reference/backoff/#yuyobackoff","text":"Utility used for handling automatic back-off. This can be used to cover cases such as hitting rate-limits and failed requests.","title":"yuyo.backoff"},{"location":"reference/backoff/#yuyo.backoff.Backoff","text":"Used to exponentially backoff asynchronously. This class acts as an asynchronous iterator and can be iterated over to provide implicit backoff where for every iteration other than the first this will either back off for the time passed to yuyo.backoff.Backoff.set_next_backoff if applicable or a time calculated exponentially. Each iteration yields the current retry count (starting at 0). Examples: An example of using this class as an asynchronous iterator may look like the following # While we can directly do `async for _ in Backoff()`, by assigning it to a # variable we allow ourself to provide a specific backoff time in some cases. backoff = Backoff () async for _ in backoff : try : message = await bot . rest . fetch_message ( channel_id , message_id ) except errors . RateLimitedError as exc : # If we have a specific backoff time then set it for the next iteration backoff . set_next_backoff ( exc . retry_after ) except errors . InternalServerError : # Else let the iterator calculate an exponential backoff before the next loop. pass else : # We need to break out of the iterator to make sure it doesn't backoff again. # Alternatively `Backoff.finish()` can be called to break out of the loop. break Alternatively you may want to explicitly call yuyo.backoff.Backoff.backoff , a alternative of the previous example which uses yuyo.backoff.Backoff.backoff may look like the following backoff = Backoff () message : typing . Optional [ messages . Message ] = None while not message : try : message = await bot . rest . fetch_message ( channel_id , message_id ) except errors . RateLimitedError as exc : # If we have a specific backoff time then set it for the next iteration. await backoff . backoff ( exc . retry_after ) except errors . InternalServerError : # Else let the iterator calculate an exponential backoff before the next loop. await backoff . backoff ()","title":"Backoff"},{"location":"reference/backoff/#yuyo.backoff.Backoff.is_depleted","text":"is_depleted : bool Whether \"max_retries\" has been reached. This can be used to workout whether the loop was explicitly broken out of using yuyo.backoff.Backoff.finish / break or if it hit \"max_retries\".","title":"is_depleted"},{"location":"reference/backoff/#yuyo.backoff.Backoff.__init__","text":"__init__ ( max_retries = None , * , base = 2.0 , maximum = 64.0 , jitter_multiplier = 1.0 , initial_increment = 0 ) Initialise a backoff instance. PARAMETER DESCRIPTION max_retries The maximum amount of times this should iterate for between resets. If left as None then this iterator will be unlimited. This must be greater than or equal to 1. TYPE: typing . Optional [ int ] DEFAULT: None base The base to use. TYPE: float DEFAULT: 2.0 maximum The max value the backoff can be in a single iteration. Anything above this will be capped to this base value plus random jitter. TYPE: float DEFAULT: 64.0 jitter_multiplier The multiplier for the random jitter. Set to 0 to disable jitter. TYPE: float DEFAULT: 1.0 initial_increment The initial increment to start at. TYPE: int DEFAULT: 0 RAISES DESCRIPTION ValueError If an int that's too big to be represented as a float or a non-finite value is passed in place of a field that's annotated as float or if max_retries is less than 1 .","title":"__init__()"},{"location":"reference/backoff/#yuyo.backoff.Backoff.backoff","text":"backoff () Sleep for the provided backoff or for the next exponent. This provides an alternative to iterating over this class. RETURNS DESCRIPTION int | None Whether this has reached the end of its iteration. If this returns True then that call didn't sleep as this has been marked as finished or has reached the max retries.","title":"backoff()"},{"location":"reference/backoff/#yuyo.backoff.Backoff.finish","text":"finish () Mark the iterator as finished to break out of the current loop.","title":"finish()"},{"location":"reference/backoff/#yuyo.backoff.Backoff.reset","text":"reset () Reset the backoff to it's original state to reuse it.","title":"reset()"},{"location":"reference/backoff/#yuyo.backoff.Backoff.set_next_backoff","text":"set_next_backoff ( backoff_ ) Specify a backoff time for the next iteration or yuyo.backoff.Backoff.backoff call. If this is called then the exponent won't be increased for this iteration. Note Calling this multiple times in a single iteration will overwrite any previously set next backoff.","title":"set_next_backoff()"},{"location":"reference/backoff/#yuyo.backoff.ErrorManager","text":"A context manager provided to allow for more concise error handling with yuyo.backoff.Backoff . Examples: The following is an example of using yuyo.backoff.ErrorManager alongside yuyo.backoff.Backoff in-order to handle the exceptions which may be raised while trying to reply to a message. retry = Backoff () # Rules can either be passed to `ErrorManager`'s initiate as variable arguments # or one at a time to `ErrorManager.with_rule` through possibly chained-calls. error_handler = ( # For the 1st rule we catch two errors which would indicate the bot # no-longer has access to the target channel and break out of the # retry loop using `Backoff.retry`. ErrorManager ((( errors . NotFoundError , errors . ForbiddenError ), lambda _ : retry . finish ())) # For the 2nd rule we catch rate limited errors and set their # `retry` value as the next backoff time before suppressing the # error to allow this to retry the request. . with_rule (( errors . RateLimitedError ,), lambda exc : retry . set_next_backoff ( exc . retry_after )) # For the 3rd rule we suppress the internal server error to allow # backoff to reach the next retry and exponentially backoff as we # don't have any specific retry time for this error. . with_rule (( errors . InternalServerError ,), lambda _ : False ) ) async for _ in retry : # We entre this context manager each iteration to catch errors before # they cause us to break out of the `Backoff` loop. with error_handler : await message . respond ( \"General Kenobi\" ) # We need to break out of `retry` if this request succeeds. break","title":"ErrorManager"},{"location":"reference/backoff/#yuyo.backoff.ErrorManager.__init__","text":"__init__ ( * rules ) Initialise an error manager instance. PARAMETER DESCRIPTION *rules Rules to initiate this error context manager with. These are each a 2-length tuple where the tuple[0] is an iterable of types of the exceptions this rule should apply to and tuple[1] is the rule's callback function. The callback function will be called with the raised exception when it matches one of the passed exceptions for the relevant rule and may raise, return True to indicate that the current error should be raised outside of the context manager or False / None to suppress the current error. TYPE: tuple [ collections . Iterable [ type [ BaseException ]], collections . Callable [[ typing . Any ], typing . Optional [ bool ]]] DEFAULT: ()","title":"__init__()"},{"location":"reference/backoff/#yuyo.backoff.ErrorManager.clear_rules","text":"clear_rules () Clear the rules registered with this handler.","title":"clear_rules()"},{"location":"reference/backoff/#yuyo.backoff.ErrorManager.with_rule","text":"with_rule ( exceptions , result ) Add a rule to this exception context manager. PARAMETER DESCRIPTION exceptions An iterable of types of the exceptions this rule should apply to. TYPE: collections . Iterable [ type [ BaseException ]] result The function called with the raised exception when it matches one of the passed exceptions . This may raise, return True to indicate that the current error should be raised outside of the context manager or False / None to suppress the current error. TYPE: collections . Callable [[ typing . Any ], typing . Optional [ bool ]] RETURNS DESCRIPTION Self This returns the handler a rule was being added to in-order to allow for chained calls.","title":"with_rule()"},{"location":"reference/chunk_tracker/","text":"yuyo.chunk_tracker # Utility class for tracking request guild member responses. ChunkRequestFinishedEvent # Bases: hikari . ShardEvent Event that's dispatched when a specific chunk request has finished. This will be fired for every chunk request which has a nonce. chunk_count property # chunk_count : int The amount of chunk events which should've been received for this request. first_received_at property # first_received_at : datetime . datetime When the first response was received. guild_id property # guild_id : hikari . Snowflake Id of the guild this chunk request was for. last_received_at property # last_received_at : datetime . datetime When the last response was received. missed_chunks property # missed_chunks : collections . Collection [ int ] Collection of the chunk responses which were missed (if any). not_found_ids property # not_found_ids : collections . Collection [ hikari . Snowflake ] Collection of the User IDs which weren't found. This is only relevant when users was specified while requesting the members. __init__ # __init__ ( app , shard , data ) Initialise a chunk request finished event. This should never be initialised directly. ChunkTracker # Chunk payload event tracker. This will dispatch ShardFinishedChunkingEvent , FinishedChunkingEvent and ChunkRequestFinishedEvent events. To configure this to automatically request member chunks to fill a member and/or presence cache on startup and guild join see ChunkTracker.set_auto_chunk_members . Note ChunkTracker.request_guild_members ensures a request will be tracked as this only tracks chunk requests with a set nonce. __init__ # __init__ ( event_manager , rest , shards ) Initialise a chunk tracker. For a shorthand for initialising this from a hikari.traits.GatewayBotAware see ChunkTracker.from_gateway_bot . PARAMETER DESCRIPTION event_manager The event manager this chunk tracker should dispatch events over. TYPE: hikari . api . EventManager shards The shard aware object this should use. TYPE: hikari . ShardAware from_gateway_bot classmethod # from_gateway_bot ( bot ) Initialise a chunk tracker from a gateway bot. PARAMETER DESCRIPTION bot The gateway bot this chunk tracker should use. TYPE: hikari . GatewayBotAware request_guild_members async # request_guild_members ( guild , * , include_presences = hikari . UNDEFINED , query = '' , limit = 0 , users = hikari . UNDEFINED ) Request guild members. Note To request the full list of members, leave query as \"\" (empty string) and limit as 0 . PARAMETER DESCRIPTION guild The guild to request chunk for. TYPE: hikari . SnowflakeishOr [ hikari . PartialGuild ] include_presences If provided, whether to request presences. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED query If not \"\" , request the members who's usernames starts with the string. TYPE: str DEFAULT: '' limit Maximum number of members to send matching the query. TYPE: int DEFAULT: 0 users If provided, the users to request for. TYPE: hikari . UndefinedOr [ hikari . SnowflakeishSequence [ hikari . User ]] DEFAULT: hikari.UNDEFINED RAISES DESCRIPTION ValueError When trying to specify users with query / limit , if limit is not between 0 and 100, both inclusive or if users length is over 100. hikari . errors . MissingIntentError When trying to request presences without the GUILD_MEMBERS or when trying to request the full list of members without GUILD_PRESENCES . set_auto_chunk_members # set_auto_chunk_members ( state , / , * , chunk_presences = True ) Configure whether this should request member chunks in response to GUILD_CREATE. This may be useful for filling 3rd party caches but may conflict with the auto_chunk_members config of hikari.impl.bot.GatewayBot if it's enabled. Warning This will be ignored if Intents.GUILD_MEMBERS hasn't been declared. PARAMETER DESCRIPTION state Whether this should request member chunks when GUILD_CREATE events are received. TYPE: bool chunk_presences Whether this should also request member presences on these member chunks. This will be ignored if Intents.GUILD_PRESENCES hasn't been declared. TYPE: bool DEFAULT: True RETURNS DESCRIPTION Self The chunk tracker object to enable call chaining. FinishedChunkingEvent # Bases: hikari . Event Event that's dispatched when the startup chunking has finished for the bot. This indicates that any cache member and presences resources should be complete globally. This will only be fired once after bot startups. __init__ # __init__ ( app ) Initialise a chunking finished event. This should never be initialised directly. ShardFinishedChunkingEvent # Bases: hikari . ShardEvent Event that's dispatched when the startup chunking has finished for a shard. This indicates that any cache member and presences resources should be complete for guilds covered by this shard. This will be fired after every shard identify which triggers chunking (including re-identifies). incomplete_guild_ids property # incomplete_guild_ids : collections . Sequence [ hikari . Snowflake ] Sequence of the IDs of guilds some chunk responses were missed for. missed_guild_ids property # missed_guild_ids : collections . Sequence [ hikari . Snowflake ] Sequence of the IDs of guilds no chunk responses were received for. __init__ # __init__ ( app , shard , / , * , incomplete_guild_ids = (), missed_guild_ids = ()) Initialise a shard chunking finished event. This should never be initialised directly.","title":"yuyo.chunk_tracker"},{"location":"reference/chunk_tracker/#yuyochunk_tracker","text":"Utility class for tracking request guild member responses.","title":"yuyo.chunk_tracker"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ChunkRequestFinishedEvent","text":"Bases: hikari . ShardEvent Event that's dispatched when a specific chunk request has finished. This will be fired for every chunk request which has a nonce.","title":"ChunkRequestFinishedEvent"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ChunkRequestFinishedEvent.chunk_count","text":"chunk_count : int The amount of chunk events which should've been received for this request.","title":"chunk_count"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ChunkRequestFinishedEvent.first_received_at","text":"first_received_at : datetime . datetime When the first response was received.","title":"first_received_at"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ChunkRequestFinishedEvent.guild_id","text":"guild_id : hikari . Snowflake Id of the guild this chunk request was for.","title":"guild_id"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ChunkRequestFinishedEvent.last_received_at","text":"last_received_at : datetime . datetime When the last response was received.","title":"last_received_at"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ChunkRequestFinishedEvent.missed_chunks","text":"missed_chunks : collections . Collection [ int ] Collection of the chunk responses which were missed (if any).","title":"missed_chunks"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ChunkRequestFinishedEvent.not_found_ids","text":"not_found_ids : collections . Collection [ hikari . Snowflake ] Collection of the User IDs which weren't found. This is only relevant when users was specified while requesting the members.","title":"not_found_ids"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ChunkRequestFinishedEvent.__init__","text":"__init__ ( app , shard , data ) Initialise a chunk request finished event. This should never be initialised directly.","title":"__init__()"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ChunkTracker","text":"Chunk payload event tracker. This will dispatch ShardFinishedChunkingEvent , FinishedChunkingEvent and ChunkRequestFinishedEvent events. To configure this to automatically request member chunks to fill a member and/or presence cache on startup and guild join see ChunkTracker.set_auto_chunk_members . Note ChunkTracker.request_guild_members ensures a request will be tracked as this only tracks chunk requests with a set nonce.","title":"ChunkTracker"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ChunkTracker.__init__","text":"__init__ ( event_manager , rest , shards ) Initialise a chunk tracker. For a shorthand for initialising this from a hikari.traits.GatewayBotAware see ChunkTracker.from_gateway_bot . PARAMETER DESCRIPTION event_manager The event manager this chunk tracker should dispatch events over. TYPE: hikari . api . EventManager shards The shard aware object this should use. TYPE: hikari . ShardAware","title":"__init__()"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ChunkTracker.from_gateway_bot","text":"from_gateway_bot ( bot ) Initialise a chunk tracker from a gateway bot. PARAMETER DESCRIPTION bot The gateway bot this chunk tracker should use. TYPE: hikari . GatewayBotAware","title":"from_gateway_bot()"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ChunkTracker.request_guild_members","text":"request_guild_members ( guild , * , include_presences = hikari . UNDEFINED , query = '' , limit = 0 , users = hikari . UNDEFINED ) Request guild members. Note To request the full list of members, leave query as \"\" (empty string) and limit as 0 . PARAMETER DESCRIPTION guild The guild to request chunk for. TYPE: hikari . SnowflakeishOr [ hikari . PartialGuild ] include_presences If provided, whether to request presences. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED query If not \"\" , request the members who's usernames starts with the string. TYPE: str DEFAULT: '' limit Maximum number of members to send matching the query. TYPE: int DEFAULT: 0 users If provided, the users to request for. TYPE: hikari . UndefinedOr [ hikari . SnowflakeishSequence [ hikari . User ]] DEFAULT: hikari.UNDEFINED RAISES DESCRIPTION ValueError When trying to specify users with query / limit , if limit is not between 0 and 100, both inclusive or if users length is over 100. hikari . errors . MissingIntentError When trying to request presences without the GUILD_MEMBERS or when trying to request the full list of members without GUILD_PRESENCES .","title":"request_guild_members()"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ChunkTracker.set_auto_chunk_members","text":"set_auto_chunk_members ( state , / , * , chunk_presences = True ) Configure whether this should request member chunks in response to GUILD_CREATE. This may be useful for filling 3rd party caches but may conflict with the auto_chunk_members config of hikari.impl.bot.GatewayBot if it's enabled. Warning This will be ignored if Intents.GUILD_MEMBERS hasn't been declared. PARAMETER DESCRIPTION state Whether this should request member chunks when GUILD_CREATE events are received. TYPE: bool chunk_presences Whether this should also request member presences on these member chunks. This will be ignored if Intents.GUILD_PRESENCES hasn't been declared. TYPE: bool DEFAULT: True RETURNS DESCRIPTION Self The chunk tracker object to enable call chaining.","title":"set_auto_chunk_members()"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.FinishedChunkingEvent","text":"Bases: hikari . Event Event that's dispatched when the startup chunking has finished for the bot. This indicates that any cache member and presences resources should be complete globally. This will only be fired once after bot startups.","title":"FinishedChunkingEvent"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.FinishedChunkingEvent.__init__","text":"__init__ ( app ) Initialise a chunking finished event. This should never be initialised directly.","title":"__init__()"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ShardFinishedChunkingEvent","text":"Bases: hikari . ShardEvent Event that's dispatched when the startup chunking has finished for a shard. This indicates that any cache member and presences resources should be complete for guilds covered by this shard. This will be fired after every shard identify which triggers chunking (including re-identifies).","title":"ShardFinishedChunkingEvent"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ShardFinishedChunkingEvent.incomplete_guild_ids","text":"incomplete_guild_ids : collections . Sequence [ hikari . Snowflake ] Sequence of the IDs of guilds some chunk responses were missed for.","title":"incomplete_guild_ids"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ShardFinishedChunkingEvent.missed_guild_ids","text":"missed_guild_ids : collections . Sequence [ hikari . Snowflake ] Sequence of the IDs of guilds no chunk responses were received for.","title":"missed_guild_ids"},{"location":"reference/chunk_tracker/#yuyo.chunk_tracker.ShardFinishedChunkingEvent.__init__","text":"__init__ ( app , shard , / , * , incomplete_guild_ids = (), missed_guild_ids = ()) Initialise a shard chunking finished event. This should never be initialised directly.","title":"__init__()"},{"location":"reference/components/","text":"yuyo.components # Higher level client for callback based component execution. WaitFor module-attribute # WaitFor = WaitForExecutor Alias of yuyo.components.WaitForExecutor . AbstractComponentExecutor # Bases: abc . ABC Abstract interface of an object which handles the execution of a message component. custom_ids abstractmethod property # custom_ids : collections . Collection [ str ] Collection of the custom IDs this executor is listening for. has_expired abstractmethod property # has_expired : bool Whether this executor has ended. ActionRowExecutor # Bases: ComponentExecutor , hikari . api . ComponentBuilder Class used for handling the execution of an action row. __init__ # __init__ ( * , ephemeral_default = False , load_from_attributes = False , timeout = datetime . timedelta ( seconds = 30 )) Initialise an action row executor. PARAMETER DESCRIPTION ephemeral_default Whether this executor's responses should default to being ephemeral. TYPE: bool DEFAULT: False timeout How long this component should last until its marked as timed out. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30) ChildActionRowExecutor # Bases: ActionRowExecutor , typing . Generic [ _ParentExecutorProtoT ] Extended action row implementation which can be tied to a multi-component executor. add_to_parent # add_to_parent () Add this action row to its parent executor. RETURNS DESCRIPTION _ParentExecutorProtoT The parent executor this action row was added to. ComponentClient # Client used to handle component executors within a REST or gateway flow. alluka property # alluka : alluka_ . abc . Client The Alluka client being used for callback dependency injection. __init__ # __init__ ( * , alluka = None , event_manager = None , event_managed = None , server = None ) Initialise a component client. Note For an easier way to initialise the client from a bot see yuyo.components.ComponentClient.from_gateway_bot and yuyo.components.ComponentClient.from_rest_bot . PARAMETER DESCRIPTION alluka The Alluka client to use for callback dependency injection in this client. If not provided then this will initialise its own Alluka client. TYPE: typing . Optional [ alluka_ . abc . Client ] DEFAULT: None event_manager The event manager this client should listen to dispatched component interactions from if applicable. TYPE: typing . Optional [ hikari . api . EventManager ] DEFAULT: None event_managed Whether this client should be automatically opened and closed based on the lifetime events dispatched by event_manager . Defaults to True if an event manager is passed. TYPE: typing . Optional [ bool ] DEFAULT: None server The server this client should listen to component interactions from if applicable. TYPE: typing . Optional [ hikari . api . InteractionServer ] DEFAULT: None RAISES DESCRIPTION ValueError If event_managed is passed as True when event_manager is None . add_executor # add_executor ( message , executor ) Deprecated alias of yuyo.components.ComponentClient.add_executor . close # close () Close the component client. from_gateway_bot classmethod # from_gateway_bot ( bot , / , * , event_managed = True ) Build a component client froma Gateway Bot. PARAMETER DESCRIPTION bot The Gateway bot this component client should be bound to. TYPE: hikari . GatewayBotAware event_managed Whether the component client should be automatically opened and closed based on the lifetime events dispatched by bot . TYPE: bool DEFAULT: True RETURNS DESCRIPTION ComponentClient The initialised component client. from_rest_bot classmethod # from_rest_bot ( bot ) Build a component client froma REST Bot. PARAMETER DESCRIPTION bot The REST bot this component client should be bound to. TYPE: hikari . RESTBotAware RETURNS DESCRIPTION ComponentClient The initialised component client. get_constant_id # get_constant_id ( custom_id ) Get a set constant \"custom_id\" callback. PARAMETER DESCRIPTION custom_id The custom_id to get the callback for. TYPE: str RETURNS DESCRIPTION CallbackSig | None The callback for the custom_id, or None if it doesn't exist. get_executor # get_executor ( message ) Get the component executor set for a message. PARAMETER DESCRIPTION message The message to get the executor for. TYPE: hikari . SnowflakeishOr [ hikari . Message ] RETURNS DESCRIPTION yuyo . components . AbstractComponentExecutor | None The executor set for the message or None if none is set. open # open () Startup the component client. remove_constant_id # remove_constant_id ( custom_id ) Remove a constant \"custom_id\" callback. PARAMETER DESCRIPTION custom_id The custom_id to remove the callback for. TYPE: str RETURNS DESCRIPTION Self The component client to allow chaining. RAISES DESCRIPTION KeyError If the custom_id is not registered. remove_executor # remove_executor ( message ) Remove the component executor for a message. PARAMETER DESCRIPTION message The message to remove the executor for. TYPE: hikari . SnowflakeishOr [ hikari . Message ] RETURNS DESCRIPTION Self The component client to allow chaining. set_constant_id # set_constant_id ( custom_id , callback , / , * , prefix_match = False ) Add a constant \"custom_id\" callback. These are callbacks which'll always be called for a specific custom_id while taking priority over executors. PARAMETER DESCRIPTION custom_id The custom_id to register the callback for. TYPE: str callback The callback to register. This should take a single argument of type yuyo.components.ComponentContext , be asynchronous and return None . TYPE: CallbackSig prefix_match Whether the custom_id should be treated as a prefix match. This allows for further state to be held in the custom id after the prefix and is lower priority than normal custom id match. TYPE: bool DEFAULT: False RETURNS DESCRIPTION Self The component client to allow chaining. RAISES DESCRIPTION ValueError If the custom_id is already registered. set_executor # set_executor ( message , executor ) Set the component executor for a message. PARAMETER DESCRIPTION message The message to set the executor for. TYPE: hikari . SnowflakeishOr [ hikari . Message ] executor The executor to set. This will be called for every component interaction for the message unless the component's custom_id is registered as a constant id callback. TYPE: AbstractComponentExecutor RETURNS DESCRIPTION Self The component client to allow chaining. with_constant_id # with_constant_id ( custom_id , / , * , prefix_match = False ) Add a constant \"custom_id\" callback through a decorator call. These are callbacks which'll always be called for a specific custom_id while taking priority over executors. PARAMETER DESCRIPTION custom_id The custom_id to register the callback for. TYPE: str prefix_match Whether the custom_id should be treated as a prefix match. This allows for further state to be held in the custom id after the prefix and is lower priority than normal custom id match. TYPE: bool DEFAULT: False RETURNS DESCRIPTION Callable [[ CallbackSigT ], CallbackSigT ] A decorator to register the callback. RAISES DESCRIPTION KeyError If the custom_id is already registered. ComponentContext # The general context passed around for a component trigger. expires_at property # expires_at : datetime . datetime When this application command context expires. After this time is reached, the message/response methods on this context will always raise hikari.errors.NotFoundError . has_been_deferred property # has_been_deferred : bool Whether this context's initial response has been deferred. This will be true if yuyo.components.ComponentContext.defer has been called. has_responded property # has_responded : bool Whether an initial response has been made to this context yet. It's worth noting that a context must be either responded to or deferred within 3 seconds from it being received otherwise it'll be marked as failed. This will be true if either yuyo.components.ComponentContext.respond , yuyo.components.ComponentContext.create_initial_response or yuyo.components.ComponentContext.edit_initial_response (after a deferral) has been called. interaction property # interaction : hikari . ComponentInteraction Object of the interaction this context is for. create_followup async # create_followup ( content = hikari . UNDEFINED , * , delete_after = None , ephemeral = False , attachment = hikari . UNDEFINED , attachments = hikari . UNDEFINED , component = hikari . UNDEFINED , components = hikari . UNDEFINED , embed = hikari . UNDEFINED , embeds = hikari . UNDEFINED , mentions_everyone = hikari . UNDEFINED , user_mentions = hikari . UNDEFINED , role_mentions = hikari . UNDEFINED , tts = hikari . UNDEFINED , flags = hikari . UNDEFINED ) Create a followup response for this context. Warning Calling this on a context which hasn't had an initial response yet will lead to a hikari.errors.NotFoundError being raised. PARAMETER DESCRIPTION content If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED delete_after If provided, the seconds after which the response message should be deleted. Slash command responses can only be deleted within 15 minutes of the command being received. TYPE: typing . Union [ datetime . timedelta , float , int , None] DEFAULT: None ephemeral Whether the deferred response should be ephemeral. Passing True here is a shorthand for including 1 << 64 in the passed flags. TYPE: bool DEFAULT: False attachment If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL. TYPE: hikari . UndefinedOr [ hikari . Resourceish ] DEFAULT: hikari.UNDEFINED attachments If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs. TYPE: hikari . UndefinedOr [ collections . Sequence [ hikari . Resourceish ]] DEFAULT: hikari.UNDEFINED component If provided, builder object of the component to include in this message. TYPE: hikari . UndefinedOr [ hikari . api . ComponentBuilder ] DEFAULT: hikari.UNDEFINED components If provided, a sequence of the component builder objects to include in this message. TYPE: hikari . UndefinedOr [ collections . Sequence [ hikari . api . ComponentBuilder ]] DEFAULT: hikari.UNDEFINED embed If provided, the message embed. TYPE: hikari . UndefinedOr [ hikari . Embed ] DEFAULT: hikari.UNDEFINED embeds If provided, the message embeds. TYPE: hikari . UndefinedOr [ collections . Sequence [ hikari . Embed ]] DEFAULT: hikari.UNDEFINED mentions_everyone If provided, whether the message should parse @everyone/@here mentions. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED user_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialUser ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED role_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialRole ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED tts If provided, whether the message will be sent as a TTS message. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED flags The flags to set for this response. As of writing this can only flag which can be provided is EPHEMERAL, other flags are just ignored. TYPE: typing . Union [ hikari . UndefinedType , int , hikari . MessageFlag ] DEFAULT: hikari.UNDEFINED RETURNS DESCRIPTION hikari . Message The created message object. RAISES DESCRIPTION hikari . NotFoundError If the current interaction is not found or it hasn't had an initial response yet. hikari . BadRequestError This can be raised if the file is too large; if the embed exceeds the defined limits; if the message content is specified only and empty or greater than 2000 characters; if neither content, file or embeds are specified. If any invalid snowflake IDs are passed; a snowflake may be invalid due to it being outside of the range of a 64 bit integer. ValueError If more than 100 unique objects/entities are passed for role_mentions or `user_mentions. If the interaction will have expired before delete_after is reached. If both attachment and attachments are passed or both component and components are passed or both embed and embeds are passed. create_initial_response async # create_initial_response ( response_type , / , content = hikari . UNDEFINED , * , delete_after = None , ephemeral = False , attachment = hikari . UNDEFINED , attachments = hikari . UNDEFINED , component = hikari . UNDEFINED , components = hikari . UNDEFINED , embed = hikari . UNDEFINED , embeds = hikari . UNDEFINED , mentions_everyone = hikari . UNDEFINED , user_mentions = hikari . UNDEFINED , role_mentions = hikari . UNDEFINED , flags = hikari . UNDEFINED , tts = hikari . UNDEFINED ) Create the initial response for this context. Warning Calling this on a context which already has an initial response will result in this raising a hikari.errors.NotFoundError . This includes if the REST interaction server has already responded to the request and deferrals. PARAMETER DESCRIPTION response_type The type of message response to give. TYPE: hikari . MessageResponseTypesT content The content to edit the last response with. If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED delete_after If provided, the seconds after which the response message should be deleted. Slash command responses can only be deleted within 15 minutes of the command being received. TYPE: typing . Union [ datetime . timedelta , float , int , None] DEFAULT: None ephemeral Whether the deferred response should be ephemeral. Passing True here is a shorthand for including 1 << 64 in the passed flags. TYPE: bool DEFAULT: False content If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED attachment If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL. TYPE: hikari . UndefinedOr [ hikari . Resourceish ] DEFAULT: hikari.UNDEFINED attachments If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs. TYPE: hikari . UndefinedOr [ collections . Sequence [ hikari . Resourceish ]] DEFAULT: hikari.UNDEFINED component If provided, builder object of the component to include in this message. TYPE: hikari . UndefinedOr [ hikari . api . ComponentBuilder ] DEFAULT: hikari.UNDEFINED components If provided, a sequence of the component builder objects to include in this message. TYPE: hikari . UndefinedOr [ collections . Sequence [ hikari . api . ComponentBuilder ]] DEFAULT: hikari.UNDEFINED embed If provided, the message embed. TYPE: hikari . UndefinedOr [ hikari . Embed ] DEFAULT: hikari.UNDEFINED embeds If provided, the message embeds. TYPE: hikari . UndefinedOr [ collections . Sequence [ hikari . Embed ]] DEFAULT: hikari.UNDEFINED flags If provided, the message flags this response should have. As of writing the only message flag which can be set here is hikari.messages.MessageFlag.EPHEMERAL . TYPE: typing . Union [ int , hikari . MessageFlag , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED tts If provided, whether the message will be read out by a screen reader using Discord's TTS (text-to-speech) system. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED mentions_everyone If provided, whether the message should parse @everyone/@here mentions. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED user_mentions If provided, and True , all user mentions will be detected. If provided, and False , all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialUser ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED role_mentions If provided, and True , all role mentions will be detected. If provided, and False , all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of [hikari.snowflakes.Snowflake], or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialRole ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED RAISES DESCRIPTION ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions . If the interaction will have expired before delete_after is reached. If both attachment and attachments are passed or both component and components are passed or both embed and embeds are passed. hikari . BadRequestError This may be raised in several discrete situations, such as messages being empty with no embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; invalid image URLs in embeds. hikari . UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari . NotFoundError If the interaction is not found or if the interaction's initial response has already been created. hikari . RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request. hikari . RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari . InternalServerError If an internal error occurs on Discord while handling the request. defer async # defer ( defer_type , / , * , ephemeral = False , flags = hikari . UNDEFINED ) Defer the initial response for this context. Note The ephemeral state of the first response is decided by whether the deferral is ephemeral. PARAMETER DESCRIPTION defer_type The type of deferral this should be. This may any of the following * ResponseType.DEFERRED_MESSAGE_CREATE to indicate that the following up call to yuyo.components.ComponentContext.edit_initial_response or yuyo.components.ComponentContext.respond should create a new message. * ResponseType.DEFERRED_MESSAGE_UPDATE to indicate that the following call to the aforementioned methods should update the existing message. TYPE: hikari . DeferredResponseTypesT ephemeral Whether the deferred response should be ephemeral. Passing True here is a shorthand for including 1 << 64 in the passed flags. TYPE: bool DEFAULT: False flags The flags to use for the initial response. TYPE: typing . Union [ hikari . UndefinedType , int , hikari . MessageFlag ] DEFAULT: hikari.UNDEFINED delete_initial_response async # delete_initial_response () Delete the initial response after invoking this context. RAISES DESCRIPTION LookupError , hikari . NotFoundError The last context has no initial response. delete_last_response async # delete_last_response () Delete the last response after invoking this context. RAISES DESCRIPTION LookupError , hikari . NotFoundError The last context has no responses. edit_initial_response async # edit_initial_response ( content = hikari . UNDEFINED , * , delete_after = None , attachment = hikari . UNDEFINED , attachments = hikari . UNDEFINED , component = hikari . UNDEFINED , components = hikari . UNDEFINED , embed = hikari . UNDEFINED , embeds = hikari . UNDEFINED , mentions_everyone = hikari . UNDEFINED , user_mentions = hikari . UNDEFINED , role_mentions = hikari . UNDEFINED ) Edit the initial response for this context. PARAMETER DESCRIPTION content The content to edit the initial response with. If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED delete_after If provided, the seconds after which the response message should be deleted. Slash command responses can only be deleted within 15 minutes of the command being received. TYPE: typing . Union [ datetime . timedelta , float , int , None] DEFAULT: None attachment A singular attachment to edit the initial response with. TYPE: hikari . UndefinedNoneOr [ hikari . Resourceish ] DEFAULT: hikari.UNDEFINED attachments A sequence of attachments to edit the initial response with. TYPE: hikari . UndefinedNoneOr [ collections . Sequence [ hikari . Resourceish ]] DEFAULT: hikari.UNDEFINED component If provided, builder object of the component to set for this message. This component will replace any previously set components and passing None will remove all components. TYPE: hikari . UndefinedNoneOr [ hikari . api . ComponentBuilder ] DEFAULT: hikari.UNDEFINED components If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing None or an empty sequence will remove all components. TYPE: hikari . UndefinedNoneOr [ collections . Sequence [ hikari . api . ComponentBuilder ]] DEFAULT: hikari.UNDEFINED embed An embed to replace the initial response with. TYPE: hikari . UndefinedNoneOr [ hikari . Embed ] DEFAULT: hikari.UNDEFINED embeds A sequence of embeds to replace the initial response with. TYPE: hikari . UndefinedNoneOr [ collections . Sequence [ hikari . Embed ]] DEFAULT: hikari.UNDEFINED mentions_everyone If provided, whether the message should parse @everyone/@here mentions. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED user_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialUser ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED role_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialRole ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED RETURNS DESCRIPTION hikari . Message The message that has been edited. RAISES DESCRIPTION ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions . If delete_after would be more than 15 minutes after the slash command was called. If both attachment and attachments are passed or both component and components are passed or both embed and embeds are passed. hikari . BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components. hikari . UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari . ForbiddenError If you are missing the SEND_MESSAGES in the channel or the person you are trying to message has the DM's disabled. hikari . NotFoundError If the channel is not found. hikari . RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request. hikari . RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari . InternalServerError If an internal error occurs on Discord while handling the request. edit_last_response async # edit_last_response ( content = hikari . UNDEFINED , * , delete_after = None , attachment = hikari . UNDEFINED , attachments = hikari . UNDEFINED , component = hikari . UNDEFINED , components = hikari . UNDEFINED , embed = hikari . UNDEFINED , embeds = hikari . UNDEFINED , mentions_everyone = hikari . UNDEFINED , user_mentions = hikari . UNDEFINED , role_mentions = hikari . UNDEFINED ) Edit the last response for this context. PARAMETER DESCRIPTION content The content to edit the last response with. If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED delete_after If provided, the seconds after which the response message should be deleted. Slash command responses can only be deleted within 15 minutes of the command being received. TYPE: typing . Union [ datetime . timedelta , float , int , None] DEFAULT: None attachment A singular attachment to edit the last response with. TYPE: hikari . UndefinedNoneOr [ hikari . Resourceish ] DEFAULT: hikari.UNDEFINED attachments A sequence of attachments to edit the last response with. TYPE: hikari . UndefinedNoneOr [ collections . Sequence [ hikari . Resourceish ]] DEFAULT: hikari.UNDEFINED component If provided, builder object of the component to set for this message. This component will replace any previously set components and passing None will remove all components. TYPE: hikari . UndefinedNoneOr [ hikari . api . ComponentBuilder ] DEFAULT: hikari.UNDEFINED components If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing None or an empty sequence will remove all components. TYPE: hikari . UndefinedNoneOr [ collections . Sequence [ hikari . api . ComponentBuilder ]] DEFAULT: hikari.UNDEFINED embed An embed to replace the last response with. TYPE: hikari . UndefinedNoneOr [ hikari . Embed ] DEFAULT: hikari.UNDEFINED embeds A sequence of embeds to replace the last response with. TYPE: hikari . UndefinedNoneOr [ collections . Sequence [ hikari . Embed ]] DEFAULT: hikari.UNDEFINED mentions_everyone If provided, whether the message should parse @everyone/@here mentions. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED user_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialUser ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED role_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialRole ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED RETURNS DESCRIPTION hikari . Message The message that has been edited. RAISES DESCRIPTION ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions . If delete_after would be more than 15 minutes after the slash command was called. If both attachment and attachments are passed or both component and components are passed or both embed and embeds are passed. hikari . BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components. hikari . UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari . ForbiddenError If you are missing the SEND_MESSAGES in the channel or the person you are trying to message has the DM's disabled. hikari . NotFoundError If the channel is not found. hikari . RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request. hikari . RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari . InternalServerError If an internal error occurs on Discord while handling the request. fetch_initial_response async # fetch_initial_response () Fetch the initial response for this context. RETURNS DESCRIPTION hikari . messages . Message The initial response's message object. RAISES DESCRIPTION LookupError , hikari . NotFoundError The response was not found. fetch_last_response async # fetch_last_response () Fetch the last response for this context. RETURNS DESCRIPTION hikari . messages . Message The most response response's message object. RAISES DESCRIPTION LookupError , hikari . NotFoundError The response was not found. respond async # respond ( content = hikari . UNDEFINED , * , ensure_result = False , delete_after = None , attachment = hikari . UNDEFINED , attachments = hikari . UNDEFINED , component = hikari . UNDEFINED , components = hikari . UNDEFINED , embed = hikari . UNDEFINED , embeds = hikari . UNDEFINED , mentions_everyone = hikari . UNDEFINED , user_mentions = hikari . UNDEFINED , role_mentions = hikari . UNDEFINED ) Respond to this context. PARAMETER DESCRIPTION content The content to respond with. If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED ensure_result Ensure that this call will always return a message object. If True then this will always return hikari.messages.Message , otherwise this will return hikari.Message | None . It's worth noting that, under certain scenarios within the slash command flow, this may lead to an extre request being made. TYPE: bool DEFAULT: False delete_after If provided, the seconds after which the response message should be deleted. Slash command responses can only be deleted within 15 minutes of the command being received. TYPE: typing . Union [ datetime . timedelta , float , int , None] DEFAULT: None attachment If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL. TYPE: hikari . UndefinedOr [ hikari . Resourceish ] DEFAULT: hikari.UNDEFINED attachments If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs. TYPE: hikari . UndefinedOr [ collections . Sequence [ hikari . Resourceish ]] DEFAULT: hikari.UNDEFINED component If provided, builder object of the component to include in this response. TYPE: hikari . UndefinedOr [ hikari . api . ComponentBuilder ] DEFAULT: hikari.UNDEFINED components If provided, a sequence of the component builder objects to include in this response. TYPE: hikari . UndefinedOr [ collections . Sequence [ hikari . api . ComponentBuilder ]] DEFAULT: hikari.UNDEFINED embed An embed to respond with. TYPE: hikari . UndefinedOr [ hikari . Embed ] DEFAULT: hikari.UNDEFINED embeds A sequence of embeds to respond with. TYPE: hikari . UndefinedOr [ collections . Sequence [ hikari . Embed ]] DEFAULT: hikari.UNDEFINED mentions_everyone If provided, whether the message should parse @everyone/@here mentions. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED user_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialUser ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED role_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialRole ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED RETURNS DESCRIPTION hikari . Message | None The message that has been created if it was immedieatly available or ensure_result was set to True , else None . RAISES DESCRIPTION ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions . If delete_after would be more than 15 minutes after the slash command was called. If both attachment and attachments are passed or both component and components are passed or both embed and embeds are passed. hikari . BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components. hikari . UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari . ForbiddenError If you are missing the SEND_MESSAGES in the channel or the person you are trying to message has the DM's disabled. hikari . NotFoundError If the channel is not found. hikari . RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request. hikari . RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari . InternalServerError If an internal error occurs on Discord while handling the request. set_ephemeral_default # set_ephemeral_default ( state ) Set the ephemeral default state for this context. PARAMETER DESCRIPTION state The new ephemeral default state. If this is True then all calls to the response creating methods on this context will default to being ephemeral. TYPE: bool ComponentExecutor # Bases: AbstractComponentExecutor Basic implementation of a class used for handling the execution of a message component. __init__ # __init__ ( * , ephemeral_default = False , load_from_attributes = True , timeout = datetime . timedelta ( seconds = 30 )) Initialise a component executor. PARAMETER DESCRIPTION ephemeral_default Whether this executor's responses should default to being ephemeral. TYPE: bool DEFAULT: False timeout How long this component should last until its marked as timed out. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30) ComponentPaginator # Bases: ActionRowExecutor Standard implementation of an action row executor used for pagination. This is a convenience class that allows you to easily implement a paginator. __init__ # __init__ ( iterator , * , authors , ephemeral_default = False , triggers = ( pagination . LEFT_TRIANGLE , pagination . STOP_SQUARE , pagination . RIGHT_TRIANGLE ), load_from_attributes = False , timeout = datetime . timedelta ( seconds = 30 )) Initialise a component paginator. PARAMETER DESCRIPTION iterator The iterator to paginate. This should be an iterator of tuples of (hikari.UndefinedOr[str], hikari.UndefinedOr[hikari.Embed]) . TYPE: collections . Iterator [ yuyo . pagination . EntryT ] | collections . AsyncIterator [ yuyo . pagination . EntryT ] authors The authors of the entries. If None is passed here then the paginator will be public (meaning that anybody can use it). TYPE: typing . Optional [ collections . Iterable [ hikari . SnowflakeishOr [ hikari . User ]]] ephemeral_default Whether or not the responses made on contexts spawned from this paginator should default to ephemeral (meaning only the author can see them) unless flags is specified on the response method. TYPE: bool DEFAULT: False triggers Collection of the unicode emojis that should trigger this paginator. As of current the only usable emojis are yuyo.pagination.LEFT_TRIANGLE , yuyo.pagination.RIGHT_TRIANGLE , yuyo.pagination.STOP_SQUARE , yuyo.pagination.LEFT_DOUBLE_TRIANGLE and yuyo.pagination.LEFT_TRIANGLE . TYPE: collections . Collection [ str ] DEFAULT: (pagination.LEFT_TRIANGLE, pagination.STOP_SQUARE, pagination.RIGHT_TRIANGLE) timeout The amount of time to wait after the component's last execution or creation until it times out. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30) builder # builder () Get a sequence of the component builders for this paginator. RETURNS DESCRIPTION collections . abc . Sequence [ hikari . api . ComponentBuilder ] The component builders for this paginator. get_next_entry async # get_next_entry () Get the next entry in this paginator. This is generally helpful for making the message which the paginator will be based off and will still internally store the entry and increment the position of the paginator. Examples: response_paginator = yuyo . ComponentPaginator ( pages , authors = ( ctx . author . id ,) ) first_response = await response_paginator . get_next_entry () assert first_response content , embed = first_response message = await ctx . respond ( content = content , embed = embed , component = response_paginator , ensure_result = True ) component_client . set_executor ( message , response_paginator ) RETURNS DESCRIPTION yuyo . pagination . EntryT | None The next entry in this paginator, or None if there are no more entries. ExecutorClosed # Bases: Exception Error used to indicate that an executor is now closed during execution. MultiComponentExecutor # Bases: AbstractComponentExecutor Multi-component implementation of a component executor. This implementation allows for multiple components to be executed as a single view. builders property # builders : collections . Sequence [ hikari . api . ComponentBuilder ] Sequence of the component builders within this executor. executors property # executors : collections . Sequence [ AbstractComponentExecutor ] Sequence of the child executors within this multi-executor. __init__ # __init__ ( * , load_from_attributes = False , timeout = datetime . timedelta ( seconds = 30 )) Initialise a multi-component executor. PARAMETER DESCRIPTION timeout The amount of time to wait after the component's last execution or creation until it times out. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30) add_action_row # add_action_row () Create a builder class to add an action row to this executor. For the most part this follows the same implementation as yuyo.components.ActionRowExecutor except with the added detail that yuyo.components.ChildActionRowExecutor.add_to_parent must be called to add the action row to the parent executor. RETURNS DESCRIPTION ChildActionRowExecutor [ Self ] A builder class to add an action row to this executor. yuyo.components.ChildActionRowExecutor.add_to_parent should be called to finalise the action row and will return the parent executor for chained calls. add_builder # add_builder ( builder ) Add a non-executable component builder to this executor. This is useful for adding components that are not meant to be executed, such as a a row of link buttons. PARAMETER DESCRIPTION builder The component builder to add. TYPE: hikari . api . ComponentBuilder RETURNS DESCRIPTION Self add_executor # add_executor ( executor ) Add a component executor to this multi-component executor. This method is internally used by the add_{component} methods. PARAMETER DESCRIPTION executor The component executor to add. TYPE: AbstractComponentExecutor RETURNS DESCRIPTION Self The multi-component executor instance to enable chained calls. WaitForExecutor # Bases: AbstractComponentExecutor Component executor used to wait for a single component interaction. Examples: responses : dict [ str , str ] message = await ctx . respond ( \"hi, pick an option\" , components = [ ... ]) executor = yuyo . components . WaitFor ( authors = ( ctx . author . id ,), timeout = datetime . timedelta ( seconds = 30 )) component_client . set_executor ( message . id , executor ) try : result = await executor . wait_for () except asyncio . TimeoutError : await ctx . respond ( \"timed out\" ) else : await result . respond ( responses [ result . interaction . custom_id ]) __init__ # __init__ ( * , authors , ephemeral_default = False , timeout ) Initialise a wait for executor. PARAMETER DESCRIPTION authors The authors of the entries. If None is passed here then the paginator will be public (meaning that anybody can use it). TYPE: typing . Optional [ collections . Iterable [ hikari . SnowflakeishOr [ hikari . User ]]] ephemeral_default Whether or not the responses made on contexts spawned from this paginator should default to ephemeral (meaning only the author can see them) unless flags is specified on the response method. TYPE: bool DEFAULT: False timeout How long this should wait for a matching component interaction until it times-out. TYPE: datetime . timedelta wait_for async # wait_for () Wait for the next matching interaction. RETURNS DESCRIPTION ComponentContext The next matching interaction. RAISES DESCRIPTION RuntimeError If the executor is already being waited for. asyncio . TimeoutError If the timeout is reached.","title":"yuyo.components"},{"location":"reference/components/#yuyocomponents","text":"Higher level client for callback based component execution.","title":"yuyo.components"},{"location":"reference/components/#yuyo.components.WaitFor","text":"WaitFor = WaitForExecutor Alias of yuyo.components.WaitForExecutor .","title":"WaitFor"},{"location":"reference/components/#yuyo.components.AbstractComponentExecutor","text":"Bases: abc . ABC Abstract interface of an object which handles the execution of a message component.","title":"AbstractComponentExecutor"},{"location":"reference/components/#yuyo.components.AbstractComponentExecutor.custom_ids","text":"custom_ids : collections . Collection [ str ] Collection of the custom IDs this executor is listening for.","title":"custom_ids"},{"location":"reference/components/#yuyo.components.AbstractComponentExecutor.has_expired","text":"has_expired : bool Whether this executor has ended.","title":"has_expired"},{"location":"reference/components/#yuyo.components.ActionRowExecutor","text":"Bases: ComponentExecutor , hikari . api . ComponentBuilder Class used for handling the execution of an action row.","title":"ActionRowExecutor"},{"location":"reference/components/#yuyo.components.ActionRowExecutor.__init__","text":"__init__ ( * , ephemeral_default = False , load_from_attributes = False , timeout = datetime . timedelta ( seconds = 30 )) Initialise an action row executor. PARAMETER DESCRIPTION ephemeral_default Whether this executor's responses should default to being ephemeral. TYPE: bool DEFAULT: False timeout How long this component should last until its marked as timed out. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30)","title":"__init__()"},{"location":"reference/components/#yuyo.components.ChildActionRowExecutor","text":"Bases: ActionRowExecutor , typing . Generic [ _ParentExecutorProtoT ] Extended action row implementation which can be tied to a multi-component executor.","title":"ChildActionRowExecutor"},{"location":"reference/components/#yuyo.components.ChildActionRowExecutor.add_to_parent","text":"add_to_parent () Add this action row to its parent executor. RETURNS DESCRIPTION _ParentExecutorProtoT The parent executor this action row was added to.","title":"add_to_parent()"},{"location":"reference/components/#yuyo.components.ComponentClient","text":"Client used to handle component executors within a REST or gateway flow.","title":"ComponentClient"},{"location":"reference/components/#yuyo.components.ComponentClient.alluka","text":"alluka : alluka_ . abc . Client The Alluka client being used for callback dependency injection.","title":"alluka"},{"location":"reference/components/#yuyo.components.ComponentClient.__init__","text":"__init__ ( * , alluka = None , event_manager = None , event_managed = None , server = None ) Initialise a component client. Note For an easier way to initialise the client from a bot see yuyo.components.ComponentClient.from_gateway_bot and yuyo.components.ComponentClient.from_rest_bot . PARAMETER DESCRIPTION alluka The Alluka client to use for callback dependency injection in this client. If not provided then this will initialise its own Alluka client. TYPE: typing . Optional [ alluka_ . abc . Client ] DEFAULT: None event_manager The event manager this client should listen to dispatched component interactions from if applicable. TYPE: typing . Optional [ hikari . api . EventManager ] DEFAULT: None event_managed Whether this client should be automatically opened and closed based on the lifetime events dispatched by event_manager . Defaults to True if an event manager is passed. TYPE: typing . Optional [ bool ] DEFAULT: None server The server this client should listen to component interactions from if applicable. TYPE: typing . Optional [ hikari . api . InteractionServer ] DEFAULT: None RAISES DESCRIPTION ValueError If event_managed is passed as True when event_manager is None .","title":"__init__()"},{"location":"reference/components/#yuyo.components.ComponentClient.add_executor","text":"add_executor ( message , executor ) Deprecated alias of yuyo.components.ComponentClient.add_executor .","title":"add_executor()"},{"location":"reference/components/#yuyo.components.ComponentClient.close","text":"close () Close the component client.","title":"close()"},{"location":"reference/components/#yuyo.components.ComponentClient.from_gateway_bot","text":"from_gateway_bot ( bot , / , * , event_managed = True ) Build a component client froma Gateway Bot. PARAMETER DESCRIPTION bot The Gateway bot this component client should be bound to. TYPE: hikari . GatewayBotAware event_managed Whether the component client should be automatically opened and closed based on the lifetime events dispatched by bot . TYPE: bool DEFAULT: True RETURNS DESCRIPTION ComponentClient The initialised component client.","title":"from_gateway_bot()"},{"location":"reference/components/#yuyo.components.ComponentClient.from_rest_bot","text":"from_rest_bot ( bot ) Build a component client froma REST Bot. PARAMETER DESCRIPTION bot The REST bot this component client should be bound to. TYPE: hikari . RESTBotAware RETURNS DESCRIPTION ComponentClient The initialised component client.","title":"from_rest_bot()"},{"location":"reference/components/#yuyo.components.ComponentClient.get_constant_id","text":"get_constant_id ( custom_id ) Get a set constant \"custom_id\" callback. PARAMETER DESCRIPTION custom_id The custom_id to get the callback for. TYPE: str RETURNS DESCRIPTION CallbackSig | None The callback for the custom_id, or None if it doesn't exist.","title":"get_constant_id()"},{"location":"reference/components/#yuyo.components.ComponentClient.get_executor","text":"get_executor ( message ) Get the component executor set for a message. PARAMETER DESCRIPTION message The message to get the executor for. TYPE: hikari . SnowflakeishOr [ hikari . Message ] RETURNS DESCRIPTION yuyo . components . AbstractComponentExecutor | None The executor set for the message or None if none is set.","title":"get_executor()"},{"location":"reference/components/#yuyo.components.ComponentClient.open","text":"open () Startup the component client.","title":"open()"},{"location":"reference/components/#yuyo.components.ComponentClient.remove_constant_id","text":"remove_constant_id ( custom_id ) Remove a constant \"custom_id\" callback. PARAMETER DESCRIPTION custom_id The custom_id to remove the callback for. TYPE: str RETURNS DESCRIPTION Self The component client to allow chaining. RAISES DESCRIPTION KeyError If the custom_id is not registered.","title":"remove_constant_id()"},{"location":"reference/components/#yuyo.components.ComponentClient.remove_executor","text":"remove_executor ( message ) Remove the component executor for a message. PARAMETER DESCRIPTION message The message to remove the executor for. TYPE: hikari . SnowflakeishOr [ hikari . Message ] RETURNS DESCRIPTION Self The component client to allow chaining.","title":"remove_executor()"},{"location":"reference/components/#yuyo.components.ComponentClient.set_constant_id","text":"set_constant_id ( custom_id , callback , / , * , prefix_match = False ) Add a constant \"custom_id\" callback. These are callbacks which'll always be called for a specific custom_id while taking priority over executors. PARAMETER DESCRIPTION custom_id The custom_id to register the callback for. TYPE: str callback The callback to register. This should take a single argument of type yuyo.components.ComponentContext , be asynchronous and return None . TYPE: CallbackSig prefix_match Whether the custom_id should be treated as a prefix match. This allows for further state to be held in the custom id after the prefix and is lower priority than normal custom id match. TYPE: bool DEFAULT: False RETURNS DESCRIPTION Self The component client to allow chaining. RAISES DESCRIPTION ValueError If the custom_id is already registered.","title":"set_constant_id()"},{"location":"reference/components/#yuyo.components.ComponentClient.set_executor","text":"set_executor ( message , executor ) Set the component executor for a message. PARAMETER DESCRIPTION message The message to set the executor for. TYPE: hikari . SnowflakeishOr [ hikari . Message ] executor The executor to set. This will be called for every component interaction for the message unless the component's custom_id is registered as a constant id callback. TYPE: AbstractComponentExecutor RETURNS DESCRIPTION Self The component client to allow chaining.","title":"set_executor()"},{"location":"reference/components/#yuyo.components.ComponentClient.with_constant_id","text":"with_constant_id ( custom_id , / , * , prefix_match = False ) Add a constant \"custom_id\" callback through a decorator call. These are callbacks which'll always be called for a specific custom_id while taking priority over executors. PARAMETER DESCRIPTION custom_id The custom_id to register the callback for. TYPE: str prefix_match Whether the custom_id should be treated as a prefix match. This allows for further state to be held in the custom id after the prefix and is lower priority than normal custom id match. TYPE: bool DEFAULT: False RETURNS DESCRIPTION Callable [[ CallbackSigT ], CallbackSigT ] A decorator to register the callback. RAISES DESCRIPTION KeyError If the custom_id is already registered.","title":"with_constant_id()"},{"location":"reference/components/#yuyo.components.ComponentContext","text":"The general context passed around for a component trigger.","title":"ComponentContext"},{"location":"reference/components/#yuyo.components.ComponentContext.expires_at","text":"expires_at : datetime . datetime When this application command context expires. After this time is reached, the message/response methods on this context will always raise hikari.errors.NotFoundError .","title":"expires_at"},{"location":"reference/components/#yuyo.components.ComponentContext.has_been_deferred","text":"has_been_deferred : bool Whether this context's initial response has been deferred. This will be true if yuyo.components.ComponentContext.defer has been called.","title":"has_been_deferred"},{"location":"reference/components/#yuyo.components.ComponentContext.has_responded","text":"has_responded : bool Whether an initial response has been made to this context yet. It's worth noting that a context must be either responded to or deferred within 3 seconds from it being received otherwise it'll be marked as failed. This will be true if either yuyo.components.ComponentContext.respond , yuyo.components.ComponentContext.create_initial_response or yuyo.components.ComponentContext.edit_initial_response (after a deferral) has been called.","title":"has_responded"},{"location":"reference/components/#yuyo.components.ComponentContext.interaction","text":"interaction : hikari . ComponentInteraction Object of the interaction this context is for.","title":"interaction"},{"location":"reference/components/#yuyo.components.ComponentContext.create_followup","text":"create_followup ( content = hikari . UNDEFINED , * , delete_after = None , ephemeral = False , attachment = hikari . UNDEFINED , attachments = hikari . UNDEFINED , component = hikari . UNDEFINED , components = hikari . UNDEFINED , embed = hikari . UNDEFINED , embeds = hikari . UNDEFINED , mentions_everyone = hikari . UNDEFINED , user_mentions = hikari . UNDEFINED , role_mentions = hikari . UNDEFINED , tts = hikari . UNDEFINED , flags = hikari . UNDEFINED ) Create a followup response for this context. Warning Calling this on a context which hasn't had an initial response yet will lead to a hikari.errors.NotFoundError being raised. PARAMETER DESCRIPTION content If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED delete_after If provided, the seconds after which the response message should be deleted. Slash command responses can only be deleted within 15 minutes of the command being received. TYPE: typing . Union [ datetime . timedelta , float , int , None] DEFAULT: None ephemeral Whether the deferred response should be ephemeral. Passing True here is a shorthand for including 1 << 64 in the passed flags. TYPE: bool DEFAULT: False attachment If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL. TYPE: hikari . UndefinedOr [ hikari . Resourceish ] DEFAULT: hikari.UNDEFINED attachments If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs. TYPE: hikari . UndefinedOr [ collections . Sequence [ hikari . Resourceish ]] DEFAULT: hikari.UNDEFINED component If provided, builder object of the component to include in this message. TYPE: hikari . UndefinedOr [ hikari . api . ComponentBuilder ] DEFAULT: hikari.UNDEFINED components If provided, a sequence of the component builder objects to include in this message. TYPE: hikari . UndefinedOr [ collections . Sequence [ hikari . api . ComponentBuilder ]] DEFAULT: hikari.UNDEFINED embed If provided, the message embed. TYPE: hikari . UndefinedOr [ hikari . Embed ] DEFAULT: hikari.UNDEFINED embeds If provided, the message embeds. TYPE: hikari . UndefinedOr [ collections . Sequence [ hikari . Embed ]] DEFAULT: hikari.UNDEFINED mentions_everyone If provided, whether the message should parse @everyone/@here mentions. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED user_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialUser ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED role_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialRole ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED tts If provided, whether the message will be sent as a TTS message. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED flags The flags to set for this response. As of writing this can only flag which can be provided is EPHEMERAL, other flags are just ignored. TYPE: typing . Union [ hikari . UndefinedType , int , hikari . MessageFlag ] DEFAULT: hikari.UNDEFINED RETURNS DESCRIPTION hikari . Message The created message object. RAISES DESCRIPTION hikari . NotFoundError If the current interaction is not found or it hasn't had an initial response yet. hikari . BadRequestError This can be raised if the file is too large; if the embed exceeds the defined limits; if the message content is specified only and empty or greater than 2000 characters; if neither content, file or embeds are specified. If any invalid snowflake IDs are passed; a snowflake may be invalid due to it being outside of the range of a 64 bit integer. ValueError If more than 100 unique objects/entities are passed for role_mentions or `user_mentions. If the interaction will have expired before delete_after is reached. If both attachment and attachments are passed or both component and components are passed or both embed and embeds are passed.","title":"create_followup()"},{"location":"reference/components/#yuyo.components.ComponentContext.create_initial_response","text":"create_initial_response ( response_type , / , content = hikari . UNDEFINED , * , delete_after = None , ephemeral = False , attachment = hikari . UNDEFINED , attachments = hikari . UNDEFINED , component = hikari . UNDEFINED , components = hikari . UNDEFINED , embed = hikari . UNDEFINED , embeds = hikari . UNDEFINED , mentions_everyone = hikari . UNDEFINED , user_mentions = hikari . UNDEFINED , role_mentions = hikari . UNDEFINED , flags = hikari . UNDEFINED , tts = hikari . UNDEFINED ) Create the initial response for this context. Warning Calling this on a context which already has an initial response will result in this raising a hikari.errors.NotFoundError . This includes if the REST interaction server has already responded to the request and deferrals. PARAMETER DESCRIPTION response_type The type of message response to give. TYPE: hikari . MessageResponseTypesT content The content to edit the last response with. If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED delete_after If provided, the seconds after which the response message should be deleted. Slash command responses can only be deleted within 15 minutes of the command being received. TYPE: typing . Union [ datetime . timedelta , float , int , None] DEFAULT: None ephemeral Whether the deferred response should be ephemeral. Passing True here is a shorthand for including 1 << 64 in the passed flags. TYPE: bool DEFAULT: False content If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED attachment If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL. TYPE: hikari . UndefinedOr [ hikari . Resourceish ] DEFAULT: hikari.UNDEFINED attachments If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs. TYPE: hikari . UndefinedOr [ collections . Sequence [ hikari . Resourceish ]] DEFAULT: hikari.UNDEFINED component If provided, builder object of the component to include in this message. TYPE: hikari . UndefinedOr [ hikari . api . ComponentBuilder ] DEFAULT: hikari.UNDEFINED components If provided, a sequence of the component builder objects to include in this message. TYPE: hikari . UndefinedOr [ collections . Sequence [ hikari . api . ComponentBuilder ]] DEFAULT: hikari.UNDEFINED embed If provided, the message embed. TYPE: hikari . UndefinedOr [ hikari . Embed ] DEFAULT: hikari.UNDEFINED embeds If provided, the message embeds. TYPE: hikari . UndefinedOr [ collections . Sequence [ hikari . Embed ]] DEFAULT: hikari.UNDEFINED flags If provided, the message flags this response should have. As of writing the only message flag which can be set here is hikari.messages.MessageFlag.EPHEMERAL . TYPE: typing . Union [ int , hikari . MessageFlag , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED tts If provided, whether the message will be read out by a screen reader using Discord's TTS (text-to-speech) system. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED mentions_everyone If provided, whether the message should parse @everyone/@here mentions. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED user_mentions If provided, and True , all user mentions will be detected. If provided, and False , all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialUser ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED role_mentions If provided, and True , all role mentions will be detected. If provided, and False , all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of [hikari.snowflakes.Snowflake], or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialRole ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED RAISES DESCRIPTION ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions . If the interaction will have expired before delete_after is reached. If both attachment and attachments are passed or both component and components are passed or both embed and embeds are passed. hikari . BadRequestError This may be raised in several discrete situations, such as messages being empty with no embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; invalid image URLs in embeds. hikari . UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari . NotFoundError If the interaction is not found or if the interaction's initial response has already been created. hikari . RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request. hikari . RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari . InternalServerError If an internal error occurs on Discord while handling the request.","title":"create_initial_response()"},{"location":"reference/components/#yuyo.components.ComponentContext.defer","text":"defer ( defer_type , / , * , ephemeral = False , flags = hikari . UNDEFINED ) Defer the initial response for this context. Note The ephemeral state of the first response is decided by whether the deferral is ephemeral. PARAMETER DESCRIPTION defer_type The type of deferral this should be. This may any of the following * ResponseType.DEFERRED_MESSAGE_CREATE to indicate that the following up call to yuyo.components.ComponentContext.edit_initial_response or yuyo.components.ComponentContext.respond should create a new message. * ResponseType.DEFERRED_MESSAGE_UPDATE to indicate that the following call to the aforementioned methods should update the existing message. TYPE: hikari . DeferredResponseTypesT ephemeral Whether the deferred response should be ephemeral. Passing True here is a shorthand for including 1 << 64 in the passed flags. TYPE: bool DEFAULT: False flags The flags to use for the initial response. TYPE: typing . Union [ hikari . UndefinedType , int , hikari . MessageFlag ] DEFAULT: hikari.UNDEFINED","title":"defer()"},{"location":"reference/components/#yuyo.components.ComponentContext.delete_initial_response","text":"delete_initial_response () Delete the initial response after invoking this context. RAISES DESCRIPTION LookupError , hikari . NotFoundError The last context has no initial response.","title":"delete_initial_response()"},{"location":"reference/components/#yuyo.components.ComponentContext.delete_last_response","text":"delete_last_response () Delete the last response after invoking this context. RAISES DESCRIPTION LookupError , hikari . NotFoundError The last context has no responses.","title":"delete_last_response()"},{"location":"reference/components/#yuyo.components.ComponentContext.edit_initial_response","text":"edit_initial_response ( content = hikari . UNDEFINED , * , delete_after = None , attachment = hikari . UNDEFINED , attachments = hikari . UNDEFINED , component = hikari . UNDEFINED , components = hikari . UNDEFINED , embed = hikari . UNDEFINED , embeds = hikari . UNDEFINED , mentions_everyone = hikari . UNDEFINED , user_mentions = hikari . UNDEFINED , role_mentions = hikari . UNDEFINED ) Edit the initial response for this context. PARAMETER DESCRIPTION content The content to edit the initial response with. If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED delete_after If provided, the seconds after which the response message should be deleted. Slash command responses can only be deleted within 15 minutes of the command being received. TYPE: typing . Union [ datetime . timedelta , float , int , None] DEFAULT: None attachment A singular attachment to edit the initial response with. TYPE: hikari . UndefinedNoneOr [ hikari . Resourceish ] DEFAULT: hikari.UNDEFINED attachments A sequence of attachments to edit the initial response with. TYPE: hikari . UndefinedNoneOr [ collections . Sequence [ hikari . Resourceish ]] DEFAULT: hikari.UNDEFINED component If provided, builder object of the component to set for this message. This component will replace any previously set components and passing None will remove all components. TYPE: hikari . UndefinedNoneOr [ hikari . api . ComponentBuilder ] DEFAULT: hikari.UNDEFINED components If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing None or an empty sequence will remove all components. TYPE: hikari . UndefinedNoneOr [ collections . Sequence [ hikari . api . ComponentBuilder ]] DEFAULT: hikari.UNDEFINED embed An embed to replace the initial response with. TYPE: hikari . UndefinedNoneOr [ hikari . Embed ] DEFAULT: hikari.UNDEFINED embeds A sequence of embeds to replace the initial response with. TYPE: hikari . UndefinedNoneOr [ collections . Sequence [ hikari . Embed ]] DEFAULT: hikari.UNDEFINED mentions_everyone If provided, whether the message should parse @everyone/@here mentions. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED user_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialUser ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED role_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialRole ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED RETURNS DESCRIPTION hikari . Message The message that has been edited. RAISES DESCRIPTION ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions . If delete_after would be more than 15 minutes after the slash command was called. If both attachment and attachments are passed or both component and components are passed or both embed and embeds are passed. hikari . BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components. hikari . UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari . ForbiddenError If you are missing the SEND_MESSAGES in the channel or the person you are trying to message has the DM's disabled. hikari . NotFoundError If the channel is not found. hikari . RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request. hikari . RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari . InternalServerError If an internal error occurs on Discord while handling the request.","title":"edit_initial_response()"},{"location":"reference/components/#yuyo.components.ComponentContext.edit_last_response","text":"edit_last_response ( content = hikari . UNDEFINED , * , delete_after = None , attachment = hikari . UNDEFINED , attachments = hikari . UNDEFINED , component = hikari . UNDEFINED , components = hikari . UNDEFINED , embed = hikari . UNDEFINED , embeds = hikari . UNDEFINED , mentions_everyone = hikari . UNDEFINED , user_mentions = hikari . UNDEFINED , role_mentions = hikari . UNDEFINED ) Edit the last response for this context. PARAMETER DESCRIPTION content The content to edit the last response with. If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED delete_after If provided, the seconds after which the response message should be deleted. Slash command responses can only be deleted within 15 minutes of the command being received. TYPE: typing . Union [ datetime . timedelta , float , int , None] DEFAULT: None attachment A singular attachment to edit the last response with. TYPE: hikari . UndefinedNoneOr [ hikari . Resourceish ] DEFAULT: hikari.UNDEFINED attachments A sequence of attachments to edit the last response with. TYPE: hikari . UndefinedNoneOr [ collections . Sequence [ hikari . Resourceish ]] DEFAULT: hikari.UNDEFINED component If provided, builder object of the component to set for this message. This component will replace any previously set components and passing None will remove all components. TYPE: hikari . UndefinedNoneOr [ hikari . api . ComponentBuilder ] DEFAULT: hikari.UNDEFINED components If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing None or an empty sequence will remove all components. TYPE: hikari . UndefinedNoneOr [ collections . Sequence [ hikari . api . ComponentBuilder ]] DEFAULT: hikari.UNDEFINED embed An embed to replace the last response with. TYPE: hikari . UndefinedNoneOr [ hikari . Embed ] DEFAULT: hikari.UNDEFINED embeds A sequence of embeds to replace the last response with. TYPE: hikari . UndefinedNoneOr [ collections . Sequence [ hikari . Embed ]] DEFAULT: hikari.UNDEFINED mentions_everyone If provided, whether the message should parse @everyone/@here mentions. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED user_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialUser ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED role_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialRole ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED RETURNS DESCRIPTION hikari . Message The message that has been edited. RAISES DESCRIPTION ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions . If delete_after would be more than 15 minutes after the slash command was called. If both attachment and attachments are passed or both component and components are passed or both embed and embeds are passed. hikari . BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components. hikari . UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari . ForbiddenError If you are missing the SEND_MESSAGES in the channel or the person you are trying to message has the DM's disabled. hikari . NotFoundError If the channel is not found. hikari . RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request. hikari . RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari . InternalServerError If an internal error occurs on Discord while handling the request.","title":"edit_last_response()"},{"location":"reference/components/#yuyo.components.ComponentContext.fetch_initial_response","text":"fetch_initial_response () Fetch the initial response for this context. RETURNS DESCRIPTION hikari . messages . Message The initial response's message object. RAISES DESCRIPTION LookupError , hikari . NotFoundError The response was not found.","title":"fetch_initial_response()"},{"location":"reference/components/#yuyo.components.ComponentContext.fetch_last_response","text":"fetch_last_response () Fetch the last response for this context. RETURNS DESCRIPTION hikari . messages . Message The most response response's message object. RAISES DESCRIPTION LookupError , hikari . NotFoundError The response was not found.","title":"fetch_last_response()"},{"location":"reference/components/#yuyo.components.ComponentContext.respond","text":"respond ( content = hikari . UNDEFINED , * , ensure_result = False , delete_after = None , attachment = hikari . UNDEFINED , attachments = hikari . UNDEFINED , component = hikari . UNDEFINED , components = hikari . UNDEFINED , embed = hikari . UNDEFINED , embeds = hikari . UNDEFINED , mentions_everyone = hikari . UNDEFINED , user_mentions = hikari . UNDEFINED , role_mentions = hikari . UNDEFINED ) Respond to this context. PARAMETER DESCRIPTION content The content to respond with. If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. TYPE: hikari . UndefinedOr [ typing . Any ] DEFAULT: hikari.UNDEFINED ensure_result Ensure that this call will always return a message object. If True then this will always return hikari.messages.Message , otherwise this will return hikari.Message | None . It's worth noting that, under certain scenarios within the slash command flow, this may lead to an extre request being made. TYPE: bool DEFAULT: False delete_after If provided, the seconds after which the response message should be deleted. Slash command responses can only be deleted within 15 minutes of the command being received. TYPE: typing . Union [ datetime . timedelta , float , int , None] DEFAULT: None attachment If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL. TYPE: hikari . UndefinedOr [ hikari . Resourceish ] DEFAULT: hikari.UNDEFINED attachments If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs. TYPE: hikari . UndefinedOr [ collections . Sequence [ hikari . Resourceish ]] DEFAULT: hikari.UNDEFINED component If provided, builder object of the component to include in this response. TYPE: hikari . UndefinedOr [ hikari . api . ComponentBuilder ] DEFAULT: hikari.UNDEFINED components If provided, a sequence of the component builder objects to include in this response. TYPE: hikari . UndefinedOr [ collections . Sequence [ hikari . api . ComponentBuilder ]] DEFAULT: hikari.UNDEFINED embed An embed to respond with. TYPE: hikari . UndefinedOr [ hikari . Embed ] DEFAULT: hikari.UNDEFINED embeds A sequence of embeds to respond with. TYPE: hikari . UndefinedOr [ collections . Sequence [ hikari . Embed ]] DEFAULT: hikari.UNDEFINED mentions_everyone If provided, whether the message should parse @everyone/@here mentions. TYPE: hikari . UndefinedOr [ bool ] DEFAULT: hikari.UNDEFINED user_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialUser ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED role_mentions If provided, and True , all mentions will be parsed. If provided, and False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. TYPE: typing . Union [ hikari . SnowflakeishSequence [ hikari . PartialRole ], bool , hikari . UndefinedType ] DEFAULT: hikari.UNDEFINED RETURNS DESCRIPTION hikari . Message | None The message that has been created if it was immedieatly available or ensure_result was set to True , else None . RAISES DESCRIPTION ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions . If delete_after would be more than 15 minutes after the slash command was called. If both attachment and attachments are passed or both component and components are passed or both embed and embeds are passed. hikari . BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components. hikari . UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari . ForbiddenError If you are missing the SEND_MESSAGES in the channel or the person you are trying to message has the DM's disabled. hikari . NotFoundError If the channel is not found. hikari . RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request. hikari . RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari . InternalServerError If an internal error occurs on Discord while handling the request.","title":"respond()"},{"location":"reference/components/#yuyo.components.ComponentContext.set_ephemeral_default","text":"set_ephemeral_default ( state ) Set the ephemeral default state for this context. PARAMETER DESCRIPTION state The new ephemeral default state. If this is True then all calls to the response creating methods on this context will default to being ephemeral. TYPE: bool","title":"set_ephemeral_default()"},{"location":"reference/components/#yuyo.components.ComponentExecutor","text":"Bases: AbstractComponentExecutor Basic implementation of a class used for handling the execution of a message component.","title":"ComponentExecutor"},{"location":"reference/components/#yuyo.components.ComponentExecutor.__init__","text":"__init__ ( * , ephemeral_default = False , load_from_attributes = True , timeout = datetime . timedelta ( seconds = 30 )) Initialise a component executor. PARAMETER DESCRIPTION ephemeral_default Whether this executor's responses should default to being ephemeral. TYPE: bool DEFAULT: False timeout How long this component should last until its marked as timed out. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30)","title":"__init__()"},{"location":"reference/components/#yuyo.components.ComponentPaginator","text":"Bases: ActionRowExecutor Standard implementation of an action row executor used for pagination. This is a convenience class that allows you to easily implement a paginator.","title":"ComponentPaginator"},{"location":"reference/components/#yuyo.components.ComponentPaginator.__init__","text":"__init__ ( iterator , * , authors , ephemeral_default = False , triggers = ( pagination . LEFT_TRIANGLE , pagination . STOP_SQUARE , pagination . RIGHT_TRIANGLE ), load_from_attributes = False , timeout = datetime . timedelta ( seconds = 30 )) Initialise a component paginator. PARAMETER DESCRIPTION iterator The iterator to paginate. This should be an iterator of tuples of (hikari.UndefinedOr[str], hikari.UndefinedOr[hikari.Embed]) . TYPE: collections . Iterator [ yuyo . pagination . EntryT ] | collections . AsyncIterator [ yuyo . pagination . EntryT ] authors The authors of the entries. If None is passed here then the paginator will be public (meaning that anybody can use it). TYPE: typing . Optional [ collections . Iterable [ hikari . SnowflakeishOr [ hikari . User ]]] ephemeral_default Whether or not the responses made on contexts spawned from this paginator should default to ephemeral (meaning only the author can see them) unless flags is specified on the response method. TYPE: bool DEFAULT: False triggers Collection of the unicode emojis that should trigger this paginator. As of current the only usable emojis are yuyo.pagination.LEFT_TRIANGLE , yuyo.pagination.RIGHT_TRIANGLE , yuyo.pagination.STOP_SQUARE , yuyo.pagination.LEFT_DOUBLE_TRIANGLE and yuyo.pagination.LEFT_TRIANGLE . TYPE: collections . Collection [ str ] DEFAULT: (pagination.LEFT_TRIANGLE, pagination.STOP_SQUARE, pagination.RIGHT_TRIANGLE) timeout The amount of time to wait after the component's last execution or creation until it times out. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30)","title":"__init__()"},{"location":"reference/components/#yuyo.components.ComponentPaginator.builder","text":"builder () Get a sequence of the component builders for this paginator. RETURNS DESCRIPTION collections . abc . Sequence [ hikari . api . ComponentBuilder ] The component builders for this paginator.","title":"builder()"},{"location":"reference/components/#yuyo.components.ComponentPaginator.get_next_entry","text":"get_next_entry () Get the next entry in this paginator. This is generally helpful for making the message which the paginator will be based off and will still internally store the entry and increment the position of the paginator. Examples: response_paginator = yuyo . ComponentPaginator ( pages , authors = ( ctx . author . id ,) ) first_response = await response_paginator . get_next_entry () assert first_response content , embed = first_response message = await ctx . respond ( content = content , embed = embed , component = response_paginator , ensure_result = True ) component_client . set_executor ( message , response_paginator ) RETURNS DESCRIPTION yuyo . pagination . EntryT | None The next entry in this paginator, or None if there are no more entries.","title":"get_next_entry()"},{"location":"reference/components/#yuyo.components.ExecutorClosed","text":"Bases: Exception Error used to indicate that an executor is now closed during execution.","title":"ExecutorClosed"},{"location":"reference/components/#yuyo.components.MultiComponentExecutor","text":"Bases: AbstractComponentExecutor Multi-component implementation of a component executor. This implementation allows for multiple components to be executed as a single view.","title":"MultiComponentExecutor"},{"location":"reference/components/#yuyo.components.MultiComponentExecutor.builders","text":"builders : collections . Sequence [ hikari . api . ComponentBuilder ] Sequence of the component builders within this executor.","title":"builders"},{"location":"reference/components/#yuyo.components.MultiComponentExecutor.executors","text":"executors : collections . Sequence [ AbstractComponentExecutor ] Sequence of the child executors within this multi-executor.","title":"executors"},{"location":"reference/components/#yuyo.components.MultiComponentExecutor.__init__","text":"__init__ ( * , load_from_attributes = False , timeout = datetime . timedelta ( seconds = 30 )) Initialise a multi-component executor. PARAMETER DESCRIPTION timeout The amount of time to wait after the component's last execution or creation until it times out. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30)","title":"__init__()"},{"location":"reference/components/#yuyo.components.MultiComponentExecutor.add_action_row","text":"add_action_row () Create a builder class to add an action row to this executor. For the most part this follows the same implementation as yuyo.components.ActionRowExecutor except with the added detail that yuyo.components.ChildActionRowExecutor.add_to_parent must be called to add the action row to the parent executor. RETURNS DESCRIPTION ChildActionRowExecutor [ Self ] A builder class to add an action row to this executor. yuyo.components.ChildActionRowExecutor.add_to_parent should be called to finalise the action row and will return the parent executor for chained calls.","title":"add_action_row()"},{"location":"reference/components/#yuyo.components.MultiComponentExecutor.add_builder","text":"add_builder ( builder ) Add a non-executable component builder to this executor. This is useful for adding components that are not meant to be executed, such as a a row of link buttons. PARAMETER DESCRIPTION builder The component builder to add. TYPE: hikari . api . ComponentBuilder RETURNS DESCRIPTION Self","title":"add_builder()"},{"location":"reference/components/#yuyo.components.MultiComponentExecutor.add_executor","text":"add_executor ( executor ) Add a component executor to this multi-component executor. This method is internally used by the add_{component} methods. PARAMETER DESCRIPTION executor The component executor to add. TYPE: AbstractComponentExecutor RETURNS DESCRIPTION Self The multi-component executor instance to enable chained calls.","title":"add_executor()"},{"location":"reference/components/#yuyo.components.WaitForExecutor","text":"Bases: AbstractComponentExecutor Component executor used to wait for a single component interaction. Examples: responses : dict [ str , str ] message = await ctx . respond ( \"hi, pick an option\" , components = [ ... ]) executor = yuyo . components . WaitFor ( authors = ( ctx . author . id ,), timeout = datetime . timedelta ( seconds = 30 )) component_client . set_executor ( message . id , executor ) try : result = await executor . wait_for () except asyncio . TimeoutError : await ctx . respond ( \"timed out\" ) else : await result . respond ( responses [ result . interaction . custom_id ])","title":"WaitForExecutor"},{"location":"reference/components/#yuyo.components.WaitForExecutor.__init__","text":"__init__ ( * , authors , ephemeral_default = False , timeout ) Initialise a wait for executor. PARAMETER DESCRIPTION authors The authors of the entries. If None is passed here then the paginator will be public (meaning that anybody can use it). TYPE: typing . Optional [ collections . Iterable [ hikari . SnowflakeishOr [ hikari . User ]]] ephemeral_default Whether or not the responses made on contexts spawned from this paginator should default to ephemeral (meaning only the author can see them) unless flags is specified on the response method. TYPE: bool DEFAULT: False timeout How long this should wait for a matching component interaction until it times-out. TYPE: datetime . timedelta","title":"__init__()"},{"location":"reference/components/#yuyo.components.WaitForExecutor.wait_for","text":"wait_for () Wait for the next matching interaction. RETURNS DESCRIPTION ComponentContext The next matching interaction. RAISES DESCRIPTION RuntimeError If the executor is already being waited for. asyncio . TimeoutError If the timeout is reached.","title":"wait_for()"},{"location":"reference/links/","text":"yuyo.links # Classes and functions for handling Discord Links. BaseLink # Bases: abc . ABC Base class for all link objects. find classmethod # find ( app , content ) Find the first link in a string. PARAMETER DESCRIPTION app The Hikari bot or REST app this should be bound to. TYPE: hikari . RESTAware content The string to searh in. TYPE: str RETURNS DESCRIPTION Self | None Object of the found link or None . find_iter classmethod # find_iter ( app , content ) Iterate over the links in a string. PARAMETER DESCRIPTION app The Hikari bot or REST app this should be bound to. TYPE: hikari . RESTAware content The string to searh in. TYPE: str RETURNS DESCRIPTION collections . abc . Iterator [ Self ] Iterator of the link objects in the passed string. from_link classmethod # from_link ( app , link ) Create a link object from a raw link. PARAMETER DESCRIPTION app The Hikari bot or REST app this should be bound to. TYPE: hikari . RESTAware link The string link to use. TYPE: str RETURNS DESCRIPTION Self The created link object. RAISES DESCRIPTION ValueError If the string doesn't match the expected link format. InviteLink dataclass # Bases: hikari . InviteCode , BaseLink Represents a Discord invite link. The following class methods are used to initialise this: InviteLink.from_link to create this from a raw invite link. InviteLink.find to find the first invite link in a string. InviteLink.find_iter to iterate over the invite links in a string. code property # code : str The invite's code. fetch async # fetch () Fetch the invite this links to. RETURNS DESCRIPTION hikari . invites . Invite Object of the invite this links to. RAISES DESCRIPTION hikari . errors . UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari . errors . NotFoundError If the invite is not found. hikari . errors . RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request. hikari . errors . RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari . errors . InternalServerError If an internal error occurs on Discord while handling the request. get # get () Get the invite this links to from the cache. RETURNS DESCRIPTION hikari . invites . InviteWithMetadata | None Object of the invite that was found in the cache or None . MessageLink dataclass # Bases: BaseLink Represents a link to a message on Discord. The following class methods are used to initialise this: MessageLink.from_link to create this from a raw message link. MessageLink.find to find the first invite link in a string. MessageLink.find_iter to iterate over the message links in a string. channel_id property # channel_id : hikari . Snowflake ID of the channel this message is in. guild_id property # guild_id : typing . Optional [ hikari . Snowflake ] ID of the guild this message is in. Will be None for DM message links. is_dm_link property # is_dm_link : bool Whether this links to a message in a DM channel. message_id property # message_id : hikari . Snowflake ID of the message this links to. fetch async # fetch () Fetch a the message this links to. RETURNS DESCRIPTION hikari . messages . Message Object of the message this links to. RAISES DESCRIPTION hikari . errors . UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari . errors . ForbiddenError If you are missing the READ_MESSAGE_HISTORY in the channel. hikari . errors . NotFoundError If the channel is not found or the message is not found in the given text channel. hikari . errors . RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request. hikari . errors . RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari . errors . InternalServerError If an internal error occurs on Discord while handling the request. get # get () Get the message this links to from the cache. RETURNS DESCRIPTION hikari . messages . Message | None Object of the message that was found in the cache or None . TemplateLink dataclass # Bases: BaseLink Represents a link to a guild template. The following class methods are used to initialise this: TemplateLink.from_link to create this from a raw template link. TemplateLink.find to find the first template link in a string. TemplateLink.find_iter to iterate over the template links in a string. code property # code : str The template's code. fetch async # fetch () Fetch the guild template this links to. RETURNS DESCRIPTION hikari . templates . Template Object of the guild template this links to. RAISES DESCRIPTION hikari . errors . NotFoundError If the template was not found. hikari . errors . UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari . errors . RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request. hikari . errors . RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari . errors . InternalServerError If an internal error occurs on Discord while handling the request. WebhookLink dataclass # Bases: hikari . ExecutableWebhook , BaseLink Represents a link to an incoming webhook. The following class methods are used to initialise this: WebhookLink.from_link to create this from a raw webhook link. WebhookLink.find to find the first webhook link in a string. WebhookLink.find_iter to iterate over the webhook links in a string. app property # app : hikari . RESTAware The bot or REST client this is bound to. token property # token : str The webhook's token. webhook_id property # webhook_id : hikari . Snowflake ID of the webhook this links to. fetch async # fetch () Fetch the incoming webhook this links to. RETURNS DESCRIPTION hikari . webhooks . IncomingWebhook Object of the incoming webhook this links to. RAISES DESCRIPTION hikari . errors . UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari . errors . NotFoundError If the webhook is not found. hikari . errors . RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request. hikari . errors . RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari . errors . InternalServerError If an internal error occurs on Discord while handling the request. make_invite_link # make_invite_link ( invite ) Make a raw link for an invite. PARAMETER DESCRIPTION invite Object or string code of the invite to make a raw link for. TYPE: typing . Union [ str , hikari . InviteCode ] RETURNS DESCRIPTION str The raw invite link. make_message_link # make_message_link ( channel , message , / , * , guild = None ) Make a raw link for a message. PARAMETER DESCRIPTION channel Object or ID of the channel the message is in. TYPE: hikari . SnowflakeishOr [ hikari . PartialChannel ] message Object or ID of the message to link to. TYPE: hikari . SnowflakeishOr [ hikari . PartialMessage ] guild Object or ID of the guild the message is in. If left as None then this will be a DM message link. TYPE: typing . Optional [ hikari . SnowflakeishOr [ hikari . PartialGuild ]] DEFAULT: None RETURNS DESCRIPTION str The raw message link. make_template_link # make_template_link ( template ) Make a raw link for a guild template. PARAMETER DESCRIPTION template Object or string code of the template to make a raw link to. TYPE: typing . Union [ hikari . Template , str ] RETURNS DESCRIPTION str The raw template link. make_webhook_link # make_webhook_link ( webhook , token ) Make a raw link for an incoming webhook. PARAMETER DESCRIPTION webhook Object or ID of the webhook to make a link for. TYPE: hikari . SnowflakeishOr [ hikari . PartialWebhook ] token The webhook's token. TYPE: str RETURNS DESCRIPTION str The raw webhook link.","title":"yuyo.links"},{"location":"reference/links/#yuyolinks","text":"Classes and functions for handling Discord Links.","title":"yuyo.links"},{"location":"reference/links/#yuyo.links.BaseLink","text":"Bases: abc . ABC Base class for all link objects.","title":"BaseLink"},{"location":"reference/links/#yuyo.links.BaseLink.find","text":"find ( app , content ) Find the first link in a string. PARAMETER DESCRIPTION app The Hikari bot or REST app this should be bound to. TYPE: hikari . RESTAware content The string to searh in. TYPE: str RETURNS DESCRIPTION Self | None Object of the found link or None .","title":"find()"},{"location":"reference/links/#yuyo.links.BaseLink.find_iter","text":"find_iter ( app , content ) Iterate over the links in a string. PARAMETER DESCRIPTION app The Hikari bot or REST app this should be bound to. TYPE: hikari . RESTAware content The string to searh in. TYPE: str RETURNS DESCRIPTION collections . abc . Iterator [ Self ] Iterator of the link objects in the passed string.","title":"find_iter()"},{"location":"reference/links/#yuyo.links.BaseLink.from_link","text":"from_link ( app , link ) Create a link object from a raw link. PARAMETER DESCRIPTION app The Hikari bot or REST app this should be bound to. TYPE: hikari . RESTAware link The string link to use. TYPE: str RETURNS DESCRIPTION Self The created link object. RAISES DESCRIPTION ValueError If the string doesn't match the expected link format.","title":"from_link()"},{"location":"reference/links/#yuyo.links.InviteLink","text":"Bases: hikari . InviteCode , BaseLink Represents a Discord invite link. The following class methods are used to initialise this: InviteLink.from_link to create this from a raw invite link. InviteLink.find to find the first invite link in a string. InviteLink.find_iter to iterate over the invite links in a string.","title":"InviteLink"},{"location":"reference/links/#yuyo.links.InviteLink.code","text":"code : str The invite's code.","title":"code"},{"location":"reference/links/#yuyo.links.InviteLink.fetch","text":"fetch () Fetch the invite this links to. RETURNS DESCRIPTION hikari . invites . Invite Object of the invite this links to. RAISES DESCRIPTION hikari . errors . UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari . errors . NotFoundError If the invite is not found. hikari . errors . RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request. hikari . errors . RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari . errors . InternalServerError If an internal error occurs on Discord while handling the request.","title":"fetch()"},{"location":"reference/links/#yuyo.links.InviteLink.get","text":"get () Get the invite this links to from the cache. RETURNS DESCRIPTION hikari . invites . InviteWithMetadata | None Object of the invite that was found in the cache or None .","title":"get()"},{"location":"reference/links/#yuyo.links.MessageLink","text":"Bases: BaseLink Represents a link to a message on Discord. The following class methods are used to initialise this: MessageLink.from_link to create this from a raw message link. MessageLink.find to find the first invite link in a string. MessageLink.find_iter to iterate over the message links in a string.","title":"MessageLink"},{"location":"reference/links/#yuyo.links.MessageLink.channel_id","text":"channel_id : hikari . Snowflake ID of the channel this message is in.","title":"channel_id"},{"location":"reference/links/#yuyo.links.MessageLink.guild_id","text":"guild_id : typing . Optional [ hikari . Snowflake ] ID of the guild this message is in. Will be None for DM message links.","title":"guild_id"},{"location":"reference/links/#yuyo.links.MessageLink.is_dm_link","text":"is_dm_link : bool Whether this links to a message in a DM channel.","title":"is_dm_link"},{"location":"reference/links/#yuyo.links.MessageLink.message_id","text":"message_id : hikari . Snowflake ID of the message this links to.","title":"message_id"},{"location":"reference/links/#yuyo.links.MessageLink.fetch","text":"fetch () Fetch a the message this links to. RETURNS DESCRIPTION hikari . messages . Message Object of the message this links to. RAISES DESCRIPTION hikari . errors . UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari . errors . ForbiddenError If you are missing the READ_MESSAGE_HISTORY in the channel. hikari . errors . NotFoundError If the channel is not found or the message is not found in the given text channel. hikari . errors . RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request. hikari . errors . RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari . errors . InternalServerError If an internal error occurs on Discord while handling the request.","title":"fetch()"},{"location":"reference/links/#yuyo.links.MessageLink.get","text":"get () Get the message this links to from the cache. RETURNS DESCRIPTION hikari . messages . Message | None Object of the message that was found in the cache or None .","title":"get()"},{"location":"reference/links/#yuyo.links.TemplateLink","text":"Bases: BaseLink Represents a link to a guild template. The following class methods are used to initialise this: TemplateLink.from_link to create this from a raw template link. TemplateLink.find to find the first template link in a string. TemplateLink.find_iter to iterate over the template links in a string.","title":"TemplateLink"},{"location":"reference/links/#yuyo.links.TemplateLink.code","text":"code : str The template's code.","title":"code"},{"location":"reference/links/#yuyo.links.TemplateLink.fetch","text":"fetch () Fetch the guild template this links to. RETURNS DESCRIPTION hikari . templates . Template Object of the guild template this links to. RAISES DESCRIPTION hikari . errors . NotFoundError If the template was not found. hikari . errors . UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari . errors . RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request. hikari . errors . RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari . errors . InternalServerError If an internal error occurs on Discord while handling the request.","title":"fetch()"},{"location":"reference/links/#yuyo.links.WebhookLink","text":"Bases: hikari . ExecutableWebhook , BaseLink Represents a link to an incoming webhook. The following class methods are used to initialise this: WebhookLink.from_link to create this from a raw webhook link. WebhookLink.find to find the first webhook link in a string. WebhookLink.find_iter to iterate over the webhook links in a string.","title":"WebhookLink"},{"location":"reference/links/#yuyo.links.WebhookLink.app","text":"app : hikari . RESTAware The bot or REST client this is bound to.","title":"app"},{"location":"reference/links/#yuyo.links.WebhookLink.token","text":"token : str The webhook's token.","title":"token"},{"location":"reference/links/#yuyo.links.WebhookLink.webhook_id","text":"webhook_id : hikari . Snowflake ID of the webhook this links to.","title":"webhook_id"},{"location":"reference/links/#yuyo.links.WebhookLink.fetch","text":"fetch () Fetch the incoming webhook this links to. RETURNS DESCRIPTION hikari . webhooks . IncomingWebhook Object of the incoming webhook this links to. RAISES DESCRIPTION hikari . errors . UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari . errors . NotFoundError If the webhook is not found. hikari . errors . RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request. hikari . errors . RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari . errors . InternalServerError If an internal error occurs on Discord while handling the request.","title":"fetch()"},{"location":"reference/links/#yuyo.links.make_invite_link","text":"make_invite_link ( invite ) Make a raw link for an invite. PARAMETER DESCRIPTION invite Object or string code of the invite to make a raw link for. TYPE: typing . Union [ str , hikari . InviteCode ] RETURNS DESCRIPTION str The raw invite link.","title":"make_invite_link()"},{"location":"reference/links/#yuyo.links.make_message_link","text":"make_message_link ( channel , message , / , * , guild = None ) Make a raw link for a message. PARAMETER DESCRIPTION channel Object or ID of the channel the message is in. TYPE: hikari . SnowflakeishOr [ hikari . PartialChannel ] message Object or ID of the message to link to. TYPE: hikari . SnowflakeishOr [ hikari . PartialMessage ] guild Object or ID of the guild the message is in. If left as None then this will be a DM message link. TYPE: typing . Optional [ hikari . SnowflakeishOr [ hikari . PartialGuild ]] DEFAULT: None RETURNS DESCRIPTION str The raw message link.","title":"make_message_link()"},{"location":"reference/links/#yuyo.links.make_template_link","text":"make_template_link ( template ) Make a raw link for a guild template. PARAMETER DESCRIPTION template Object or string code of the template to make a raw link to. TYPE: typing . Union [ hikari . Template , str ] RETURNS DESCRIPTION str The raw template link.","title":"make_template_link()"},{"location":"reference/links/#yuyo.links.make_webhook_link","text":"make_webhook_link ( webhook , token ) Make a raw link for an incoming webhook. PARAMETER DESCRIPTION webhook Object or ID of the webhook to make a link for. TYPE: hikari . SnowflakeishOr [ hikari . PartialWebhook ] token The webhook's token. TYPE: str RETURNS DESCRIPTION str The raw webhook link.","title":"make_webhook_link()"},{"location":"reference/list_status/","text":"yuyo.list_status # Utility classes for updating a bot's guild count on several bot list services. ServiceSig module-attribute # ServiceSig = collections . Callable [[ 'AbstractManager' ], collections . Coroutine [ typing . Any , typing . Any , None ]] Signature of a callback used to update a service. AbstractCountStrategy # Bases: abc . ABC Protocol of a class used for calculating the bot's guild count. is_shard_bound abstractmethod property # is_shard_bound : bool Whether this count is just for the current shards. close abstractmethod async # close () Close the counter. count abstractmethod async # count () Get a possibly cached guild count from this counter. RETURNS DESCRIPTION int The current guild count(s). If this is an int then this is a global count. If this is a mapping then this is shard-specific counts. RAISES DESCRIPTION CountUnknownError If the count is currently unknown. open abstractmethod async # open () Open the counter. AbstractManager # Bases: typing . Protocol Abstract class used for managing services. cache abstractmethod property # cache : typing . Optional [ hikari . api . Cache ] The cache service this manager is bound to. counter abstractmethod property # counter : AbstractCountStrategy The country strategy this manager was initialised with. event_manager abstractmethod property # event_manager : typing . Optional [ hikari . api . EventManager ] The event manager this manager is bound to. rest abstractmethod property # rest : hikari . api . RESTClient The REST client this manager is bound to. shards abstractmethod property # shards : typing . Optional [ hikari . ShardAware ] The shard aware client this manager is bound to. user_agent abstractmethod property # user_agent : str User agent services within this manager should use for requests. get_me abstractmethod async # get_me () Get user object of the bot this manager is bound to. RETURNS DESCRIPTION hikari . users . User User object of the bot this manager is bound to. get_session abstractmethod # get_session () Get an aiohttp session to use to make requests within the services. RETURNS DESCRIPTION aiohttp . ClientSession an aiohttp session to use to make requests within the services. RAISES DESCRIPTION RuntimeError If this is called in an environment with no running event loop. If the client isn't running. BotsGGService # https://discord.bots.gg status update service. __init__ # __init__ ( token ) Initialise a bots.gg service. PARAMETER DESCRIPTION token Authorization token used to update the bot's status. TYPE: str CacheStrategy # Bases: _LoadableStrategy Cache based implementation of yuyo.list_status.AbstractCountStrategy . Warning This will only function properly if GUILD intents are declared and the guild cache resource is enabled. __init__ # __init__ ( cache , shards ) Initialise a cache strategy. PARAMETER DESCRIPTION cache The cache object this should use for getting the guild count. TYPE: hikari . api . Cache shards The shard aware client this should use for grouping counts per-shard. TYPE: hikari . ShardAware CountUnknownError # Bases: RuntimeError Error raised when the count is currently unknown. DiscordBotListService # https://discordbotlist.com status update service. __init__ # __init__ ( token ) Initialise a discordbotlist.com service. PARAMETER DESCRIPTION token Authorization token used to update the bot's status. TYPE: str EventStrategy # Bases: _LoadableStrategy Cache based implementation of yuyo.list_status.AbstractCountStrategy . Warning This will only function properly if GUILD intents are declared. __init__ # __init__ ( event_manager , shards ) Initialise an event etrategy. Note You usually won't need to initialise this yourself as yuyo.list_status.ServiceManager will automatically pick this strategy if the bot config matches it. PARAMETER DESCRIPTION event_manager The event manager this should use to track shard guild counts. TYPE: hikari . api . EventManager shards The shard manager this should use to track shard guild counts. TYPE: hikari . ShardAware SakeStrategy # Bases: AbstractCountStrategy Async cache based implementation of yuyo.list_status.AbstractCountStrategy . This relies on Sake . __init__ # __init__ ( cache ) Initialise a Sake strategy. Unlike CacheStrategy and EventStrategy this strategy must be directly initialised and passed to ServiceManager. init as strategy= . PARAMETER DESCRIPTION cache The Sake guild cache to use to get the guild count. TYPE: sake . abc . GuildCache ServiceManager # Bases: AbstractManager Standard service manager. is_alive property # is_alive : bool Wwhether this manager is active. __init__ # __init__ ( rest , / , * , cache = None , event_manager = None , shards = None , event_managed = None , strategy = None , user_agent = None ) Initialise a service manager. PARAMETER DESCRIPTION rest The RESTAware Hikari client to bind this manager to. TYPE: hikari . api . RESTClient cache The cache aware Hikari client this manager should use. TYPE: typing . Optional [ hikari . api . Cache ] DEFAULT: None event_manager The event manager aware Hikari client this manager should use. TYPE: typing . Optional [ hikari . api . EventManager ] DEFAULT: None shards The shard aware Hikari client this manager should use. TYPE: typing . Optional [ traits . ShardAware ] DEFAULT: None event_managed Whether this client should be automatically opened and closed based on event_manager 's lifetime events. Defaults to True when event_manager is passed. TYPE: typing . Optional [ bool ] DEFAULT: None strategy The counter strategy this manager should expose to services. If this is left as None then the manager will try to pick a suitable standard strategy based on the provided Hikari clients. TYPE: typing . Optional [ AbstractCountStrategy ] DEFAULT: None user_agent Override the standard user agent used during requests to bot list services. TYPE: typing . Optional [ str ] DEFAULT: None RAISES DESCRIPTION ValueError If the manager failed to find a suitable standard strategy to use when strategy was left as None . If event_managed is passed as True when event_manager is None . add_service # add_service ( service , / , * , repeat = datetime . timedelta ( hours = 1 )) Add a service to this manager. PARAMETER DESCRIPTION service Asynchronous callback used to update this service. TYPE: ServiceSig repeat How often this service should be updated in seconds. TYPE: typing . Union [ datetime . timedelta , int , float ] DEFAULT: datetime.timedelta(hours=1) RETURNS DESCRIPTION Self Object of this service manager. RAISES DESCRIPTION ValueError If repeat is less than 1 second. RuntimeError If the client is already running. close async # close () Close this manager. from_gateway_bot classmethod # from_gateway_bot ( bot , / , * , event_managed = True , strategy = None , user_agent = None ) Build a service manager from a gateway bot. PARAMETER DESCRIPTION bot The gateway bot to build a service manager from. TYPE: traits . GatewayBotAware event_managed Whether this client should be automatically opened and closed based on bot 's lifetime events. TYPE: bool DEFAULT: True strategy The counter strategy this manager should expose to services. If this is left as None then the manager will try to pick a suitable standard strategy based on the provided Hikari clients. TYPE: typing . Optional [ AbstractCountStrategy ] DEFAULT: None user_agent Override the standard user agent used during requests to bot list services. TYPE: typing . Optional [ str ] DEFAULT: None RETURNS DESCRIPTION ServiceManager The build service manager. RAISES DESCRIPTION ValueError If the manager failed to find a suitable standard strategy to use when strategy was left as None . open async # open () Start this manager. RAISES DESCRIPTION RuntimeError If this manager is already running. remove_service # remove_service ( service ) Remove the first found entry of the registered service. PARAMETER DESCRIPTION service Service callback to unregister. TYPE: ServiceSig RAISES DESCRIPTION RuntimeError If called while the manager is active. ValueError If the service callback isn't found. with_service # with_service ( * , repeat = datetime . timedelta ( hours = 1 )) Add a service to this manager by decorating a function. PARAMETER DESCRIPTION repeat How often this service should be updated in seconds. TYPE: typing . Union [ datetime . timedelta , int , float ] DEFAULT: datetime.timedelta(hours=1) RETURNS DESCRIPTION collections . abc . Callable [[ ServiceSig ], ServiceSig ] Decorator callback used to add a service. RAISES DESCRIPTION ValueError If repeat is less than 1 second. RuntimeError If the client is already running. TopGGService # https://top.gg status update service. __init__ # __init__ ( token ) Initialise a top.gg service. PARAMETER DESCRIPTION token Authorization token used to update the bot's status. TYPE: str","title":"yuyo.list_status"},{"location":"reference/list_status/#yuyolist_status","text":"Utility classes for updating a bot's guild count on several bot list services.","title":"yuyo.list_status"},{"location":"reference/list_status/#yuyo.list_status.ServiceSig","text":"ServiceSig = collections . Callable [[ 'AbstractManager' ], collections . Coroutine [ typing . Any , typing . Any , None ]] Signature of a callback used to update a service.","title":"ServiceSig"},{"location":"reference/list_status/#yuyo.list_status.AbstractCountStrategy","text":"Bases: abc . ABC Protocol of a class used for calculating the bot's guild count.","title":"AbstractCountStrategy"},{"location":"reference/list_status/#yuyo.list_status.AbstractCountStrategy.is_shard_bound","text":"is_shard_bound : bool Whether this count is just for the current shards.","title":"is_shard_bound"},{"location":"reference/list_status/#yuyo.list_status.AbstractCountStrategy.close","text":"close () Close the counter.","title":"close()"},{"location":"reference/list_status/#yuyo.list_status.AbstractCountStrategy.count","text":"count () Get a possibly cached guild count from this counter. RETURNS DESCRIPTION int The current guild count(s). If this is an int then this is a global count. If this is a mapping then this is shard-specific counts. RAISES DESCRIPTION CountUnknownError If the count is currently unknown.","title":"count()"},{"location":"reference/list_status/#yuyo.list_status.AbstractCountStrategy.open","text":"open () Open the counter.","title":"open()"},{"location":"reference/list_status/#yuyo.list_status.AbstractManager","text":"Bases: typing . Protocol Abstract class used for managing services.","title":"AbstractManager"},{"location":"reference/list_status/#yuyo.list_status.AbstractManager.cache","text":"cache : typing . Optional [ hikari . api . Cache ] The cache service this manager is bound to.","title":"cache"},{"location":"reference/list_status/#yuyo.list_status.AbstractManager.counter","text":"counter : AbstractCountStrategy The country strategy this manager was initialised with.","title":"counter"},{"location":"reference/list_status/#yuyo.list_status.AbstractManager.event_manager","text":"event_manager : typing . Optional [ hikari . api . EventManager ] The event manager this manager is bound to.","title":"event_manager"},{"location":"reference/list_status/#yuyo.list_status.AbstractManager.rest","text":"rest : hikari . api . RESTClient The REST client this manager is bound to.","title":"rest"},{"location":"reference/list_status/#yuyo.list_status.AbstractManager.shards","text":"shards : typing . Optional [ hikari . ShardAware ] The shard aware client this manager is bound to.","title":"shards"},{"location":"reference/list_status/#yuyo.list_status.AbstractManager.user_agent","text":"user_agent : str User agent services within this manager should use for requests.","title":"user_agent"},{"location":"reference/list_status/#yuyo.list_status.AbstractManager.get_me","text":"get_me () Get user object of the bot this manager is bound to. RETURNS DESCRIPTION hikari . users . User User object of the bot this manager is bound to.","title":"get_me()"},{"location":"reference/list_status/#yuyo.list_status.AbstractManager.get_session","text":"get_session () Get an aiohttp session to use to make requests within the services. RETURNS DESCRIPTION aiohttp . ClientSession an aiohttp session to use to make requests within the services. RAISES DESCRIPTION RuntimeError If this is called in an environment with no running event loop. If the client isn't running.","title":"get_session()"},{"location":"reference/list_status/#yuyo.list_status.BotsGGService","text":"https://discord.bots.gg status update service.","title":"BotsGGService"},{"location":"reference/list_status/#yuyo.list_status.BotsGGService.__init__","text":"__init__ ( token ) Initialise a bots.gg service. PARAMETER DESCRIPTION token Authorization token used to update the bot's status. TYPE: str","title":"__init__()"},{"location":"reference/list_status/#yuyo.list_status.CacheStrategy","text":"Bases: _LoadableStrategy Cache based implementation of yuyo.list_status.AbstractCountStrategy . Warning This will only function properly if GUILD intents are declared and the guild cache resource is enabled.","title":"CacheStrategy"},{"location":"reference/list_status/#yuyo.list_status.CacheStrategy.__init__","text":"__init__ ( cache , shards ) Initialise a cache strategy. PARAMETER DESCRIPTION cache The cache object this should use for getting the guild count. TYPE: hikari . api . Cache shards The shard aware client this should use for grouping counts per-shard. TYPE: hikari . ShardAware","title":"__init__()"},{"location":"reference/list_status/#yuyo.list_status.CountUnknownError","text":"Bases: RuntimeError Error raised when the count is currently unknown.","title":"CountUnknownError"},{"location":"reference/list_status/#yuyo.list_status.DiscordBotListService","text":"https://discordbotlist.com status update service.","title":"DiscordBotListService"},{"location":"reference/list_status/#yuyo.list_status.DiscordBotListService.__init__","text":"__init__ ( token ) Initialise a discordbotlist.com service. PARAMETER DESCRIPTION token Authorization token used to update the bot's status. TYPE: str","title":"__init__()"},{"location":"reference/list_status/#yuyo.list_status.EventStrategy","text":"Bases: _LoadableStrategy Cache based implementation of yuyo.list_status.AbstractCountStrategy . Warning This will only function properly if GUILD intents are declared.","title":"EventStrategy"},{"location":"reference/list_status/#yuyo.list_status.EventStrategy.__init__","text":"__init__ ( event_manager , shards ) Initialise an event etrategy. Note You usually won't need to initialise this yourself as yuyo.list_status.ServiceManager will automatically pick this strategy if the bot config matches it. PARAMETER DESCRIPTION event_manager The event manager this should use to track shard guild counts. TYPE: hikari . api . EventManager shards The shard manager this should use to track shard guild counts. TYPE: hikari . ShardAware","title":"__init__()"},{"location":"reference/list_status/#yuyo.list_status.SakeStrategy","text":"Bases: AbstractCountStrategy Async cache based implementation of yuyo.list_status.AbstractCountStrategy . This relies on Sake .","title":"SakeStrategy"},{"location":"reference/list_status/#yuyo.list_status.SakeStrategy.__init__","text":"__init__ ( cache ) Initialise a Sake strategy. Unlike CacheStrategy and EventStrategy this strategy must be directly initialised and passed to ServiceManager. init as strategy= . PARAMETER DESCRIPTION cache The Sake guild cache to use to get the guild count. TYPE: sake . abc . GuildCache","title":"__init__()"},{"location":"reference/list_status/#yuyo.list_status.ServiceManager","text":"Bases: AbstractManager Standard service manager.","title":"ServiceManager"},{"location":"reference/list_status/#yuyo.list_status.ServiceManager.is_alive","text":"is_alive : bool Wwhether this manager is active.","title":"is_alive"},{"location":"reference/list_status/#yuyo.list_status.ServiceManager.__init__","text":"__init__ ( rest , / , * , cache = None , event_manager = None , shards = None , event_managed = None , strategy = None , user_agent = None ) Initialise a service manager. PARAMETER DESCRIPTION rest The RESTAware Hikari client to bind this manager to. TYPE: hikari . api . RESTClient cache The cache aware Hikari client this manager should use. TYPE: typing . Optional [ hikari . api . Cache ] DEFAULT: None event_manager The event manager aware Hikari client this manager should use. TYPE: typing . Optional [ hikari . api . EventManager ] DEFAULT: None shards The shard aware Hikari client this manager should use. TYPE: typing . Optional [ traits . ShardAware ] DEFAULT: None event_managed Whether this client should be automatically opened and closed based on event_manager 's lifetime events. Defaults to True when event_manager is passed. TYPE: typing . Optional [ bool ] DEFAULT: None strategy The counter strategy this manager should expose to services. If this is left as None then the manager will try to pick a suitable standard strategy based on the provided Hikari clients. TYPE: typing . Optional [ AbstractCountStrategy ] DEFAULT: None user_agent Override the standard user agent used during requests to bot list services. TYPE: typing . Optional [ str ] DEFAULT: None RAISES DESCRIPTION ValueError If the manager failed to find a suitable standard strategy to use when strategy was left as None . If event_managed is passed as True when event_manager is None .","title":"__init__()"},{"location":"reference/list_status/#yuyo.list_status.ServiceManager.add_service","text":"add_service ( service , / , * , repeat = datetime . timedelta ( hours = 1 )) Add a service to this manager. PARAMETER DESCRIPTION service Asynchronous callback used to update this service. TYPE: ServiceSig repeat How often this service should be updated in seconds. TYPE: typing . Union [ datetime . timedelta , int , float ] DEFAULT: datetime.timedelta(hours=1) RETURNS DESCRIPTION Self Object of this service manager. RAISES DESCRIPTION ValueError If repeat is less than 1 second. RuntimeError If the client is already running.","title":"add_service()"},{"location":"reference/list_status/#yuyo.list_status.ServiceManager.close","text":"close () Close this manager.","title":"close()"},{"location":"reference/list_status/#yuyo.list_status.ServiceManager.from_gateway_bot","text":"from_gateway_bot ( bot , / , * , event_managed = True , strategy = None , user_agent = None ) Build a service manager from a gateway bot. PARAMETER DESCRIPTION bot The gateway bot to build a service manager from. TYPE: traits . GatewayBotAware event_managed Whether this client should be automatically opened and closed based on bot 's lifetime events. TYPE: bool DEFAULT: True strategy The counter strategy this manager should expose to services. If this is left as None then the manager will try to pick a suitable standard strategy based on the provided Hikari clients. TYPE: typing . Optional [ AbstractCountStrategy ] DEFAULT: None user_agent Override the standard user agent used during requests to bot list services. TYPE: typing . Optional [ str ] DEFAULT: None RETURNS DESCRIPTION ServiceManager The build service manager. RAISES DESCRIPTION ValueError If the manager failed to find a suitable standard strategy to use when strategy was left as None .","title":"from_gateway_bot()"},{"location":"reference/list_status/#yuyo.list_status.ServiceManager.open","text":"open () Start this manager. RAISES DESCRIPTION RuntimeError If this manager is already running.","title":"open()"},{"location":"reference/list_status/#yuyo.list_status.ServiceManager.remove_service","text":"remove_service ( service ) Remove the first found entry of the registered service. PARAMETER DESCRIPTION service Service callback to unregister. TYPE: ServiceSig RAISES DESCRIPTION RuntimeError If called while the manager is active. ValueError If the service callback isn't found.","title":"remove_service()"},{"location":"reference/list_status/#yuyo.list_status.ServiceManager.with_service","text":"with_service ( * , repeat = datetime . timedelta ( hours = 1 )) Add a service to this manager by decorating a function. PARAMETER DESCRIPTION repeat How often this service should be updated in seconds. TYPE: typing . Union [ datetime . timedelta , int , float ] DEFAULT: datetime.timedelta(hours=1) RETURNS DESCRIPTION collections . abc . Callable [[ ServiceSig ], ServiceSig ] Decorator callback used to add a service. RAISES DESCRIPTION ValueError If repeat is less than 1 second. RuntimeError If the client is already running.","title":"with_service()"},{"location":"reference/list_status/#yuyo.list_status.TopGGService","text":"https://top.gg status update service.","title":"TopGGService"},{"location":"reference/list_status/#yuyo.list_status.TopGGService.__init__","text":"__init__ ( token ) Initialise a top.gg service. PARAMETER DESCRIPTION token Authorization token used to update the bot's status. TYPE: str","title":"__init__()"},{"location":"reference/pagination/","text":"yuyo.pagination # Utilities used for quick pagination handling within reaction and component executors. BLACK_CROSS module-attribute # BLACK_CROSS : typing . Final [ hikari . UnicodeEmoji ] = hikari . UnicodeEmoji ( '\u2716\ufe0f' ) The emoji used to close a menu in a component context. EntryT module-attribute # EntryT = tuple [ hikari . UndefinedOr [ str ], hikari . UndefinedOr [ hikari . Embed ]] A type hint used to represent a paginator entry. This should be a tuple of the string message content or hikari.undefined.UNDEFINED to the message's embed if set else hikari.undefined.UNDEFINED . LEFT_DOUBLE_TRIANGLE module-attribute # LEFT_DOUBLE_TRIANGLE : typing . Final [ hikari . UnicodeEmoji ] = hikari . UnicodeEmoji ( '\u23ee\ufe0f' ) The emoji used to go back to the first entry. LEFT_TRIANGLE module-attribute # LEFT_TRIANGLE : typing . Final [ hikari . UnicodeEmoji ] = hikari . UnicodeEmoji ( '\u25c0\ufe0f' ) The emoji used to go back an entry. RIGHT_DOUBLE_TRIANGLE module-attribute # RIGHT_DOUBLE_TRIANGLE : typing . Final [ hikari . UnicodeEmoji ] = hikari . UnicodeEmoji ( '\u23ed\ufe0f' ) The emoji used for the lesser-enabled skip to last entry button. RIGHT_TRIANGLE module-attribute # RIGHT_TRIANGLE : typing . Final [ hikari . UnicodeEmoji ] = hikari . UnicodeEmoji ( '\u25b6\ufe0f' ) The emoji used to continue to the next entry. STOP_SQUARE module-attribute # STOP_SQUARE : typing . Final [ hikari . UnicodeEmoji ] = hikari . UnicodeEmoji ( '\u23f9\ufe0f' ) The emoji used to close a menu in a reaction context. aenumerate async # aenumerate ( iterable ) Async equivalent of enumerate . PARAMETER DESCRIPTION iterable The async iterable to enumerate. TYPE: collections . AsyncIterable [ _T ] RETURNS DESCRIPTION collections . abc . AsyncIterator [ tuple [ int , _T ]] The enumerated async iterator. async_paginate_string async # async_paginate_string ( lines , * , char_limit = 2000 , line_limit = 25 , wrapper = None ) Lazily paginate an iterator of lines. PARAMETER DESCRIPTION lines The asynchronous iterator of lines to paginate. TYPE: collections . AsyncIterable [ str ] char_limit The limit for how many characters should be included per yielded page. TYPE: int DEFAULT: 2000 line_limit The limit for how many lines should be included per yielded page. TYPE: int DEFAULT: 25 wrapper A wrapper for each yielded page. This should leave \"{}\" in it to be replaced by the page's content. TYPE: typing . Optional [ str ] DEFAULT: None RETURNS DESCRIPTION typing . AsyncIterator [ tuple [ str , int ]] An async iterator of page tuples (string context to int zero-based index). paginate_string # paginate_string ( lines , * , char_limit = 2000 , line_limit = 25 , wrapper = None ) Lazily paginate an iterator of lines. PARAMETER DESCRIPTION lines The iterator of lines to paginate. This iterator may be asynchronous or synchronous. TYPE: collections . abc . Iterator [ str ] | collections . abc . AsyncIterator [ str ] char_limit The limit for how many characters should be included per yielded page. TYPE: int DEFAULT: 2000 line_limit The limit for how many lines should be included per yielded page. TYPE: int DEFAULT: 25 wrapper A wrapper for each yielded page. This should leave \"{}\" in it to be replaced by the page's content. TYPE: typing . Optional [ str ] DEFAULT: None RETURNS DESCRIPTION collections . abc . AsyncIterator [ tuple [ str , int ]] | collections . abc . Iterator [ tuple [ str , int ]] An iterator of page tuples (string context to int zero-based index). sync_paginate_string # sync_paginate_string ( lines , * , char_limit = 2000 , line_limit = 25 , wrapper = None ) Lazily paginate an iterator of lines. PARAMETER DESCRIPTION lines The iterator of lines to paginate. TYPE: collections . Iterable [ str ] char_limit The limit for how many characters should be included per yielded page. TYPE: int DEFAULT: 2000 line_limit The limit for how many lines should be included per yielded page. TYPE: int DEFAULT: 25 wrapper A wrapper for each yielded page. This should leave \"{}\" in it to be replaced by the page's content. TYPE: typing . Optional [ str ] DEFAULT: None RETURNS DESCRIPTION collections . abc . Iterator [ tuple [ str , int ]] An iterator of page tuples (string context to int zero-based index).","title":"yuyo.pagination"},{"location":"reference/pagination/#yuyopagination","text":"Utilities used for quick pagination handling within reaction and component executors.","title":"yuyo.pagination"},{"location":"reference/pagination/#yuyo.pagination.BLACK_CROSS","text":"BLACK_CROSS : typing . Final [ hikari . UnicodeEmoji ] = hikari . UnicodeEmoji ( '\u2716\ufe0f' ) The emoji used to close a menu in a component context.","title":"BLACK_CROSS"},{"location":"reference/pagination/#yuyo.pagination.EntryT","text":"EntryT = tuple [ hikari . UndefinedOr [ str ], hikari . UndefinedOr [ hikari . Embed ]] A type hint used to represent a paginator entry. This should be a tuple of the string message content or hikari.undefined.UNDEFINED to the message's embed if set else hikari.undefined.UNDEFINED .","title":"EntryT"},{"location":"reference/pagination/#yuyo.pagination.LEFT_DOUBLE_TRIANGLE","text":"LEFT_DOUBLE_TRIANGLE : typing . Final [ hikari . UnicodeEmoji ] = hikari . UnicodeEmoji ( '\u23ee\ufe0f' ) The emoji used to go back to the first entry.","title":"LEFT_DOUBLE_TRIANGLE"},{"location":"reference/pagination/#yuyo.pagination.LEFT_TRIANGLE","text":"LEFT_TRIANGLE : typing . Final [ hikari . UnicodeEmoji ] = hikari . UnicodeEmoji ( '\u25c0\ufe0f' ) The emoji used to go back an entry.","title":"LEFT_TRIANGLE"},{"location":"reference/pagination/#yuyo.pagination.RIGHT_DOUBLE_TRIANGLE","text":"RIGHT_DOUBLE_TRIANGLE : typing . Final [ hikari . UnicodeEmoji ] = hikari . UnicodeEmoji ( '\u23ed\ufe0f' ) The emoji used for the lesser-enabled skip to last entry button.","title":"RIGHT_DOUBLE_TRIANGLE"},{"location":"reference/pagination/#yuyo.pagination.RIGHT_TRIANGLE","text":"RIGHT_TRIANGLE : typing . Final [ hikari . UnicodeEmoji ] = hikari . UnicodeEmoji ( '\u25b6\ufe0f' ) The emoji used to continue to the next entry.","title":"RIGHT_TRIANGLE"},{"location":"reference/pagination/#yuyo.pagination.STOP_SQUARE","text":"STOP_SQUARE : typing . Final [ hikari . UnicodeEmoji ] = hikari . UnicodeEmoji ( '\u23f9\ufe0f' ) The emoji used to close a menu in a reaction context.","title":"STOP_SQUARE"},{"location":"reference/pagination/#yuyo.pagination.aenumerate","text":"aenumerate ( iterable ) Async equivalent of enumerate . PARAMETER DESCRIPTION iterable The async iterable to enumerate. TYPE: collections . AsyncIterable [ _T ] RETURNS DESCRIPTION collections . abc . AsyncIterator [ tuple [ int , _T ]] The enumerated async iterator.","title":"aenumerate()"},{"location":"reference/pagination/#yuyo.pagination.async_paginate_string","text":"async_paginate_string ( lines , * , char_limit = 2000 , line_limit = 25 , wrapper = None ) Lazily paginate an iterator of lines. PARAMETER DESCRIPTION lines The asynchronous iterator of lines to paginate. TYPE: collections . AsyncIterable [ str ] char_limit The limit for how many characters should be included per yielded page. TYPE: int DEFAULT: 2000 line_limit The limit for how many lines should be included per yielded page. TYPE: int DEFAULT: 25 wrapper A wrapper for each yielded page. This should leave \"{}\" in it to be replaced by the page's content. TYPE: typing . Optional [ str ] DEFAULT: None RETURNS DESCRIPTION typing . AsyncIterator [ tuple [ str , int ]] An async iterator of page tuples (string context to int zero-based index).","title":"async_paginate_string()"},{"location":"reference/pagination/#yuyo.pagination.paginate_string","text":"paginate_string ( lines , * , char_limit = 2000 , line_limit = 25 , wrapper = None ) Lazily paginate an iterator of lines. PARAMETER DESCRIPTION lines The iterator of lines to paginate. This iterator may be asynchronous or synchronous. TYPE: collections . abc . Iterator [ str ] | collections . abc . AsyncIterator [ str ] char_limit The limit for how many characters should be included per yielded page. TYPE: int DEFAULT: 2000 line_limit The limit for how many lines should be included per yielded page. TYPE: int DEFAULT: 25 wrapper A wrapper for each yielded page. This should leave \"{}\" in it to be replaced by the page's content. TYPE: typing . Optional [ str ] DEFAULT: None RETURNS DESCRIPTION collections . abc . AsyncIterator [ tuple [ str , int ]] | collections . abc . Iterator [ tuple [ str , int ]] An iterator of page tuples (string context to int zero-based index).","title":"paginate_string()"},{"location":"reference/pagination/#yuyo.pagination.sync_paginate_string","text":"sync_paginate_string ( lines , * , char_limit = 2000 , line_limit = 25 , wrapper = None ) Lazily paginate an iterator of lines. PARAMETER DESCRIPTION lines The iterator of lines to paginate. TYPE: collections . Iterable [ str ] char_limit The limit for how many characters should be included per yielded page. TYPE: int DEFAULT: 2000 line_limit The limit for how many lines should be included per yielded page. TYPE: int DEFAULT: 25 wrapper A wrapper for each yielded page. This should leave \"{}\" in it to be replaced by the page's content. TYPE: typing . Optional [ str ] DEFAULT: None RETURNS DESCRIPTION collections . abc . Iterator [ tuple [ str , int ]] An iterator of page tuples (string context to int zero-based index).","title":"sync_paginate_string()"},{"location":"reference/reactions/","text":"yuyo.reactions # Client for higher level callback based reaction menu handling. AbstractReactionHandler # Bases: abc . ABC The interface for a reaction handler used with yuyo.reactions.ReactionClient . has_expired abstractmethod property # has_expired : bool Whether this handler has ended. last_triggered abstractmethod property # last_triggered : datetime . datetime When this handler was last triggered. Note If it hasn't ever been triggered then this will be when it was created. close abstractmethod async # close () Close this handler. on_reaction_event abstractmethod async # on_reaction_event ( event , / , * , alluka = None ) Handle a reaction event. PARAMETER DESCRIPTION event The event to handle. TYPE: EventT alluka The Alluka client to use for callback dependency injection during callback calls. TYPE: typing . Optional [ alluka_ . abc . Client ] DEFAULT: None RAISES DESCRIPTION HandlerClosed If this reaction handler has been closed. open abstractmethod async # open ( message ) Open this handler. PARAMETER DESCRIPTION message The message to bind this handler to. TYPE: hikari . Message HandlerClosed # Bases: Exception Error raised when a reaction handler has been closed. ReactionClient # A class which handles the events for multiple registered reaction handlers. Note For a quicker way to initialise this client from a bot, see yuyo.reactions.ReactionClient.from_gateway_bot . alluka property # alluka : alluka_ . abc . Client The Alluka client being used for callback dependency injection. is_closed property # is_closed : bool Whether this client is closed. __init__ # __init__ ( * , rest , event_manager , alluka = None , event_managed = True ) Initialise a reaction client. PARAMETER DESCRIPTION rest The REST client to register this reaction client with. TYPE: hikari . api . RESTClient event_manager The event manager client to register this reaction client with. TYPE: hikari . api . EventManager alluka The alluka client to use for callback DI. TYPE: typing . Optional [ alluka_ . abc . Client ] DEFAULT: None event_managed Whether the reaction client should be automatically opened and closed based on the lifetime events dispatched by event_managed . TYPE: bool DEFAULT: True add_handler # add_handler ( message , / , paginator ) Add a reaction handler to this reaction client. Note This does not call yuyo.reactions.AbstractReactionHandler.open . PARAMETER DESCRIPTION message The message ID to add register a reaction handler with. TYPE: hikari . SnowflakeishOr [ hikari . Message ] paginator The object of the opened paginator to register in this reaction client. TYPE: AbstractReactionHandler close async # close () Close this client by unregistering any registered tasks and event listeners. from_gateway_bot classmethod # from_gateway_bot ( bot , / , * , event_managed = True ) Build a ReactionClient from a gateway bot. PARAMETER DESCRIPTION bot The bot to build a reaction client for. TYPE: hikari . GatewayBotAware event_managed Whether the reaction client should be automatically opened and closed based on the lifetime events dispatched by bot . TYPE: bool DEFAULT: True RETURNS DESCRIPTION ReactionClient The reaction client for the bot. get_handler # get_handler ( message ) Get a reference to a paginator registered in this reaction client. Note This does not call yuyo.reactions.AbstractReactionHandler.close . PARAMETER DESCRIPTION message The message ID to remove a paginator for. TYPE: hikari . SnowflakeishOr [ hikari . Message ] RETURNS DESCRIPTION AbstractReactionHandler | None The object of the registered paginator if found else None . open async # open () Start this client by registering the required tasks and event listeners for it to function. remove_handler # remove_handler ( message ) Remove a paginator from this reaction client. Note This does not call yuyo.reactions.AbstractReactionHandler.close . PARAMETER DESCRIPTION message The message ID to remove a paginator for. TYPE: hikari . SnowflakeishOr [ hikari . Message ] RETURNS DESCRIPTION AbstractReactionHandler | None The object of the registered paginator if found else None . ReactionHandler # Bases: AbstractReactionHandler Standard basic implementation of a reaction handler. authors property # authors : collections . Set [ hikari . Snowflake ] Set of the authors/owner of a enabled handler. Note If this is empty then the handler is considered public and any user will be able to trigger it. timeout property # timeout : datetime . timedelta How long this handler will wait since the last event before timing out. __init__ # __init__ ( * , authors = (), timeout = datetime . timedelta ( seconds = 30 ), load_from_attributes = True ) Initialise a reaction handler. PARAMETER DESCRIPTION authors An iterable of IDs of the users who can call this paginator. If left empty then all users will be able to call this paginator. TYPE: collections . Iterable [ hikari . SnowflakeishOr [ hikari . User ]] DEFAULT: () timeout How long it should take for this paginator to timeout. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30) add_callback # add_callback ( emoji_identifier , callback ) Add a callback to this reaction handler. PARAMETER DESCRIPTION emoji_identifier Identifier of the emoji this callback is for. This should be a snowfake if this is for a custom emoji or a string if this is for a unicode emoji. TYPE: typing . Union [ str , hikari . SnowflakeishOr [ hikari . CustomEmoji ]] callback The callback to add. This should be a function that accepts a single parameter, which is the event that triggered this reaction. TYPE: CallbackSig remove_callback # remove_callback ( emoji_identifier ) Remove a callback from this reaction handler. PARAMETER DESCRIPTION emoji_identifier Identifier of the emoji the callback to remove is for. This should be a snowfake if this is for a custom emoji or a string if this is for a unicode emoji. TYPE: typing . Union [ str , hikari . SnowflakeishOr [ hikari . CustomEmoji ]] with_callback # with_callback ( emoji_identifier ) Add a callback to this reaction handler through a decorator call. PARAMETER DESCRIPTION emoji_identifier Identifier of the emoji this callback is for. This should be a snowfake if this is for a custom emoji or a string if this is for a unicode emoji. TYPE: typing . Union [ str , hikari . SnowflakeishOr [ hikari . CustomEmoji ]] RETURNS DESCRIPTION collections . abc . Callabke [[ CallbackSigT ], CallbackSigT ] A decorator to add a callback to this reaction handler. ReactionPaginator # Bases: ReactionHandler Standard implementation of a reaction handler for pagination. __init__ # __init__ ( iterator , * , authors , triggers = ( pagination . LEFT_TRIANGLE , pagination . STOP_SQUARE , pagination . RIGHT_TRIANGLE ), timeout = datetime . timedelta ( seconds = 30 )) Initialise a reaction paginator. PARAMETER DESCRIPTION iterator Either an asynchronous or synchronous iterator of the entries this should paginate through. entry[0] represents the message's possible content and can either be str or hikari.undefined.UNDEFINED and entry[1] represents the message's possible embed and can either be hikari.embeds.Embed or hikari.undefined.UNDEFINED . TYPE: collections . Iterator [ yuyo . pagination . EntryT ] | collections . AsyncIterator [ yuyo . pagination . EntryT ] authors An iterable of IDs of the users who can call this paginator. If left empty then all users will be able to call this paginator. TYPE: collections . Iterable [ hikari . SnowflakeishOr [ hikari . User ]] timeout How long it should take for this paginator to timeout. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30) add_author # add_author ( user ) Add a author/owner to this handler. PARAMETER DESCRIPTION user The user to add as an owner for this handler. TYPE: hikari . SnowflakeishOr [ hikari . User ] close async # close ( * , remove_reactions = False , max_retries = 5 , max_backoff = 2.0 ) Close this handler and deregister any previously registered message. PARAMETER DESCRIPTION remove_reactions Whether this should remove the reactions that were being used to paginate through this from the previously registered message. TYPE: bool DEFAULT: False create_message async # create_message ( rest , channel_id , / , * , add_reactions = True , max_retries = 5 , max_backoff = 2.0 ) Start this handler and link it to a bot message. Note Calling this multiple times will replace the previously registered message. PARAMETER DESCRIPTION rest Rest client to use to make the response. TYPE: hikari . api . RESTClient channel_id ID of the channel to respond in. TYPE: hikari . SnowflakeishOr [ hikari . TextableChannel ] add_reactions Whether this should add the paginator's reactions to the message after responding. TYPE: bool DEFAULT: True max_retries How many times this should retry to respond if Hikari raises any ratelimit errors. TYPE: int DEFAULT: 5 max_backoff The maximum time this should backoff for before trying if Hikari raises any ratelimit errors. TYPE: float DEFAULT: 2.0 RETURNS DESCRIPTION hikari . messages . Message Object of the message this handler now targets. If message was not supplied then this will be the object of a newly created message, otherwise this will be what was supplied as message . RAISES DESCRIPTION ValueError If the provided iterator didn't yield any content for the first message. remove_author # remove_author ( user ) Remove a author/owner from this handler. Note If the provided user isn't already a registered owner of this paginator then this should pass silently without raising. PARAMETER DESCRIPTION user The user to remove from this handler's owners. TYPE: hikari . SnowflakeishOr [ hikari . User ]","title":"yuyo.reactions"},{"location":"reference/reactions/#yuyoreactions","text":"Client for higher level callback based reaction menu handling.","title":"yuyo.reactions"},{"location":"reference/reactions/#yuyo.reactions.AbstractReactionHandler","text":"Bases: abc . ABC The interface for a reaction handler used with yuyo.reactions.ReactionClient .","title":"AbstractReactionHandler"},{"location":"reference/reactions/#yuyo.reactions.AbstractReactionHandler.has_expired","text":"has_expired : bool Whether this handler has ended.","title":"has_expired"},{"location":"reference/reactions/#yuyo.reactions.AbstractReactionHandler.last_triggered","text":"last_triggered : datetime . datetime When this handler was last triggered. Note If it hasn't ever been triggered then this will be when it was created.","title":"last_triggered"},{"location":"reference/reactions/#yuyo.reactions.AbstractReactionHandler.close","text":"close () Close this handler.","title":"close()"},{"location":"reference/reactions/#yuyo.reactions.AbstractReactionHandler.on_reaction_event","text":"on_reaction_event ( event , / , * , alluka = None ) Handle a reaction event. PARAMETER DESCRIPTION event The event to handle. TYPE: EventT alluka The Alluka client to use for callback dependency injection during callback calls. TYPE: typing . Optional [ alluka_ . abc . Client ] DEFAULT: None RAISES DESCRIPTION HandlerClosed If this reaction handler has been closed.","title":"on_reaction_event()"},{"location":"reference/reactions/#yuyo.reactions.AbstractReactionHandler.open","text":"open ( message ) Open this handler. PARAMETER DESCRIPTION message The message to bind this handler to. TYPE: hikari . Message","title":"open()"},{"location":"reference/reactions/#yuyo.reactions.HandlerClosed","text":"Bases: Exception Error raised when a reaction handler has been closed.","title":"HandlerClosed"},{"location":"reference/reactions/#yuyo.reactions.ReactionClient","text":"A class which handles the events for multiple registered reaction handlers. Note For a quicker way to initialise this client from a bot, see yuyo.reactions.ReactionClient.from_gateway_bot .","title":"ReactionClient"},{"location":"reference/reactions/#yuyo.reactions.ReactionClient.alluka","text":"alluka : alluka_ . abc . Client The Alluka client being used for callback dependency injection.","title":"alluka"},{"location":"reference/reactions/#yuyo.reactions.ReactionClient.is_closed","text":"is_closed : bool Whether this client is closed.","title":"is_closed"},{"location":"reference/reactions/#yuyo.reactions.ReactionClient.__init__","text":"__init__ ( * , rest , event_manager , alluka = None , event_managed = True ) Initialise a reaction client. PARAMETER DESCRIPTION rest The REST client to register this reaction client with. TYPE: hikari . api . RESTClient event_manager The event manager client to register this reaction client with. TYPE: hikari . api . EventManager alluka The alluka client to use for callback DI. TYPE: typing . Optional [ alluka_ . abc . Client ] DEFAULT: None event_managed Whether the reaction client should be automatically opened and closed based on the lifetime events dispatched by event_managed . TYPE: bool DEFAULT: True","title":"__init__()"},{"location":"reference/reactions/#yuyo.reactions.ReactionClient.add_handler","text":"add_handler ( message , / , paginator ) Add a reaction handler to this reaction client. Note This does not call yuyo.reactions.AbstractReactionHandler.open . PARAMETER DESCRIPTION message The message ID to add register a reaction handler with. TYPE: hikari . SnowflakeishOr [ hikari . Message ] paginator The object of the opened paginator to register in this reaction client. TYPE: AbstractReactionHandler","title":"add_handler()"},{"location":"reference/reactions/#yuyo.reactions.ReactionClient.close","text":"close () Close this client by unregistering any registered tasks and event listeners.","title":"close()"},{"location":"reference/reactions/#yuyo.reactions.ReactionClient.from_gateway_bot","text":"from_gateway_bot ( bot , / , * , event_managed = True ) Build a ReactionClient from a gateway bot. PARAMETER DESCRIPTION bot The bot to build a reaction client for. TYPE: hikari . GatewayBotAware event_managed Whether the reaction client should be automatically opened and closed based on the lifetime events dispatched by bot . TYPE: bool DEFAULT: True RETURNS DESCRIPTION ReactionClient The reaction client for the bot.","title":"from_gateway_bot()"},{"location":"reference/reactions/#yuyo.reactions.ReactionClient.get_handler","text":"get_handler ( message ) Get a reference to a paginator registered in this reaction client. Note This does not call yuyo.reactions.AbstractReactionHandler.close . PARAMETER DESCRIPTION message The message ID to remove a paginator for. TYPE: hikari . SnowflakeishOr [ hikari . Message ] RETURNS DESCRIPTION AbstractReactionHandler | None The object of the registered paginator if found else None .","title":"get_handler()"},{"location":"reference/reactions/#yuyo.reactions.ReactionClient.open","text":"open () Start this client by registering the required tasks and event listeners for it to function.","title":"open()"},{"location":"reference/reactions/#yuyo.reactions.ReactionClient.remove_handler","text":"remove_handler ( message ) Remove a paginator from this reaction client. Note This does not call yuyo.reactions.AbstractReactionHandler.close . PARAMETER DESCRIPTION message The message ID to remove a paginator for. TYPE: hikari . SnowflakeishOr [ hikari . Message ] RETURNS DESCRIPTION AbstractReactionHandler | None The object of the registered paginator if found else None .","title":"remove_handler()"},{"location":"reference/reactions/#yuyo.reactions.ReactionHandler","text":"Bases: AbstractReactionHandler Standard basic implementation of a reaction handler.","title":"ReactionHandler"},{"location":"reference/reactions/#yuyo.reactions.ReactionHandler.authors","text":"authors : collections . Set [ hikari . Snowflake ] Set of the authors/owner of a enabled handler. Note If this is empty then the handler is considered public and any user will be able to trigger it.","title":"authors"},{"location":"reference/reactions/#yuyo.reactions.ReactionHandler.timeout","text":"timeout : datetime . timedelta How long this handler will wait since the last event before timing out.","title":"timeout"},{"location":"reference/reactions/#yuyo.reactions.ReactionHandler.__init__","text":"__init__ ( * , authors = (), timeout = datetime . timedelta ( seconds = 30 ), load_from_attributes = True ) Initialise a reaction handler. PARAMETER DESCRIPTION authors An iterable of IDs of the users who can call this paginator. If left empty then all users will be able to call this paginator. TYPE: collections . Iterable [ hikari . SnowflakeishOr [ hikari . User ]] DEFAULT: () timeout How long it should take for this paginator to timeout. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30)","title":"__init__()"},{"location":"reference/reactions/#yuyo.reactions.ReactionHandler.add_callback","text":"add_callback ( emoji_identifier , callback ) Add a callback to this reaction handler. PARAMETER DESCRIPTION emoji_identifier Identifier of the emoji this callback is for. This should be a snowfake if this is for a custom emoji or a string if this is for a unicode emoji. TYPE: typing . Union [ str , hikari . SnowflakeishOr [ hikari . CustomEmoji ]] callback The callback to add. This should be a function that accepts a single parameter, which is the event that triggered this reaction. TYPE: CallbackSig","title":"add_callback()"},{"location":"reference/reactions/#yuyo.reactions.ReactionHandler.remove_callback","text":"remove_callback ( emoji_identifier ) Remove a callback from this reaction handler. PARAMETER DESCRIPTION emoji_identifier Identifier of the emoji the callback to remove is for. This should be a snowfake if this is for a custom emoji or a string if this is for a unicode emoji. TYPE: typing . Union [ str , hikari . SnowflakeishOr [ hikari . CustomEmoji ]]","title":"remove_callback()"},{"location":"reference/reactions/#yuyo.reactions.ReactionHandler.with_callback","text":"with_callback ( emoji_identifier ) Add a callback to this reaction handler through a decorator call. PARAMETER DESCRIPTION emoji_identifier Identifier of the emoji this callback is for. This should be a snowfake if this is for a custom emoji or a string if this is for a unicode emoji. TYPE: typing . Union [ str , hikari . SnowflakeishOr [ hikari . CustomEmoji ]] RETURNS DESCRIPTION collections . abc . Callabke [[ CallbackSigT ], CallbackSigT ] A decorator to add a callback to this reaction handler.","title":"with_callback()"},{"location":"reference/reactions/#yuyo.reactions.ReactionPaginator","text":"Bases: ReactionHandler Standard implementation of a reaction handler for pagination.","title":"ReactionPaginator"},{"location":"reference/reactions/#yuyo.reactions.ReactionPaginator.__init__","text":"__init__ ( iterator , * , authors , triggers = ( pagination . LEFT_TRIANGLE , pagination . STOP_SQUARE , pagination . RIGHT_TRIANGLE ), timeout = datetime . timedelta ( seconds = 30 )) Initialise a reaction paginator. PARAMETER DESCRIPTION iterator Either an asynchronous or synchronous iterator of the entries this should paginate through. entry[0] represents the message's possible content and can either be str or hikari.undefined.UNDEFINED and entry[1] represents the message's possible embed and can either be hikari.embeds.Embed or hikari.undefined.UNDEFINED . TYPE: collections . Iterator [ yuyo . pagination . EntryT ] | collections . AsyncIterator [ yuyo . pagination . EntryT ] authors An iterable of IDs of the users who can call this paginator. If left empty then all users will be able to call this paginator. TYPE: collections . Iterable [ hikari . SnowflakeishOr [ hikari . User ]] timeout How long it should take for this paginator to timeout. TYPE: datetime . timedelta DEFAULT: datetime.timedelta(seconds=30)","title":"__init__()"},{"location":"reference/reactions/#yuyo.reactions.ReactionPaginator.add_author","text":"add_author ( user ) Add a author/owner to this handler. PARAMETER DESCRIPTION user The user to add as an owner for this handler. TYPE: hikari . SnowflakeishOr [ hikari . User ]","title":"add_author()"},{"location":"reference/reactions/#yuyo.reactions.ReactionPaginator.close","text":"close ( * , remove_reactions = False , max_retries = 5 , max_backoff = 2.0 ) Close this handler and deregister any previously registered message. PARAMETER DESCRIPTION remove_reactions Whether this should remove the reactions that were being used to paginate through this from the previously registered message. TYPE: bool DEFAULT: False","title":"close()"},{"location":"reference/reactions/#yuyo.reactions.ReactionPaginator.create_message","text":"create_message ( rest , channel_id , / , * , add_reactions = True , max_retries = 5 , max_backoff = 2.0 ) Start this handler and link it to a bot message. Note Calling this multiple times will replace the previously registered message. PARAMETER DESCRIPTION rest Rest client to use to make the response. TYPE: hikari . api . RESTClient channel_id ID of the channel to respond in. TYPE: hikari . SnowflakeishOr [ hikari . TextableChannel ] add_reactions Whether this should add the paginator's reactions to the message after responding. TYPE: bool DEFAULT: True max_retries How many times this should retry to respond if Hikari raises any ratelimit errors. TYPE: int DEFAULT: 5 max_backoff The maximum time this should backoff for before trying if Hikari raises any ratelimit errors. TYPE: float DEFAULT: 2.0 RETURNS DESCRIPTION hikari . messages . Message Object of the message this handler now targets. If message was not supplied then this will be the object of a newly created message, otherwise this will be what was supplied as message . RAISES DESCRIPTION ValueError If the provided iterator didn't yield any content for the first message.","title":"create_message()"},{"location":"reference/reactions/#yuyo.reactions.ReactionPaginator.remove_author","text":"remove_author ( user ) Remove a author/owner from this handler. Note If the provided user isn't already a registered owner of this paginator then this should pass silently without raising. PARAMETER DESCRIPTION user The user to remove from this handler's owners. TYPE: hikari . SnowflakeishOr [ hikari . User ]","title":"remove_author()"},{"location":"reference/to_builder/","text":"yuyo.to_builder # Utility functions for converting Hikari data models to builders. to_button_builder # to_button_builder ( button ) Convert a button component to a builder. PARAMETER DESCRIPTION button The button component to convert to a builder. TYPE: hikari . ButtonComponent RETURNS DESCRIPTION hikari . api . LinkButtonBuilder | hikari . api . InteractiveButtonBuilder The buttion builder. to_cmd_builder # to_cmd_builder ( cmd ) Convert a partial command to a command builder. PARAMETER DESCRIPTION cmd The command to convert to a builder. TYPE: hikari . PartialCommand RETURNS DESCRIPTION hikari . api . CommandBuilder The command builder. This will always be a subclass. RAISES DESCRIPTION NotImplementedError If a unsupported command type is passed. Currently hikari.commands.SlashCommand and hikari.commands.ContextMenuCommand are supported. to_context_menu_builder # to_context_menu_builder ( cmd ) Convert a context menu command to a builder. PARAMETER DESCRIPTION cmd The context menu command to convert to a builder. TYPE: hikari . ContextMenuCommand RETURNS DESCRIPTION hikari . api . ContextMenuCommandBuilder The context menu command builder. RAISES DESCRIPTION NotImplementedError If a unsupported context menu type is passed. Currently hikari.commands.CommandType.MESSAGE and hikari.commands.CommandType.USER are supported. to_msg_action_row_builder # to_msg_action_row_builder ( action_row ) Convert a message action row component to a builder. PARAMETER DESCRIPTION action_row The message action row to convert to a builder. TYPE: hikari . MessageActionRowComponent RETURNS DESCRIPTION hikari . api . MessageActionRowBuilder The message action row builder. RAISES DESCRIPTION NotImplementedError If the action row contains an unsupported component type. The following are currently supported: hikari.components.ComponentType.ACTION_ROW hikari.components.ComponentType.BUTTON hikari.components.ComponentType.SELECT_MENU to_select_menu_builder # to_select_menu_builder ( select_menu ) Convert a select menu component to a builder. PARAMETER DESCRIPTION select_menu The selectmenu to convert to a builder. TYPE: hikari . SelectMenuComponent RETURNS DESCRIPTION hikari . api . SelectMenuBuilder The select menu builder. to_slash_cmd_builder # to_slash_cmd_builder ( cmd ) Convert a slash command to a builder. PARAMETER DESCRIPTION cmd The command to convert to a builder. TYPE: hikari . SlashCommand RETURNS DESCRIPTION hikari . api . SlashCommandBuilder The slash command builder.","title":"yuyo.to_builder"},{"location":"reference/to_builder/#yuyoto_builder","text":"Utility functions for converting Hikari data models to builders.","title":"yuyo.to_builder"},{"location":"reference/to_builder/#yuyo.to_builder.to_button_builder","text":"to_button_builder ( button ) Convert a button component to a builder. PARAMETER DESCRIPTION button The button component to convert to a builder. TYPE: hikari . ButtonComponent RETURNS DESCRIPTION hikari . api . LinkButtonBuilder | hikari . api . InteractiveButtonBuilder The buttion builder.","title":"to_button_builder()"},{"location":"reference/to_builder/#yuyo.to_builder.to_cmd_builder","text":"to_cmd_builder ( cmd ) Convert a partial command to a command builder. PARAMETER DESCRIPTION cmd The command to convert to a builder. TYPE: hikari . PartialCommand RETURNS DESCRIPTION hikari . api . CommandBuilder The command builder. This will always be a subclass. RAISES DESCRIPTION NotImplementedError If a unsupported command type is passed. Currently hikari.commands.SlashCommand and hikari.commands.ContextMenuCommand are supported.","title":"to_cmd_builder()"},{"location":"reference/to_builder/#yuyo.to_builder.to_context_menu_builder","text":"to_context_menu_builder ( cmd ) Convert a context menu command to a builder. PARAMETER DESCRIPTION cmd The context menu command to convert to a builder. TYPE: hikari . ContextMenuCommand RETURNS DESCRIPTION hikari . api . ContextMenuCommandBuilder The context menu command builder. RAISES DESCRIPTION NotImplementedError If a unsupported context menu type is passed. Currently hikari.commands.CommandType.MESSAGE and hikari.commands.CommandType.USER are supported.","title":"to_context_menu_builder()"},{"location":"reference/to_builder/#yuyo.to_builder.to_msg_action_row_builder","text":"to_msg_action_row_builder ( action_row ) Convert a message action row component to a builder. PARAMETER DESCRIPTION action_row The message action row to convert to a builder. TYPE: hikari . MessageActionRowComponent RETURNS DESCRIPTION hikari . api . MessageActionRowBuilder The message action row builder. RAISES DESCRIPTION NotImplementedError If the action row contains an unsupported component type. The following are currently supported: hikari.components.ComponentType.ACTION_ROW hikari.components.ComponentType.BUTTON hikari.components.ComponentType.SELECT_MENU","title":"to_msg_action_row_builder()"},{"location":"reference/to_builder/#yuyo.to_builder.to_select_menu_builder","text":"to_select_menu_builder ( select_menu ) Convert a select menu component to a builder. PARAMETER DESCRIPTION select_menu The selectmenu to convert to a builder. TYPE: hikari . SelectMenuComponent RETURNS DESCRIPTION hikari . api . SelectMenuBuilder The select menu builder.","title":"to_select_menu_builder()"},{"location":"reference/to_builder/#yuyo.to_builder.to_slash_cmd_builder","text":"to_slash_cmd_builder ( cmd ) Convert a slash command to a builder. PARAMETER DESCRIPTION cmd The command to convert to a builder. TYPE: hikari . SlashCommand RETURNS DESCRIPTION hikari . api . SlashCommandBuilder The slash command builder.","title":"to_slash_cmd_builder()"}]}