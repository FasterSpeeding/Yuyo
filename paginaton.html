<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>yuyo.paginaton API documentation</title>
<meta name="description" content="Utilities used for handling reaction based paginated messages." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>yuyo.paginaton</code></h1>
</header>
<section id="section-intro">
<p>Utilities used for handling reaction based paginated messages.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
# cython: language_level=3
# BSD 3-Clause License
#
# Copyright (c) 2020, Faster Speeding
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of the copyright holder nor the names of its
#   contributors may be used to endorse or promote products derived from
#   this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &#34;AS IS&#34;
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
&#34;&#34;&#34;Utilities used for handling reaction based paginated messages.&#34;&#34;&#34;

from __future__ import annotations

__slots__: typing.Sequence[str] = [&#34;AbstractPaginator&#34;, &#34;Paginator&#34;, &#34;PaginatorPool&#34;]

import abc
import asyncio
import datetime
import textwrap
import typing

from hikari import embeds
from hikari import emojis
from hikari import errors
from hikari import snowflakes
from hikari import traits
from hikari import undefined
from hikari.events import lifetime_events
from hikari.events import reaction_events

from yuyo import backoff

if typing.TYPE_CHECKING:
    from hikari import channels
    from hikari import messages
    from hikari import users


LEFT_DOUBLE_TRIANGLE: typing.Final[emojis.UnicodeEmoji] = emojis.UnicodeEmoji(
    &#34;\N{BLACK LEFT-POINTING DOUBLE TRIANGLE WITH VERTICAL BAR}\N{VARIATION SELECTOR-16}&#34;
)
&#34;&#34;&#34;The emoji used to go back to the first entry.&#34;&#34;&#34;
LEFT_TRIANGLE: typing.Final[emojis.UnicodeEmoji] = emojis.UnicodeEmoji(
    &#34;\N{BLACK LEFT-POINTING TRIANGLE}\N{VARIATION SELECTOR-16}&#34;
)
&#34;&#34;&#34;The emoji used to go back an entry.&#34;&#34;&#34;
STOP_SQUARE: typing.Final[emojis.UnicodeEmoji] = emojis.UnicodeEmoji(
    &#34;\N{BLACK SQUARE FOR STOP}\N{VARIATION SELECTOR-16}&#34;
)
&#34;&#34;&#34;The emoji used to close a menu.&#34;&#34;&#34;
RIGHT_TRIANGLE: typing.Final[emojis.UnicodeEmoji] = emojis.UnicodeEmoji(
    &#34;\N{BLACK RIGHT-POINTING TRIANGLE}\N{VARIATION SELECTOR-16}&#34;
)
&#34;&#34;&#34;The emoji used to continue to the next entry.&#34;&#34;&#34;
RIGHT_DOUBLE_TRIANGLE: typing.Final[emojis.UnicodeEmoji] = emojis.UnicodeEmoji(
    &#34;\N{BLACK RIGHT-POINTING DOUBLE TRIANGLE WITH VERTICAL BAR}\N{VARIATION SELECTOR-16}&#34;
)
&#34;&#34;&#34;The emoji used for the lesser-enabled skip to last entry button.&#34;&#34;&#34;
END = &#34;END&#34;
&#34;&#34;&#34;A return value used by `AbstractPaginator.on_reaction_event`.

This indicates that the paginator should be removed from the pool.
&#34;&#34;&#34;
DefaultT = typing.TypeVar(&#34;DefaultT&#34;)
&#34;&#34;&#34;A type hint used to represent a &#34;default&#34; argument provided to a function.&#34;&#34;&#34;
EntryT = typing.Tuple[undefined.UndefinedOr[str], undefined.UndefinedOr[embeds.Embed]]
&#34;&#34;&#34;A type hint used to represent a paginator entry.

This should be a tuple of the string message content or `hikari.undefined.UNDEFINED`
to the message&#39;s embed if set else `hikari.undefined.UNDEFINED`.
&#34;&#34;&#34;
ValueT = typing.TypeVar(&#34;ValueT&#34;)
&#34;&#34;&#34;A type hint used to represent the type handled by an iterator.&#34;&#34;&#34;
IteratorT = typing.Union[typing.AsyncIterator[ValueT], typing.Iterator[ValueT]]
&#34;&#34;&#34;A type hint used in places where both iterators and async-iterators are supported.&#34;&#34;&#34;


class AbstractPaginator(abc.ABC):
    &#34;&#34;&#34;The interface for a paginator handled within the `PaginatorPool`.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    @property
    @abc.abstractmethod
    def authors(self) -&gt; typing.AbstractSet[snowflakes.Snowflake]:
        &#34;&#34;&#34;The authors/owner of a enabled paginator.

        !!! note
            If this is empty then the paginator is considered public and
            any user will be able to trigger it.

        Returns
        -------
        typing.AbstractSet[hikari.snowflakes.Snowflake]
            A set of the owner user IDs.
        &#34;&#34;&#34;
        raise NotImplementedError

    @property
    @abc.abstractmethod
    def expired(self) -&gt; bool:
        &#34;&#34;&#34;Whether this paginator has ended.

        Returns
        -------
        bool
            Whether this paginator has ended.
        &#34;&#34;&#34;
        raise NotImplementedError

    @property
    @abc.abstractmethod
    def last_triggered(self) -&gt; datetime.datetime:
        &#34;&#34;&#34;When this paginator was last triggered.

        !!! note
            If it hasn&#39;t ever been triggered then this will be when it was created.

        Returns
        -------
        datetime.datetime
            When this paginator was last triggered.
        &#34;&#34;&#34;
        raise NotImplementedError

    @property
    @abc.abstractmethod
    def locked(self) -&gt; bool:
        &#34;&#34;&#34;Whether this paginator has been locked by a call to it.

        Returns
        -------
        bool
            Whether this paginator has been locked by a call to it.
        &#34;&#34;&#34;
        raise NotImplementedError

    @property
    @abc.abstractmethod
    def triggers(self) -&gt; typing.Sequence[emojis.Emoji]:
        &#34;&#34;&#34;The enabled trigger emojis for this paginator.

        Returns
        -------
        typing.Sequence[emojis.Emoji]
            A sequence of the emojis that are enabled as triggers for
            this paginator.
        &#34;&#34;&#34;
        raise NotImplementedError

    @abc.abstractmethod
    def add_author(self, user: snowflakes.SnowflakeishOr[users.User], /) -&gt; None:
        &#34;&#34;&#34;Add a author/owner to this paginator.

        Parameters
        ----------
        user : hikari.snowflakes.SnowflakeishOr[hikari.users.User]
            The user to add as an owner for this paginator.
        &#34;&#34;&#34;
        raise NotImplementedError

    @abc.abstractmethod
    def remove_author(self, user: snowflakes.SnowflakeishOr[users.User], /) -&gt; None:
        &#34;&#34;&#34;Remove a author/owner from this paginator.

        !!! note
            If the provided user isn&#39;t already a registered owner of this paginator
            then this should pass silently without raising.

        Parameters
        ----------
        user : hikari.snowflakes.SnowflakeishOr[hikari.users.User]
            The user to remove from this paginator&#39;s owners..
        &#34;&#34;&#34;
        raise NotImplementedError

    @abc.abstractmethod
    async def close(self, *, remove_reactions: bool = False) -&gt; None:
        &#34;&#34;&#34;Close this paginator and deregister any previously registered message.

        Other Parameters
        ----------------
        remove_reactions : builtins.bool
            Whether this should remove the reactions that were being used to
            paginate through this from the previously registered message.
            This defaults to `builtins.False`.
        &#34;&#34;&#34;
        raise NotImplementedError

    @abc.abstractmethod
    async def open(
        self,
        *,
        message: typing.Optional[snowflakes.SnowflakeishOr[messages.Message]] = None,
        add_reactions: bool = True,
    ) -&gt; typing.Optional[messages.Message]:
        &#34;&#34;&#34;Start this paginator and link it to a message.

        Other Parameters
        ----------------
        message : typing.Optional[hikari.messages.Message]
            If already created, the message this paginator should target.
            If left as `builtins.None` then this call will create a message
            in the channel provided when initiating the paginator.
        add_reactions : bool
            Whether this should also add reactions that&#39;ll be used to paginate
            over this resource.
            This defaults to `builtins.True`.

        !!! note
            Calling this multiple times will replace the previously registered message.

        Returns
        -------
        typing.Optional[hikari.messages.Message]
            The message that this paginator created if `message_id` was left as `builtins.None`
            else `builtins.None`.

        Raises
        ------
        ValueError
            If the provided iterator didn&#39;t yield any content for the first message.
        &#34;&#34;&#34;
        raise NotImplementedError

    @abc.abstractmethod
    async def on_reaction_event(self, emoji: emojis.Emoji, user_id: snowflakes.Snowflake) -&gt; typing.Optional[str]:
        &#34;&#34;&#34;The logic for handling reaction pagination.

        !!! note
            This should generally speaking only be called on ReactionAddEvent
            and ReactionDeleteEvent.

        Parameters
        ----------
        emoji : hikari.emojis.Emoji
            The unicode or custom emoji being added or removed in this event.
        user_id : hikari.snowflakes.Snowflake
            The ID of the user adding or removing this reaction.

        Returns
        -------
        typing.Optional[str]
            This will either be a string command (&#39;&#34;END&#34;&#39; to signal that the
            paginator has been de-registered and should be removed from the
            pool) or `builtins.None`.
        &#34;&#34;&#34;
        raise NotImplementedError


async def _collect_iterator(iterator: IteratorT[ValueT], /) -&gt; typing.MutableSequence[ValueT]:
    &#34;&#34;&#34;Collect the rest of an async or sync iterator into a mutable sequence

    Parameters
    ----------
    iterator : typing.union[typing.AsyncIterator[ValueT], typing.Iterator[ValueT]]
        The iterator to collect. This iterator may be asynchronous or synchronous.

    Returns
    -------
    ValueT
        A sequence of the remaining values in the iterator.
    &#34;&#34;&#34;
    if isinstance(iterator, typing.AsyncIterator):
        return [value async for value in iterator]

    if isinstance(iterator, typing.Iterator):
        return list(iterator)

    raise ValueError(f&#34;{type(iterator)!r} is not a valid iterator&#34;)


async def _seek_iterator(iterator: IteratorT[ValueT], /, default: DefaultT) -&gt; typing.Optional[ValueT]:
    &#34;&#34;&#34;Get the next value in an async or sync iterator.

    Parameters
    ----------
    iterator : typing.union[typing.AsyncIterator[builtins.str], typing.Iterator[builtins.str]]
        The iterator to get the next value of. This iterator may be asynchronous or synchronous.

    Other Parameters
    ----------------
    default : DefaultT
        The value this should return if the iterator has been exhausted
        (didn&#39;t yield any more values).
        This defaults to `builtins.None`.

    Returns
    -------
    typing.Union[ValueT, DefaultT]
        The next value in the iterator if available else the value passed
        for `default`.
    &#34;&#34;&#34;
    value: typing.Union[ValueT, DefaultT] = default
    if isinstance(iterator, typing.AsyncIterator):
        async for value in iterator:
            break

    elif isinstance(iterator, typing.Iterator):
        for value in iterator:
            break

    else:
        raise ValueError(f&#34;{type(iterator)!r} is not a valid iterator&#34;)

    return value


def _process_known_custom_emoji(emoji: emojis.Emoji, /) -&gt; emojis.Emoji:
    # For the sake of equality checks we need to ensure we&#39;re handling CustomEmoji rather than KnownCustomEmoji
    if isinstance(emoji, emojis.KnownCustomEmoji):
        return emojis.CustomEmoji(id=emoji.id, name=emoji.name, is_animated=emoji.is_animated)

    return emoji


class Paginator(AbstractPaginator):
    &#34;&#34;&#34;The standard implementation of `AbstractPaginator`.

    Parameters
    ----------
    rest : hikari.traits.RESTAware
        The REST aware client this should be bound to.
    channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
        The ID of the text channel this iterator targets.
    iterator : Iterator[typing.Tuple[undefined.UndefinedOr[str], undefined.UndefinedOr[embeds.Embed]]]
        Either an asynchronous or synchronous iterator of the entries this
        should paginate through.
        Entry[0] represents the message&#39;s possible content and can either be
        `builtins.str` or `hikari.undefined.UNDEFINED` and Entry[1] represents
        the message&#39;s possible embed and can either be `hikari.embeds.Embed`
        or `hikari.undefined.UNDEFINED`.
    authors : typing.Iterable[hikari.snowflakes.SnowflakeishOr[hikari.users.User]]
        An iterable of IDs of the users who can call this paginator.
        If left empty then all users will be able to call this
        paginator.

    Other Parameters
    ----------------
    timeout : datetime.timedelta
        How long it should take for this paginator to timeout.
        This defaults to a timdelta of 30 seconds.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (
        &#34;_authors&#34;,
        &#34;_buffer&#34;,
        &#34;_channel_id&#34;,
        &#34;_emoji_mapping&#34;,
        &#34;_index&#34;,
        &#34;_iterator&#34;,
        &#34;_last_triggered&#34;,
        &#34;_locked&#34;,
        &#34;_message_id&#34;,
        &#34;_rest&#34;,
        &#34;timeout&#34;,
        &#34;_triggers&#34;,
    )

    def __init__(
        self,
        rest: traits.RESTAware,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        iterator: typing.Union[IteratorT[EntryT]],
        *,
        authors: typing.Iterable[snowflakes.SnowflakeishOr[users.User]],
        triggers: typing.Sequence[emojis.Emoji] = (
            LEFT_TRIANGLE,
            STOP_SQUARE,
            RIGHT_TRIANGLE,
        ),
        timeout: datetime.timedelta = datetime.timedelta(seconds=30),
    ) -&gt; None:
        if isinstance(iterator, typing.Iterator):
            raise ValueError(f&#34;Invalid value passed for `iterator`, expected an iterator but got {type(iterator)}&#34;)

        self._authors = set(map(snowflakes.Snowflake, authors))
        self._buffer: typing.MutableSequence[EntryT] = []
        self._channel_id = channel
        self._emoji_mapping: typing.Mapping[
            typing.Union[emojis.Emoji, snowflakes.Snowflake],
            typing.Callable[[], typing.Coroutine[typing.Any, typing.Any, typing.Union[EntryT, None, str]]],
        ] = {
            LEFT_DOUBLE_TRIANGLE: self._on_first,
            LEFT_TRIANGLE: self._on_previous,
            STOP_SQUARE: self._on_disable,
            RIGHT_TRIANGLE: self._on_next,
            RIGHT_DOUBLE_TRIANGLE: self._on_last,
        }
        self._index = 0
        self._iterator = iterator
        self._last_triggered = datetime.datetime.now(tz=datetime.timezone.utc)
        self._locked = False
        self._message_id: typing.Optional[snowflakes.Snowflake] = None
        self._rest = rest
        self.timeout = timeout
        self._triggers = tuple(_process_known_custom_emoji(emoji) for emoji in triggers)

    @property
    def authors(self) -&gt; typing.AbstractSet[snowflakes.Snowflake]:
        # &lt;&lt;inherited docstring from AbstractPaginator&gt;&gt;.
        return frozenset(self._authors)

    @property
    def expired(self) -&gt; bool:
        # &lt;&lt;inherited docstring from AbstractPaginator&gt;&gt;.
        return self.timeout &lt; datetime.datetime.now(tz=datetime.timezone.utc) - self._last_triggered

    @property
    def last_triggered(self) -&gt; datetime.datetime:
        # &lt;&lt;inherited docstring from AbstractPaginator&gt;&gt;.
        return self._last_triggered

    @property
    def locked(self) -&gt; bool:
        # &lt;&lt;inherited docstring from AbstractPaginator&gt;&gt;.
        return self._locked

    @property
    def triggers(self) -&gt; typing.Sequence[emojis.Emoji]:
        # &lt;&lt;inherited docstring from AbstractPaginator&gt;&gt;.
        return self._triggers

    async def _delete_message(self, message_id: snowflakes.Snowflake, /) -&gt; None:
        retry = backoff.Backoff()

        async for _ in retry:
            try:
                await self._rest.rest.delete_message(self._channel_id, message_id)

            except (errors.NotFoundError, errors.ForbiddenError):  # TODO: better permission handling.
                return

            except errors.InternalServerError:
                continue

            except errors.RateLimitedError as exc:
                retry.set_next_backoff(exc.retry_after)

            else:
                break

    async def _on_disable(self) -&gt; str:
        if message_id := self._message_id:
            self._message_id = None
            # We create a task here rather than awaiting this to ensure the instance is marked as ended as soon as
            # possible.
            asyncio.create_task(self._delete_message(message_id))

        return END

    async def _on_first(self) -&gt; typing.Optional[EntryT]:
        if self._index == 0:
            return None

        return self._buffer[0]

    async def _on_last(self) -&gt; typing.Optional[EntryT]:
        self._locked = True
        if isinstance(self._iterator, typing.AsyncIterator):
            self._buffer.extend([embed async for embed in self._iterator])

        elif isinstance(self._iterator, typing.Iterator):
            self._buffer.extend(self._iterator)

        self._locked = False

        if self._buffer:
            self._index = len(self._buffer) - 1
            return self._buffer[-1]

        return None

    async def _on_next(self) -&gt; typing.Optional[EntryT]:
        # Check to see if we&#39;re behind the buffer before trying to go forward in the generator.
        if len(self._buffer) &gt;= self._index + 2:
            self._index += 1
            return self._buffer[self._index]

        # If entry is not None then the generator&#39;s position was pushed forwards.
        if (entry := await _seek_iterator(self._iterator, default=None)) is not None:
            self._index += 1
            self._buffer.append(entry)

        return entry

    async def _on_previous(self) -&gt; typing.Optional[EntryT]:
        if self._index &lt;= 0:
            return None

        self._index -= 1
        return self._buffer[self._index]

    def add_author(self, user: snowflakes.SnowflakeishOr[users.User], /) -&gt; None:
        # &lt;&lt;inherited docstring from AbstractPaginator&gt;&gt;.
        self._authors.add(snowflakes.Snowflake(user))

    def remove_author(self, user: snowflakes.SnowflakeishOr[users.User], /) -&gt; None:
        # &lt;&lt;inherited docstring from AbstractPaginator&gt;&gt;.
        try:
            self._authors.remove(snowflakes.Snowflake(user))
        except KeyError:
            pass

    async def close(self, remove_reactions: bool = False) -&gt; None:
        # &lt;&lt;inherited docstring from AbstractPaginator&gt;&gt;.
        if message_id := self._message_id:
            self._message_id = None
            retry = backoff.Backoff()
            # TODO: check if we can just clear the reactions before doing this using the cache.
            for emoji in self._triggers:
                retry.reset()
                async for _ in retry:
                    try:
                        await self._rest.rest.delete_my_reaction(self._channel_id, message_id, emoji)

                    except (errors.NotFoundError, errors.ForbiddenError):
                        return

                    except errors.RateLimitedError as exc:
                        retry.set_next_backoff(exc.retry_after)

                    except errors.InternalServerError:
                        continue

                    else:
                        break

    async def open(
        self,
        *,
        message: typing.Optional[snowflakes.SnowflakeishOr[messages.Message]] = None,
        add_reactions: bool = True,
        max_retries: int = 5,
        max_backoff: float = 2.0,
    ) -&gt; typing.Optional[messages.Message]:
        # &lt;&lt;inherited docstring from AbstractPaginator&gt;&gt;.
        created_message: typing.Optional[messages.Message] = None
        if self._message_id is not None:
            return None

        retry = backoff.Backoff(max_retries=max_retries - 1, maximum=max_backoff)
        if message is None:
            entry = await self._on_next()

            if entry is None:
                raise ValueError(&#34;Paginator iterator yielded no pages.&#34;)

            async for _ in retry:
                try:
                    created_message = await self._rest.rest.create_message(
                        self._channel_id, content=entry[0], embed=entry[1]
                    )
                    message = created_message.id

                except errors.RateLimitedError as exc:
                    if exc.retry_after &gt; max_backoff:
                        raise

                    retry.set_next_backoff(exc.retry_after)

                except errors.InternalServerError:
                    continue

                else:
                    break

            else:
                message = await self._rest.rest.create_message(self._channel_id, content=entry[0], embed=entry[1])

        message = snowflakes.Snowflake(message)
        self._message_id = message
        for emoji in self._triggers:
            retry.reset()
            async for _ in retry:
                try:
                    await self._rest.rest.add_reaction(self._channel_id, message, emoji)

                except (errors.NotFoundError, errors.ForbiddenError):
                    self._message_id = None
                    raise

                except errors.RateLimitedError as exc:
                    if exc.retry_after &gt; max_backoff:
                        raise

                    retry.set_next_backoff(exc.retry_after)

                except errors.InternalServerError:
                    continue

                else:
                    break

            else:
                await self._rest.rest.add_reaction(self._channel_id, message, emoji)

        return created_message

    async def on_reaction_event(self, emoji: emojis.Emoji, user_id: snowflakes.Snowflake) -&gt; typing.Optional[str]:
        # &lt;&lt;inherited docstring from AbstractPaginator&gt;&gt;.
        if self.expired:
            asyncio.create_task(self.close(remove_reactions=True))
            return END

        if self._message_id is None or self._authors and user_id not in self._authors or self._locked:
            return None

        method = self._emoji_mapping.get(emoji)
        if emoji not in self._triggers or not method:
            return None

        result = await method()
        if isinstance(result, str) or result is None:
            return END

        self._last_triggered = datetime.datetime.now(tz=datetime.timezone.utc)
        retry = backoff.Backoff()

        async for _ in retry:
            # Mypy makes the false assumption that this value will stay as None while this function yields.
            if self._message_id is None:
                break  # type: ignore[unreachable]

            try:
                await self._rest.rest.edit_message(
                    self._channel_id, self._message_id, content=result[0], embed=result[1]
                )

            except errors.InternalServerError:
                continue

            except errors.RateLimitedError as exc:
                retry.set_next_backoff(exc.retry_after)

            except (errors.NotFoundError, errors.ForbiddenError):
                return END

            else:
                break

        return None


class PaginatorPool:
    &#34;&#34;&#34;A class which handles the events for multiple registered paginators.

    Parameters
    ----------
    rest : hikari.traits.RESTAware
        The REST aware client to register this paginator pool with.
    dispatch : typing.Optional[hikari.traits.DispatcherAware]
        The dispatcher aware client to register this paginator pool with.

        !!! note
            This may only be left as `builtins.None` if `rest` is dispatcher
            aware.

    Raises
    ------
    ValueError
        If `dispatch` is left as `builtins.None` when `rest` is not also
        dispatcher aware.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (&#34;blacklist&#34;, &#34;_dispatch&#34;, &#34;_gc_task&#34;, &#34;_listeners&#34;, &#34;_rest&#34;)

    def __init__(self, rest: traits.RESTAware, dispatch: typing.Optional[traits.DispatcherAware] = None, /) -&gt; None:
        if dispatch is None and isinstance(rest, traits.DispatcherAware):
            dispatch = rest

        if dispatch is None:
            raise ValueError(&#34;Missing dispatcher aware client.&#34;)

        self.blacklist: typing.MutableSequence[snowflakes.Snowflake] = []
        self._dispatch = dispatch
        self._gc_task: typing.Optional[asyncio.Task[None]] = None
        self._listeners: typing.MutableMapping[snowflakes.Snowflake, AbstractPaginator] = {}
        self._rest = rest

    async def _gc(self) -&gt; None:
        while True:
            for listener_id, listener in tuple(self._listeners.items()):
                if not listener.expired or listener_id not in self._listeners:
                    continue

                del self._listeners[listener_id]
                # This may slow this gc task down but the more we yield the better.
                await listener.close(remove_reactions=True)

            await asyncio.sleep(5)  # TODO: is this a good time?

    async def _on_reaction_event(
        self, event: typing.Union[reaction_events.ReactionAddEvent, reaction_events.ReactionDeleteEvent], /
    ) -&gt; None:
        if event.user_id in self.blacklist:
            return

        if listener := self._listeners.get(event.message_id):
            result = await listener.on_reaction_event(event.emoji, user_id=event.user_id)
            if result is END and event.message_id in self._listeners:
                del self._listeners[event.message_id]

    async def _on_starting_event(self, _: lifetime_events.StartingEvent, /) -&gt; None:
        await self.open()

    async def _on_stopping_event(self, _: lifetime_events.StoppingEvent, /) -&gt; None:
        await self.close()

    def add_paginator(
        self, message: snowflakes.SnowflakeishOr[messages.Message], /, paginator: AbstractPaginator
    ) -&gt; None:
        &#34;&#34;&#34;Add a paginator to this pool.

        !!! note
            This does not call `AbstractPaginator.open`.

        Parameters
        ----------
        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.Message]
            The message ID to add register a paginator with.
        paginator : AbstractPaginator
            The object of the opened paginator to register in this pool.
        &#34;&#34;&#34;
        self._listeners[snowflakes.Snowflake(message)] = paginator

    def get_paginator(
        self, message: snowflakes.SnowflakeishOr[messages.Message], /
    ) -&gt; typing.Optional[AbstractPaginator]:
        &#34;&#34;&#34;Get a reference to a paginator registered in this pool.

        !!! note
            This does not call `AbstractPaginator.close`.

        Parameters
        ----------
        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.Message]
            The message ID to remove a paginator for.

        Returns
        -------
        AbstractPaginator
            The object of the registered paginator if found else `builtins.None`.
        &#34;&#34;&#34;
        return self._listeners.get(snowflakes.Snowflake(message))

    def remove_paginator(
        self, message: snowflakes.SnowflakeishOr[messages.Message], /
    ) -&gt; typing.Optional[AbstractPaginator]:
        &#34;&#34;&#34;Remove a paginator from this pool.

        !!! note
            This does not call `AbstractPaginator.close`.

        Parameters
        ----------
        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.Message]
            The message ID to remove a paginator for.

        Returns
        -------
        AbstractPaginator
            The object of the registered paginator if found else `builtins.None`.
        &#34;&#34;&#34;
        return self._listeners.pop(snowflakes.Snowflake(message))

    async def close(self) -&gt; None:
        &#34;&#34;&#34;Close this pool by unregistering any tasks and event listeners registered by `PaginatorPool.open`.&#34;&#34;&#34;
        if self._gc_task is not None:
            self._dispatch.dispatcher.unsubscribe(lifetime_events.StartingEvent, self._on_starting_event)
            self._dispatch.dispatcher.unsubscribe(lifetime_events.StoppingEvent, self._on_stopping_event)
            self._dispatch.dispatcher.unsubscribe(reaction_events.ReactionAddEvent, self._on_reaction_event)
            self._dispatch.dispatcher.unsubscribe(reaction_events.ReactionDeleteEvent, self._on_reaction_event)
            self._gc_task.cancel()
            listeners = self._listeners
            self._listeners = {}
            await asyncio.gather(*(listener.close() for listener in listeners.values()))

    async def open(self) -&gt; None:
        &#34;&#34;&#34;Start this pool by registering the required tasks and event listeners for it to function.&#34;&#34;&#34;
        if self._gc_task is None:
            self._gc_task = asyncio.create_task(self._gc())
            self.blacklist.append((await self._rest.rest.fetch_my_user()).id)
            self._dispatch.dispatcher.subscribe(lifetime_events.StartingEvent, self._on_starting_event)
            self._dispatch.dispatcher.subscribe(lifetime_events.StoppingEvent, self._on_stopping_event)
            self._dispatch.dispatcher.subscribe(reaction_events.ReactionAddEvent, self._on_reaction_event)
            self._dispatch.dispatcher.subscribe(reaction_events.ReactionDeleteEvent, self._on_reaction_event)


async def string_paginator(
    lines: IteratorT[str],
    *,
    char_limit: int = 2000,
    line_limit: int = 25,
    wrapper: typing.Optional[str] = None,
) -&gt; typing.AsyncIterator[typing.Tuple[str, int]]:
    &#34;&#34;&#34;Lazily paginate an iterator of lines.

    Parameters
    ----------
    lines : typing.union[typing.AsyncIterator[builtins.str], typing.Iterator[builtins.str]]
        The iterator of lines to paginate. This iterator may be asynchronous or synchronous.
    char_limit : builtins.int
        The limit for how many characters should be included per yielded page.
        This defaults to 2000
    line_limit : builtins.int
        The limit for how many lines should be included per yielded page.
        This defaults to 25.
    wrapper : typing.Optional[builtins.str]
        A wrapper for each yielded page. This should leave &#34;{}&#34; in it
        to be replaced by the page&#39;s content.

    Returns
    -------
    typing.AsyncIterator[typing.Tuple[builtins.str, builtins.int]]
        An async iterator of page tuples (string context to int zero-based index).
    &#34;&#34;&#34;
    if wrapper:
        char_limit -= len(wrapper) + 2

    # As this is incremented before yielding and zero-index we have to start at -1.
    page_number = -1
    page_size = 0
    page: typing.MutableSequence[str] = []

    while (line := await _seek_iterator(lines, default=None)) is not None:
        # If the page is already populated and adding the current line would bring it over one of the predefined limits
        # then we want to yield this page.
        if len(page) &gt;= line_limit or page and page_size + len(line) &gt; char_limit:
            yield wrapper.format(&#34;\n&#34;.join(page)) if wrapper else &#34;\n&#34;.join(page), (page_number := page_number + 1)
            page.clear()
            page_size = 0

        # If the current line doesn&#39;t fit into a page then we need to split it up into sub-pages to yield and can
        # assume the previous page was yielded.
        if len(line) &gt;= char_limit:
            sub_pages = textwrap.wrap(
                line, width=char_limit, drop_whitespace=False, break_on_hyphens=False, expand_tabs=False
            )

            # If the last page could possible fit into a page with other lines then we add it to the next page
            # to avoid sending small terraced pages.
            if len(sub_pages[-1]) &lt; char_limit:
                sub_line = sub_pages.pop(-1)
                page_size += len(sub_line)
                page.append(sub_line)

            # yield all the sub-lines at once.
            for sub_line in map(wrapper.format, sub_pages) if wrapper else sub_pages:
                yield sub_line, (page_number := page_number + 1)

        # Otherwise it should be added to the next page.
        else:
            page_size += len(line)
            page.append(line)

    # This catches the likely dangling page after iteration ends.
    if page:
        yield wrapper.format(&#34;\n&#34;.join(page)) if wrapper else &#34;\n&#34;.join(page), page_number + 1</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="yuyo.paginaton.DefaultT"><code class="name">var <span class="ident">DefaultT</span></code></dt>
<dd>
<div class="desc"><p>A type hint used to represent a "default" argument provided to a function.</p></div>
</dd>
<dt id="yuyo.paginaton.END"><code class="name">var <span class="ident">END</span></code></dt>
<dd>
<div class="desc"><p>A return value used by <code><a title="yuyo.paginaton.AbstractPaginator.on_reaction_event" href="#yuyo.paginaton.AbstractPaginator.on_reaction_event">AbstractPaginator.on_reaction_event()</a></code>.</p>
<p>This indicates that the paginator should be removed from the pool.</p></div>
</dd>
<dt id="yuyo.paginaton.EntryT"><code class="name">var <span class="ident">EntryT</span></code></dt>
<dd>
<div class="desc"><p>A type hint used to represent a paginator entry.</p>
<p>This should be a tuple of the string message content or <code>hikari.undefined.UNDEFINED</code>
to the message's embed if set else <code>hikari.undefined.UNDEFINED</code>.</p></div>
</dd>
<dt id="yuyo.paginaton.IteratorT"><code class="name">var <span class="ident">IteratorT</span></code></dt>
<dd>
<div class="desc"><p>A type hint used in places where both iterators and async-iterators are supported.</p></div>
</dd>
<dt id="yuyo.paginaton.LEFT_DOUBLE_TRIANGLE"><code class="name">var <span class="ident">LEFT_DOUBLE_TRIANGLE</span></code></dt>
<dd>
<div class="desc"><p>The emoji used to go back to the first entry.</p></div>
</dd>
<dt id="yuyo.paginaton.LEFT_TRIANGLE"><code class="name">var <span class="ident">LEFT_TRIANGLE</span></code></dt>
<dd>
<div class="desc"><p>The emoji used to go back an entry.</p></div>
</dd>
<dt id="yuyo.paginaton.RIGHT_DOUBLE_TRIANGLE"><code class="name">var <span class="ident">RIGHT_DOUBLE_TRIANGLE</span></code></dt>
<dd>
<div class="desc"><p>The emoji used for the lesser-enabled skip to last entry button.</p></div>
</dd>
<dt id="yuyo.paginaton.RIGHT_TRIANGLE"><code class="name">var <span class="ident">RIGHT_TRIANGLE</span></code></dt>
<dd>
<div class="desc"><p>The emoji used to continue to the next entry.</p></div>
</dd>
<dt id="yuyo.paginaton.STOP_SQUARE"><code class="name">var <span class="ident">STOP_SQUARE</span></code></dt>
<dd>
<div class="desc"><p>The emoji used to close a menu.</p></div>
</dd>
<dt id="yuyo.paginaton.ValueT"><code class="name">var <span class="ident">ValueT</span></code></dt>
<dd>
<div class="desc"><p>A type hint used to represent the type handled by an iterator.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="yuyo.paginaton.string_paginator"><code class="name flex">
<span>async def <span class="ident">string_paginator</span></span>(<span>lines: <a title="yuyo.paginaton.IteratorT" href="#yuyo.paginaton.IteratorT">IteratorT</a>[str], *, char_limit: int = 2000, line_limit: int = 25, wrapper: typing.Optional[str] = None) ‑> AsyncIterator[Tuple[str, int]]</span>
</code></dt>
<dd>
<div class="desc"><p>Lazily paginate an iterator of lines.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>lines</code></strong> :&ensp;<code>typing.union[typing.AsyncIterator[builtins.str], typing.Iterator[builtins.str]]</code></dt>
<dd>The iterator of lines to paginate. This iterator may be asynchronous or synchronous.</dd>
<dt><strong><code>char_limit</code></strong> :&ensp;<code>builtins.int</code></dt>
<dd>The limit for how many characters should be included per yielded page.
This defaults to 2000</dd>
<dt><strong><code>line_limit</code></strong> :&ensp;<code>builtins.int</code></dt>
<dd>The limit for how many lines should be included per yielded page.
This defaults to 25.</dd>
<dt><strong><code>wrapper</code></strong> :&ensp;<code>typing.Optional[builtins.str]</code></dt>
<dd>A wrapper for each yielded page. This should leave "{}" in it
to be replaced by the page's content.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>typing.AsyncIterator[typing.Tuple[builtins.str, builtins.int]]</code></dt>
<dd>An async iterator of page tuples (string context to int zero-based index).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def string_paginator(
    lines: IteratorT[str],
    *,
    char_limit: int = 2000,
    line_limit: int = 25,
    wrapper: typing.Optional[str] = None,
) -&gt; typing.AsyncIterator[typing.Tuple[str, int]]:
    &#34;&#34;&#34;Lazily paginate an iterator of lines.

    Parameters
    ----------
    lines : typing.union[typing.AsyncIterator[builtins.str], typing.Iterator[builtins.str]]
        The iterator of lines to paginate. This iterator may be asynchronous or synchronous.
    char_limit : builtins.int
        The limit for how many characters should be included per yielded page.
        This defaults to 2000
    line_limit : builtins.int
        The limit for how many lines should be included per yielded page.
        This defaults to 25.
    wrapper : typing.Optional[builtins.str]
        A wrapper for each yielded page. This should leave &#34;{}&#34; in it
        to be replaced by the page&#39;s content.

    Returns
    -------
    typing.AsyncIterator[typing.Tuple[builtins.str, builtins.int]]
        An async iterator of page tuples (string context to int zero-based index).
    &#34;&#34;&#34;
    if wrapper:
        char_limit -= len(wrapper) + 2

    # As this is incremented before yielding and zero-index we have to start at -1.
    page_number = -1
    page_size = 0
    page: typing.MutableSequence[str] = []

    while (line := await _seek_iterator(lines, default=None)) is not None:
        # If the page is already populated and adding the current line would bring it over one of the predefined limits
        # then we want to yield this page.
        if len(page) &gt;= line_limit or page and page_size + len(line) &gt; char_limit:
            yield wrapper.format(&#34;\n&#34;.join(page)) if wrapper else &#34;\n&#34;.join(page), (page_number := page_number + 1)
            page.clear()
            page_size = 0

        # If the current line doesn&#39;t fit into a page then we need to split it up into sub-pages to yield and can
        # assume the previous page was yielded.
        if len(line) &gt;= char_limit:
            sub_pages = textwrap.wrap(
                line, width=char_limit, drop_whitespace=False, break_on_hyphens=False, expand_tabs=False
            )

            # If the last page could possible fit into a page with other lines then we add it to the next page
            # to avoid sending small terraced pages.
            if len(sub_pages[-1]) &lt; char_limit:
                sub_line = sub_pages.pop(-1)
                page_size += len(sub_line)
                page.append(sub_line)

            # yield all the sub-lines at once.
            for sub_line in map(wrapper.format, sub_pages) if wrapper else sub_pages:
                yield sub_line, (page_number := page_number + 1)

        # Otherwise it should be added to the next page.
        else:
            page_size += len(line)
            page.append(line)

    # This catches the likely dangling page after iteration ends.
    if page:
        yield wrapper.format(&#34;\n&#34;.join(page)) if wrapper else &#34;\n&#34;.join(page), page_number + 1</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="yuyo.paginaton.AbstractPaginator"><code class="flex name class">
<span>class <span class="ident">AbstractPaginator</span></span>
</code></dt>
<dd>
<div class="desc"><p>The interface for a paginator handled within the <code><a title="yuyo.paginaton.PaginatorPool" href="#yuyo.paginaton.PaginatorPool">PaginatorPool</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AbstractPaginator(abc.ABC):
    &#34;&#34;&#34;The interface for a paginator handled within the `PaginatorPool`.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    @property
    @abc.abstractmethod
    def authors(self) -&gt; typing.AbstractSet[snowflakes.Snowflake]:
        &#34;&#34;&#34;The authors/owner of a enabled paginator.

        !!! note
            If this is empty then the paginator is considered public and
            any user will be able to trigger it.

        Returns
        -------
        typing.AbstractSet[hikari.snowflakes.Snowflake]
            A set of the owner user IDs.
        &#34;&#34;&#34;
        raise NotImplementedError

    @property
    @abc.abstractmethod
    def expired(self) -&gt; bool:
        &#34;&#34;&#34;Whether this paginator has ended.

        Returns
        -------
        bool
            Whether this paginator has ended.
        &#34;&#34;&#34;
        raise NotImplementedError

    @property
    @abc.abstractmethod
    def last_triggered(self) -&gt; datetime.datetime:
        &#34;&#34;&#34;When this paginator was last triggered.

        !!! note
            If it hasn&#39;t ever been triggered then this will be when it was created.

        Returns
        -------
        datetime.datetime
            When this paginator was last triggered.
        &#34;&#34;&#34;
        raise NotImplementedError

    @property
    @abc.abstractmethod
    def locked(self) -&gt; bool:
        &#34;&#34;&#34;Whether this paginator has been locked by a call to it.

        Returns
        -------
        bool
            Whether this paginator has been locked by a call to it.
        &#34;&#34;&#34;
        raise NotImplementedError

    @property
    @abc.abstractmethod
    def triggers(self) -&gt; typing.Sequence[emojis.Emoji]:
        &#34;&#34;&#34;The enabled trigger emojis for this paginator.

        Returns
        -------
        typing.Sequence[emojis.Emoji]
            A sequence of the emojis that are enabled as triggers for
            this paginator.
        &#34;&#34;&#34;
        raise NotImplementedError

    @abc.abstractmethod
    def add_author(self, user: snowflakes.SnowflakeishOr[users.User], /) -&gt; None:
        &#34;&#34;&#34;Add a author/owner to this paginator.

        Parameters
        ----------
        user : hikari.snowflakes.SnowflakeishOr[hikari.users.User]
            The user to add as an owner for this paginator.
        &#34;&#34;&#34;
        raise NotImplementedError

    @abc.abstractmethod
    def remove_author(self, user: snowflakes.SnowflakeishOr[users.User], /) -&gt; None:
        &#34;&#34;&#34;Remove a author/owner from this paginator.

        !!! note
            If the provided user isn&#39;t already a registered owner of this paginator
            then this should pass silently without raising.

        Parameters
        ----------
        user : hikari.snowflakes.SnowflakeishOr[hikari.users.User]
            The user to remove from this paginator&#39;s owners..
        &#34;&#34;&#34;
        raise NotImplementedError

    @abc.abstractmethod
    async def close(self, *, remove_reactions: bool = False) -&gt; None:
        &#34;&#34;&#34;Close this paginator and deregister any previously registered message.

        Other Parameters
        ----------------
        remove_reactions : builtins.bool
            Whether this should remove the reactions that were being used to
            paginate through this from the previously registered message.
            This defaults to `builtins.False`.
        &#34;&#34;&#34;
        raise NotImplementedError

    @abc.abstractmethod
    async def open(
        self,
        *,
        message: typing.Optional[snowflakes.SnowflakeishOr[messages.Message]] = None,
        add_reactions: bool = True,
    ) -&gt; typing.Optional[messages.Message]:
        &#34;&#34;&#34;Start this paginator and link it to a message.

        Other Parameters
        ----------------
        message : typing.Optional[hikari.messages.Message]
            If already created, the message this paginator should target.
            If left as `builtins.None` then this call will create a message
            in the channel provided when initiating the paginator.
        add_reactions : bool
            Whether this should also add reactions that&#39;ll be used to paginate
            over this resource.
            This defaults to `builtins.True`.

        !!! note
            Calling this multiple times will replace the previously registered message.

        Returns
        -------
        typing.Optional[hikari.messages.Message]
            The message that this paginator created if `message_id` was left as `builtins.None`
            else `builtins.None`.

        Raises
        ------
        ValueError
            If the provided iterator didn&#39;t yield any content for the first message.
        &#34;&#34;&#34;
        raise NotImplementedError

    @abc.abstractmethod
    async def on_reaction_event(self, emoji: emojis.Emoji, user_id: snowflakes.Snowflake) -&gt; typing.Optional[str]:
        &#34;&#34;&#34;The logic for handling reaction pagination.

        !!! note
            This should generally speaking only be called on ReactionAddEvent
            and ReactionDeleteEvent.

        Parameters
        ----------
        emoji : hikari.emojis.Emoji
            The unicode or custom emoji being added or removed in this event.
        user_id : hikari.snowflakes.Snowflake
            The ID of the user adding or removing this reaction.

        Returns
        -------
        typing.Optional[str]
            This will either be a string command (&#39;&#34;END&#34;&#39; to signal that the
            paginator has been de-registered and should be removed from the
            pool) or `builtins.None`.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="yuyo.paginaton.Paginator" href="#yuyo.paginaton.Paginator">Paginator</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="yuyo.paginaton.AbstractPaginator.authors"><code class="name">var <span class="ident">authors</span> : AbstractSet[hikari.snowflakes.Snowflake]</code></dt>
<dd>
<div class="desc"><p>The authors/owner of a enabled paginator.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If this is empty then the paginator is considered public and
any user will be able to trigger it.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>typing.AbstractSet[hikari.snowflakes.Snowflake]</code></dt>
<dd>A set of the owner user IDs.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abc.abstractmethod
def authors(self) -&gt; typing.AbstractSet[snowflakes.Snowflake]:
    &#34;&#34;&#34;The authors/owner of a enabled paginator.

    !!! note
        If this is empty then the paginator is considered public and
        any user will be able to trigger it.

    Returns
    -------
    typing.AbstractSet[hikari.snowflakes.Snowflake]
        A set of the owner user IDs.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="yuyo.paginaton.AbstractPaginator.expired"><code class="name">var <span class="ident">expired</span> : bool</code></dt>
<dd>
<div class="desc"><p>Whether this paginator has ended.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Whether this paginator has ended.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abc.abstractmethod
def expired(self) -&gt; bool:
    &#34;&#34;&#34;Whether this paginator has ended.

    Returns
    -------
    bool
        Whether this paginator has ended.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="yuyo.paginaton.AbstractPaginator.last_triggered"><code class="name">var <span class="ident">last_triggered</span> : datetime.datetime</code></dt>
<dd>
<div class="desc"><p>When this paginator was last triggered.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If it hasn't ever been triggered then this will be when it was created.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>datetime.datetime</code></dt>
<dd>When this paginator was last triggered.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abc.abstractmethod
def last_triggered(self) -&gt; datetime.datetime:
    &#34;&#34;&#34;When this paginator was last triggered.

    !!! note
        If it hasn&#39;t ever been triggered then this will be when it was created.

    Returns
    -------
    datetime.datetime
        When this paginator was last triggered.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="yuyo.paginaton.AbstractPaginator.locked"><code class="name">var <span class="ident">locked</span> : bool</code></dt>
<dd>
<div class="desc"><p>Whether this paginator has been locked by a call to it.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Whether this paginator has been locked by a call to it.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abc.abstractmethod
def locked(self) -&gt; bool:
    &#34;&#34;&#34;Whether this paginator has been locked by a call to it.

    Returns
    -------
    bool
        Whether this paginator has been locked by a call to it.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="yuyo.paginaton.AbstractPaginator.triggers"><code class="name">var <span class="ident">triggers</span> : Sequence[hikari.emojis.Emoji]</code></dt>
<dd>
<div class="desc"><p>The enabled trigger emojis for this paginator.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>typing.Sequence[emojis.Emoji]</code></dt>
<dd>A sequence of the emojis that are enabled as triggers for
this paginator.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abc.abstractmethod
def triggers(self) -&gt; typing.Sequence[emojis.Emoji]:
    &#34;&#34;&#34;The enabled trigger emojis for this paginator.

    Returns
    -------
    typing.Sequence[emojis.Emoji]
        A sequence of the emojis that are enabled as triggers for
        this paginator.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="yuyo.paginaton.AbstractPaginator.add_author"><code class="name flex">
<span>def <span class="ident">add_author</span></span>(<span>self, user: snowflakes.SnowflakeishOr[users.User], /) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Add a author/owner to this paginator.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user</code></strong> :&ensp;<code>hikari.snowflakes.SnowflakeishOr[hikari.users.User]</code></dt>
<dd>The user to add as an owner for this paginator.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def add_author(self, user: snowflakes.SnowflakeishOr[users.User], /) -&gt; None:
    &#34;&#34;&#34;Add a author/owner to this paginator.

    Parameters
    ----------
    user : hikari.snowflakes.SnowflakeishOr[hikari.users.User]
        The user to add as an owner for this paginator.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="yuyo.paginaton.AbstractPaginator.close"><code class="name flex">
<span>async def <span class="ident">close</span></span>(<span>self, *, remove_reactions: bool = False) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Close this paginator and deregister any previously registered message.</p>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>remove_reactions</code></strong> :&ensp;<code>builtins.bool</code></dt>
<dd>Whether this should remove the reactions that were being used to
paginate through this from the previously registered message.
This defaults to <code>builtins.False</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
async def close(self, *, remove_reactions: bool = False) -&gt; None:
    &#34;&#34;&#34;Close this paginator and deregister any previously registered message.

    Other Parameters
    ----------------
    remove_reactions : builtins.bool
        Whether this should remove the reactions that were being used to
        paginate through this from the previously registered message.
        This defaults to `builtins.False`.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="yuyo.paginaton.AbstractPaginator.on_reaction_event"><code class="name flex">
<span>async def <span class="ident">on_reaction_event</span></span>(<span>self, emoji: emojis.Emoji, user_id: snowflakes.Snowflake) ‑> Optional[str]</span>
</code></dt>
<dd>
<div class="desc"><p>The logic for handling reaction pagination.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This should generally speaking only be called on ReactionAddEvent
and ReactionDeleteEvent.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>emoji</code></strong> :&ensp;<code>hikari.emojis.Emoji</code></dt>
<dd>The unicode or custom emoji being added or removed in this event.</dd>
<dt><strong><code>user_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflake</code></dt>
<dd>The ID of the user adding or removing this reaction.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>typing.Optional[str]</code></dt>
<dd>This will either be a string command ('"END"' to signal that the
paginator has been de-registered and should be removed from the
pool) or <code>builtins.None</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
async def on_reaction_event(self, emoji: emojis.Emoji, user_id: snowflakes.Snowflake) -&gt; typing.Optional[str]:
    &#34;&#34;&#34;The logic for handling reaction pagination.

    !!! note
        This should generally speaking only be called on ReactionAddEvent
        and ReactionDeleteEvent.

    Parameters
    ----------
    emoji : hikari.emojis.Emoji
        The unicode or custom emoji being added or removed in this event.
    user_id : hikari.snowflakes.Snowflake
        The ID of the user adding or removing this reaction.

    Returns
    -------
    typing.Optional[str]
        This will either be a string command (&#39;&#34;END&#34;&#39; to signal that the
        paginator has been de-registered and should be removed from the
        pool) or `builtins.None`.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="yuyo.paginaton.AbstractPaginator.open"><code class="name flex">
<span>async def <span class="ident">open</span></span>(<span>self, *, message: typing.Optional[snowflakes.SnowflakeishOr[messages.Message]] = None, add_reactions: bool = True) ‑> typing.Optional[messages.Message]</span>
</code></dt>
<dd>
<div class="desc"><p>Start this paginator and link it to a message.</p>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code>typing.Optional[hikari.messages.Message]</code></dt>
<dd>If already created, the message this paginator should target.
If left as <code>builtins.None</code> then this call will create a message
in the channel provided when initiating the paginator.</dd>
<dt><strong><code>add_reactions</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether this should also add reactions that'll be used to paginate
over this resource.
This defaults to <code>builtins.True</code>.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calling this multiple times will replace the previously registered message.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>typing.Optional[hikari.messages.Message]</code></dt>
<dd>The message that this paginator created if <code>message_id</code> was left as <code>builtins.None</code>
else <code>builtins.None</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the provided iterator didn't yield any content for the first message.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
async def open(
    self,
    *,
    message: typing.Optional[snowflakes.SnowflakeishOr[messages.Message]] = None,
    add_reactions: bool = True,
) -&gt; typing.Optional[messages.Message]:
    &#34;&#34;&#34;Start this paginator and link it to a message.

    Other Parameters
    ----------------
    message : typing.Optional[hikari.messages.Message]
        If already created, the message this paginator should target.
        If left as `builtins.None` then this call will create a message
        in the channel provided when initiating the paginator.
    add_reactions : bool
        Whether this should also add reactions that&#39;ll be used to paginate
        over this resource.
        This defaults to `builtins.True`.

    !!! note
        Calling this multiple times will replace the previously registered message.

    Returns
    -------
    typing.Optional[hikari.messages.Message]
        The message that this paginator created if `message_id` was left as `builtins.None`
        else `builtins.None`.

    Raises
    ------
    ValueError
        If the provided iterator didn&#39;t yield any content for the first message.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="yuyo.paginaton.AbstractPaginator.remove_author"><code class="name flex">
<span>def <span class="ident">remove_author</span></span>(<span>self, user: snowflakes.SnowflakeishOr[users.User], /) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Remove a author/owner from this paginator.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the provided user isn't already a registered owner of this paginator
then this should pass silently without raising.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user</code></strong> :&ensp;<code>hikari.snowflakes.SnowflakeishOr[hikari.users.User]</code></dt>
<dd>The user to remove from this paginator's owners..</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def remove_author(self, user: snowflakes.SnowflakeishOr[users.User], /) -&gt; None:
    &#34;&#34;&#34;Remove a author/owner from this paginator.

    !!! note
        If the provided user isn&#39;t already a registered owner of this paginator
        then this should pass silently without raising.

    Parameters
    ----------
    user : hikari.snowflakes.SnowflakeishOr[hikari.users.User]
        The user to remove from this paginator&#39;s owners..
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="yuyo.paginaton.Paginator"><code class="flex name class">
<span>class <span class="ident">Paginator</span></span>
<span>(</span><span>rest: traits.RESTAware, channel: snowflakes.SnowflakeishOr[channels.TextChannel], iterator: typing.Union[<a title="yuyo.paginaton.IteratorT" href="#yuyo.paginaton.IteratorT">IteratorT</a>[<a title="yuyo.paginaton.EntryT" href="#yuyo.paginaton.EntryT">EntryT</a>]], *, authors: typing.Iterable[snowflakes.SnowflakeishOr[users.User]], triggers: typing.Sequence[emojis.Emoji] = (UnicodeEmoji(name='◀️'), UnicodeEmoji(name='⏹️'), UnicodeEmoji(name='▶️')), timeout: datetime.timedelta = datetime.timedelta(seconds=30))</span>
</code></dt>
<dd>
<div class="desc"><p>The standard implementation of <code><a title="yuyo.paginaton.AbstractPaginator" href="#yuyo.paginaton.AbstractPaginator">AbstractPaginator</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rest</code></strong> :&ensp;<code>hikari.traits.RESTAware</code></dt>
<dd>The REST aware client this should be bound to.</dd>
<dt><strong><code>channel</code></strong> :&ensp;<code>hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]</code></dt>
<dd>The ID of the text channel this iterator targets.</dd>
<dt><strong><code>iterator</code></strong> :&ensp;<code>Iterator[typing.Tuple[undefined.UndefinedOr[str], undefined.UndefinedOr[embeds.Embed]]]</code></dt>
<dd>Either an asynchronous or synchronous iterator of the entries this
should paginate through.
Entry[0] represents the message's possible content and can either be
<code>builtins.str</code> or <code>hikari.undefined.UNDEFINED</code> and Entry[1] represents
the message's possible embed and can either be <code>hikari.embeds.Embed</code>
or <code>hikari.undefined.UNDEFINED</code>.</dd>
<dt><strong><code>authors</code></strong> :&ensp;<code>typing.Iterable[hikari.snowflakes.SnowflakeishOr[hikari.users.User]]</code></dt>
<dd>An iterable of IDs of the users who can call this paginator.
If left empty then all users will be able to call this
paginator.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>datetime.timedelta</code></dt>
<dd>How long it should take for this paginator to timeout.
This defaults to a timdelta of 30 seconds.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Paginator(AbstractPaginator):
    &#34;&#34;&#34;The standard implementation of `AbstractPaginator`.

    Parameters
    ----------
    rest : hikari.traits.RESTAware
        The REST aware client this should be bound to.
    channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
        The ID of the text channel this iterator targets.
    iterator : Iterator[typing.Tuple[undefined.UndefinedOr[str], undefined.UndefinedOr[embeds.Embed]]]
        Either an asynchronous or synchronous iterator of the entries this
        should paginate through.
        Entry[0] represents the message&#39;s possible content and can either be
        `builtins.str` or `hikari.undefined.UNDEFINED` and Entry[1] represents
        the message&#39;s possible embed and can either be `hikari.embeds.Embed`
        or `hikari.undefined.UNDEFINED`.
    authors : typing.Iterable[hikari.snowflakes.SnowflakeishOr[hikari.users.User]]
        An iterable of IDs of the users who can call this paginator.
        If left empty then all users will be able to call this
        paginator.

    Other Parameters
    ----------------
    timeout : datetime.timedelta
        How long it should take for this paginator to timeout.
        This defaults to a timdelta of 30 seconds.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (
        &#34;_authors&#34;,
        &#34;_buffer&#34;,
        &#34;_channel_id&#34;,
        &#34;_emoji_mapping&#34;,
        &#34;_index&#34;,
        &#34;_iterator&#34;,
        &#34;_last_triggered&#34;,
        &#34;_locked&#34;,
        &#34;_message_id&#34;,
        &#34;_rest&#34;,
        &#34;timeout&#34;,
        &#34;_triggers&#34;,
    )

    def __init__(
        self,
        rest: traits.RESTAware,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        iterator: typing.Union[IteratorT[EntryT]],
        *,
        authors: typing.Iterable[snowflakes.SnowflakeishOr[users.User]],
        triggers: typing.Sequence[emojis.Emoji] = (
            LEFT_TRIANGLE,
            STOP_SQUARE,
            RIGHT_TRIANGLE,
        ),
        timeout: datetime.timedelta = datetime.timedelta(seconds=30),
    ) -&gt; None:
        if isinstance(iterator, typing.Iterator):
            raise ValueError(f&#34;Invalid value passed for `iterator`, expected an iterator but got {type(iterator)}&#34;)

        self._authors = set(map(snowflakes.Snowflake, authors))
        self._buffer: typing.MutableSequence[EntryT] = []
        self._channel_id = channel
        self._emoji_mapping: typing.Mapping[
            typing.Union[emojis.Emoji, snowflakes.Snowflake],
            typing.Callable[[], typing.Coroutine[typing.Any, typing.Any, typing.Union[EntryT, None, str]]],
        ] = {
            LEFT_DOUBLE_TRIANGLE: self._on_first,
            LEFT_TRIANGLE: self._on_previous,
            STOP_SQUARE: self._on_disable,
            RIGHT_TRIANGLE: self._on_next,
            RIGHT_DOUBLE_TRIANGLE: self._on_last,
        }
        self._index = 0
        self._iterator = iterator
        self._last_triggered = datetime.datetime.now(tz=datetime.timezone.utc)
        self._locked = False
        self._message_id: typing.Optional[snowflakes.Snowflake] = None
        self._rest = rest
        self.timeout = timeout
        self._triggers = tuple(_process_known_custom_emoji(emoji) for emoji in triggers)

    @property
    def authors(self) -&gt; typing.AbstractSet[snowflakes.Snowflake]:
        # &lt;&lt;inherited docstring from AbstractPaginator&gt;&gt;.
        return frozenset(self._authors)

    @property
    def expired(self) -&gt; bool:
        # &lt;&lt;inherited docstring from AbstractPaginator&gt;&gt;.
        return self.timeout &lt; datetime.datetime.now(tz=datetime.timezone.utc) - self._last_triggered

    @property
    def last_triggered(self) -&gt; datetime.datetime:
        # &lt;&lt;inherited docstring from AbstractPaginator&gt;&gt;.
        return self._last_triggered

    @property
    def locked(self) -&gt; bool:
        # &lt;&lt;inherited docstring from AbstractPaginator&gt;&gt;.
        return self._locked

    @property
    def triggers(self) -&gt; typing.Sequence[emojis.Emoji]:
        # &lt;&lt;inherited docstring from AbstractPaginator&gt;&gt;.
        return self._triggers

    async def _delete_message(self, message_id: snowflakes.Snowflake, /) -&gt; None:
        retry = backoff.Backoff()

        async for _ in retry:
            try:
                await self._rest.rest.delete_message(self._channel_id, message_id)

            except (errors.NotFoundError, errors.ForbiddenError):  # TODO: better permission handling.
                return

            except errors.InternalServerError:
                continue

            except errors.RateLimitedError as exc:
                retry.set_next_backoff(exc.retry_after)

            else:
                break

    async def _on_disable(self) -&gt; str:
        if message_id := self._message_id:
            self._message_id = None
            # We create a task here rather than awaiting this to ensure the instance is marked as ended as soon as
            # possible.
            asyncio.create_task(self._delete_message(message_id))

        return END

    async def _on_first(self) -&gt; typing.Optional[EntryT]:
        if self._index == 0:
            return None

        return self._buffer[0]

    async def _on_last(self) -&gt; typing.Optional[EntryT]:
        self._locked = True
        if isinstance(self._iterator, typing.AsyncIterator):
            self._buffer.extend([embed async for embed in self._iterator])

        elif isinstance(self._iterator, typing.Iterator):
            self._buffer.extend(self._iterator)

        self._locked = False

        if self._buffer:
            self._index = len(self._buffer) - 1
            return self._buffer[-1]

        return None

    async def _on_next(self) -&gt; typing.Optional[EntryT]:
        # Check to see if we&#39;re behind the buffer before trying to go forward in the generator.
        if len(self._buffer) &gt;= self._index + 2:
            self._index += 1
            return self._buffer[self._index]

        # If entry is not None then the generator&#39;s position was pushed forwards.
        if (entry := await _seek_iterator(self._iterator, default=None)) is not None:
            self._index += 1
            self._buffer.append(entry)

        return entry

    async def _on_previous(self) -&gt; typing.Optional[EntryT]:
        if self._index &lt;= 0:
            return None

        self._index -= 1
        return self._buffer[self._index]

    def add_author(self, user: snowflakes.SnowflakeishOr[users.User], /) -&gt; None:
        # &lt;&lt;inherited docstring from AbstractPaginator&gt;&gt;.
        self._authors.add(snowflakes.Snowflake(user))

    def remove_author(self, user: snowflakes.SnowflakeishOr[users.User], /) -&gt; None:
        # &lt;&lt;inherited docstring from AbstractPaginator&gt;&gt;.
        try:
            self._authors.remove(snowflakes.Snowflake(user))
        except KeyError:
            pass

    async def close(self, remove_reactions: bool = False) -&gt; None:
        # &lt;&lt;inherited docstring from AbstractPaginator&gt;&gt;.
        if message_id := self._message_id:
            self._message_id = None
            retry = backoff.Backoff()
            # TODO: check if we can just clear the reactions before doing this using the cache.
            for emoji in self._triggers:
                retry.reset()
                async for _ in retry:
                    try:
                        await self._rest.rest.delete_my_reaction(self._channel_id, message_id, emoji)

                    except (errors.NotFoundError, errors.ForbiddenError):
                        return

                    except errors.RateLimitedError as exc:
                        retry.set_next_backoff(exc.retry_after)

                    except errors.InternalServerError:
                        continue

                    else:
                        break

    async def open(
        self,
        *,
        message: typing.Optional[snowflakes.SnowflakeishOr[messages.Message]] = None,
        add_reactions: bool = True,
        max_retries: int = 5,
        max_backoff: float = 2.0,
    ) -&gt; typing.Optional[messages.Message]:
        # &lt;&lt;inherited docstring from AbstractPaginator&gt;&gt;.
        created_message: typing.Optional[messages.Message] = None
        if self._message_id is not None:
            return None

        retry = backoff.Backoff(max_retries=max_retries - 1, maximum=max_backoff)
        if message is None:
            entry = await self._on_next()

            if entry is None:
                raise ValueError(&#34;Paginator iterator yielded no pages.&#34;)

            async for _ in retry:
                try:
                    created_message = await self._rest.rest.create_message(
                        self._channel_id, content=entry[0], embed=entry[1]
                    )
                    message = created_message.id

                except errors.RateLimitedError as exc:
                    if exc.retry_after &gt; max_backoff:
                        raise

                    retry.set_next_backoff(exc.retry_after)

                except errors.InternalServerError:
                    continue

                else:
                    break

            else:
                message = await self._rest.rest.create_message(self._channel_id, content=entry[0], embed=entry[1])

        message = snowflakes.Snowflake(message)
        self._message_id = message
        for emoji in self._triggers:
            retry.reset()
            async for _ in retry:
                try:
                    await self._rest.rest.add_reaction(self._channel_id, message, emoji)

                except (errors.NotFoundError, errors.ForbiddenError):
                    self._message_id = None
                    raise

                except errors.RateLimitedError as exc:
                    if exc.retry_after &gt; max_backoff:
                        raise

                    retry.set_next_backoff(exc.retry_after)

                except errors.InternalServerError:
                    continue

                else:
                    break

            else:
                await self._rest.rest.add_reaction(self._channel_id, message, emoji)

        return created_message

    async def on_reaction_event(self, emoji: emojis.Emoji, user_id: snowflakes.Snowflake) -&gt; typing.Optional[str]:
        # &lt;&lt;inherited docstring from AbstractPaginator&gt;&gt;.
        if self.expired:
            asyncio.create_task(self.close(remove_reactions=True))
            return END

        if self._message_id is None or self._authors and user_id not in self._authors or self._locked:
            return None

        method = self._emoji_mapping.get(emoji)
        if emoji not in self._triggers or not method:
            return None

        result = await method()
        if isinstance(result, str) or result is None:
            return END

        self._last_triggered = datetime.datetime.now(tz=datetime.timezone.utc)
        retry = backoff.Backoff()

        async for _ in retry:
            # Mypy makes the false assumption that this value will stay as None while this function yields.
            if self._message_id is None:
                break  # type: ignore[unreachable]

            try:
                await self._rest.rest.edit_message(
                    self._channel_id, self._message_id, content=result[0], embed=result[1]
                )

            except errors.InternalServerError:
                continue

            except errors.RateLimitedError as exc:
                retry.set_next_backoff(exc.retry_after)

            except (errors.NotFoundError, errors.ForbiddenError):
                return END

            else:
                break

        return None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="yuyo.paginaton.AbstractPaginator" href="#yuyo.paginaton.AbstractPaginator">AbstractPaginator</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="yuyo.paginaton.Paginator.timeout"><code class="name">var <span class="ident">timeout</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="yuyo.paginaton.AbstractPaginator" href="#yuyo.paginaton.AbstractPaginator">AbstractPaginator</a></b></code>:
<ul class="hlist">
<li><code><a title="yuyo.paginaton.AbstractPaginator.add_author" href="#yuyo.paginaton.AbstractPaginator.add_author">add_author</a></code></li>
<li><code><a title="yuyo.paginaton.AbstractPaginator.authors" href="#yuyo.paginaton.AbstractPaginator.authors">authors</a></code></li>
<li><code><a title="yuyo.paginaton.AbstractPaginator.close" href="#yuyo.paginaton.AbstractPaginator.close">close</a></code></li>
<li><code><a title="yuyo.paginaton.AbstractPaginator.expired" href="#yuyo.paginaton.AbstractPaginator.expired">expired</a></code></li>
<li><code><a title="yuyo.paginaton.AbstractPaginator.last_triggered" href="#yuyo.paginaton.AbstractPaginator.last_triggered">last_triggered</a></code></li>
<li><code><a title="yuyo.paginaton.AbstractPaginator.locked" href="#yuyo.paginaton.AbstractPaginator.locked">locked</a></code></li>
<li><code><a title="yuyo.paginaton.AbstractPaginator.on_reaction_event" href="#yuyo.paginaton.AbstractPaginator.on_reaction_event">on_reaction_event</a></code></li>
<li><code><a title="yuyo.paginaton.AbstractPaginator.open" href="#yuyo.paginaton.AbstractPaginator.open">open</a></code></li>
<li><code><a title="yuyo.paginaton.AbstractPaginator.remove_author" href="#yuyo.paginaton.AbstractPaginator.remove_author">remove_author</a></code></li>
<li><code><a title="yuyo.paginaton.AbstractPaginator.triggers" href="#yuyo.paginaton.AbstractPaginator.triggers">triggers</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="yuyo.paginaton.PaginatorPool"><code class="flex name class">
<span>class <span class="ident">PaginatorPool</span></span>
<span>(</span><span>rest: traits.RESTAware, dispatch: typing.Optional[traits.DispatcherAware] = None, /)</span>
</code></dt>
<dd>
<div class="desc"><p>A class which handles the events for multiple registered paginators.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rest</code></strong> :&ensp;<code>hikari.traits.RESTAware</code></dt>
<dd>The REST aware client to register this paginator pool with.</dd>
<dt><strong><code>dispatch</code></strong> :&ensp;<code>typing.Optional[hikari.traits.DispatcherAware]</code></dt>
<dd>
<p>The dispatcher aware client to register this paginator pool with.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This may only be left as <code>builtins.None</code> if <code>rest</code> is dispatcher
aware.</p>
</div>
</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If <code>dispatch</code> is left as <code>builtins.None</code> when <code>rest</code> is not also
dispatcher aware.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PaginatorPool:
    &#34;&#34;&#34;A class which handles the events for multiple registered paginators.

    Parameters
    ----------
    rest : hikari.traits.RESTAware
        The REST aware client to register this paginator pool with.
    dispatch : typing.Optional[hikari.traits.DispatcherAware]
        The dispatcher aware client to register this paginator pool with.

        !!! note
            This may only be left as `builtins.None` if `rest` is dispatcher
            aware.

    Raises
    ------
    ValueError
        If `dispatch` is left as `builtins.None` when `rest` is not also
        dispatcher aware.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (&#34;blacklist&#34;, &#34;_dispatch&#34;, &#34;_gc_task&#34;, &#34;_listeners&#34;, &#34;_rest&#34;)

    def __init__(self, rest: traits.RESTAware, dispatch: typing.Optional[traits.DispatcherAware] = None, /) -&gt; None:
        if dispatch is None and isinstance(rest, traits.DispatcherAware):
            dispatch = rest

        if dispatch is None:
            raise ValueError(&#34;Missing dispatcher aware client.&#34;)

        self.blacklist: typing.MutableSequence[snowflakes.Snowflake] = []
        self._dispatch = dispatch
        self._gc_task: typing.Optional[asyncio.Task[None]] = None
        self._listeners: typing.MutableMapping[snowflakes.Snowflake, AbstractPaginator] = {}
        self._rest = rest

    async def _gc(self) -&gt; None:
        while True:
            for listener_id, listener in tuple(self._listeners.items()):
                if not listener.expired or listener_id not in self._listeners:
                    continue

                del self._listeners[listener_id]
                # This may slow this gc task down but the more we yield the better.
                await listener.close(remove_reactions=True)

            await asyncio.sleep(5)  # TODO: is this a good time?

    async def _on_reaction_event(
        self, event: typing.Union[reaction_events.ReactionAddEvent, reaction_events.ReactionDeleteEvent], /
    ) -&gt; None:
        if event.user_id in self.blacklist:
            return

        if listener := self._listeners.get(event.message_id):
            result = await listener.on_reaction_event(event.emoji, user_id=event.user_id)
            if result is END and event.message_id in self._listeners:
                del self._listeners[event.message_id]

    async def _on_starting_event(self, _: lifetime_events.StartingEvent, /) -&gt; None:
        await self.open()

    async def _on_stopping_event(self, _: lifetime_events.StoppingEvent, /) -&gt; None:
        await self.close()

    def add_paginator(
        self, message: snowflakes.SnowflakeishOr[messages.Message], /, paginator: AbstractPaginator
    ) -&gt; None:
        &#34;&#34;&#34;Add a paginator to this pool.

        !!! note
            This does not call `AbstractPaginator.open`.

        Parameters
        ----------
        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.Message]
            The message ID to add register a paginator with.
        paginator : AbstractPaginator
            The object of the opened paginator to register in this pool.
        &#34;&#34;&#34;
        self._listeners[snowflakes.Snowflake(message)] = paginator

    def get_paginator(
        self, message: snowflakes.SnowflakeishOr[messages.Message], /
    ) -&gt; typing.Optional[AbstractPaginator]:
        &#34;&#34;&#34;Get a reference to a paginator registered in this pool.

        !!! note
            This does not call `AbstractPaginator.close`.

        Parameters
        ----------
        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.Message]
            The message ID to remove a paginator for.

        Returns
        -------
        AbstractPaginator
            The object of the registered paginator if found else `builtins.None`.
        &#34;&#34;&#34;
        return self._listeners.get(snowflakes.Snowflake(message))

    def remove_paginator(
        self, message: snowflakes.SnowflakeishOr[messages.Message], /
    ) -&gt; typing.Optional[AbstractPaginator]:
        &#34;&#34;&#34;Remove a paginator from this pool.

        !!! note
            This does not call `AbstractPaginator.close`.

        Parameters
        ----------
        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.Message]
            The message ID to remove a paginator for.

        Returns
        -------
        AbstractPaginator
            The object of the registered paginator if found else `builtins.None`.
        &#34;&#34;&#34;
        return self._listeners.pop(snowflakes.Snowflake(message))

    async def close(self) -&gt; None:
        &#34;&#34;&#34;Close this pool by unregistering any tasks and event listeners registered by `PaginatorPool.open`.&#34;&#34;&#34;
        if self._gc_task is not None:
            self._dispatch.dispatcher.unsubscribe(lifetime_events.StartingEvent, self._on_starting_event)
            self._dispatch.dispatcher.unsubscribe(lifetime_events.StoppingEvent, self._on_stopping_event)
            self._dispatch.dispatcher.unsubscribe(reaction_events.ReactionAddEvent, self._on_reaction_event)
            self._dispatch.dispatcher.unsubscribe(reaction_events.ReactionDeleteEvent, self._on_reaction_event)
            self._gc_task.cancel()
            listeners = self._listeners
            self._listeners = {}
            await asyncio.gather(*(listener.close() for listener in listeners.values()))

    async def open(self) -&gt; None:
        &#34;&#34;&#34;Start this pool by registering the required tasks and event listeners for it to function.&#34;&#34;&#34;
        if self._gc_task is None:
            self._gc_task = asyncio.create_task(self._gc())
            self.blacklist.append((await self._rest.rest.fetch_my_user()).id)
            self._dispatch.dispatcher.subscribe(lifetime_events.StartingEvent, self._on_starting_event)
            self._dispatch.dispatcher.subscribe(lifetime_events.StoppingEvent, self._on_stopping_event)
            self._dispatch.dispatcher.subscribe(reaction_events.ReactionAddEvent, self._on_reaction_event)
            self._dispatch.dispatcher.subscribe(reaction_events.ReactionDeleteEvent, self._on_reaction_event)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="yuyo.paginaton.PaginatorPool.blacklist"><code class="name">var <span class="ident">blacklist</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="yuyo.paginaton.PaginatorPool.add_paginator"><code class="name flex">
<span>def <span class="ident">add_paginator</span></span>(<span>self, message: snowflakes.SnowflakeishOr[messages.Message], /, paginator: <a title="yuyo.paginaton.AbstractPaginator" href="#yuyo.paginaton.AbstractPaginator">AbstractPaginator</a>) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Add a paginator to this pool.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This does not call <code><a title="yuyo.paginaton.AbstractPaginator.open" href="#yuyo.paginaton.AbstractPaginator.open">AbstractPaginator.open()</a></code>.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code>hikari.snowflakes.SnowflakeishOr[hikari.messages.Message]</code></dt>
<dd>The message ID to add register a paginator with.</dd>
<dt><strong><code>paginator</code></strong> :&ensp;<code><a title="yuyo.paginaton.AbstractPaginator" href="#yuyo.paginaton.AbstractPaginator">AbstractPaginator</a></code></dt>
<dd>The object of the opened paginator to register in this pool.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_paginator(
    self, message: snowflakes.SnowflakeishOr[messages.Message], /, paginator: AbstractPaginator
) -&gt; None:
    &#34;&#34;&#34;Add a paginator to this pool.

    !!! note
        This does not call `AbstractPaginator.open`.

    Parameters
    ----------
    message : hikari.snowflakes.SnowflakeishOr[hikari.messages.Message]
        The message ID to add register a paginator with.
    paginator : AbstractPaginator
        The object of the opened paginator to register in this pool.
    &#34;&#34;&#34;
    self._listeners[snowflakes.Snowflake(message)] = paginator</code></pre>
</details>
</dd>
<dt id="yuyo.paginaton.PaginatorPool.close"><code class="name flex">
<span>async def <span class="ident">close</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Close this pool by unregistering any tasks and event listeners registered by <code><a title="yuyo.paginaton.PaginatorPool.open" href="#yuyo.paginaton.PaginatorPool.open">PaginatorPool.open()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def close(self) -&gt; None:
    &#34;&#34;&#34;Close this pool by unregistering any tasks and event listeners registered by `PaginatorPool.open`.&#34;&#34;&#34;
    if self._gc_task is not None:
        self._dispatch.dispatcher.unsubscribe(lifetime_events.StartingEvent, self._on_starting_event)
        self._dispatch.dispatcher.unsubscribe(lifetime_events.StoppingEvent, self._on_stopping_event)
        self._dispatch.dispatcher.unsubscribe(reaction_events.ReactionAddEvent, self._on_reaction_event)
        self._dispatch.dispatcher.unsubscribe(reaction_events.ReactionDeleteEvent, self._on_reaction_event)
        self._gc_task.cancel()
        listeners = self._listeners
        self._listeners = {}
        await asyncio.gather(*(listener.close() for listener in listeners.values()))</code></pre>
</details>
</dd>
<dt id="yuyo.paginaton.PaginatorPool.get_paginator"><code class="name flex">
<span>def <span class="ident">get_paginator</span></span>(<span>self, message: snowflakes.SnowflakeishOr[messages.Message], /) ‑> typing.Optional[<a title="yuyo.paginaton.AbstractPaginator" href="#yuyo.paginaton.AbstractPaginator">AbstractPaginator</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get a reference to a paginator registered in this pool.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This does not call <code><a title="yuyo.paginaton.AbstractPaginator.close" href="#yuyo.paginaton.AbstractPaginator.close">AbstractPaginator.close()</a></code>.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code>hikari.snowflakes.SnowflakeishOr[hikari.messages.Message]</code></dt>
<dd>The message ID to remove a paginator for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="yuyo.paginaton.AbstractPaginator" href="#yuyo.paginaton.AbstractPaginator">AbstractPaginator</a></code></dt>
<dd>The object of the registered paginator if found else <code>builtins.None</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_paginator(
    self, message: snowflakes.SnowflakeishOr[messages.Message], /
) -&gt; typing.Optional[AbstractPaginator]:
    &#34;&#34;&#34;Get a reference to a paginator registered in this pool.

    !!! note
        This does not call `AbstractPaginator.close`.

    Parameters
    ----------
    message : hikari.snowflakes.SnowflakeishOr[hikari.messages.Message]
        The message ID to remove a paginator for.

    Returns
    -------
    AbstractPaginator
        The object of the registered paginator if found else `builtins.None`.
    &#34;&#34;&#34;
    return self._listeners.get(snowflakes.Snowflake(message))</code></pre>
</details>
</dd>
<dt id="yuyo.paginaton.PaginatorPool.open"><code class="name flex">
<span>async def <span class="ident">open</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Start this pool by registering the required tasks and event listeners for it to function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def open(self) -&gt; None:
    &#34;&#34;&#34;Start this pool by registering the required tasks and event listeners for it to function.&#34;&#34;&#34;
    if self._gc_task is None:
        self._gc_task = asyncio.create_task(self._gc())
        self.blacklist.append((await self._rest.rest.fetch_my_user()).id)
        self._dispatch.dispatcher.subscribe(lifetime_events.StartingEvent, self._on_starting_event)
        self._dispatch.dispatcher.subscribe(lifetime_events.StoppingEvent, self._on_stopping_event)
        self._dispatch.dispatcher.subscribe(reaction_events.ReactionAddEvent, self._on_reaction_event)
        self._dispatch.dispatcher.subscribe(reaction_events.ReactionDeleteEvent, self._on_reaction_event)</code></pre>
</details>
</dd>
<dt id="yuyo.paginaton.PaginatorPool.remove_paginator"><code class="name flex">
<span>def <span class="ident">remove_paginator</span></span>(<span>self, message: snowflakes.SnowflakeishOr[messages.Message], /) ‑> typing.Optional[<a title="yuyo.paginaton.AbstractPaginator" href="#yuyo.paginaton.AbstractPaginator">AbstractPaginator</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Remove a paginator from this pool.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This does not call <code><a title="yuyo.paginaton.AbstractPaginator.close" href="#yuyo.paginaton.AbstractPaginator.close">AbstractPaginator.close()</a></code>.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code>hikari.snowflakes.SnowflakeishOr[hikari.messages.Message]</code></dt>
<dd>The message ID to remove a paginator for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="yuyo.paginaton.AbstractPaginator" href="#yuyo.paginaton.AbstractPaginator">AbstractPaginator</a></code></dt>
<dd>The object of the registered paginator if found else <code>builtins.None</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_paginator(
    self, message: snowflakes.SnowflakeishOr[messages.Message], /
) -&gt; typing.Optional[AbstractPaginator]:
    &#34;&#34;&#34;Remove a paginator from this pool.

    !!! note
        This does not call `AbstractPaginator.close`.

    Parameters
    ----------
    message : hikari.snowflakes.SnowflakeishOr[hikari.messages.Message]
        The message ID to remove a paginator for.

    Returns
    -------
    AbstractPaginator
        The object of the registered paginator if found else `builtins.None`.
    &#34;&#34;&#34;
    return self._listeners.pop(snowflakes.Snowflake(message))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="yuyo" href="index.html">yuyo</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="yuyo.paginaton.DefaultT" href="#yuyo.paginaton.DefaultT">DefaultT</a></code></li>
<li><code><a title="yuyo.paginaton.END" href="#yuyo.paginaton.END">END</a></code></li>
<li><code><a title="yuyo.paginaton.EntryT" href="#yuyo.paginaton.EntryT">EntryT</a></code></li>
<li><code><a title="yuyo.paginaton.IteratorT" href="#yuyo.paginaton.IteratorT">IteratorT</a></code></li>
<li><code><a title="yuyo.paginaton.LEFT_DOUBLE_TRIANGLE" href="#yuyo.paginaton.LEFT_DOUBLE_TRIANGLE">LEFT_DOUBLE_TRIANGLE</a></code></li>
<li><code><a title="yuyo.paginaton.LEFT_TRIANGLE" href="#yuyo.paginaton.LEFT_TRIANGLE">LEFT_TRIANGLE</a></code></li>
<li><code><a title="yuyo.paginaton.RIGHT_DOUBLE_TRIANGLE" href="#yuyo.paginaton.RIGHT_DOUBLE_TRIANGLE">RIGHT_DOUBLE_TRIANGLE</a></code></li>
<li><code><a title="yuyo.paginaton.RIGHT_TRIANGLE" href="#yuyo.paginaton.RIGHT_TRIANGLE">RIGHT_TRIANGLE</a></code></li>
<li><code><a title="yuyo.paginaton.STOP_SQUARE" href="#yuyo.paginaton.STOP_SQUARE">STOP_SQUARE</a></code></li>
<li><code><a title="yuyo.paginaton.ValueT" href="#yuyo.paginaton.ValueT">ValueT</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="yuyo.paginaton.string_paginator" href="#yuyo.paginaton.string_paginator">string_paginator</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="yuyo.paginaton.AbstractPaginator" href="#yuyo.paginaton.AbstractPaginator">AbstractPaginator</a></code></h4>
<ul class="two-column">
<li><code><a title="yuyo.paginaton.AbstractPaginator.add_author" href="#yuyo.paginaton.AbstractPaginator.add_author">add_author</a></code></li>
<li><code><a title="yuyo.paginaton.AbstractPaginator.authors" href="#yuyo.paginaton.AbstractPaginator.authors">authors</a></code></li>
<li><code><a title="yuyo.paginaton.AbstractPaginator.close" href="#yuyo.paginaton.AbstractPaginator.close">close</a></code></li>
<li><code><a title="yuyo.paginaton.AbstractPaginator.expired" href="#yuyo.paginaton.AbstractPaginator.expired">expired</a></code></li>
<li><code><a title="yuyo.paginaton.AbstractPaginator.last_triggered" href="#yuyo.paginaton.AbstractPaginator.last_triggered">last_triggered</a></code></li>
<li><code><a title="yuyo.paginaton.AbstractPaginator.locked" href="#yuyo.paginaton.AbstractPaginator.locked">locked</a></code></li>
<li><code><a title="yuyo.paginaton.AbstractPaginator.on_reaction_event" href="#yuyo.paginaton.AbstractPaginator.on_reaction_event">on_reaction_event</a></code></li>
<li><code><a title="yuyo.paginaton.AbstractPaginator.open" href="#yuyo.paginaton.AbstractPaginator.open">open</a></code></li>
<li><code><a title="yuyo.paginaton.AbstractPaginator.remove_author" href="#yuyo.paginaton.AbstractPaginator.remove_author">remove_author</a></code></li>
<li><code><a title="yuyo.paginaton.AbstractPaginator.triggers" href="#yuyo.paginaton.AbstractPaginator.triggers">triggers</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="yuyo.paginaton.Paginator" href="#yuyo.paginaton.Paginator">Paginator</a></code></h4>
<ul class="">
<li><code><a title="yuyo.paginaton.Paginator.timeout" href="#yuyo.paginaton.Paginator.timeout">timeout</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="yuyo.paginaton.PaginatorPool" href="#yuyo.paginaton.PaginatorPool">PaginatorPool</a></code></h4>
<ul class="two-column">
<li><code><a title="yuyo.paginaton.PaginatorPool.add_paginator" href="#yuyo.paginaton.PaginatorPool.add_paginator">add_paginator</a></code></li>
<li><code><a title="yuyo.paginaton.PaginatorPool.blacklist" href="#yuyo.paginaton.PaginatorPool.blacklist">blacklist</a></code></li>
<li><code><a title="yuyo.paginaton.PaginatorPool.close" href="#yuyo.paginaton.PaginatorPool.close">close</a></code></li>
<li><code><a title="yuyo.paginaton.PaginatorPool.get_paginator" href="#yuyo.paginaton.PaginatorPool.get_paginator">get_paginator</a></code></li>
<li><code><a title="yuyo.paginaton.PaginatorPool.open" href="#yuyo.paginaton.PaginatorPool.open">open</a></code></li>
<li><code><a title="yuyo.paginaton.PaginatorPool.remove_paginator" href="#yuyo.paginaton.PaginatorPool.remove_paginator">remove_paginator</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>